-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Generic HTTP types for Haskell (for both client and server code).
--   
--   Types and functions to describe and handle HTTP concepts. Including
--   "methods", "headers", "query strings", "paths" and "HTTP versions".
@package http-types
@version 0.12.4


-- | Type and constants for handling HTTP header fields.
--   
--   At the bottom are also some functions to handle certain header field
--   values.
module Network.HTTP.Types.Header

-- | A full HTTP header field with the name and value separated.
--   
--   E.g. <tt>"Content-Length: 28"</tt> parsed into a <a>Header</a> would
--   turn into <tt>("Content-Length", "28")</tt>
type Header = (HeaderName, ByteString)

-- | A case-insensitive name of a header field.
--   
--   This is the part of the header field before the colon: <tt>HeaderName:
--   some value</tt>
type HeaderName = CI ByteString

-- | A list of <a>Header</a>s.
--   
--   Same type as <a>ResponseHeaders</a>, but useful to differentiate in
--   type signatures.
type RequestHeaders = [Header]

-- | A list of <a>Header</a>s.
--   
--   Same type as <a>RequestHeaders</a>, but useful to differentiate in
--   type signatures.
type ResponseHeaders = [Header]

-- | <a>Accept</a>
hAccept :: HeaderName

-- | <a>Accept-Charset</a>
hAcceptCharset :: HeaderName

-- | <a>Accept-Encoding</a>
hAcceptEncoding :: HeaderName

-- | <a>Accept-Language</a>
hAcceptLanguage :: HeaderName

-- | <a>Accept-Ranges</a>
hAcceptRanges :: HeaderName

-- | <a>Age</a>
hAge :: HeaderName

-- | <a>Allow</a>
hAllow :: HeaderName

-- | <a>Authorization</a>
hAuthorization :: HeaderName

-- | <a>Cache-Control</a>
hCacheControl :: HeaderName

-- | <a>Connection</a>
hConnection :: HeaderName

-- | <a>Content-Disposition</a>
hContentDisposition :: HeaderName

-- | <a>Content-Encoding</a>
hContentEncoding :: HeaderName

-- | <a>Content-Language</a>
hContentLanguage :: HeaderName

-- | <a>Content-Length</a>
hContentLength :: HeaderName

-- | <a>Content-Location</a>
hContentLocation :: HeaderName

-- | <a>Content-MD5</a>
--   
--   <i>This header has been obsoleted in RFC 9110.</i>
hContentMD5 :: HeaderName

-- | <a>Content-Range</a>
hContentRange :: HeaderName

-- | <a>Content-Type</a>
hContentType :: HeaderName

-- | <a>Cookie</a>
hCookie :: HeaderName

-- | <a>Date</a>
hDate :: HeaderName

-- | <a>ETag</a>
hETag :: HeaderName

-- | <a>Expect</a>
hExpect :: HeaderName

-- | <a>Expires</a>
hExpires :: HeaderName

-- | <a>From</a>
hFrom :: HeaderName

-- | <a>Host</a>
hHost :: HeaderName

-- | <a>If-Match</a>
hIfMatch :: HeaderName

-- | <a>If-Modified-Since</a>
hIfModifiedSince :: HeaderName

-- | <a>If-None-Match</a>
hIfNoneMatch :: HeaderName

-- | <a>If-Range</a>
hIfRange :: HeaderName

-- | <a>If-Unmodified-Since</a>
hIfUnmodifiedSince :: HeaderName

-- | <a>Last-Modified</a>
hLastModified :: HeaderName

-- | <a>Location</a>
hLocation :: HeaderName

-- | <a>Max-Forwards</a>
hMaxForwards :: HeaderName

-- | <a>MIME-Version</a>
hMIMEVersion :: HeaderName

-- | <a>Origin</a>
hOrigin :: HeaderName

-- | <a>Pragma</a>
--   
--   <i>This header has been deprecated in RFC 9111 in favor of
--   "Cache-Control".</i>
hPragma :: HeaderName

-- | <a>Prefer</a>
hPrefer :: HeaderName

-- | <a>Preference-Applied</a>
hPreferenceApplied :: HeaderName

-- | <a>Proxy-Authenticate</a>
hProxyAuthenticate :: HeaderName

-- | <a>Proxy-Authorization</a>
hProxyAuthorization :: HeaderName

-- | <a>Range</a>
hRange :: HeaderName

-- | <a>Referer</a>
hReferer :: HeaderName

-- | <a>Retry-After</a>
hRetryAfter :: HeaderName

-- | <a>Server</a>
hServer :: HeaderName

-- | <a>Set-Cookie</a>
hSetCookie :: HeaderName

-- | <a>TE</a>
hTE :: HeaderName

-- | <a>Trailer</a>
hTrailer :: HeaderName

-- | <a>Transfer-Encoding</a>
hTransferEncoding :: HeaderName

-- | <a>Upgrade</a>
hUpgrade :: HeaderName

-- | <a>User-Agent</a>
hUserAgent :: HeaderName

-- | <a>Vary</a>
hVary :: HeaderName

-- | <a>Via</a>
hVia :: HeaderName

-- | <a>WWW-Authenticate</a>
hWWWAuthenticate :: HeaderName

-- | <a>Warning</a>
--   
--   <i>This header has been obsoleted in RFC 9110.</i>
hWarning :: HeaderName

-- | An individual byte range.
--   
--   Negative indices are not allowed!
data ByteRange
ByteRangeFrom :: !Integer -> ByteRange
ByteRangeFromTo :: !Integer -> !Integer -> ByteRange
ByteRangeSuffix :: !Integer -> ByteRange

-- | Turns a byte range into a byte string <a>Builder</a>.
renderByteRangeBuilder :: ByteRange -> Builder

-- | Renders a byte range into a <a>ByteString</a>.
--   
--   <pre>
--   &gt;&gt;&gt; renderByteRange (ByteRangeFrom 2048)
--   "2048-"
--   </pre>
renderByteRange :: ByteRange -> ByteString

-- | A list of byte ranges.
type ByteRanges = [ByteRange]

-- | Turns a list of byte ranges into a byte string <a>Builder</a>.
renderByteRangesBuilder :: ByteRanges -> Builder

-- | Renders a list of byte ranges into a <a>ByteString</a>.
--   
--   <pre>
--   &gt;&gt;&gt; renderByteRanges [ByteRangeFrom 2048, ByteRangeSuffix 20]
--   "bytes=2048-,-20"
--   </pre>
renderByteRanges :: ByteRanges -> ByteString

-- | Parse the value of a Range header into a <a>ByteRanges</a>.
--   
--   <pre>
--   &gt;&gt;&gt; parseByteRanges "error"
--   Nothing
--   
--   &gt;&gt;&gt; parseByteRanges "bytes=0-499"
--   Just [ByteRangeFromTo 0 499]
--   
--   &gt;&gt;&gt; parseByteRanges "bytes=500-999"
--   Just [ByteRangeFromTo 500 999]
--   
--   &gt;&gt;&gt; parseByteRanges "bytes=-500"
--   Just [ByteRangeSuffix 500]
--   
--   &gt;&gt;&gt; parseByteRanges "bytes=9500-"
--   Just [ByteRangeFrom 9500]
--   
--   &gt;&gt;&gt; parseByteRanges "bytes=0-0,-1"
--   Just [ByteRangeFromTo 0 0,ByteRangeSuffix 1]
--   
--   &gt;&gt;&gt; parseByteRanges "bytes=500-600,601-999"
--   Just [ByteRangeFromTo 500 600,ByteRangeFromTo 601 999]
--   
--   &gt;&gt;&gt; parseByteRanges "bytes=500-700,601-999"
--   Just [ByteRangeFromTo 500 700,ByteRangeFromTo 601 999]
--   </pre>
parseByteRanges :: ByteString -> Maybe ByteRanges
instance GHC.Generics.Generic Network.HTTP.Types.Header.ByteRange
instance Data.Data.Data Network.HTTP.Types.Header.ByteRange
instance GHC.Classes.Ord Network.HTTP.Types.Header.ByteRange
instance GHC.Classes.Eq Network.HTTP.Types.Header.ByteRange
instance GHC.Show.Show Network.HTTP.Types.Header.ByteRange


-- | Types and constants for HTTP methods.
--   
--   The HTTP standard defines a set of standard methods, when to use them,
--   and how to handle them. The standard set has been provided as a
--   separate data type <a>StdMethod</a>, but since you can also use custom
--   methods, the basic type <a>Method</a> is just a synonym for
--   <tt>ByteString</tt>.
module Network.HTTP.Types.Method

-- | HTTP method (flat <tt>ByteString</tt> type).
type Method = ByteString

-- | HTTP GET Method
methodGet :: Method

-- | HTTP POST Method
methodPost :: Method

-- | HTTP HEAD Method
methodHead :: Method

-- | HTTP PUT Method
methodPut :: Method

-- | HTTP DELETE Method
methodDelete :: Method

-- | HTTP TRACE Method
methodTrace :: Method

-- | HTTP CONNECT Method
methodConnect :: Method

-- | HTTP OPTIONS Method
methodOptions :: Method

-- | HTTP PATCH Method
methodPatch :: Method

-- | HTTP standard method (as defined by RFC 2616, and PATCH which is
--   defined by RFC 5789).
data StdMethod
GET :: StdMethod
POST :: StdMethod
HEAD :: StdMethod
PUT :: StdMethod
DELETE :: StdMethod
TRACE :: StdMethod
CONNECT :: StdMethod
OPTIONS :: StdMethod

PATCH :: StdMethod

-- | Convert a method <tt>ByteString</tt> to a <a>StdMethod</a> if
--   possible.
parseMethod :: Method -> Either ByteString StdMethod

-- | Convert an algebraic method to a <tt>ByteString</tt>.
--   
--   <pre>
--   renderMethod (parseMethod bs) == bs
--   </pre>
renderMethod :: Either ByteString StdMethod -> Method

-- | Convert a <a>StdMethod</a> to a <tt>ByteString</tt>.
renderStdMethod :: StdMethod -> Method
instance Data.Data.Data Network.HTTP.Types.Method.StdMethod
instance GHC.Generics.Generic Network.HTTP.Types.Method.StdMethod
instance GHC.Ix.Ix Network.HTTP.Types.Method.StdMethod
instance GHC.Enum.Bounded Network.HTTP.Types.Method.StdMethod
instance GHC.Enum.Enum Network.HTTP.Types.Method.StdMethod
instance GHC.Classes.Ord Network.HTTP.Types.Method.StdMethod
instance GHC.Classes.Eq Network.HTTP.Types.Method.StdMethod
instance GHC.Show.Show Network.HTTP.Types.Method.StdMethod
instance GHC.Read.Read Network.HTTP.Types.Method.StdMethod


-- | Types and constants to describe HTTP status codes.
--   
--   At the bottom are some functions to check if a given <a>Status</a> is
--   from a certain category. (i.e. <tt>1XX</tt>, <tt>2XX</tt>, etc.)
module Network.HTTP.Types.Status

-- | HTTP Status.
--   
--   Only the <a>statusCode</a> is used for comparisons.
--   
--   <i>Please use <a>mkStatus</a> to create status codes from code and
--   message, or the <a>Enum</a> instance or the</i> <i>status code
--   constants (like <a>ok200</a>). There might be additional record
--   members in the future.</i>
--   
--   Note that the <a>Show</a> instance is only for debugging.
data Status
Status :: Int -> ByteString -> Status
statusCode :: Status -> Int
statusMessage :: Status -> ByteString

-- | Create a <a>Status</a> from a status code and message.
mkStatus :: Int -> ByteString -> Status

-- | Continue 100
status100 :: Status

-- | Continue 100
continue100 :: Status

-- | Switching Protocols 101
status101 :: Status

-- | Switching Protocols 101
switchingProtocols101 :: Status

-- | OK 200
status200 :: Status

-- | OK 200
ok200 :: Status

-- | Created 201
status201 :: Status

-- | Created 201
created201 :: Status

-- | Accepted 202
status202 :: Status

-- | Accepted 202
accepted202 :: Status

-- | Non-Authoritative Information 203
status203 :: Status

-- | Non-Authoritative Information 203
nonAuthoritative203 :: Status

-- | No Content 204
status204 :: Status

-- | No Content 204
noContent204 :: Status

-- | Reset Content 205
status205 :: Status

-- | Reset Content 205
resetContent205 :: Status

-- | Partial Content 206
status206 :: Status

-- | Partial Content 206
partialContent206 :: Status

-- | Multiple Choices 300
status300 :: Status

-- | Multiple Choices 300
multipleChoices300 :: Status

-- | Moved Permanently 301
status301 :: Status

-- | Moved Permanently 301
movedPermanently301 :: Status

-- | Found 302
status302 :: Status

-- | Found 302
found302 :: Status

-- | See Other 303
status303 :: Status

-- | See Other 303
seeOther303 :: Status

-- | Not Modified 304
status304 :: Status

-- | Not Modified 304
notModified304 :: Status

-- | Use Proxy 305
status305 :: Status

-- | Use Proxy 305
useProxy305 :: Status

-- | Temporary Redirect 307
status307 :: Status

-- | Temporary Redirect 307
temporaryRedirect307 :: Status

-- | Permanent Redirect 308
status308 :: Status

-- | Permanent Redirect 308
permanentRedirect308 :: Status

-- | Bad Request 400
status400 :: Status

-- | Bad Request 400
badRequest400 :: Status

-- | Unauthorized 401
status401 :: Status

-- | Unauthorized 401
unauthorized401 :: Status

-- | Payment Required 402
status402 :: Status

-- | Payment Required 402
paymentRequired402 :: Status

-- | Forbidden 403
status403 :: Status

-- | Forbidden 403
forbidden403 :: Status

-- | Not Found 404
status404 :: Status

-- | Not Found 404
notFound404 :: Status

-- | Method Not Allowed 405
status405 :: Status

-- | Method Not Allowed 405
methodNotAllowed405 :: Status

-- | Not Acceptable 406
status406 :: Status

-- | Not Acceptable 406
notAcceptable406 :: Status

-- | Proxy Authentication Required 407
status407 :: Status

-- | Proxy Authentication Required 407
proxyAuthenticationRequired407 :: Status

-- | Request Timeout 408
status408 :: Status

-- | Request Timeout 408
requestTimeout408 :: Status

-- | Conflict 409
status409 :: Status

-- | Conflict 409
conflict409 :: Status

-- | Gone 410
status410 :: Status

-- | Gone 410
gone410 :: Status

-- | Length Required 411
status411 :: Status

-- | Length Required 411
lengthRequired411 :: Status

-- | Precondition Failed 412
status412 :: Status

-- | Precondition Failed 412
preconditionFailed412 :: Status

-- | Request Entity Too Large 413
status413 :: Status

-- | Request Entity Too Large 413
requestEntityTooLarge413 :: Status

-- | Request-URI Too Long 414
status414 :: Status

-- | Request-URI Too Long 414
requestURITooLong414 :: Status

-- | Unsupported Media Type 415
status415 :: Status

-- | Unsupported Media Type 415
unsupportedMediaType415 :: Status

-- | Requested Range Not Satisfiable 416
status416 :: Status

-- | Requested Range Not Satisfiable 416
requestedRangeNotSatisfiable416 :: Status

-- | Expectation Failed 417
status417 :: Status

-- | Expectation Failed 417
expectationFailed417 :: Status

-- | I'm a teapot 418
status418 :: Status

-- | I'm a teapot 418
imATeapot418 :: Status

-- | Unprocessable Entity 422 (<a>RFC 4918</a>)
status422 :: Status

-- | Unprocessable Entity 422 (<a>RFC 4918</a>)
unprocessableEntity422 :: Status

-- | Upgrade Required 426
--   (<a>https://tools.ietf.org/html/rfc7231#section-6.5.15</a>)
status426 :: Status

-- | Upgrade Required 426
--   (<a>https://tools.ietf.org/html/rfc7231#section-6.5.15</a>)
upgradeRequired426 :: Status

-- | Precondition Required 428 (<a>RFC 6585</a>)
status428 :: Status

-- | Precondition Required 428 (<a>RFC 6585</a>)
preconditionRequired428 :: Status

-- | Too Many Requests 429 (<a>RFC 6585</a>)
status429 :: Status

-- | Too Many Requests 429 (<a>RFC 6585</a>)
tooManyRequests429 :: Status

-- | Request Header Fields Too Large 431 (<a>RFC 6585</a>)
status431 :: Status

-- | Request Header Fields Too Large 431 (<a>RFC 6585</a>)
requestHeaderFieldsTooLarge431 :: Status

-- | Internal Server Error 500
status500 :: Status

-- | Internal Server Error 500
internalServerError500 :: Status

-- | Not Implemented 501
status501 :: Status

-- | Not Implemented 501
notImplemented501 :: Status

-- | Bad Gateway 502
status502 :: Status

-- | Bad Gateway 502
badGateway502 :: Status

-- | Service Unavailable 503
status503 :: Status

-- | Service Unavailable 503
serviceUnavailable503 :: Status

-- | Gateway Timeout 504
status504 :: Status

-- | Gateway Timeout 504
gatewayTimeout504 :: Status

-- | HTTP Version Not Supported 505
status505 :: Status

-- | Network Authentication Required 511 (<a>RFC 6585</a>)
status511 :: Status

-- | Network Authentication Required 511 (<a>RFC 6585</a>)
networkAuthenticationRequired511 :: Status

-- | HTTP Version Not Supported 505
httpVersionNotSupported505 :: Status

-- | Informational class
--   
--   Checks if the status is in the 1XX range.
statusIsInformational :: Status -> Bool

-- | Successful class
--   
--   Checks if the status is in the 2XX range.
statusIsSuccessful :: Status -> Bool

-- | Redirection class
--   
--   Checks if the status is in the 3XX range.
statusIsRedirection :: Status -> Bool

-- | Client Error class
--   
--   Checks if the status is in the 4XX range.
statusIsClientError :: Status -> Bool

-- | Server Error class
--   
--   Checks if the status is in the 5XX range.
statusIsServerError :: Status -> Bool
instance GHC.Generics.Generic Network.HTTP.Types.Status.Status
instance Data.Data.Data Network.HTTP.Types.Status.Status
instance GHC.Show.Show Network.HTTP.Types.Status.Status
instance GHC.Classes.Eq Network.HTTP.Types.Status.Status
instance GHC.Classes.Ord Network.HTTP.Types.Status.Status
instance GHC.Enum.Enum Network.HTTP.Types.Status.Status
instance GHC.Enum.Bounded Network.HTTP.Types.Status.Status


-- | Query strings generally have the following form:
--   <tt>"key1=value1&amp;key2=value2"</tt>
--   
--   <pre>
--   &gt;&gt;&gt; renderQuery False [("key1", Just "value1"), ("key2", Just "value2")]
--   "key1=value1&amp;key2=value2"
--   </pre>
--   
--   But if the value of <tt>key1</tt> is <a>Nothing</a>, it becomes:
--   <tt>key1&amp;key2=value2</tt>
--   
--   <pre>
--   &gt;&gt;&gt; renderQuery False [("key1", Nothing), ("key2", Just "value2")]
--   "key1&amp;key2=value2"
--   </pre>
--   
--   This module also provides type synonyms and functions to handle
--   queries that do not allow/expect keys without values
--   (<a>SimpleQuery</a>), handle queries which have partially escaped
--   characters
module Network.HTTP.Types.URI

-- | A sequence of <a>QueryItem</a>s.
type Query = [QueryItem]

-- | An item from the query string, split up into two parts.
--   
--   The second part should be <a>Nothing</a> if there was no key-value
--   separator after the query item name.
type QueryItem = (ByteString, Maybe ByteString)

-- | Renders the given <a>Query</a> into a <a>ByteString</a>.
--   
--   If you want a question mark (<tt>?</tt>) added to the front of the
--   result, use <a>True</a>.
renderQuery :: Bool -> Query -> ByteString

-- | Renders the given <a>Query</a> into a <tt>Builder</tt>.
--   
--   If you want a question mark (<tt>?</tt>) added to the front of the
--   result, use <a>True</a>.
renderQueryBuilder :: Bool -> Query -> Builder

-- | Split out the query string into a list of keys and values. A few
--   importants points:
--   
--   <ul>
--   <li>The result returned is still bytestrings, since we perform no
--   character decoding here. Most likely, you will want to use UTF-8
--   decoding, but this is left to the user of the library.</li>
--   <li>Percent decoding errors are ignored. In particular, <tt>"%Q"</tt>
--   will be output as <tt>"%Q"</tt>.</li>
--   <li>It decodes <tt>'+'</tt> characters to <tt>' '</tt></li>
--   </ul>
parseQuery :: ByteString -> Query

-- | Same functionality as <a>parseQuery</a>, but with the option to decode
--   <tt>'+'</tt> characters to <tt>' '</tt> or to preserve any
--   <tt>'+'</tt> encountered.
--   
--   If you want to replace any <tt>'+'</tt> with a space, use <a>True</a>.
parseQueryReplacePlus :: Bool -> ByteString -> Query

-- | Like Query, but with <a>Text</a> instead of <a>ByteString</a>
--   (UTF8-encoded).
type QueryText = [(Text, Maybe Text)]

-- | Convert <a>QueryText</a> to <a>Query</a>.
queryTextToQuery :: QueryText -> Query

-- | Convert <a>Query</a> to <a>QueryText</a> (leniently decoding the
--   UTF-8).
queryToQueryText :: Query -> QueryText

-- | Convert <a>QueryText</a> to a <a>Builder</a>.
--   
--   If you want a question mark (<tt>?</tt>) added to the front of the
--   result, use <a>True</a>.
renderQueryText :: Bool -> QueryText -> Builder

-- | Parse a <a>QueryText</a> from a <a>ByteString</a>. See
--   <a>parseQuery</a> for details.
--   
--   <pre>
--   <a>queryToQueryText</a> . <a>parseQuery</a>
--   </pre>
parseQueryText :: ByteString -> QueryText

-- | A sequence of <a>SimpleQueryItem</a>s.
type SimpleQuery = [SimpleQueryItem]

-- | Simplified query item type without support for parameter-less items.
type SimpleQueryItem = (ByteString, ByteString)

-- | Convert <a>SimpleQuery</a> to <a>Query</a>.
simpleQueryToQuery :: SimpleQuery -> Query

-- | Render the given <a>SimpleQuery</a> into a <tt>ByteString</tt>.
--   
--   If you want a question mark (<tt>?</tt>) added to the front of the
--   result, use <a>True</a>.
renderSimpleQuery :: Bool -> SimpleQuery -> ByteString

-- | Parse <a>SimpleQuery</a> from a <tt>ByteString</tt>.
--   
--   This uses <a>parseQuery</a> under the hood, and will transform any
--   <a>Nothing</a> values into an empty <a>ByteString</a>.
parseSimpleQuery :: ByteString -> SimpleQuery

-- | Query with some characters that should not be escaped.
--   
--   General form: <tt>a=b&amp;c=d:e+f&amp;g=h</tt>
type PartialEscapeQuery = [PartialEscapeQueryItem]

-- | Partially escaped query item.
--   
--   The key will always be encoded using <tt>'urlEncode True'</tt>, but
--   the value will be encoded depending on which <a>EscapeItem</a>s are
--   used.
type PartialEscapeQueryItem = (ByteString, [EscapeItem])

-- | Section of a query item value that decides whether to use regular URL
--   encoding (using <tt>'urlEncode True'</tt>) with <a>QE</a>, or to not
--   encode <i>anything</i> with <a>QN</a>.
data EscapeItem

-- | will be URL encoded
QE :: ByteString -> EscapeItem

-- | will NOT <i>at all</i> be URL encoded
QN :: ByteString -> EscapeItem

-- | Convert <a>PartialEscapeQuery</a> to <tt>ByteString</tt>.
--   
--   If you want a question mark (<tt>?</tt>) added to the front of the
--   result, use <a>True</a>.
--   
--   <pre>
--   &gt;&gt;&gt; renderQueryPartialEscape True [("a", [QN "x:z + ", QE (encodeUtf8 "They said: \"שלום\"")])]
--   "?a=x:z + They%20said%3A%20%22%D7%A9%D7%9C%D7%95%D7%9D%22"
--   </pre>
renderQueryPartialEscape :: Bool -> PartialEscapeQuery -> ByteString

-- | Convert a <a>PartialEscapeQuery</a> to a <a>Builder</a>.
--   
--   If you want a question mark (<tt>?</tt>) added to the front of the
--   result, use <a>True</a>.
renderQueryBuilderPartialEscape :: Bool -> PartialEscapeQuery -> Builder

-- | Extract whole path (path segments + query) from a <a>RFC 2616
--   Request-URI</a>.
--   
--   Though a more accurate description of this function's behaviour is
--   that it removes the domain/origin if the string starts with an HTTP
--   protocol. (i.e. <tt>http://</tt> or <tt>https://</tt>)
--   
--   This function will not change anything when given any other
--   <a>ByteString</a>. (except return a root path <tt>"/"</tt> if given an
--   empty string)
--   
--   <pre>
--   &gt;&gt;&gt; extractPath "/path"
--   "/path"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; extractPath "http://example.com:8080/path"
--   "/path"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; extractPath "http://example.com"
--   "/"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; extractPath ""
--   "/"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; extractPath "www.google.com/some/path"
--   "www.google.com/some/path"
--   </pre>
extractPath :: ByteString -> ByteString

-- | Encode a whole path (path segments + query).
encodePath :: [Text] -> Query -> Builder

-- | Decode a whole path (path segments + query).
decodePath :: ByteString -> ([Text], Query)

-- | Encodes a list of path segments into a valid URL fragment.
--   
--   This function takes the following three steps:
--   
--   <ul>
--   <li>UTF-8 encodes the characters.</li>
--   <li>Prepends each segment with a slash.</li>
--   <li>Performs percent-encoding on all characters that are
--   <b>not</b>:<ul><li>alphanumeric (i.e. <tt>A-Z</tt> and
--   <tt>a-z</tt>)</li><li>digits (i.e. <tt>0-9</tt>)</li><li>a dash
--   <tt>'-'</tt>, an underscore <tt>'_'</tt>, a dot <tt>'.'</tt>, or a
--   tilde <tt>'~'</tt></li></ul></li>
--   </ul>
--   
--   For example:
--   
--   <pre>
--   &gt;&gt;&gt; encodePathSegments ["foo", "bar1", "~baz"]
--   "/foo/bar1/~baz"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; encodePathSegments ["foo bar", "baz/bin"]
--   "/foo%20bar/baz%2Fbin"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; encodePathSegments ["שלום"]
--   "/%D7%A9%D7%9C%D7%95%D7%9D"
--   </pre>
--   
--   Huge thanks to <i>Jeremy Shaw</i> who created the original
--   implementation of this function in web-routes and did such thorough
--   research to determine all correct escaping procedures.
encodePathSegments :: [Text] -> Builder

-- | Like <a>encodePathSegments</a>, but without the initial slash.
encodePathSegmentsRelative :: [Text] -> Builder

-- | Parse a list of path segments from a valid URL fragment.
--   
--   Will also decode any percent-encoded characters.
decodePathSegments :: ByteString -> [Text]

-- | Percent-encoding for URLs.
--   
--   In short:
--   
--   <ul>
--   <li>if you're encoding (parts of) a path element, use
--   <a>False</a>.</li>
--   <li>if you're encoding (parts of) a query string, use
--   <a>True</a>.</li>
--   </ul>
--   
--   <h3><b>In-depth explanation</b></h3>
--   
--   This will substitute every byte with its percent-encoded equivalent
--   unless:
--   
--   <ul>
--   <li>The byte is alphanumeric. (i.e. <tt>A-Z</tt>, <tt>a-z</tt>, or
--   <tt>0-9</tt>)</li>
--   <li>The byte is either a dash <tt>'-'</tt>, an underscore
--   <tt>'_'</tt>, a dot <tt>'.'</tt>, or a tilde <tt>'~'</tt></li>
--   <li>If <a>False</a> is used, the following will also <i>not</i> be
--   percent-encoded:<ul><li>colon <tt>':'</tt>, at sign <tt>'@'</tt>,
--   ampersand <tt>'&amp;'</tt>, equals sign <tt>'='</tt>, plus sign
--   <tt>'+'</tt>, dollar sign <tt>'$'</tt> or a comma
--   <tt>','</tt></li></ul></li>
--   </ul>
urlEncode :: Bool -> ByteString -> ByteString

-- | Percent-encoding for URLs.
--   
--   Like <a>urlEncode</a>, but only makes the <a>Builder</a>.
urlEncodeBuilder :: Bool -> ByteString -> Builder

-- | Percent-decoding.
--   
--   If you want to replace any <tt>'+'</tt> with a space, use <a>True</a>.
urlDecode :: Bool -> ByteString -> ByteString
instance GHC.Classes.Ord Network.HTTP.Types.URI.EscapeItem
instance GHC.Classes.Eq Network.HTTP.Types.URI.EscapeItem
instance GHC.Show.Show Network.HTTP.Types.URI.EscapeItem


-- | Some type classes to make more general functions when handling query
--   strings.
module Network.HTTP.Types.QueryLike

-- | Types which can, and commonly are, converted to <a>Query</a> are in
--   this class.
--   
--   You can use lists of simple key value pairs, with <a>ByteString</a>
--   (strict, or lazy: <a>ByteString</a>), <a>Text</a>, or <a>String</a> as
--   the key/value types. You can also have the value type lifted into a
--   Maybe to support keys without values; and finally it is possible to
--   put each pair into a Maybe for key-value pairs that aren't always
--   present.
class QueryLike a

-- | Convert to <a>Query</a>.
toQuery :: QueryLike a => a -> Query

-- | Types which, in a Query-like key-value list, are used in the Key
--   position.
class QueryKeyLike a
toQueryKey :: QueryKeyLike a => a -> ByteString

-- | Types which, in a Query-like key-value list, are used in the Value
--   position.
class QueryValueLike a
toQueryValue :: QueryValueLike a => a -> Maybe ByteString
instance (Network.HTTP.Types.QueryLike.QueryKeyLike k, Network.HTTP.Types.QueryLike.QueryValueLike v) => Network.HTTP.Types.QueryLike.QueryLike [(k, v)]
instance (Network.HTTP.Types.QueryLike.QueryKeyLike k, Network.HTTP.Types.QueryLike.QueryValueLike v) => Network.HTTP.Types.QueryLike.QueryLike [GHC.Maybe.Maybe (k, v)]
instance Network.HTTP.Types.QueryLike.QueryValueLike Data.ByteString.Internal.Type.ByteString
instance Network.HTTP.Types.QueryLike.QueryValueLike Data.ByteString.Lazy.Internal.ByteString
instance Network.HTTP.Types.QueryLike.QueryValueLike Data.Text.Internal.Text
instance Network.HTTP.Types.QueryLike.QueryValueLike [GHC.Types.Char]
instance Network.HTTP.Types.QueryLike.QueryValueLike a => Network.HTTP.Types.QueryLike.QueryValueLike (GHC.Maybe.Maybe a)
instance Network.HTTP.Types.QueryLike.QueryKeyLike Data.ByteString.Internal.Type.ByteString
instance Network.HTTP.Types.QueryLike.QueryKeyLike Data.ByteString.Lazy.Internal.ByteString
instance Network.HTTP.Types.QueryLike.QueryKeyLike Data.Text.Internal.Text
instance Network.HTTP.Types.QueryLike.QueryKeyLike [GHC.Types.Char]


-- | Types and constants to describe the HTTP version.
module Network.HTTP.Types.Version

-- | HTTP Version.
--   
--   Note that the <a>Show</a> instance is intended merely for debugging.
data HttpVersion
HttpVersion :: !Int -> !Int -> HttpVersion
[httpMajor] :: HttpVersion -> !Int
[httpMinor] :: HttpVersion -> !Int

-- | HTTP 0.9
http09 :: HttpVersion

-- | HTTP 1.0
http10 :: HttpVersion

-- | HTTP 1.1
http11 :: HttpVersion

-- | HTTP 2.0
http20 :: HttpVersion
instance GHC.Generics.Generic Network.HTTP.Types.Version.HttpVersion
instance Data.Data.Data Network.HTTP.Types.Version.HttpVersion
instance GHC.Classes.Ord Network.HTTP.Types.Version.HttpVersion
instance GHC.Classes.Eq Network.HTTP.Types.Version.HttpVersion
instance GHC.Show.Show Network.HTTP.Types.Version.HttpVersion

module Network.HTTP.Types

-- | HTTP method (flat <tt>ByteString</tt> type).
type Method = ByteString

-- | HTTP GET Method
methodGet :: Method

-- | HTTP POST Method
methodPost :: Method

-- | HTTP HEAD Method
methodHead :: Method

-- | HTTP PUT Method
methodPut :: Method

-- | HTTP DELETE Method
methodDelete :: Method

-- | HTTP TRACE Method
methodTrace :: Method

-- | HTTP CONNECT Method
methodConnect :: Method

-- | HTTP OPTIONS Method
methodOptions :: Method

-- | HTTP PATCH Method
methodPatch :: Method

-- | HTTP standard method (as defined by RFC 2616, and PATCH which is
--   defined by RFC 5789).
data StdMethod
GET :: StdMethod
POST :: StdMethod
HEAD :: StdMethod
PUT :: StdMethod
DELETE :: StdMethod
TRACE :: StdMethod
CONNECT :: StdMethod
OPTIONS :: StdMethod

PATCH :: StdMethod

-- | Convert a method <tt>ByteString</tt> to a <a>StdMethod</a> if
--   possible.
parseMethod :: Method -> Either ByteString StdMethod

-- | Convert an algebraic method to a <tt>ByteString</tt>.
--   
--   <pre>
--   renderMethod (parseMethod bs) == bs
--   </pre>
renderMethod :: Either ByteString StdMethod -> Method

-- | Convert a <a>StdMethod</a> to a <tt>ByteString</tt>.
renderStdMethod :: StdMethod -> Method

-- | HTTP Version.
--   
--   Note that the <a>Show</a> instance is intended merely for debugging.
data HttpVersion
HttpVersion :: !Int -> !Int -> HttpVersion
[httpMajor] :: HttpVersion -> !Int
[httpMinor] :: HttpVersion -> !Int

-- | HTTP 0.9
http09 :: HttpVersion

-- | HTTP 1.0
http10 :: HttpVersion

-- | HTTP 1.1
http11 :: HttpVersion

-- | HTTP 2.0
http20 :: HttpVersion

-- | HTTP Status.
--   
--   Only the <a>statusCode</a> is used for comparisons.
--   
--   <i>Please use <a>mkStatus</a> to create status codes from code and
--   message, or the <a>Enum</a> instance or the</i> <i>status code
--   constants (like <a>ok200</a>). There might be additional record
--   members in the future.</i>
--   
--   Note that the <a>Show</a> instance is only for debugging.
data Status
Status :: Int -> ByteString -> Status
[statusCode] :: Status -> Int
[statusMessage] :: Status -> ByteString

-- | Create a <a>Status</a> from a status code and message.
mkStatus :: Int -> ByteString -> Status

-- | Continue 100
status100 :: Status

-- | Continue 100
continue100 :: Status

-- | Switching Protocols 101
status101 :: Status

-- | Switching Protocols 101
switchingProtocols101 :: Status

-- | OK 200
status200 :: Status

-- | OK 200
ok200 :: Status

-- | Created 201
status201 :: Status

-- | Created 201
created201 :: Status

-- | Accepted 202
status202 :: Status

-- | Accepted 202
accepted202 :: Status

-- | Non-Authoritative Information 203
status203 :: Status

-- | Non-Authoritative Information 203
nonAuthoritative203 :: Status

-- | No Content 204
status204 :: Status

-- | No Content 204
noContent204 :: Status

-- | Reset Content 205
status205 :: Status

-- | Reset Content 205
resetContent205 :: Status

-- | Partial Content 206
status206 :: Status

-- | Partial Content 206
partialContent206 :: Status

-- | Multiple Choices 300
status300 :: Status

-- | Multiple Choices 300
multipleChoices300 :: Status

-- | Moved Permanently 301
status301 :: Status

-- | Moved Permanently 301
movedPermanently301 :: Status

-- | Found 302
status302 :: Status

-- | Found 302
found302 :: Status

-- | See Other 303
status303 :: Status

-- | See Other 303
seeOther303 :: Status

-- | Not Modified 304
status304 :: Status

-- | Not Modified 304
notModified304 :: Status

-- | Use Proxy 305
status305 :: Status

-- | Use Proxy 305
useProxy305 :: Status

-- | Temporary Redirect 307
status307 :: Status

-- | Temporary Redirect 307
temporaryRedirect307 :: Status

-- | Permanent Redirect 308
status308 :: Status

-- | Permanent Redirect 308
permanentRedirect308 :: Status

-- | Bad Request 400
status400 :: Status

-- | Bad Request 400
badRequest400 :: Status

-- | Unauthorized 401
status401 :: Status

-- | Unauthorized 401
unauthorized401 :: Status

-- | Payment Required 402
status402 :: Status

-- | Payment Required 402
paymentRequired402 :: Status

-- | Forbidden 403
status403 :: Status

-- | Forbidden 403
forbidden403 :: Status

-- | Not Found 404
status404 :: Status

-- | Not Found 404
notFound404 :: Status

-- | Method Not Allowed 405
status405 :: Status

-- | Method Not Allowed 405
methodNotAllowed405 :: Status

-- | Not Acceptable 406
status406 :: Status

-- | Not Acceptable 406
notAcceptable406 :: Status

-- | Proxy Authentication Required 407
status407 :: Status

-- | Proxy Authentication Required 407
proxyAuthenticationRequired407 :: Status

-- | Request Timeout 408
status408 :: Status

-- | Request Timeout 408
requestTimeout408 :: Status

-- | Conflict 409
status409 :: Status

-- | Conflict 409
conflict409 :: Status

-- | Gone 410
status410 :: Status

-- | Gone 410
gone410 :: Status

-- | Length Required 411
status411 :: Status

-- | Length Required 411
lengthRequired411 :: Status

-- | Precondition Failed 412
status412 :: Status

-- | Precondition Failed 412
preconditionFailed412 :: Status

-- | Request Entity Too Large 413
status413 :: Status

-- | Request Entity Too Large 413
requestEntityTooLarge413 :: Status

-- | Request-URI Too Long 414
status414 :: Status

-- | Request-URI Too Long 414
requestURITooLong414 :: Status

-- | Unsupported Media Type 415
status415 :: Status

-- | Unsupported Media Type 415
unsupportedMediaType415 :: Status

-- | Requested Range Not Satisfiable 416
status416 :: Status

-- | Requested Range Not Satisfiable 416
requestedRangeNotSatisfiable416 :: Status

-- | Expectation Failed 417
status417 :: Status

-- | Expectation Failed 417
expectationFailed417 :: Status

-- | I'm a teapot 418
status418 :: Status

-- | I'm a teapot 418
imATeapot418 :: Status

-- | Unprocessable Entity 422 (<a>RFC 4918</a>)
status422 :: Status

-- | Unprocessable Entity 422 (<a>RFC 4918</a>)
unprocessableEntity422 :: Status

-- | Precondition Required 428 (<a>RFC 6585</a>)
status428 :: Status

-- | Precondition Required 428 (<a>RFC 6585</a>)
preconditionRequired428 :: Status

-- | Too Many Requests 429 (<a>RFC 6585</a>)
status429 :: Status

-- | Too Many Requests 429 (<a>RFC 6585</a>)
tooManyRequests429 :: Status

-- | Request Header Fields Too Large 431 (<a>RFC 6585</a>)
status431 :: Status

-- | Request Header Fields Too Large 431 (<a>RFC 6585</a>)
requestHeaderFieldsTooLarge431 :: Status

-- | Internal Server Error 500
status500 :: Status

-- | Internal Server Error 500
internalServerError500 :: Status

-- | Not Implemented 501
status501 :: Status

-- | Not Implemented 501
notImplemented501 :: Status

-- | Bad Gateway 502
status502 :: Status

-- | Bad Gateway 502
badGateway502 :: Status

-- | Service Unavailable 503
status503 :: Status

-- | Service Unavailable 503
serviceUnavailable503 :: Status

-- | Gateway Timeout 504
status504 :: Status

-- | Gateway Timeout 504
gatewayTimeout504 :: Status

-- | HTTP Version Not Supported 505
status505 :: Status

-- | HTTP Version Not Supported 505
httpVersionNotSupported505 :: Status

-- | Network Authentication Required 511 (<a>RFC 6585</a>)
status511 :: Status

-- | Network Authentication Required 511 (<a>RFC 6585</a>)
networkAuthenticationRequired511 :: Status

-- | Informational class
--   
--   Checks if the status is in the 1XX range.
statusIsInformational :: Status -> Bool

-- | Successful class
--   
--   Checks if the status is in the 2XX range.
statusIsSuccessful :: Status -> Bool

-- | Redirection class
--   
--   Checks if the status is in the 3XX range.
statusIsRedirection :: Status -> Bool

-- | Client Error class
--   
--   Checks if the status is in the 4XX range.
statusIsClientError :: Status -> Bool

-- | Server Error class
--   
--   Checks if the status is in the 5XX range.
statusIsServerError :: Status -> Bool

-- | A full HTTP header field with the name and value separated.
--   
--   E.g. <tt>"Content-Length: 28"</tt> parsed into a <a>Header</a> would
--   turn into <tt>("Content-Length", "28")</tt>
type Header = (HeaderName, ByteString)

-- | A case-insensitive name of a header field.
--   
--   This is the part of the header field before the colon: <tt>HeaderName:
--   some value</tt>
type HeaderName = CI ByteString

-- | A list of <a>Header</a>s.
--   
--   Same type as <a>ResponseHeaders</a>, but useful to differentiate in
--   type signatures.
type RequestHeaders = [Header]

-- | A list of <a>Header</a>s.
--   
--   Same type as <a>RequestHeaders</a>, but useful to differentiate in
--   type signatures.
type ResponseHeaders = [Header]

-- | <a>Accept</a>
hAccept :: HeaderName

-- | <a>Accept-Language</a>
hAcceptLanguage :: HeaderName

-- | <a>Authorization</a>
hAuthorization :: HeaderName

-- | <a>Cache-Control</a>
hCacheControl :: HeaderName

-- | <a>Cookie</a>
hCookie :: HeaderName

-- | <a>Connection</a>
hConnection :: HeaderName

-- | <a>Content-Encoding</a>
hContentEncoding :: HeaderName

-- | <a>Content-Length</a>
hContentLength :: HeaderName

-- | <a>Content-MD5</a>
--   
--   <i>This header has been obsoleted in RFC 9110.</i>
hContentMD5 :: HeaderName

-- | <a>Content-Type</a>
hContentType :: HeaderName

-- | <a>Date</a>
hDate :: HeaderName

-- | <a>If-Modified-Since</a>
hIfModifiedSince :: HeaderName

-- | <a>If-Range</a>
hIfRange :: HeaderName

-- | <a>Last-Modified</a>
hLastModified :: HeaderName

-- | <a>Location</a>
hLocation :: HeaderName

-- | <a>Range</a>
hRange :: HeaderName

-- | <a>Referer</a>
hReferer :: HeaderName

-- | <a>Server</a>
hServer :: HeaderName

-- | <a>User-Agent</a>
hUserAgent :: HeaderName

-- | An individual byte range.
--   
--   Negative indices are not allowed!
data ByteRange
ByteRangeFrom :: !Integer -> ByteRange
ByteRangeFromTo :: !Integer -> !Integer -> ByteRange
ByteRangeSuffix :: !Integer -> ByteRange

-- | Turns a byte range into a byte string <a>Builder</a>.
renderByteRangeBuilder :: ByteRange -> Builder

-- | Renders a byte range into a <a>ByteString</a>.
--   
--   <pre>
--   &gt;&gt;&gt; renderByteRange (ByteRangeFrom 2048)
--   "2048-"
--   </pre>
renderByteRange :: ByteRange -> ByteString

-- | A list of byte ranges.
type ByteRanges = [ByteRange]

-- | Turns a list of byte ranges into a byte string <a>Builder</a>.
renderByteRangesBuilder :: ByteRanges -> Builder

-- | Renders a list of byte ranges into a <a>ByteString</a>.
--   
--   <pre>
--   &gt;&gt;&gt; renderByteRanges [ByteRangeFrom 2048, ByteRangeSuffix 20]
--   "bytes=2048-,-20"
--   </pre>
renderByteRanges :: ByteRanges -> ByteString

-- | Parse the value of a Range header into a <a>ByteRanges</a>.
--   
--   <pre>
--   &gt;&gt;&gt; parseByteRanges "error"
--   Nothing
--   
--   &gt;&gt;&gt; parseByteRanges "bytes=0-499"
--   Just [ByteRangeFromTo 0 499]
--   
--   &gt;&gt;&gt; parseByteRanges "bytes=500-999"
--   Just [ByteRangeFromTo 500 999]
--   
--   &gt;&gt;&gt; parseByteRanges "bytes=-500"
--   Just [ByteRangeSuffix 500]
--   
--   &gt;&gt;&gt; parseByteRanges "bytes=9500-"
--   Just [ByteRangeFrom 9500]
--   
--   &gt;&gt;&gt; parseByteRanges "bytes=0-0,-1"
--   Just [ByteRangeFromTo 0 0,ByteRangeSuffix 1]
--   
--   &gt;&gt;&gt; parseByteRanges "bytes=500-600,601-999"
--   Just [ByteRangeFromTo 500 600,ByteRangeFromTo 601 999]
--   
--   &gt;&gt;&gt; parseByteRanges "bytes=500-700,601-999"
--   Just [ByteRangeFromTo 500 700,ByteRangeFromTo 601 999]
--   </pre>
parseByteRanges :: ByteString -> Maybe ByteRanges

-- | A sequence of <a>QueryItem</a>s.
type Query = [QueryItem]

-- | An item from the query string, split up into two parts.
--   
--   The second part should be <a>Nothing</a> if there was no key-value
--   separator after the query item name.
type QueryItem = (ByteString, Maybe ByteString)

-- | Renders the given <a>Query</a> into a <a>ByteString</a>.
--   
--   If you want a question mark (<tt>?</tt>) added to the front of the
--   result, use <a>True</a>.
renderQuery :: Bool -> Query -> ByteString

-- | Renders the given <a>Query</a> into a <tt>Builder</tt>.
--   
--   If you want a question mark (<tt>?</tt>) added to the front of the
--   result, use <a>True</a>.
renderQueryBuilder :: Bool -> Query -> Builder

-- | Split out the query string into a list of keys and values. A few
--   importants points:
--   
--   <ul>
--   <li>The result returned is still bytestrings, since we perform no
--   character decoding here. Most likely, you will want to use UTF-8
--   decoding, but this is left to the user of the library.</li>
--   <li>Percent decoding errors are ignored. In particular, <tt>"%Q"</tt>
--   will be output as <tt>"%Q"</tt>.</li>
--   <li>It decodes <tt>'+'</tt> characters to <tt>' '</tt></li>
--   </ul>
parseQuery :: ByteString -> Query

-- | Same functionality as <a>parseQuery</a>, but with the option to decode
--   <tt>'+'</tt> characters to <tt>' '</tt> or to preserve any
--   <tt>'+'</tt> encountered.
--   
--   If you want to replace any <tt>'+'</tt> with a space, use <a>True</a>.
parseQueryReplacePlus :: Bool -> ByteString -> Query

-- | Like Query, but with <a>Text</a> instead of <a>ByteString</a>
--   (UTF8-encoded).
type QueryText = [(Text, Maybe Text)]

-- | Convert <a>QueryText</a> to <a>Query</a>.
queryTextToQuery :: QueryText -> Query

-- | Convert <a>Query</a> to <a>QueryText</a> (leniently decoding the
--   UTF-8).
queryToQueryText :: Query -> QueryText

-- | Convert <a>QueryText</a> to a <a>Builder</a>.
--   
--   If you want a question mark (<tt>?</tt>) added to the front of the
--   result, use <a>True</a>.
renderQueryText :: Bool -> QueryText -> Builder

-- | Parse a <a>QueryText</a> from a <a>ByteString</a>. See
--   <a>parseQuery</a> for details.
--   
--   <pre>
--   <a>queryToQueryText</a> . <a>parseQuery</a>
--   </pre>
parseQueryText :: ByteString -> QueryText

-- | A sequence of <a>SimpleQueryItem</a>s.
type SimpleQuery = [SimpleQueryItem]

-- | Simplified query item type without support for parameter-less items.
type SimpleQueryItem = (ByteString, ByteString)

-- | Convert <a>SimpleQuery</a> to <a>Query</a>.
simpleQueryToQuery :: SimpleQuery -> Query

-- | Render the given <a>SimpleQuery</a> into a <tt>ByteString</tt>.
--   
--   If you want a question mark (<tt>?</tt>) added to the front of the
--   result, use <a>True</a>.
renderSimpleQuery :: Bool -> SimpleQuery -> ByteString

-- | Parse <a>SimpleQuery</a> from a <tt>ByteString</tt>.
--   
--   This uses <a>parseQuery</a> under the hood, and will transform any
--   <a>Nothing</a> values into an empty <a>ByteString</a>.
parseSimpleQuery :: ByteString -> SimpleQuery

-- | Query with some characters that should not be escaped.
--   
--   General form: <tt>a=b&amp;c=d:e+f&amp;g=h</tt>
type PartialEscapeQuery = [PartialEscapeQueryItem]

-- | Partially escaped query item.
--   
--   The key will always be encoded using <tt>'urlEncode True'</tt>, but
--   the value will be encoded depending on which <a>EscapeItem</a>s are
--   used.
type PartialEscapeQueryItem = (ByteString, [EscapeItem])

-- | Section of a query item value that decides whether to use regular URL
--   encoding (using <tt>'urlEncode True'</tt>) with <a>QE</a>, or to not
--   encode <i>anything</i> with <a>QN</a>.
data EscapeItem

-- | will be URL encoded
QE :: ByteString -> EscapeItem

-- | will NOT <i>at all</i> be URL encoded
QN :: ByteString -> EscapeItem

-- | Convert <a>PartialEscapeQuery</a> to <tt>ByteString</tt>.
--   
--   If you want a question mark (<tt>?</tt>) added to the front of the
--   result, use <a>True</a>.
--   
--   <pre>
--   &gt;&gt;&gt; renderQueryPartialEscape True [("a", [QN "x:z + ", QE (encodeUtf8 "They said: \"שלום\"")])]
--   "?a=x:z + They%20said%3A%20%22%D7%A9%D7%9C%D7%95%D7%9D%22"
--   </pre>
renderQueryPartialEscape :: Bool -> PartialEscapeQuery -> ByteString

-- | Convert a <a>PartialEscapeQuery</a> to a <a>Builder</a>.
--   
--   If you want a question mark (<tt>?</tt>) added to the front of the
--   result, use <a>True</a>.
renderQueryBuilderPartialEscape :: Bool -> PartialEscapeQuery -> Builder

-- | Types which can, and commonly are, converted to <a>Query</a> are in
--   this class.
--   
--   You can use lists of simple key value pairs, with <a>ByteString</a>
--   (strict, or lazy: <a>ByteString</a>), <a>Text</a>, or <a>String</a> as
--   the key/value types. You can also have the value type lifted into a
--   Maybe to support keys without values; and finally it is possible to
--   put each pair into a Maybe for key-value pairs that aren't always
--   present.
class QueryLike a

-- | Convert to <a>Query</a>.
toQuery :: QueryLike a => a -> Query

-- | Extract whole path (path segments + query) from a <a>RFC 2616
--   Request-URI</a>.
--   
--   Though a more accurate description of this function's behaviour is
--   that it removes the domain/origin if the string starts with an HTTP
--   protocol. (i.e. <tt>http://</tt> or <tt>https://</tt>)
--   
--   This function will not change anything when given any other
--   <a>ByteString</a>. (except return a root path <tt>"/"</tt> if given an
--   empty string)
--   
--   <pre>
--   &gt;&gt;&gt; extractPath "/path"
--   "/path"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; extractPath "http://example.com:8080/path"
--   "/path"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; extractPath "http://example.com"
--   "/"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; extractPath ""
--   "/"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; extractPath "www.google.com/some/path"
--   "www.google.com/some/path"
--   </pre>
extractPath :: ByteString -> ByteString

-- | Encode a whole path (path segments + query).
encodePath :: [Text] -> Query -> Builder

-- | Decode a whole path (path segments + query).
decodePath :: ByteString -> ([Text], Query)

-- | Encodes a list of path segments into a valid URL fragment.
--   
--   This function takes the following three steps:
--   
--   <ul>
--   <li>UTF-8 encodes the characters.</li>
--   <li>Prepends each segment with a slash.</li>
--   <li>Performs percent-encoding on all characters that are
--   <b>not</b>:<ul><li>alphanumeric (i.e. <tt>A-Z</tt> and
--   <tt>a-z</tt>)</li><li>digits (i.e. <tt>0-9</tt>)</li><li>a dash
--   <tt>'-'</tt>, an underscore <tt>'_'</tt>, a dot <tt>'.'</tt>, or a
--   tilde <tt>'~'</tt></li></ul></li>
--   </ul>
--   
--   For example:
--   
--   <pre>
--   &gt;&gt;&gt; encodePathSegments ["foo", "bar1", "~baz"]
--   "/foo/bar1/~baz"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; encodePathSegments ["foo bar", "baz/bin"]
--   "/foo%20bar/baz%2Fbin"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; encodePathSegments ["שלום"]
--   "/%D7%A9%D7%9C%D7%95%D7%9D"
--   </pre>
--   
--   Huge thanks to <i>Jeremy Shaw</i> who created the original
--   implementation of this function in web-routes and did such thorough
--   research to determine all correct escaping procedures.
encodePathSegments :: [Text] -> Builder

-- | Like <a>encodePathSegments</a>, but without the initial slash.
encodePathSegmentsRelative :: [Text] -> Builder

-- | Parse a list of path segments from a valid URL fragment.
--   
--   Will also decode any percent-encoded characters.
decodePathSegments :: ByteString -> [Text]

-- | Percent-encoding for URLs.
--   
--   In short:
--   
--   <ul>
--   <li>if you're encoding (parts of) a path element, use
--   <a>False</a>.</li>
--   <li>if you're encoding (parts of) a query string, use
--   <a>True</a>.</li>
--   </ul>
--   
--   <h3><b>In-depth explanation</b></h3>
--   
--   This will substitute every byte with its percent-encoded equivalent
--   unless:
--   
--   <ul>
--   <li>The byte is alphanumeric. (i.e. <tt>A-Z</tt>, <tt>a-z</tt>, or
--   <tt>0-9</tt>)</li>
--   <li>The byte is either a dash <tt>'-'</tt>, an underscore
--   <tt>'_'</tt>, a dot <tt>'.'</tt>, or a tilde <tt>'~'</tt></li>
--   <li>If <a>False</a> is used, the following will also <i>not</i> be
--   percent-encoded:<ul><li>colon <tt>':'</tt>, at sign <tt>'@'</tt>,
--   ampersand <tt>'&amp;'</tt>, equals sign <tt>'='</tt>, plus sign
--   <tt>'+'</tt>, dollar sign <tt>'$'</tt> or a comma
--   <tt>','</tt></li></ul></li>
--   </ul>
urlEncode :: Bool -> ByteString -> ByteString

-- | Percent-encoding for URLs.
--   
--   Like <a>urlEncode</a>, but only makes the <a>Builder</a>.
urlEncodeBuilder :: Bool -> ByteString -> Builder

-- | Percent-decoding.
--   
--   If you want to replace any <tt>'+'</tt> with a space, use <a>True</a>.
urlDecode :: Bool -> ByteString -> ByteString
