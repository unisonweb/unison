-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Utilities for indexed profunctors
--   
--   This package contains basic definitions related to indexed
--   profunctors. These are primarily intended as internal utilities to
--   support the <tt>optics</tt> and <tt>generic-lens</tt> package
--   families.
@package indexed-profunctors
@version 0.1.1.1


-- | Definitions of concrete profunctors and profunctor classes.
module Data.Profunctor.Indexed
class Profunctor p
dimap :: Profunctor p => (a -> b) -> (c -> d) -> p i b c -> p i a d
lmap :: Profunctor p => (a -> b) -> p i b c -> p i a c
rmap :: Profunctor p => (c -> d) -> p i b c -> p i b d
lcoerce' :: (Profunctor p, Coercible a b) => p i a c -> p i b c
lcoerce' :: (Profunctor p, Coercible (p i a c) (p i b c)) => p i a c -> p i b c
rcoerce' :: (Profunctor p, Coercible a b) => p i c a -> p i c b
rcoerce' :: (Profunctor p, Coercible (p i c a) (p i c b)) => p i c a -> p i c b
conjoined__ :: Profunctor p => (p i a b -> p i s t) -> (p i a b -> p j s t) -> p i a b -> p j s t
conjoined__ :: (Profunctor p, Coercible (p i s t) (p j s t)) => (p i a b -> p i s t) -> (p i a b -> p j s t) -> p i a b -> p j s t
ixcontramap :: Profunctor p => (j -> i) -> p i a b -> p j a b
ixcontramap :: (Profunctor p, Coercible (p i a b) (p j a b)) => (j -> i) -> p i a b -> p j a b

-- | <a>lcoerce'</a> with type arguments rearranged for TypeApplications.
lcoerce :: (Coercible a b, Profunctor p) => p i a c -> p i b c

-- | <a>rcoerce'</a> with type arguments rearranged for TypeApplications.
rcoerce :: (Coercible a b, Profunctor p) => p i c a -> p i c b
class Profunctor p => Strong p
first' :: Strong p => p i a b -> p i (a, c) (b, c)
second' :: Strong p => p i a b -> p i (c, a) (c, b)
linear :: Strong p => (forall f. Functor f => (a -> f b) -> s -> f t) -> p i a b -> p i s t
ilinear :: Strong p => (forall f. Functor f => (i -> a -> f b) -> s -> f t) -> p j a b -> p (i -> j) s t
ilinear :: (Strong p, Coercible (p j s t) (p (i -> j) s t)) => (forall f. Functor f => (i -> a -> f b) -> s -> f t) -> p j a b -> p (i -> j) s t
class Profunctor p => Costrong p
unfirst :: Costrong p => p i (a, d) (b, d) -> p i a b
unsecond :: Costrong p => p i (d, a) (d, b) -> p i a b
class Profunctor p => Choice p
left' :: Choice p => p i a b -> p i (Either a c) (Either b c)
right' :: Choice p => p i a b -> p i (Either c a) (Either c b)
class Profunctor p => Cochoice p
unleft :: Cochoice p => p i (Either a d) (Either b d) -> p i a b
unright :: Cochoice p => p i (Either d a) (Either d b) -> p i a b
class (Choice p, Strong p) => Visiting p
visit :: forall i s t a b. Visiting p => (forall f. Functor f => (forall r. r -> f r) -> (a -> f b) -> s -> f t) -> p i a b -> p i s t
ivisit :: Visiting p => (forall f. Functor f => (forall r. r -> f r) -> (i -> a -> f b) -> s -> f t) -> p j a b -> p (i -> j) s t
ivisit :: (Visiting p, Coercible (p j s t) (p (i -> j) s t)) => (forall f. Functor f => (forall r. r -> f r) -> (i -> a -> f b) -> s -> f t) -> p j a b -> p (i -> j) s t
class Traversing p => Mapping p
roam :: Mapping p => ((a -> b) -> s -> t) -> p i a b -> p i s t
iroam :: Mapping p => ((i -> a -> b) -> s -> t) -> p j a b -> p (i -> j) s t
class Visiting p => Traversing p
wander :: Traversing p => (forall f. Applicative f => (a -> f b) -> s -> f t) -> p i a b -> p i s t
iwander :: Traversing p => (forall f. Applicative f => (i -> a -> f b) -> s -> f t) -> p j a b -> p (i -> j) s t

-- | Needed for traversals.
newtype Star f i a b
Star :: (a -> f b) -> Star f i a b
[runStar] :: Star f i a b -> a -> f b

-- | Repack <a>Star</a> to change its index type.
reStar :: Star f i a b -> Star f j a b

-- | Needed for getters and folds.
newtype Forget r i a b
Forget :: (a -> r) -> Forget r i a b
[runForget] :: Forget r i a b -> a -> r

-- | Repack <a>Forget</a> to change its index type.
reForget :: Forget r i a b -> Forget r j a b

-- | Needed for affine folds.
newtype ForgetM r i a b
ForgetM :: (a -> Maybe r) -> ForgetM r i a b
[runForgetM] :: ForgetM r i a b -> a -> Maybe r

-- | Needed for setters.
newtype FunArrow i a b
FunArrow :: (a -> b) -> FunArrow i a b
[runFunArrow] :: FunArrow i a b -> a -> b

-- | Repack <a>FunArrow</a> to change its index type.
reFunArrow :: FunArrow i a b -> FunArrow j a b

-- | Needed for indexed traversals.
newtype IxStar f i a b
IxStar :: (i -> a -> f b) -> IxStar f i a b
[runIxStar] :: IxStar f i a b -> i -> a -> f b

-- | Needed for indexed folds.
newtype IxForget r i a b
IxForget :: (i -> a -> r) -> IxForget r i a b
[runIxForget] :: IxForget r i a b -> i -> a -> r

-- | Needed for indexed affine folds.
newtype IxForgetM r i a b
IxForgetM :: (i -> a -> Maybe r) -> IxForgetM r i a b
[runIxForgetM] :: IxForgetM r i a b -> i -> a -> Maybe r

-- | Needed for indexed setters.
newtype IxFunArrow i a b
IxFunArrow :: (i -> a -> b) -> IxFunArrow i a b
[runIxFunArrow] :: IxFunArrow i a b -> i -> a -> b

-- | Needed for conversion of affine traversal back to its VL
--   representation.
data StarA f i a b
StarA :: (forall r. r -> f r) -> (a -> f b) -> StarA f i a b

-- | Unwrap <a>StarA</a>.
runStarA :: StarA f i a b -> a -> f b

-- | Needed for conversion of indexed affine traversal back to its VL
--   representation.
data IxStarA f i a b
IxStarA :: (forall r. r -> f r) -> (i -> a -> f b) -> IxStarA f i a b

-- | Unwrap <a>StarA</a>.
runIxStarA :: IxStarA f i a b -> i -> a -> f b
data Exchange a b i s t
Exchange :: (s -> a) -> (b -> t) -> Exchange a b i s t

-- | Type to represent the components of a lens.
data Store a b i s t
Store :: (s -> a) -> (s -> b -> t) -> Store a b i s t

-- | Type to represent the components of a prism.
data Market a b i s t
Market :: (b -> t) -> (s -> Either t a) -> Market a b i s t

-- | Type to represent the components of an affine traversal.
data AffineMarket a b i s t
AffineMarket :: (s -> b -> t) -> (s -> Either t a) -> AffineMarket a b i s t

-- | Tag a value with not one but two phantom type parameters (so that
--   <a>Tagged</a> can be used as an indexed profunctor).
newtype Tagged i a b
Tagged :: b -> Tagged i a b
[unTagged] :: Tagged i a b -> b
data Context a b t
Context :: (b -> t) -> a -> Context a b t

-- | Composition operator where the first argument must be an identity
--   function up to representational equivalence (e.g. a newtype wrapper or
--   unwrapper), and will be ignored at runtime.
(#.) :: Coercible b c => (b -> c) -> (a -> b) -> a -> c
infixr 9 #.

-- | Composition operator where the second argument must be an identity
--   function up to representational equivalence (e.g. a newtype wrapper or
--   unwrapper), and will be ignored at runtime.
(.#) :: Coercible a b => (b -> c) -> (a -> b) -> a -> c
infixl 8 .#
instance GHC.Base.Functor (Data.Profunctor.Indexed.Context a b)
instance Data.Profunctor.Indexed.Mapping Data.Profunctor.Indexed.FunArrow
instance Data.Profunctor.Indexed.Mapping Data.Profunctor.Indexed.IxFunArrow
instance GHC.Base.Applicative f => Data.Profunctor.Indexed.Traversing (Data.Profunctor.Indexed.Star f)
instance GHC.Base.Monoid r => Data.Profunctor.Indexed.Traversing (Data.Profunctor.Indexed.Forget r)
instance Data.Profunctor.Indexed.Traversing Data.Profunctor.Indexed.FunArrow
instance GHC.Base.Applicative f => Data.Profunctor.Indexed.Traversing (Data.Profunctor.Indexed.IxStar f)
instance GHC.Base.Monoid r => Data.Profunctor.Indexed.Traversing (Data.Profunctor.Indexed.IxForget r)
instance Data.Profunctor.Indexed.Traversing Data.Profunctor.Indexed.IxFunArrow
instance GHC.Base.Functor f => Data.Profunctor.Indexed.Visiting (Data.Profunctor.Indexed.StarA f)
instance GHC.Base.Applicative f => Data.Profunctor.Indexed.Visiting (Data.Profunctor.Indexed.Star f)
instance GHC.Base.Monoid r => Data.Profunctor.Indexed.Visiting (Data.Profunctor.Indexed.Forget r)
instance Data.Profunctor.Indexed.Visiting (Data.Profunctor.Indexed.ForgetM r)
instance Data.Profunctor.Indexed.Visiting Data.Profunctor.Indexed.FunArrow
instance GHC.Base.Functor f => Data.Profunctor.Indexed.Visiting (Data.Profunctor.Indexed.IxStarA f)
instance GHC.Base.Applicative f => Data.Profunctor.Indexed.Visiting (Data.Profunctor.Indexed.IxStar f)
instance GHC.Base.Monoid r => Data.Profunctor.Indexed.Visiting (Data.Profunctor.Indexed.IxForget r)
instance Data.Profunctor.Indexed.Visiting (Data.Profunctor.Indexed.IxForgetM r)
instance Data.Profunctor.Indexed.Visiting Data.Profunctor.Indexed.IxFunArrow
instance Data.Profunctor.Indexed.Visiting (Data.Profunctor.Indexed.AffineMarket a b)
instance GHC.Base.Functor f => Data.Profunctor.Indexed.Strong (Data.Profunctor.Indexed.StarA f)
instance GHC.Base.Functor f => Data.Profunctor.Indexed.Strong (Data.Profunctor.Indexed.Star f)
instance Data.Profunctor.Indexed.Strong (Data.Profunctor.Indexed.Forget r)
instance Data.Profunctor.Indexed.Strong (Data.Profunctor.Indexed.ForgetM r)
instance Data.Profunctor.Indexed.Strong Data.Profunctor.Indexed.FunArrow
instance GHC.Base.Functor f => Data.Profunctor.Indexed.Strong (Data.Profunctor.Indexed.IxStarA f)
instance GHC.Base.Functor f => Data.Profunctor.Indexed.Strong (Data.Profunctor.Indexed.IxStar f)
instance Data.Profunctor.Indexed.Strong (Data.Profunctor.Indexed.IxForget r)
instance Data.Profunctor.Indexed.Strong (Data.Profunctor.Indexed.IxForgetM r)
instance Data.Profunctor.Indexed.Strong Data.Profunctor.Indexed.IxFunArrow
instance Data.Profunctor.Indexed.Strong (Data.Profunctor.Indexed.Store a b)
instance Data.Profunctor.Indexed.Strong (Data.Profunctor.Indexed.AffineMarket a b)
instance GHC.Base.Functor (Data.Profunctor.Indexed.Tagged i a)
instance Data.Profunctor.Indexed.Profunctor Data.Profunctor.Indexed.Tagged
instance Data.Profunctor.Indexed.Choice Data.Profunctor.Indexed.Tagged
instance Data.Profunctor.Indexed.Costrong Data.Profunctor.Indexed.Tagged
instance Data.Profunctor.Indexed.Profunctor (Data.Profunctor.Indexed.AffineMarket a b)
instance Data.Profunctor.Indexed.Choice (Data.Profunctor.Indexed.AffineMarket a b)
instance GHC.Base.Functor (Data.Profunctor.Indexed.Market a b i s)
instance Data.Profunctor.Indexed.Profunctor (Data.Profunctor.Indexed.Market a b)
instance Data.Profunctor.Indexed.Choice (Data.Profunctor.Indexed.Market a b)
instance Data.Profunctor.Indexed.Profunctor (Data.Profunctor.Indexed.Store a b)
instance Data.Profunctor.Indexed.Profunctor (Data.Profunctor.Indexed.Exchange a b)
instance Data.Profunctor.Indexed.Cochoice (Data.Profunctor.Indexed.Forget r)
instance Data.Profunctor.Indexed.Cochoice (Data.Profunctor.Indexed.ForgetM r)
instance Data.Profunctor.Indexed.Cochoice (Data.Profunctor.Indexed.IxForget r)
instance Data.Profunctor.Indexed.Cochoice (Data.Profunctor.Indexed.IxForgetM r)
instance GHC.Base.Functor f => Data.Profunctor.Indexed.Choice (Data.Profunctor.Indexed.StarA f)
instance GHC.Base.Applicative f => Data.Profunctor.Indexed.Choice (Data.Profunctor.Indexed.Star f)
instance GHC.Base.Monoid r => Data.Profunctor.Indexed.Choice (Data.Profunctor.Indexed.Forget r)
instance Data.Profunctor.Indexed.Choice (Data.Profunctor.Indexed.ForgetM r)
instance Data.Profunctor.Indexed.Choice Data.Profunctor.Indexed.FunArrow
instance GHC.Base.Functor f => Data.Profunctor.Indexed.Choice (Data.Profunctor.Indexed.IxStarA f)
instance GHC.Base.Applicative f => Data.Profunctor.Indexed.Choice (Data.Profunctor.Indexed.IxStar f)
instance GHC.Base.Monoid r => Data.Profunctor.Indexed.Choice (Data.Profunctor.Indexed.IxForget r)
instance Data.Profunctor.Indexed.Choice (Data.Profunctor.Indexed.IxForgetM r)
instance Data.Profunctor.Indexed.Choice Data.Profunctor.Indexed.IxFunArrow
instance GHC.Base.Functor f => Data.Profunctor.Indexed.Profunctor (Data.Profunctor.Indexed.StarA f)
instance GHC.Base.Functor f => Data.Profunctor.Indexed.Profunctor (Data.Profunctor.Indexed.Star f)
instance Data.Profunctor.Indexed.Profunctor (Data.Profunctor.Indexed.Forget r)
instance Data.Profunctor.Indexed.Profunctor (Data.Profunctor.Indexed.ForgetM r)
instance Data.Profunctor.Indexed.Profunctor Data.Profunctor.Indexed.FunArrow
instance GHC.Base.Functor f => Data.Profunctor.Indexed.Profunctor (Data.Profunctor.Indexed.IxStarA f)
instance GHC.Base.Functor f => Data.Profunctor.Indexed.Profunctor (Data.Profunctor.Indexed.IxStar f)
instance Data.Profunctor.Indexed.Profunctor (Data.Profunctor.Indexed.IxForget r)
instance Data.Profunctor.Indexed.Profunctor (Data.Profunctor.Indexed.IxForgetM r)
instance Data.Profunctor.Indexed.Profunctor Data.Profunctor.Indexed.IxFunArrow
