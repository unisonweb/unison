-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Fuzzy text matching
--   
--   A package that provides an API for fuzzy text search in Haskell, using
--   a modified version of the Smith-Waterman algorithm. The search is
--   intended to behave similarly to the excellent fzf tool by Junegunn
--   Choi.
@package fuzzyfind
@version 3.0.2


-- | A package that provides an API for fuzzy text search in Haskell, using
--   a modified version of the Smith-Waterman algorithm. The search is
--   intended to behave similarly to the excellent fzf tool by Junegunn
--   Choi.
module Text.FuzzyFind

-- | <tt>bestMatch query string</tt> will return <a>Nothing</a> if
--   <tt>query</tt> is not a subsequence of <tt>string</tt>. Otherwise, it
--   will return the "best" way to line up the characters in <tt>query</tt>
--   with the characters in <tt>string</tt>. Lower-case characters in the
--   <tt>query</tt> are assumed to be case-insensitive, and upper-case
--   characters are assumed to be case-sensitive.
--   
--   For example:
--   
--   <pre>
--   &gt; bestMatch "ff" "FuzzyFind"
--   Just (Alignment {score = 25, result = Result {[Match "F", Gap "uzzy", Match "F", Gap "ind"]}})
--   </pre>
--   
--   The score indicates how "good" the match is. Better matches have
--   higher scores. There's no maximum score (except for the upper limit of
--   the <a>Int</a> datatype), but the lowest score is <tt>0</tt>.
--   
--   A substring from the query will generate a <a>Match</a>, and any
--   characters from the input that don't result in a <a>Match</a> will
--   generate a <a>Gap</a>. Concatenating all the <a>Match</a> and
--   <a>Gap</a> results should yield the original input string.
--   
--   Note that the matched characters in the input always occur in the same
--   order as they do in the query pattern.
--   
--   The algorithm prefers (and will generate higher scores for) the
--   following kinds of matches:
--   
--   <ol>
--   <li>Contiguous characters from the query string. For example,
--   <tt>bestMatch "pp"</tt> will find the last two ps in "pickled
--   pepper".</li>
--   <li>Characters at the beginnings of words. For example, <tt>bestMatch
--   "pp"</tt> will find the first two Ps in "Peter Piper".</li>
--   <li>Characters at CamelCase humps. For example, <tt>bestMatch "bm"
--   "BatMan"</tt> will score higher than <tt>bestMatch "bm"
--   "Batman".</tt></li>
--   <li>The algorithm strongly prefers the first character of the query
--   pattern to be at the beginning of a word or CamelHump. For example,
--   <tt>bestMatch "mn" "Bat Man"</tt> will score higher than <tt>bestMatch
--   "atn" "Batman"</tt>.</li>
--   </ol>
--   
--   All else being equal, matches that occur later in the input string are
--   preferred.
bestMatch :: String -> String -> Maybe Alignment

-- | Finds input strings that match all the given input patterns. For each
--   input that matches, it returns one <a>Alignment</a>. The output is not
--   sorted. ascending.
--   
--   For example:
--   
--   <pre>
--   &gt; import Data.Foldable
--   &gt; traverse_ (putStrLn . ("\n" ++) . highlight) $ fuzzyFind ["dad", "mac", "dam"] ["red macadamia", "Madam Card"]
--   
--   Madam Card
--   * *** ** *
--   
--   red macadamia
--     * *******
--   </pre>
fuzzyFind :: [String] -> [String] -> [Alignment]

-- | A version of <a>fuzzyFind</a> that searches on the given text field of
--   the data.
fuzzyFindOn :: (a -> String) -> [String] -> [a] -> [(Alignment, a)]
type Score = Int

-- | An <a>Alignment</a> is a <a>Score</a> together with a <a>Result</a>.
--   Better results have higher scores.
data Alignment
Alignment :: !Score -> !Result -> Alignment
[score] :: Alignment -> !Score
[result] :: Alignment -> !Result

-- | The base score given to a matching character
defaultMatchScore :: Int

-- | The base score given to a mismatched character
defaultMismatchScore :: Int

-- | Bonus points given to characters matching at the beginning of words
defaultBoundaryBonus :: Int

-- | Bonus points given to characters matching a hump of a CamelCase word.
--   We subtract a point from the word boundary score, since a word
--   boundary will incur a gap penalty.
defaultCamelCaseBonus :: Int

-- | Double any bonus points for matching the first pattern of the
--   character. This way we strongly prefer starting the match at the
--   beginning of a word.
defaultFirstCharBonusMultiplier :: Int

-- | We prefer consecutive runs of matched characters in the pattern, so we
--   impose a penalty for any gaps, which is added to the size of the gap.
defaultGapPenalty :: Int

-- | We give a bonus to consecutive matching characters. A number about the
--   same as the boundary bonus will prefer runs of consecutive characters
--   vs finding acronyms.
defaultConsecutiveBonus :: Int

-- | We give a bonus for matches that occur later in the input string. If
--   this is e.g. 100, we give one bonus point for each percentage of the
--   length of the input that the match occurs at (100 points for the last
--   character, 50 for characters in the middle, and so on).
defaultLaterBonusMultiplier :: Int
segmentToString :: ResultSegment -> String

-- | Renders an <a>Alignment</a> as a pair of lines with "*" on the lower
--   line indicating the location of pattern matches.
highlight :: Alignment -> String
highlight' :: Alignment -> Text

-- | A highly configurable version of <a>bestMatch</a>.
bestMatch' :: Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> String -> String -> Maybe Alignment
data ResultSegment
Gap :: !String -> ResultSegment
Match :: !String -> ResultSegment

-- | Concatenating all the <a>ResultSegment</a>s should yield the original
--   input string.
newtype Result
Result :: Seq ResultSegment -> Result
[segments] :: Result -> Seq ResultSegment
mergeResults :: Result -> Result -> Result
instance GHC.Generics.Generic Text.FuzzyFind.ResultSegment
instance GHC.Show.Show Text.FuzzyFind.ResultSegment
instance GHC.Classes.Ord Text.FuzzyFind.ResultSegment
instance GHC.Classes.Eq Text.FuzzyFind.ResultSegment
instance GHC.Generics.Generic Text.FuzzyFind.Result
instance GHC.Show.Show Text.FuzzyFind.Result
instance GHC.Classes.Ord Text.FuzzyFind.Result
instance GHC.Classes.Eq Text.FuzzyFind.Result
instance GHC.Generics.Generic Text.FuzzyFind.Alignment
instance GHC.Show.Show Text.FuzzyFind.Alignment
instance GHC.Classes.Ord Text.FuzzyFind.Alignment
instance GHC.Classes.Eq Text.FuzzyFind.Alignment
instance GHC.Base.Semigroup Text.FuzzyFind.Alignment
instance GHC.Base.Monoid Text.FuzzyFind.Alignment
instance GHC.Base.Monoid Text.FuzzyFind.Result
instance GHC.Base.Semigroup Text.FuzzyFind.Result
