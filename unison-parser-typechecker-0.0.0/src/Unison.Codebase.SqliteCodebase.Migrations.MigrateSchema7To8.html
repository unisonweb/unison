<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><link rel="stylesheet" type="text/css" href="style.css" /><script type="text/javascript" src="highlight.js"></script></head><body><pre><span class="hs-pragma">{-# LANGUAGE QuasiQuotes #-}</span><span>
</span><span id="line-2"></span><span>
</span><span id="line-3"></span><span class="hs-keyword">module</span><span> </span><span class="hs-identifier">Unison.Codebase.SqliteCodebase.Migrations.MigrateSchema7To8</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Unison.Codebase.SqliteCodebase.Migrations.MigrateSchema7To8.html#migrateSchema7To8"><span class="hs-identifier">migrateSchema7To8</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-4"></span><span>
</span><span id="line-5"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">U.Codebase.Sqlite.Queries</span></span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">Q</span></span><span>
</span><span id="line-6"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Unison.Sqlite</span></span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">Sqlite</span></span><span>
</span><span id="line-7"></span><span>
</span><span id="line-8"></span><span class="hs-comment">-- | Adds a table for tracking namespace statistics</span><span>
</span><span id="line-9"></span><span class="hs-comment">-- Adds stats for all existing namespaces, even though missing stats are computed on-demand if missing.</span><span>
</span><span id="line-10"></span><span class="annot"><a href="Unison.Codebase.SqliteCodebase.Migrations.MigrateSchema7To8.html#migrateSchema7To8"><span class="hs-identifier hs-type">migrateSchema7To8</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Sqlite.Transaction</span></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><span id="line-11"></span><span id="migrateSchema7To8"><span class="annot"><span class="annottext">migrateSchema7To8 :: Transaction ()
</span><a href="Unison.Codebase.SqliteCodebase.Migrations.MigrateSchema7To8.html#migrateSchema7To8"><span class="hs-identifier hs-var hs-var">migrateSchema7To8</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-12"></span><span>  </span><span class="annot"><span class="annottext">SchemaVersion -&gt; Transaction ()
</span><span class="hs-identifier hs-var">Q.expectSchemaVersion</span></span><span> </span><span class="annot"><span class="annottext">SchemaVersion
</span><span class="hs-number">7</span></span><span>
</span><span id="line-13"></span><span>  </span><span class="annot"><span class="annottext">Transaction ()
</span><a href="Unison.Codebase.SqliteCodebase.Migrations.MigrateSchema7To8.html#createScopedNameLookupTables"><span class="hs-identifier hs-var">createScopedNameLookupTables</span></a></span><span>
</span><span id="line-14"></span><span>  </span><span class="annot"><span class="annottext">SchemaVersion -&gt; Transaction ()
</span><span class="hs-identifier hs-var">Q.setSchemaVersion</span></span><span> </span><span class="annot"><span class="annottext">SchemaVersion
</span><span class="hs-number">8</span></span><span>
</span><span id="line-15"></span><span>
</span><span id="line-16"></span><span class="annot"><span class="hs-comment">-- | Create the scoped name lookup tables.</span></span><span>
</span><span id="line-17"></span><span class="annot"><a href="Unison.Codebase.SqliteCodebase.Migrations.MigrateSchema7To8.html#createScopedNameLookupTables"><span class="hs-identifier hs-type">createScopedNameLookupTables</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Sqlite.Transaction</span></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><span id="line-18"></span><span id="createScopedNameLookupTables"><span class="annot"><span class="annottext">createScopedNameLookupTables :: Transaction ()
</span><a href="Unison.Codebase.SqliteCodebase.Migrations.MigrateSchema7To8.html#createScopedNameLookupTables"><span class="hs-identifier hs-var hs-var">createScopedNameLookupTables</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-19"></span><span>  </span><span class="hs-comment">-- This table allows us to look up which causal hashes have a name lookup.</span><span>
</span><span id="line-20"></span><span>  </span><span class="annot"><span class="annottext">HasCallStack =&gt; Sql -&gt; Transaction ()
Sql -&gt; Transaction ()
</span><span class="hs-identifier hs-var">Sqlite.execute</span></span><span>
</span><span id="line-21"></span><span>    </span><span class="annot"><span class="">[Sqlite.sql|
      CREATE TABLE name_lookups (
        root_branch_hash_id INTEGER PRIMARY KEY REFERENCES hash(id) ON DELETE CASCADE
      )
    |]</span></span><span>
</span><span id="line-26"></span><span>
</span><span id="line-27"></span><span>  </span><span class="annot"><span class="annottext">HasCallStack =&gt; Sql -&gt; Transaction ()
Sql -&gt; Transaction ()
</span><span class="hs-identifier hs-var">Sqlite.execute</span></span><span>
</span><span id="line-28"></span><span>    </span><span class="annot"><span class="">[Sqlite.sql|
      CREATE TABLE scoped_term_name_lookup (
        root_branch_hash_id INTEGER NOT NULL REFERENCES hash(id) ON DELETE CASCADE,

        -- The name of the term in reversed form, with a trailing '.':
        -- E.g. map.List.base.
        --
        -- The trailing '.' is helpful when performing suffix queries where we may not know
        -- whether the suffix is complete or not, e.g. we could suffix search using any of the
        -- following globs and it would still find 'map.List.base.':
        --  map.List.base.*
        --  map.List.*
        --  map.*
        reversed_name TEXT NOT NULL,

        -- The last name segment of the name. This is used when looking up names for
        -- suffixification when building PPEs.
        -- E.g. for the name 'base.List.map' this would be 'map'
        last_name_segment TEXT NOT NULL,

        -- The namespace containing this definition, not reversed, with a trailing '.'
        -- The trailing '.' simplifies GLOB queries, so that 'base.*' matches both things in
        -- 'base' and 'base.List', but not 'base1', which allows us to avoid an OR in our where
        -- clauses which in turn helps the sqlite query planner use indexes more effectively.
        --
        -- example value: 'base.List.'
        namespace TEXT NOT NULL,
        referent_builtin TEXT NULL,
        referent_component_hash TEXT NULL,
        referent_component_index INTEGER NULL,
        referent_constructor_index INTEGER NULL,
        referent_constructor_type INTEGER NULL,
        PRIMARY KEY (root_branch_hash_id, reversed_name, referent_builtin, referent_component_hash, referent_component_index, referent_constructor_index)
      )
    |]</span></span><span>
</span><span id="line-63"></span><span>
</span><span id="line-64"></span><span>  </span><span class="hs-comment">-- This index allows finding all names we need to consider within a given namespace for</span><span>
</span><span id="line-65"></span><span>  </span><span class="hs-comment">-- suffixification of a name.</span><span>
</span><span id="line-66"></span><span>  </span><span class="hs-comment">-- It may seem strange to use last_name_segment rather than a suffix search over reversed_name name here;</span><span>
</span><span id="line-67"></span><span>  </span><span class="hs-comment">-- but SQLite will only optimize for a single prefix-glob at once, so we can't glob search</span><span>
</span><span id="line-68"></span><span>  </span><span class="hs-comment">-- over both namespace and reversed_name, but we can EXACT match on last_name_segment and</span><span>
</span><span id="line-69"></span><span>  </span><span class="hs-comment">-- then glob search on the namespace prefix, and have SQLite do the final glob search on</span><span>
</span><span id="line-70"></span><span>  </span><span class="hs-comment">-- reversed_name over rows with a matching last segment without using an index and should be plenty fast.</span><span>
</span><span id="line-71"></span><span>  </span><span class="annot"><span class="annottext">HasCallStack =&gt; Sql -&gt; Transaction ()
Sql -&gt; Transaction ()
</span><span class="hs-identifier hs-var">Sqlite.execute</span></span><span>
</span><span id="line-72"></span><span>    </span><span class="annot"><span class="">[Sqlite.sql|
      CREATE INDEX scoped_term_names_by_namespace_and_last_name_segment ON scoped_term_name_lookup(root_branch_hash_id, last_name_segment, namespace)
    |]</span></span><span>
</span><span id="line-75"></span><span>  </span><span class="hs-comment">-- This index allows us to find all names with a given ref within a specific namespace</span><span>
</span><span id="line-76"></span><span>  </span><span class="annot"><span class="annottext">HasCallStack =&gt; Sql -&gt; Transaction ()
Sql -&gt; Transaction ()
</span><span class="hs-identifier hs-var">Sqlite.execute</span></span><span>
</span><span id="line-77"></span><span>    </span><span class="annot"><span class="">[Sqlite.sql|
      CREATE INDEX scoped_term_name_by_referent_lookup ON scoped_term_name_lookup(root_branch_hash_id, referent_builtin, referent_component_hash, referent_component_index, referent_constructor_index, namespace)
    |]</span></span><span>
</span><span id="line-80"></span><span>
</span><span id="line-81"></span><span>  </span><span class="hs-comment">-- Allows fetching ALL names within a specific namespace prefix. We currently use this to</span><span>
</span><span id="line-82"></span><span>  </span><span class="hs-comment">-- pretty-print on share, but will be replaced with a more precise set of queries soon.</span><span>
</span><span id="line-83"></span><span>  </span><span class="annot"><span class="annottext">HasCallStack =&gt; Sql -&gt; Transaction ()
Sql -&gt; Transaction ()
</span><span class="hs-identifier hs-var">Sqlite.execute</span></span><span>
</span><span id="line-84"></span><span>    </span><span class="annot"><span class="">[Sqlite.sql|
      CREATE INDEX scoped_term_names_by_namespace ON scoped_term_name_lookup(root_branch_hash_id, namespace)
    |]</span></span><span>
</span><span id="line-87"></span><span>  </span><span class="annot"><span class="annottext">HasCallStack =&gt; Sql -&gt; Transaction ()
Sql -&gt; Transaction ()
</span><span class="hs-identifier hs-var">Sqlite.execute</span></span><span>
</span><span id="line-88"></span><span>    </span><span class="annot"><span class="">[Sqlite.sql|
      CREATE TABLE scoped_type_name_lookup (
        root_branch_hash_id INTEGER NOT NULL REFERENCES hash(id),
        -- The name of the term: E.g. List.base
        reversed_name TEXT NOT NULL,
        -- The last name segment of the name. This is used when looking up names for
        -- suffixification when building PPEs.
        -- E.g. for the name 'base.List.map' this would be 'map'
        last_name_segment TEXT NOT NULL,
        -- The namespace containing this definition, not reversed, with a trailing '.'
        -- The trailing '.' simplifies GLOB queries, so that 'base.*' matches both things in
        -- 'base' and 'base.List', but not 'base1', which allows us to avoid an OR in our where
        -- clauses which in turn helps the sqlite query planner use indexes more effectively.
        --
        -- example value: 'base.List.'
        namespace TEXT NOT NULL,
        reference_builtin TEXT NULL,
        reference_component_hash INTEGER NULL,
        reference_component_index INTEGER NULL,
        PRIMARY KEY (reversed_name, reference_builtin, reference_component_hash, reference_component_index)
      );
    |]</span></span><span>
</span><span id="line-110"></span><span>
</span><span id="line-111"></span><span>  </span><span class="hs-comment">-- This index allows finding all names we need to consider within a given namespace for</span><span>
</span><span id="line-112"></span><span>  </span><span class="hs-comment">-- suffixification of a name.</span><span>
</span><span id="line-113"></span><span>  </span><span class="hs-comment">-- It may seem strange to use last_name_segment rather than a suffix search over reversed_name name here;</span><span>
</span><span id="line-114"></span><span>  </span><span class="hs-comment">-- but SQLite will only optimize for a single prefix-glob at once, so we can't glob search</span><span>
</span><span id="line-115"></span><span>  </span><span class="hs-comment">-- over both namespace and reversed_name, but we can EXACT match on last_name_segment and</span><span>
</span><span id="line-116"></span><span>  </span><span class="hs-comment">-- then glob search on the namespace prefix, and have SQLite do the final glob search on</span><span>
</span><span id="line-117"></span><span>  </span><span class="hs-comment">-- reversed_name over rows with a matching last segment without using an index and should be plenty fast.</span><span>
</span><span id="line-118"></span><span>  </span><span class="annot"><span class="annottext">HasCallStack =&gt; Sql -&gt; Transaction ()
Sql -&gt; Transaction ()
</span><span class="hs-identifier hs-var">Sqlite.execute</span></span><span>
</span><span id="line-119"></span><span>    </span><span class="annot"><span class="">[Sqlite.sql|
      CREATE INDEX scoped_type_names_by_namespace_and_last_name_segment ON scoped_type_name_lookup(root_branch_hash_id, last_name_segment, namespace)
    |]</span></span><span>
</span><span id="line-122"></span><span>
</span><span id="line-123"></span><span>  </span><span class="hs-comment">-- This index allows us to find all names with a given ref within a specific namespace.</span><span>
</span><span id="line-124"></span><span>  </span><span class="annot"><span class="annottext">HasCallStack =&gt; Sql -&gt; Transaction ()
Sql -&gt; Transaction ()
</span><span class="hs-identifier hs-var">Sqlite.execute</span></span><span>
</span><span id="line-125"></span><span>    </span><span class="annot"><span class="">[Sqlite.sql|
      CREATE INDEX scoped_type_name_by_reference_lookup ON scoped_type_name_lookup(root_branch_hash_id, reference_builtin, reference_component_hash, reference_component_index, namespace)
    |]</span></span><span>
</span><span id="line-128"></span><span>
</span><span id="line-129"></span><span>  </span><span class="hs-comment">-- Allows fetching ALL names within a specific namespace prefix. We currently use this to</span><span>
</span><span id="line-130"></span><span>  </span><span class="hs-comment">-- pretty-print on share, but will be replaced with a more precise set of queries soon.</span><span>
</span><span id="line-131"></span><span>  </span><span class="annot"><span class="annottext">HasCallStack =&gt; Sql -&gt; Transaction ()
Sql -&gt; Transaction ()
</span><span class="hs-identifier hs-var">Sqlite.execute</span></span><span>
</span><span id="line-132"></span><span>    </span><span class="annot"><span class="">[Sqlite.sql|
      CREATE INDEX scoped_type_names_by_namespace ON scoped_type_name_lookup(root_branch_hash_id, namespace)
    |]</span></span><span>
</span><span id="line-135"></span></pre></body></html>