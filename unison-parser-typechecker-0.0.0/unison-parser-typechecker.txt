-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


@package unison-parser-typechecker
@version 0.0.0

module U.Codebase.Branch.Diff

-- | A tree of local diffs. Each node of the tree contains the definition
--   diffs at that path.
newtype TreeDiff m
TreeDiff :: Cofree (Compose (Map NameSegment) m) DefinitionDiffs -> TreeDiff m
[$sel:unTreeDiff:TreeDiff] :: TreeDiff m -> Cofree (Compose (Map NameSegment) m) DefinitionDiffs
hoistTreeDiff :: Functor m => (forall x. m x -> n x) -> TreeDiff m -> TreeDiff n

-- | A summary of a <a>TreeDiff</a>, containing all names added and
--   removed. Note that there isn't a clear notion of a name "changing"
--   since conflicts might muddy the notion by having multiple copies of
--   both the from and to names, so we just talk about adds and removals
--   instead.
data NameChanges
NameChanges :: [(Name, Referent)] -> [(Name, Referent)] -> [(Name, Reference)] -> [(Name, Reference)] -> NameChanges
[$sel:termNameAdds:NameChanges] :: NameChanges -> [(Name, Referent)]
[$sel:termNameRemovals:NameChanges] :: NameChanges -> [(Name, Referent)]
[$sel:typeNameAdds:NameChanges] :: NameChanges -> [(Name, Reference)]
[$sel:typeNameRemovals:NameChanges] :: NameChanges -> [(Name, Reference)]

-- | Represents the changes to definitions at a given path, not including
--   child paths.
--   
--   Note: doesn't yet include any info on patch diffs. Feel free to add
--   it.
data DefinitionDiffs
DefinitionDiffs :: Map NameSegment (Diff Referent) -> Map NameSegment (Diff Reference) -> DefinitionDiffs
[$sel:termDiffs:DefinitionDiffs] :: DefinitionDiffs -> Map NameSegment (Diff Referent)
[$sel:typeDiffs:DefinitionDiffs] :: DefinitionDiffs -> Map NameSegment (Diff Reference)
data Diff a
Diff :: Set a -> Set a -> Diff a
[$sel:adds:Diff] :: Diff a -> Set a
[$sel:removals:Diff] :: Diff a -> Set a

-- | A name-based diff for namespaces <tt>N1</tt> and <tt>N2</tt> is (for
--   both terms and types) a relation between references, where `a R b` if:
--   
--   <ol>
--   <li><tt>a</tt> has name <tt>n</tt> in <tt>N1</tt>, and <tt>b</tt> has
--   the same name <tt>n</tt> in <tt>N2</tt></li>
--   <li><tt>a</tt> != <tt>b</tt></li>
--   </ol>
data NameBasedDiff
NameBasedDiff :: Relation Reference Reference -> Relation Reference Reference -> NameBasedDiff
[$sel:terms:NameBasedDiff] :: NameBasedDiff -> Relation Reference Reference
[$sel:types:NameBasedDiff] :: NameBasedDiff -> Relation Reference Reference

-- | Diff two Branches, returning a tree containing all of the changes
diffBranches :: Branch Transaction -> Branch Transaction -> Transaction (TreeDiff Transaction)

-- | Get a summary of all of the name adds and removals from a tree diff.
--   
--   The provided name will be prepended to all names in the output diff,
--   and can be useful if diffing branches at a specific sub-tree, but you
--   can pass <a>Nothing</a> if you're diffing from the root.
allNameChanges :: Monad m => Maybe Name -> TreeDiff m -> m NameChanges

-- | Get a <a>NameBasedDiff</a> from a <a>TreeDiff</a>.
nameBasedDiff :: Monad m => TreeDiff m -> m NameBasedDiff

-- | Stream a summary of all of the name adds and removals from a tree
--   diff. Callback is passed the diff from one namespace level at a time,
--   with the name representing that location. Accumulator is folded
--   strictly, use <tt>()</tt> if you don't need one.
streamNameChanges :: (Monad m, Monoid r) => Maybe Name -> TreeDiff m -> (Maybe Name -> NameChanges -> m r) -> m r
instance GHC.Classes.Ord a => GHC.Classes.Ord (U.Codebase.Branch.Diff.Diff a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (U.Codebase.Branch.Diff.Diff a)
instance GHC.Show.Show a => GHC.Show.Show (U.Codebase.Branch.Diff.Diff a)
instance GHC.Classes.Ord U.Codebase.Branch.Diff.DefinitionDiffs
instance GHC.Classes.Eq U.Codebase.Branch.Diff.DefinitionDiffs
instance GHC.Show.Show U.Codebase.Branch.Diff.DefinitionDiffs
instance Data.Functor.Classes.Ord1 m => GHC.Classes.Ord (U.Codebase.Branch.Diff.TreeDiff m)
instance Data.Functor.Classes.Eq1 m => GHC.Classes.Eq (U.Codebase.Branch.Diff.TreeDiff m)
instance Data.Functor.Classes.Show1 m => GHC.Show.Show (U.Codebase.Branch.Diff.TreeDiff m)
instance GHC.Classes.Eq U.Codebase.Branch.Diff.NameChanges
instance GHC.Show.Show U.Codebase.Branch.Diff.NameChanges
instance GHC.Show.Show U.Codebase.Branch.Diff.NameBasedDiff
instance GHC.Generics.Generic U.Codebase.Branch.Diff.NameBasedDiff
instance GHC.Base.Monoid U.Codebase.Branch.Diff.NameBasedDiff
instance GHC.Base.Semigroup U.Codebase.Branch.Diff.NameBasedDiff
instance GHC.Base.Semigroup U.Codebase.Branch.Diff.NameChanges
instance GHC.Base.Monoid U.Codebase.Branch.Diff.NameChanges
instance GHC.Base.Applicative m => GHC.Base.Semigroup (U.Codebase.Branch.Diff.TreeDiff m)
instance GHC.Base.Applicative m => GHC.Base.Monoid (U.Codebase.Branch.Diff.TreeDiff m)
instance GHC.Base.Semigroup U.Codebase.Branch.Diff.DefinitionDiffs
instance GHC.Base.Monoid U.Codebase.Branch.Diff.DefinitionDiffs

module Unison.Codebase.BuiltinAnnotation
class BuiltinAnnotation a
builtinAnnotation :: BuiltinAnnotation a => a
instance Unison.Codebase.BuiltinAnnotation.BuiltinAnnotation Unison.Parser.Ann.Ann
instance Unison.Codebase.BuiltinAnnotation.BuiltinAnnotation ()

module Unison.Codebase.Causal.Type
data Causal m e
UnsafeOne :: CausalHash -> HashFor e -> e -> Causal m e
[$sel:currentHash:UnsafeOne] :: Causal m e -> CausalHash
[$sel:valueHash:UnsafeOne] :: Causal m e -> HashFor e
[$sel:head:UnsafeOne] :: Causal m e -> e
UnsafeCons :: CausalHash -> HashFor e -> e -> (CausalHash, m (Causal m e)) -> Causal m e
[$sel:currentHash:UnsafeOne] :: Causal m e -> CausalHash
[$sel:valueHash:UnsafeOne] :: Causal m e -> HashFor e
[$sel:head:UnsafeOne] :: Causal m e -> e
[$sel:tail:UnsafeOne] :: Causal m e -> (CausalHash, m (Causal m e))
UnsafeMerge :: CausalHash -> HashFor e -> e -> Map CausalHash (m (Causal m e)) -> Causal m e
[$sel:currentHash:UnsafeOne] :: Causal m e -> CausalHash
[$sel:valueHash:UnsafeOne] :: Causal m e -> HashFor e
[$sel:head:UnsafeOne] :: Causal m e -> e
[$sel:tails:UnsafeOne] :: Causal m e -> Map CausalHash (m (Causal m e))
pattern One :: CausalHash -> HashFor e -> e -> Causal m e
pattern Cons :: CausalHash -> HashFor e -> e -> (CausalHash, m (Causal m e)) -> Causal m e
pattern Merge :: CausalHash -> HashFor e -> e -> Map CausalHash (m (Causal m e)) -> Causal m e
before :: Monad m => Causal m e -> Causal m e -> m Bool
predecessors :: Causal m e -> Seq (m (Causal m e))
lca :: Monad m => Causal m e -> Causal m e -> m (Maybe (Causal m e))
instance GHC.Show.Show e => GHC.Show.Show (Unison.Codebase.Causal.Type.Causal m e)
instance GHC.Classes.Eq (Unison.Codebase.Causal.Type.Causal m a)
instance GHC.Classes.Ord (Unison.Codebase.Causal.Type.Causal m a)

module Unison.Codebase.CodeLookup
data CodeLookup v m a
CodeLookup :: (Id -> m (Maybe (Term v a))) -> (Id -> m (Maybe (Type v a))) -> (Id -> m (Maybe (Decl v a))) -> CodeLookup v m a
[$sel:getTerm:CodeLookup] :: CodeLookup v m a -> Id -> m (Maybe (Term v a))
[$sel:getTypeOfTerm:CodeLookup] :: CodeLookup v m a -> Id -> m (Maybe (Type v a))
[$sel:getTypeDeclaration:CodeLookup] :: CodeLookup v m a -> Id -> m (Maybe (Decl v a))
transitiveDependencies :: (Monad m, Var v) => CodeLookup v m a -> Set Id -> Id -> m (Set Id)
instance Control.Monad.Morph.MFunctor (Unison.Codebase.CodeLookup.CodeLookup v)
instance (GHC.Classes.Ord v, GHC.Base.Functor m) => GHC.Base.Functor (Unison.Codebase.CodeLookup.CodeLookup v m)
instance GHC.Base.Monad m => GHC.Base.Semigroup (Unison.Codebase.CodeLookup.CodeLookup v m a)
instance GHC.Base.Monad m => GHC.Base.Monoid (Unison.Codebase.CodeLookup.CodeLookup v m a)

module Unison.Codebase.Init.CreateCodebaseError
data CreateCodebaseError
CreateCodebaseAlreadyExists :: CreateCodebaseError
type Pretty = Pretty ColorText
instance GHC.Show.Show Unison.Codebase.Init.CreateCodebaseError.CreateCodebaseError


-- | Open codebase error type.
module Unison.Codebase.Init.OpenCodebaseError

-- | An error that can occur when attempting to open a codebase.
data OpenCodebaseError

-- | The codebase doesn't exist.
OpenCodebaseDoesntExist :: OpenCodebaseError

-- | The codebase exists, but its schema version is unknown to this
--   application.
OpenCodebaseUnknownSchemaVersion :: SchemaVersion -> OpenCodebaseError
OpenCodebaseFileLockFailed :: OpenCodebaseError

-- | The codebase exists, but requires a migration before it can be used.
OpenCodebaseRequiresMigration :: SchemaVersion -> SchemaVersion -> OpenCodebaseError
instance GHC.Exception.Type.Exception Unison.Codebase.Init.OpenCodebaseError.OpenCodebaseError
instance GHC.Classes.Eq Unison.Codebase.Init.OpenCodebaseError.OpenCodebaseError
instance GHC.Show.Show Unison.Codebase.Init.OpenCodebaseError.OpenCodebaseError

module Unison.Codebase.Path

-- | A <a>Path</a> is an internal structure representing some namespace in
--   the codebase.
--   
--   <tt>Foo.Bar.baz</tt> becomes <tt>[<a>Foo</a>, <a>Bar</a>, "baz"]</tt>.
--   
--   <b>NB</b>: This shouldn’t be exposed outside of this module
--   (prefer<a>Path'</a>, <a>Absolute</a>, or <a>Relative</a>), but it’s
--   currently used pretty widely. Such usage should be replaced when
--   encountered.
newtype Path
Path :: Seq NameSegment -> Path
[$sel:toSeq:Path] :: Path -> Seq NameSegment

-- | A namespace that may be either absolute or relative, This is the most
--   general type that should be used.
newtype Path'
Path' :: Either Absolute Relative -> Path'
[$sel:unPath':Path'] :: Path' -> Either Absolute Relative

-- | An absolute from the current project root
newtype Absolute
Absolute :: Path -> Absolute
[$sel:unabsolute:Absolute] :: Absolute -> Path
pattern AbsolutePath' :: Absolute -> Path'
absPath_ :: Lens' Absolute Path

-- | A namespace path that doesn’t necessarily start from the root.
--   Typically refers to a path from the current namespace.
newtype Relative
Relative :: Path -> Relative
[$sel:unrelative:Relative] :: Relative -> Path
relPath_ :: Lens' Relative Path
pattern RelativePath' :: Relative -> Path'
class Resolve l r o
resolve :: Resolve l r o => l -> r -> o
pattern Empty :: Path
pattern (:<) :: Cons b b a a => a -> b -> b
infixr 5 :<
pattern (:>) :: Snoc a a b b => a -> b -> a
infixl 5 :>
singleton :: NameSegment -> Path
uncons :: Path -> Maybe (NameSegment, Path)
empty :: Path
isAbsolute :: Path' -> Bool
isRelative :: Path' -> Bool
absoluteEmpty :: Absolute
absoluteEmpty' :: Path'
relativeEmpty :: Relative
relativeEmpty' :: Path'
currentPath :: Path'

-- | This always prefixes, since the secend argument can never be Absolute.
prefix :: Path' -> Relative -> Path'
prefixAbs :: Absolute -> Relative -> Absolute
prefixRel :: Relative -> Relative -> Relative

-- | Returns <a>Nothing</a> if the second argument is absolute. A common
--   pattern is <tt>fromMaybe path $ maybePrefix prefix path</tt> to use
--   the unmodified path in that case.
maybePrefix :: Path' -> Path' -> Maybe Path'

-- | examples: unprefix .foo.bar .blah == .blah (absolute paths left alone)
--   unprefix .foo.bar id == id (relative paths starting w/ nonmatching
--   prefix left alone) unprefix .foo.bar foo.bar.baz == baz (relative
--   paths w/ common prefix get stripped)
unprefix :: Absolute -> Path' -> Path

-- | Returns <a>Nothing</a> if the second argument is absolute. A common
--   pattern is <tt>fromMaybe name $ maybePrefixName prefix name</tt> to
--   use the unmodified path in that case.
maybePrefixName :: Path' -> Name -> Maybe Name
prefixNameIfRel :: Path' -> Name -> Name

-- | Remove a path prefix from a name. Returns <a>Nothing</a> if there are
--   no remaining segments to construct the name from.
--   
--   <pre>
--   &gt;&gt;&gt; unprefixName (Absolute $ fromList ["base", "List"]) (Name.unsafeFromText "base.List.map")
--   Just (Name Relative (NameSegment {toText = "map"} :| []))
--   </pre>
unprefixName :: Absolute -> Name -> Maybe Name
type HQSplit = (Path, HQSegment)
type HQSplitAbsolute = (Absolute, HQSegment)
type AbsSplit = (Absolute, NameSegment)
type Split = (Path, NameSegment)
type Split' = (Path', NameSegment)
type HQSplit' = (Path', HQSegment)
ancestors :: Absolute -> Seq Absolute

-- | Finds the longest shared path prefix of two paths. Returns (shared
--   prefix, path to first location from shared prefix, path to second
--   location from shared prefix)
--   
--   <pre>
--   &gt;&gt;&gt; longestPathPrefix ("a" :&lt; "b" :&lt; "x" :&lt; Empty) ("a" :&lt; "b" :&lt; "c" :&lt; Empty)
--   (a.b,x,c)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; longestPathPrefix Empty ("a" :&lt; "b" :&lt; "c" :&lt; Empty)
--   (,,a.b.c)
--   </pre>
longestPathPrefix :: Path -> Path -> (Path, Path, Path)
isCurrentPath :: Path' -> Bool
isRoot :: Absolute -> Bool
isRoot' :: Path' -> Bool
absoluteToPath' :: Absolute -> Path'
fromList :: [NameSegment] -> Path
fromName :: Name -> Path
fromName' :: Name -> Path'
fromPath' :: Path' -> Path
unsafeParseText :: Text -> Path

-- | Construct a Path' from a text
--   
--   <pre>
--   &gt;&gt;&gt; fromText' "a.b.c"
--   a.b.c
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; fromText' ".a.b.c"
--   .a.b.c
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; show $ fromText' ""
--   ""
--   </pre>
unsafeParseText' :: Text -> Path'
toAbsoluteSplit :: Absolute -> (Path', a) -> (Absolute, a)
toSplit' :: Path' -> Maybe (Path', NameSegment)
toList :: Path -> [NameSegment]
toName :: Path -> Maybe Name

-- | Convert a Path' to a Name
toName' :: Path' -> Maybe Name

-- | Note: This treats the path as relative.
toText :: Path -> Text
toText' :: Path' -> Text
absToText :: Absolute -> Text
relToText :: Relative -> Text
unsplit :: Split -> Path
unsplit' :: Split' -> Path'
unsplitAbsolute :: (Absolute, NameSegment) -> Absolute
nameFromHQSplit :: HQSplit -> HashQualified Name
nameFromHQSplit' :: HQSplit' -> HashQualified Name
nameFromSplit' :: Split' -> Name

-- | <pre>
--   &gt;&gt;&gt; splitFromName "a.b.c"
--   (a.b,c)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; splitFromName "foo"
--   (,foo)
--   </pre>
splitFromName :: Name -> Split
splitFromName' :: Name -> Split'
hqSplitFromName' :: Name -> HQSplit'
cons :: NameSegment -> Path -> Path
snoc :: Path -> NameSegment -> Path
unsnoc :: Path -> Maybe (Path, NameSegment)
instance GHC.Base.Monoid Unison.Codebase.Path.Path
instance GHC.Base.Semigroup Unison.Codebase.Path.Path
instance GHC.Classes.Ord Unison.Codebase.Path.Path
instance GHC.Classes.Eq Unison.Codebase.Path.Path
instance GHC.Classes.Ord Unison.Codebase.Path.Absolute
instance GHC.Classes.Eq Unison.Codebase.Path.Absolute
instance GHC.Classes.Ord Unison.Codebase.Path.Relative
instance GHC.Classes.Eq Unison.Codebase.Path.Relative
instance GHC.Classes.Ord Unison.Codebase.Path.Path'
instance GHC.Classes.Eq Unison.Codebase.Path.Path'
instance Control.Lens.Empty.AsEmpty Unison.Codebase.Path.Path
instance Unison.Codebase.Path.Resolve Unison.Codebase.Path.Path Unison.Codebase.Path.Path Unison.Codebase.Path.Path
instance Unison.Codebase.Path.Resolve Unison.Codebase.Path.Relative Unison.Codebase.Path.Relative Unison.Codebase.Path.Relative
instance Unison.Codebase.Path.Resolve Unison.Codebase.Path.Absolute Unison.Codebase.Path.Relative Unison.Codebase.Path.Absolute
instance Unison.Codebase.Path.Resolve Unison.Codebase.Path.Absolute Unison.Codebase.Path.Relative Unison.Codebase.Path.Path'
instance Unison.Codebase.Path.Resolve Unison.Codebase.Path.Absolute Unison.Codebase.Path.Path Unison.Codebase.Path.Absolute
instance Unison.Codebase.Path.Resolve Unison.Codebase.Path.Path' Unison.Codebase.Path.Path' Unison.Codebase.Path.Path'
instance Unison.Codebase.Path.Resolve Unison.Codebase.Path.Path' Unison.Codebase.Path.Split' Unison.Codebase.Path.Path'
instance Unison.Codebase.Path.Resolve Unison.Codebase.Path.Path' Unison.Codebase.Path.Split' Unison.Codebase.Path.Split'
instance Unison.Codebase.Path.Resolve Unison.Codebase.Path.Absolute Unison.Codebase.Path.HQSplit Unison.Codebase.Path.HQSplitAbsolute
instance Unison.Codebase.Path.Resolve Unison.Codebase.Path.Absolute Unison.Codebase.Path.Path' Unison.Codebase.Path.Absolute
instance Control.Lens.Cons.Snoc Unison.Codebase.Path.Split' Unison.Codebase.Path.Split' Unison.NameSegment.Internal.NameSegment Unison.NameSegment.Internal.NameSegment
instance GHC.Show.Show Unison.Codebase.Path.Path'
instance Witch.From.From Unison.Codebase.Path.Path' Data.Text.Internal.Text
instance Control.Lens.Cons.Cons Unison.Codebase.Path.Path' Unison.Codebase.Path.Path' Unison.NameSegment.Internal.NameSegment Unison.NameSegment.Internal.NameSegment
instance Control.Lens.Cons.Snoc Unison.Codebase.Path.Path' Unison.Codebase.Path.Path' Unison.NameSegment.Internal.NameSegment Unison.NameSegment.Internal.NameSegment
instance GHC.Show.Show Unison.Codebase.Path.Relative
instance Witch.From.From Unison.Codebase.Path.Relative Data.Text.Internal.Text
instance Control.Lens.Cons.Snoc Unison.Codebase.Path.Relative Unison.Codebase.Path.Relative Unison.NameSegment.Internal.NameSegment Unison.NameSegment.Internal.NameSegment
instance Control.Lens.Cons.Cons Unison.Codebase.Path.Relative Unison.Codebase.Path.Relative Unison.NameSegment.Internal.NameSegment Unison.NameSegment.Internal.NameSegment
instance GHC.Show.Show Unison.Codebase.Path.Absolute
instance Witch.From.From Unison.Codebase.Path.Absolute Data.Text.Internal.Text
instance Control.Lens.Cons.Cons Unison.Codebase.Path.Absolute Unison.Codebase.Path.Absolute Unison.NameSegment.Internal.NameSegment Unison.NameSegment.Internal.NameSegment
instance Control.Lens.Cons.Snoc Unison.Codebase.Path.Absolute Unison.Codebase.Path.Absolute Unison.NameSegment.Internal.NameSegment Unison.NameSegment.Internal.NameSegment
instance GHC.IsList.IsList Unison.Codebase.Path.Path
instance GHC.Show.Show Unison.Codebase.Path.Path
instance Witch.From.From Unison.Codebase.Path.Path Data.Text.Internal.Text
instance Control.Lens.Cons.Cons Unison.Codebase.Path.Path Unison.Codebase.Path.Path Unison.NameSegment.Internal.NameSegment Unison.NameSegment.Internal.NameSegment
instance Control.Lens.Cons.Snoc Unison.Codebase.Path.Path Unison.Codebase.Path.Path Unison.NameSegment.Internal.NameSegment Unison.NameSegment.Internal.NameSegment

module U.Codebase.Projects

-- | Find all dependency mounts within a branch and the path to those
--   mounts.
--   
--   For a typical project this will return something like: <tt>[(lib.base,
--   #abc), (lib.distributed, #def)]</tt>
--   
--   For the top-level name lookup of a user codebase it returns the
--   project roots, and will return something like:
--   <tt>[(public.nested.myproject.latest, #abc),
--   (public.other.namespace.otherproject.main, #def)]</tt>
inferDependencyMounts :: Branch Transaction -> Transaction [(Path, BranchHash)]

module Unison.Codebase.Path.Parse
parsePath :: String -> Either Text Path
parsePath' :: String -> Either Text Path'
parseSplit :: String -> Either Text Split
parseSplit' :: String -> Either Text Split'
parseHQSplit :: String -> Either Text HQSplit
parseHQSplit' :: String -> Either Text HQSplit'
parseShortHashOrHQSplit' :: String -> Either Text (Either ShortHash HQSplit')
pathP :: Parsec (Token Text) [Char] Path
pathP' :: Parsec (Token Text) [Char] Path'
splitP :: Parsec (Token Text) [Char] Split
splitP' :: Parsec (Token Text) [Char] Split'

module Unison.Codebase.ProjectPath
data ProjectPathG proj branch
ProjectPath :: proj -> branch -> Absolute -> ProjectPathG proj branch
[$sel:project:ProjectPath] :: ProjectPathG proj branch -> proj
[$sel:branch:ProjectPath] :: ProjectPathG proj branch -> branch
[$sel:absPath:ProjectPath] :: ProjectPathG proj branch -> Absolute
type ProjectPathIds = ProjectPathG ProjectId ProjectBranchId
type ProjectPathNames = ProjectPathG ProjectName ProjectBranchName
type ProjectPath = ProjectPathG Project ProjectBranch
fromProjectAndBranch :: ProjectAndBranch Project ProjectBranch -> Absolute -> ProjectPath
projectBranchRoot :: ProjectAndBranch Project ProjectBranch -> ProjectPath

-- | Discard any path within the project and get the project's root
toRoot :: ProjectPath -> ProjectPath
absPath_ :: Lens' (ProjectPathG p b) Absolute
path_ :: Lens' (ProjectPathG p b) Path
path :: ProjectPathG p b -> Path
toProjectAndBranch :: ProjectPathG p b -> ProjectAndBranch p b
projectAndBranch_ :: Lens (ProjectPathG p b) (ProjectPathG p' b') (ProjectAndBranch p b) (ProjectAndBranch p' b')
toText :: ProjectPathG Project ProjectBranch -> Text

-- | Project a project context into a project path of just IDs
toIds :: ProjectPath -> ProjectPathIds

-- | Project a project context into a project path of just names
toNames :: ProjectPath -> ProjectPathNames
projectPathParser :: Parser ProjectPathNames
parseProjectPath :: Text -> Either Text ProjectPathNames

-- | A generic data structure that contains information about a project and
--   a branch in that project.
data () => ProjectAndBranch a b
ProjectAndBranch :: a -> b -> ProjectAndBranch a b
[project] :: ProjectAndBranch a b -> a
[branch] :: ProjectAndBranch a b -> b

-- | A project.
data () => Project
Project :: !ProjectId -> !ProjectName -> Project
[$sel:projectId:Project] :: Project -> !ProjectId
[$sel:name:Project] :: Project -> !ProjectName

-- | A project branch.
data () => ProjectBranch
ProjectBranch :: !ProjectId -> !ProjectBranchId -> !ProjectBranchName -> !Maybe ProjectBranchId -> ProjectBranch
[$sel:projectId:ProjectBranch] :: ProjectBranch -> !ProjectId
[$sel:branchId:ProjectBranch] :: ProjectBranch -> !ProjectBranchId
[$sel:name:ProjectBranch] :: ProjectBranch -> !ProjectBranchName
[$sel:parentBranchId:ProjectBranch] :: ProjectBranch -> !Maybe ProjectBranchId
instance GHC.Generics.Generic (Unison.Codebase.ProjectPath.ProjectPathG proj branch)
instance (GHC.Show.Show proj, GHC.Show.Show branch) => GHC.Show.Show (Unison.Codebase.ProjectPath.ProjectPathG proj branch)
instance (GHC.Classes.Ord proj, GHC.Classes.Ord branch) => GHC.Classes.Ord (Unison.Codebase.ProjectPath.ProjectPathG proj branch)
instance GHC.Base.Functor (Unison.Codebase.ProjectPath.ProjectPathG proj)
instance (GHC.Classes.Eq proj, GHC.Classes.Eq branch) => GHC.Classes.Eq (Unison.Codebase.ProjectPath.ProjectPathG proj branch)
instance Witch.From.From Unison.Codebase.ProjectPath.ProjectPath Data.Text.Internal.Text
instance Witch.From.From Unison.Codebase.ProjectPath.ProjectPathNames Data.Text.Internal.Text
instance Witch.From.From (Unison.Codebase.ProjectPath.ProjectPathG () Unison.Core.Project.ProjectBranchName) Data.Text.Internal.Text
instance Data.Bifunctor.Bifunctor Unison.Codebase.ProjectPath.ProjectPathG
instance Data.Bifoldable.Bifoldable Unison.Codebase.ProjectPath.ProjectPathG
instance Data.Bitraversable.Bitraversable Unison.Codebase.ProjectPath.ProjectPathG


-- | This module defines the <a>PushBehavior</a> type.
module Unison.Codebase.PushBehavior

-- | How a <tt>push</tt> behaves.
data PushBehavior
ForcePush :: PushBehavior

-- | The namespace being pushed to is required to be empty.
RequireEmpty :: PushBehavior

-- | The namespace being pushed to is required to be non-empty
RequireNonEmpty :: PushBehavior
instance GHC.Show.Show Unison.Codebase.PushBehavior.PushBehavior
instance GHC.Classes.Eq Unison.Codebase.PushBehavior.PushBehavior

module Unison.Codebase.Serialization
type Get a = forall m. (MonadGet m) => m a
type Put a = forall m. (MonadPut m) => a -> m ()
data Format a
Format :: Get a -> Put a -> Format a
[$sel:get:Format] :: Format a -> Get a
[$sel:put:Format] :: Format a -> Put a
getFromBytes :: Get a -> ByteString -> Maybe a
getFromFile :: MonadIO m => Get a -> FilePath -> m (Maybe a)
getFromFile' :: MonadIO m => Get a -> FilePath -> m (Either String a)
putBytes :: Put a -> a -> ByteString
putWithParentDirs :: MonadIO m => Put a -> FilePath -> a -> m ()

module Unison.Codebase.ShortCausalHash
toString :: ShortCausalHash -> String
toHash :: Coercible Hash h => ShortCausalHash -> Maybe h
fromHash :: Int -> CausalHash -> ShortCausalHash

-- | This allows a full hash to be preserved as a <a>ShortCausalHash</a>.
--   
--   <a>ShortCausalHash</a> is used for input when we expect a user to
--   enter a hash on the command line, so they aren’t required to enter the
--   full hash. However, these inputs may also come from an internal
--   source, and in such cases, there is no reason to truncate the hash.
fromFullHash :: Coercible h Hash => h -> ShortCausalHash
fromText :: Text -> Maybe ShortCausalHash

-- | Causal Hash Prefix
newtype ShortCausalHash
ShortCausalHash :: Text -> ShortCausalHash
[$sel:toText:ShortCausalHash] :: ShortCausalHash -> Text
instance GHC.Generics.Generic Unison.Codebase.ShortCausalHash.ShortCausalHash
instance GHC.Classes.Ord Unison.Codebase.ShortCausalHash.ShortCausalHash
instance GHC.Classes.Eq Unison.Codebase.ShortCausalHash.ShortCausalHash
instance GHC.Show.Show Unison.Codebase.ShortCausalHash.ShortCausalHash
instance Witch.From.From Unison.Codebase.ShortCausalHash.ShortCausalHash Data.Text.Internal.Text

module Unison.Codebase.SqliteCodebase.Migrations.Helpers
abortMigration :: String -> Transaction a

module Unison.Codebase.SqliteCodebase.Migrations.MigrateSchema11To12

-- | This migration just deletes all the old name lookups, it doesn't
--   recreate them. On share we'll rebuild only the required name lookups
--   from scratch.
migrateSchema11To12 :: Transaction ()

module Unison.Codebase.SqliteCodebase.Migrations.MigrateSchema1To2.DbHelpers
dbBranchHash :: DbBranch -> Transaction BranchHash
dbPatchHash :: Patch -> Transaction PatchHash
syncCausalHash :: SyncCausalFormat -> Transaction CausalHash


-- | There are many invariants we expect to hold in our sqlite database and
--   on codebase objects which we can't maintain using database checks.
--   This module performs checks for some of these invariants, which can be
--   useful to run after performing potentially dangerous operations like
--   migrations.
module Unison.Codebase.IntegrityCheck

-- | Performs all available integrity checks.
integrityCheckFullCodebase :: Transaction IntegrityResult

-- | Performs a bevy of checks on branch objects and their relation to
--   causals.
integrityCheckAllBranches :: Transaction IntegrityResult

-- | Performs a bevy of checks on causals.
integrityCheckAllCausals :: Transaction IntegrityResult
prettyPrintIntegrityErrors :: Foldable f => f IntegrityError -> Pretty ColorText
data IntegrityResult
IntegrityErrorDetected :: NESet IntegrityError -> IntegrityResult
NoIntegrityErrors :: IntegrityResult
instance GHC.Classes.Ord Unison.Codebase.IntegrityCheck.BranchError
instance GHC.Classes.Eq Unison.Codebase.IntegrityCheck.BranchError
instance GHC.Show.Show Unison.Codebase.IntegrityCheck.BranchError
instance GHC.Classes.Ord Unison.Codebase.IntegrityCheck.IntegrityError
instance GHC.Classes.Eq Unison.Codebase.IntegrityCheck.IntegrityError
instance GHC.Show.Show Unison.Codebase.IntegrityCheck.IntegrityError
instance GHC.Classes.Ord Unison.Codebase.IntegrityCheck.IntegrityResult
instance GHC.Classes.Eq Unison.Codebase.IntegrityCheck.IntegrityResult
instance GHC.Show.Show Unison.Codebase.IntegrityCheck.IntegrityResult
instance GHC.Base.Semigroup Unison.Codebase.IntegrityCheck.IntegrityResult
instance GHC.Base.Monoid Unison.Codebase.IntegrityCheck.IntegrityResult

module Unison.Codebase.SqliteCodebase.Migrations.MigrateSchema3To4

-- | There was a bug in previous versions of UCM which incorrectly used
--   causal hashes as branch hashes. This remained undetected because there
--   was never a need for this hash to be verifiable, and the hashes were
--   still unique because the namespace hash was PART of the causal hash.
--   It did however result in many identical branches being stored multiple
--   times under different <tt>primary_hash_id</tt>s.
--   
--   However, with the advent of Share and Sync, we now need to correctly
--   verify these namespace hashes.
--   
--   This migration fixes the issue by re-hashing namespace objects where
--   the value_hash_id of a causal matches the self_hash_id. Luckily this
--   doesn't change any causal hashes.
--   
--   However, due to the possibility of multiple identical objects stored
--   under different <tt>primary_hash_id</tt>s, we may now have multiple
--   objects with the same <tt>primary_hash_id</tt>, which our DB schema
--   doesn't allow.
--   
--   To address this, we keep exactly one <tt>canonical</tt> object for
--   each hash, then remap all references to old objects into this
--   canonical object instead. Unfortunately this requires mapping over
--   every branch object and traversing the child references.
--   
--   It was also discovered that some developers had many branches which
--   referenced objects which weren't in their codebase. We're not yet sure
--   how this happened, but it's unlikely to be the case for most end
--   users, and it turned out that these references were in causals and
--   branches which were unreachable from the root namespace. As a fix,
--   this migration also tracks every causal and branch which is reachable
--   from the root namespace and deletes all causals and namespaces which
--   are unreachable. Note that this may orphan some definitions, patches,
--   etc. which were previously referenced in an <tt>unreachable</tt>
--   branch, but they were already floating around in an unreachable state.
migrateSchema3To4 :: Transaction ()
instance GHC.Generics.Generic Unison.Codebase.SqliteCodebase.Migrations.MigrateSchema3To4.MigrationState

module Unison.Codebase.SqliteCodebase.Migrations.MigrateSchema6To7

-- | Adds a table for tracking namespace statistics Adds stats for all
--   existing namespaces, even though missing stats are computed on-demand
--   if missing.
migrateSchema6To7 :: Transaction ()

module Unison.Codebase.SqliteCodebase.Migrations.MigrateSchema7To8

-- | Adds a table for tracking namespace statistics Adds stats for all
--   existing namespaces, even though missing stats are computed on-demand
--   if missing.
migrateSchema7To8 :: Transaction ()

module Unison.Codebase.SqliteCodebase.SyncEphemeral
data Dependencies
Dependencies :: Set Hash -> Set Hash -> Dependencies
[$sel:definitions:Dependencies] :: Dependencies -> Set Hash
[$sel:branches:Dependencies] :: Dependencies -> Set Hash
data Error
SrcWrongSchema :: SchemaVersion -> Error
DestWrongSchema :: SchemaVersion -> Error
DisappearingBranch :: CausalHash -> Error
instance GHC.Exception.Type.Exception Unison.Codebase.SqliteCodebase.SyncEphemeral.Error
instance GHC.Show.Show Unison.Codebase.SqliteCodebase.SyncEphemeral.Error

module Unison.Codebase.TermEdit
data TermEdit
Replace :: Reference -> Typing -> TermEdit
Deprecate :: TermEdit
references :: TermEdit -> [Reference]
data Typing
Same :: Typing
Subtype :: Typing
Different :: Typing
toReference :: TermEdit -> Maybe Reference
isTypePreserving :: TermEdit -> Bool
isSame :: TermEdit -> Bool
instance GHC.Show.Show Unison.Codebase.TermEdit.Typing
instance GHC.Classes.Ord Unison.Codebase.TermEdit.Typing
instance GHC.Classes.Eq Unison.Codebase.TermEdit.Typing
instance GHC.Show.Show Unison.Codebase.TermEdit.TermEdit
instance GHC.Classes.Ord Unison.Codebase.TermEdit.TermEdit
instance GHC.Classes.Eq Unison.Codebase.TermEdit.TermEdit

module Unison.Codebase.TypeEdit
data TypeEdit
Replace :: Reference -> TypeEdit
Deprecate :: TypeEdit
references :: TypeEdit -> [Reference]
toReference :: TypeEdit -> Maybe Reference
instance GHC.Show.Show Unison.Codebase.TypeEdit.TypeEdit
instance GHC.Classes.Ord Unison.Codebase.TypeEdit.TypeEdit
instance GHC.Classes.Eq Unison.Codebase.TypeEdit.TypeEdit

module Unison.Codebase.Patch
data Patch
Patch :: Relation Reference TermEdit -> Relation Reference TypeEdit -> Patch
[$sel:_termEdits:Patch] :: Patch -> Relation Reference TermEdit
[$sel:_typeEdits:Patch] :: Patch -> Relation Reference TypeEdit
data PatchDiff
PatchDiff :: Relation Reference TermEdit -> Relation Reference TypeEdit -> Relation Reference TermEdit -> Relation Reference TypeEdit -> PatchDiff
[$sel:_addedTermEdits:PatchDiff] :: PatchDiff -> Relation Reference TermEdit
[$sel:_addedTypeEdits:PatchDiff] :: PatchDiff -> Relation Reference TypeEdit
[$sel:_removedTermEdits:PatchDiff] :: PatchDiff -> Relation Reference TermEdit
[$sel:_removedTypeEdits:PatchDiff] :: PatchDiff -> Relation Reference TypeEdit
typeEdits :: Lens' Patch (Relation Reference TypeEdit)
termEdits :: Lens' Patch (Relation Reference TermEdit)
removedTypeEdits :: Lens' PatchDiff (Relation Reference TypeEdit)
removedTermEdits :: Lens' PatchDiff (Relation Reference TermEdit)
addedTypeEdits :: Lens' PatchDiff (Relation Reference TypeEdit)
addedTermEdits :: Lens' PatchDiff (Relation Reference TermEdit)
diff :: Patch -> Patch -> PatchDiff
labeledDependencies :: Patch -> Set LabeledDependency
empty :: Patch
isEmpty :: Patch -> Bool
allReferences :: Patch -> Set Reference

-- | Returns the set of references which are the target of an arrow in the
--   patch
allReferenceTargets :: Patch -> Set Reference
updateTerm :: (Reference -> Reference -> Typing) -> Reference -> TermEdit -> Patch -> Patch
updateType :: Reference -> TypeEdit -> Patch -> Patch
conflicts :: Patch -> Patch
instance GHC.Base.Semigroup Unison.Codebase.Patch.Patch
instance GHC.Base.Monoid Unison.Codebase.Patch.Patch
instance GHC.Base.Semigroup Unison.Codebase.Patch.PatchDiff
instance GHC.Base.Monoid Unison.Codebase.Patch.PatchDiff
instance GHC.Show.Show Unison.Codebase.Patch.Patch
instance GHC.Classes.Ord Unison.Codebase.Patch.Patch
instance GHC.Classes.Eq Unison.Codebase.Patch.Patch
instance GHC.Show.Show Unison.Codebase.Patch.PatchDiff
instance GHC.Classes.Ord Unison.Codebase.Patch.PatchDiff
instance GHC.Classes.Eq Unison.Codebase.Patch.PatchDiff


-- | This module contains functionality related to computing a "unique type
--   guid lookup" function, which resolves a name to a unique type's GUID
--   to reuse.
module Unison.Codebase.UniqueTypeGuidLookup

-- | <tt>loadUniqueTypeGuid loadNamespaceAtPath path name</tt> looks up the
--   GUID associated with the unique type named <tt>name</tt> at child
--   namespace <tt>path</tt> in the root namespace. If there are multiple
--   such types, an arbitrary one is chosen.
--   
--   For (potential) efficiency, this function accepts an argument that
--   loads a namespace at a path, which may be backed by a cache.
loadUniqueTypeGuid :: (ProjectPath -> Transaction (Maybe (Branch Transaction))) -> ProjectPath -> NameSegment -> Transaction (Maybe Text)

module Unison.Codebase.Verbosity
data Verbosity
Verbose :: Verbosity
Silent :: Verbosity
isSilent :: Verbosity -> Bool
instance GHC.Show.Show Unison.Codebase.Verbosity.Verbosity
instance GHC.Classes.Eq Unison.Codebase.Verbosity.Verbosity

module Unison.CodebasePath

-- | A directory that contains a codebase.
type CodebasePath = FilePath
getCodebaseDir :: MonadIO m => Maybe CodebasePath -> m CodebasePath

module Unison.KindInference.UVar
data UVar v loc
UVar :: Symbol -> Type v loc -> UVar v loc
[$sel:_uvarSymbol:UVar] :: UVar v loc -> Symbol
[$sel:uvarType:UVar] :: UVar v loc -> Type v loc
instance GHC.Show.Show v => GHC.Show.Show (Unison.KindInference.UVar.UVar v loc)
instance U.Core.ABT.Var.Var v => GHC.Classes.Ord (Unison.KindInference.UVar.UVar v loc)
instance U.Core.ABT.Var.Var v => GHC.Classes.Eq (Unison.KindInference.UVar.UVar v loc)

module Unison.KindInference.Constraint.Context

-- | The context in which the constraint was generated. This is useful when
--   generating user-facing error messages.
data ConstraintContext v loc
AppAbs :: !UVar v loc -> !UVar v loc -> ConstraintContext v loc
AppArg :: !UVar v loc -> !UVar v loc -> !UVar v loc -> ConstraintContext v loc
AppArrow :: loc -> !Type v loc -> !Type v loc -> ConstraintContext v loc
Annotation :: ConstraintContext v loc
EffectsList :: ConstraintContext v loc
ScopeReference :: ConstraintContext v loc
TypeAnnotation :: ConstraintContext v loc
DeclDefinition :: ConstraintContext v loc
Builtin :: ConstraintContext v loc
ContextLookup :: ConstraintContext v loc
instance (U.Core.ABT.Var.Var v, GHC.Classes.Ord loc) => GHC.Classes.Ord (Unison.KindInference.Constraint.Context.ConstraintContext v loc)
instance (U.Core.ABT.Var.Var v, GHC.Classes.Eq loc) => GHC.Classes.Eq (Unison.KindInference.Constraint.Context.ConstraintContext v loc)
instance (GHC.Show.Show v, GHC.Show.Show loc) => GHC.Show.Show (Unison.KindInference.Constraint.Context.ConstraintContext v loc)

module Unison.KindInference.Constraint.Provenance

-- | A tag for a source span and context indicating where the generated
--   constraint came from. This is helpful to propagate the constraint
--   context through the solver for user-facing error messages.
data Provenance v loc
Provenance :: !ConstraintContext v loc -> !loc -> Provenance v loc
loc :: Lens' (Provenance v loc) loc
instance (U.Core.ABT.Var.Var v, GHC.Classes.Ord loc) => GHC.Classes.Ord (Unison.KindInference.Constraint.Provenance.Provenance v loc)
instance (U.Core.ABT.Var.Var v, GHC.Classes.Eq loc) => GHC.Classes.Eq (Unison.KindInference.Constraint.Provenance.Provenance v loc)
instance (GHC.Show.Show v, GHC.Show.Show loc) => GHC.Show.Show (Unison.KindInference.Constraint.Provenance.Provenance v loc)

module Unison.KindInference.Constraint.Unsolved

-- | Unsolved constraints
--   
--   These are produced during constraint generation and given as input to
--   the constraint solver.
data Constraint uv v loc typeProv

-- | An IsType constraint may arise from generation or from the solver.
--   During generation the provenance is always a real source code
--   location, but the solver defaults unconstrained kind vars to Star.
IsType :: uv -> typeProv v loc -> Constraint uv v loc typeProv
IsArr :: uv -> Provenance v loc -> uv -> uv -> Constraint uv v loc typeProv
IsAbility :: uv -> Provenance v loc -> Constraint uv v loc typeProv
Unify :: Provenance v loc -> uv -> uv -> Constraint uv v loc typeProv
typeProv :: Traversal (Constraint uv v loc prov) (Constraint uv v loc prov') (prov v loc) (prov' v loc)
prov :: Lens (Constraint uv v loc Provenance) (Constraint uv v loc' Provenance) (Provenance v loc) (Provenance v loc')
loc :: Lens' (Constraint uv v loc Provenance) loc
instance (U.Core.ABT.Var.Var v, GHC.Classes.Ord loc, GHC.Classes.Ord uv, GHC.Classes.Ord (typeProv v loc)) => GHC.Classes.Ord (Unison.KindInference.Constraint.Unsolved.Constraint uv v loc typeProv)
instance (U.Core.ABT.Var.Var v, GHC.Classes.Eq loc, GHC.Classes.Eq uv, GHC.Classes.Eq (typeProv v loc)) => GHC.Classes.Eq (Unison.KindInference.Constraint.Unsolved.Constraint uv v loc typeProv)
instance (GHC.Show.Show v, GHC.Show.Show loc, GHC.Show.Show uv, GHC.Show.Show (typeProv v loc)) => GHC.Show.Show (Unison.KindInference.Constraint.Unsolved.Constraint uv v loc typeProv)

module Unison.KindInference.Generate.Monad
newtype Gen v loc a
Gen :: (GenState v loc -> (a, GenState v loc)) -> Gen v loc a
[$sel:unGen:Gen] :: Gen v loc a -> GenState v loc -> (a, GenState v loc)

-- | The <tt>Gen</tt> monad state
data GenState v loc
GenState :: !Set Symbol -> !Map (Type v loc) (NonEmpty (UVar v loc)) -> [UVar v loc] -> GenState v loc
[$sel:unifVars:GenState] :: GenState v loc -> !Set Symbol
[$sel:typeMap:GenState] :: GenState v loc -> !Map (Type v loc) (NonEmpty (UVar v loc))
[$sel:newVars:GenState] :: GenState v loc -> [UVar v loc]

-- | A generated constraint
type GeneratedConstraint v loc = Constraint (UVar v loc) v loc Provenance

-- | <tt>Gen</tt> monad runner
run :: Gen v loc a -> GenState v loc -> (a, GenState v loc)

-- | Create a unique <tt>UVar</tt> associated with <tt>typ</tt>
freshVar :: Var v => Type v loc -> Gen v loc (UVar v loc)

-- | Associate a fresh <tt>UVar</tt> with <tt>t</tt>, push onto context
pushType :: Var v => Type v loc -> Gen v loc (UVar v loc)

-- | Remove a <tt>Type</tt> from the context
popType :: Var v => Type v loc -> Gen v loc ()

-- | Helper to run an action with the given <tt>Type</tt> in the context
scopedType :: Var v => Type v loc -> (UVar v loc -> Gen v loc r) -> Gen v loc r

-- | Lookup the <tt>UVar</tt> associated with a <tt>Type</tt>
lookupType :: Var v => Type v loc -> Gen v loc (Maybe (UVar v loc))
instance GHC.Generics.Generic (Unison.KindInference.Generate.Monad.GenState v loc)
instance Control.Monad.State.Class.MonadState (Unison.KindInference.Generate.Monad.GenState v loc) (Unison.KindInference.Generate.Monad.Gen v loc)
instance GHC.Base.Monad (Unison.KindInference.Generate.Monad.Gen v loc)
instance GHC.Base.Applicative (Unison.KindInference.Generate.Monad.Gen v loc)
instance GHC.Base.Functor (Unison.KindInference.Generate.Monad.Gen v loc)

module Unison.KindInference.Constraint.TypeProvenance

-- | Provenance of an <tt>IsType</tt> constraint. <tt>IsType</tt>
--   constraints arise in constraint generation (in which case it will have
--   a <tt>Provenance</tt>) and also in the solver through kind-defaulting
--   on unconstrained unification variables.
data TypeProvenance v loc
NotDefault :: Provenance v loc -> TypeProvenance v loc
Default :: TypeProvenance v loc
prov :: Traversal (TypeProvenance v loc) (TypeProvenance v loc') (Provenance v loc) (Provenance v loc')
instance (U.Core.ABT.Var.Var v, GHC.Classes.Ord loc) => GHC.Classes.Ord (Unison.KindInference.Constraint.TypeProvenance.TypeProvenance v loc)
instance (U.Core.ABT.Var.Var v, GHC.Classes.Eq loc) => GHC.Classes.Eq (Unison.KindInference.Constraint.TypeProvenance.TypeProvenance v loc)
instance (GHC.Show.Show v, GHC.Show.Show loc) => GHC.Show.Show (Unison.KindInference.Constraint.TypeProvenance.TypeProvenance v loc)

module Unison.KindInference.Constraint.Solved

-- | Solved constraints
--   
--   These constraints are associated with unification variables during
--   kind inference.
data Constraint uv v loc
IsType :: TypeProvenance v loc -> Constraint uv v loc
IsAbility :: Provenance v loc -> Constraint uv v loc
IsArr :: Provenance v loc -> uv -> uv -> Constraint uv v loc
prov :: Traversal (Constraint uv v loc) (Constraint uv v loc') (Provenance v loc) (Provenance v loc')
loc :: Traversal' (Constraint uv v loc) loc
instance (U.Core.ABT.Var.Var v, GHC.Classes.Ord loc, GHC.Classes.Ord uv) => GHC.Classes.Ord (Unison.KindInference.Constraint.Solved.Constraint uv v loc)
instance (U.Core.ABT.Var.Var v, GHC.Classes.Eq loc, GHC.Classes.Eq uv) => GHC.Classes.Eq (Unison.KindInference.Constraint.Solved.Constraint uv v loc)
instance (GHC.Show.Show v, GHC.Show.Show loc, GHC.Show.Show uv) => GHC.Show.Show (Unison.KindInference.Constraint.Solved.Constraint uv v loc)

module Unison.PatternMatchCoverage.GrdTree

-- | A <tt>GrdTree</tt> is the simple language to desugar matches into. All
--   pattern matching constructs (<i>e.g.</i> structural pattern matching,
--   boolean guards, pattern guards, view patterns, etc) are desugared into
--   this simpler structure.
--   
--   It is parameterized by the values at guard nodes, <tt>n</tt>, and the
--   values at the leaves, <tt>l</tt>. When desugaring, <tt>n</tt> is
--   <a>PmGrd</a> and <tt>l</tt> is the source location. After annotating
--   the <tt>GrdTree</tt>, <tt>n</tt> is a refinement type representing
--   matching values and the <tt>l</tt> is pairs of the aforementioned
--   refinement type and source location.
--   
--   For example:
--   
--   <pre>
--   example : Optional Nat -&gt; Nat
--   example = cases
--     None -&gt; 0
--     Some x
--       | isEven x -&gt; 0
--       | otherwise -&gt; 1
--   </pre>
--   
--   is desugared into
--   
--   <pre>
--   ──┬─ None &lt;- v0 ── srcloc
--     ├─ Some ( v1 :: ##Nat ) &lt;- v0 ── let v2 = isEven v1 ── True &lt;- v2 ── srcloc
--     └─ Some ( v3 :: ##Nat ) &lt;- v0 ── srcloc
--   </pre>
type GrdTree n l = Fix (GrdTreeF n l)
data GrdTreeF n l a

-- | A successful match
LeafF :: l -> GrdTreeF n l a

-- | A constraint of some kind (structural pattern match, boolan guard,
--   etc)
GrdF :: n -> a -> GrdTreeF n l a

-- | A list of alternative matches, tried in order
ForkF :: [a] -> GrdTreeF n l a
pattern Leaf :: l -> GrdTree n l
pattern Grd :: n -> GrdTree n l -> GrdTree n l
pattern Fork :: [GrdTree n l] -> GrdTree n l
prettyGrdTree :: forall n l s. (ListLike s Char, IsString s) => (n -> Pretty s) -> (l -> Pretty s) -> GrdTree n l -> Pretty s
instance (GHC.Show.Show l, GHC.Show.Show n, GHC.Show.Show a) => GHC.Show.Show (Unison.PatternMatchCoverage.GrdTree.GrdTreeF n l a)
instance GHC.Base.Functor (Unison.PatternMatchCoverage.GrdTree.GrdTreeF n l)

module Unison.PatternMatchCoverage.IntervalSet
data IntervalSet
empty :: IntervalSet
singleton :: (Int, Int) -> IntervalSet
fromList :: [(Int, Int)] -> IntervalSet

-- | insert inclusive bounds interval into set
insert :: (Int, Int) -> IntervalSet -> IntervalSet
delete :: (Int, Int) -> IntervalSet -> IntervalSet
difference :: IntervalSet -> IntervalSet -> IntervalSet
intersection :: IntervalSet -> IntervalSet -> IntervalSet
complement :: IntervalSet -> IntervalSet
null :: IntervalSet -> Bool
member :: Int -> IntervalSet -> Bool
extractSingleton :: IntervalSet -> Maybe Int
intersectIntervals :: (Int, Int) -> (Int, Int) -> Maybe (Int, Int)
map :: ((Int, Int) -> (Int, Int)) -> IntervalSet -> IntervalSet
foldr :: (Int -> Int -> b -> b) -> b -> IntervalSet -> b
lookupMin :: IntervalSet -> Maybe Int
lookupMax :: IntervalSet -> Maybe Int
instance GHC.Classes.Ord Unison.PatternMatchCoverage.IntervalSet.IntervalSet
instance GHC.Classes.Eq Unison.PatternMatchCoverage.IntervalSet.IntervalSet
instance GHC.Show.Show Unison.PatternMatchCoverage.IntervalSet.IntervalSet

module Unison.PatternMatchCoverage.ListPat
data ListPat
Cons :: ListPat
Snoc :: ListPat
Nil :: ListPat
prettyListPat :: ListPat -> Pretty ColorText
instance GHC.Classes.Ord Unison.PatternMatchCoverage.ListPat.ListPat
instance GHC.Classes.Eq Unison.PatternMatchCoverage.ListPat.ListPat
instance GHC.Show.Show Unison.PatternMatchCoverage.ListPat.ListPat

module Unison.PatternMatchCoverage.PmLit
data PmLit
Int :: Int64 -> PmLit
Nat :: Word64 -> PmLit
Boolean :: Bool -> PmLit
Float :: Double -> PmLit
Text :: Text -> PmLit
Char :: Char -> PmLit
prettyPmLit :: IsString s => PmLit -> Pretty s
instance GHC.Classes.Ord Unison.PatternMatchCoverage.PmLit.PmLit
instance GHC.Classes.Eq Unison.PatternMatchCoverage.PmLit.PmLit
instance GHC.Show.Show Unison.PatternMatchCoverage.PmLit.PmLit

module Unison.PatternMatchCoverage.UFMap

-- | A union-find structure. Used by <a>NormalizedConstraints</a> to
--   provide efficient unification.
data UFMap k v
data UFValue k v

-- | This is not the canonical value, lookup k in the map to try again
Indirection :: !k -> UFValue k v

-- | The number of elements in the equivalence class
Canonical :: !Int -> !v -> UFValue k v
empty :: UFMap k v

-- | Lookup the canonical value
lookupCanon :: Ord k => k -> UFMap k v -> Maybe (k, Int, v, UFMap k v)
insert :: Ord k => k -> v -> UFMap k v -> UFMap k v
union :: forall m k v r. (MonadFix m, Ord k) => k -> k -> UFMap k v -> (UFMap k v -> m r) -> (k -> v -> UFMap k v -> m (Maybe r)) -> m (Maybe r)
alterF :: forall f k v. (Functor f, Ord k) => k -> f (Maybe v) -> (k -> Int -> v -> f (UFValue k v)) -> UFMap k v -> f (UFMap k v)
alter :: forall k v. Ord k => k -> Maybe v -> (k -> Int -> v -> UFValue k v) -> UFMap k v -> UFMap k v
keys :: UFMap k v -> [k]

-- | Dump the <tt>UFmap</tt> to a list grouped by equivalence class
toClasses :: forall k v. Ord k => UFMap k v -> [(k, Set k, v)]
instance (GHC.Show.Show k, GHC.Show.Show v) => GHC.Show.Show (Unison.PatternMatchCoverage.UFMap.UFValue k v)
instance (GHC.Classes.Ord k, GHC.Classes.Ord v) => GHC.Classes.Ord (Unison.PatternMatchCoverage.UFMap.UFValue k v)
instance (GHC.Classes.Eq k, GHC.Classes.Eq v) => GHC.Classes.Eq (Unison.PatternMatchCoverage.UFMap.UFValue k v)
instance (GHC.Show.Show k, GHC.Show.Show v) => GHC.Show.Show (Unison.PatternMatchCoverage.UFMap.UFMap k v)
instance (GHC.Classes.Ord k, GHC.Classes.Ord v) => GHC.Classes.Ord (Unison.PatternMatchCoverage.UFMap.UFMap k v)
instance (GHC.Classes.Eq k, GHC.Classes.Eq v) => GHC.Classes.Eq (Unison.PatternMatchCoverage.UFMap.UFMap k v)
instance GHC.Base.Functor (Unison.PatternMatchCoverage.UFMap.UnionValue k v)

module Unison.PrettyPrintEnv
data PrettyPrintEnv
PrettyPrintEnv :: (Referent -> [(HashQualified Name, HashQualified Name)]) -> (Reference -> [(HashQualified Name, HashQualified Name)]) -> PrettyPrintEnv
[$sel:termNames:PrettyPrintEnv] :: PrettyPrintEnv -> Referent -> [(HashQualified Name, HashQualified Name)]
[$sel:typeNames:PrettyPrintEnv] :: PrettyPrintEnv -> Reference -> [(HashQualified Name, HashQualified Name)]
patterns :: PrettyPrintEnv -> ConstructorReference -> Maybe (HashQualified Name)
patternName :: PrettyPrintEnv -> ConstructorReference -> HashQualified Name
terms :: PrettyPrintEnv -> Referent -> Maybe (HashQualified Name)
types :: PrettyPrintEnv -> Reference -> Maybe (HashQualified Name)
allTermNames :: PrettyPrintEnv -> Referent -> [HashQualified Name]
allTypeNames :: PrettyPrintEnv -> Reference -> [HashQualified Name]
termName :: PrettyPrintEnv -> Referent -> HashQualified Name
typeName :: PrettyPrintEnv -> Reference -> HashQualified Name
termNameOrHashOnly :: PrettyPrintEnv -> Referent -> HashQualified Name
typeNameOrHashOnly :: PrettyPrintEnv -> Reference -> HashQualified Name
termNameOrHashOnlyFq :: PrettyPrintEnv -> Referent -> HashQualified Name
typeNameOrHashOnlyFq :: PrettyPrintEnv -> Reference -> HashQualified Name

-- | Prefer names which share a common prefix with any provided target.
--   
--   Results are sorted according to the longest common prefix found
--   against ANY target.
biasTo :: [Name] -> PrettyPrintEnv -> PrettyPrintEnv

-- | Get a name for a LabeledDependency from the PPE.
labeledRefName :: PrettyPrintEnv -> LabeledDependency -> HashQualified Name
todoHashLength :: Int

-- | Attempts to find a name in primary ppe, falls back to backup ppe only
--   if no names are found. Typically one can use this to shadow global or
--   absolute names with names that are within the current path.
addFallback :: PrettyPrintEnv -> PrettyPrintEnv -> PrettyPrintEnv

-- | Finds names from both PPEs, if left unbiased the name from the left
--   ppe is preferred.
--   
--   This is distinct from <a>addFallback</a> with respect to biasing; A
--   bias applied to a union might select a name in the right half of the
--   union. Whereas, a bias applied to the result of <a>addFallback</a>
--   will bias within the available names inside the left PPE and will only
--   search in the fallback if there aren't ANY names in the primary ppe.
--   
--   If you don't know the difference, it's likely you want
--   <a>addFallback</a> where you add global names as a fallback for local
--   names.
union :: PrettyPrintEnv -> PrettyPrintEnv -> PrettyPrintEnv
empty :: PrettyPrintEnv
instance GHC.Generics.Generic Unison.PrettyPrintEnv.PrettyPrintEnv
instance GHC.Show.Show Unison.PrettyPrintEnv.PrettyPrintEnv

module Unison.PatternMatchCoverage.Class

-- | A typeclass for the queries required to perform pattern match coverage
--   checking.
class (Ord loc, Var vt, Var v, MonadFix m) => Pmc vt v loc m | m -> vt v loc

-- | Get the constructors of a type
getConstructors :: Pmc vt v loc m => Type vt loc -> m (EnumeratedConstructors vt v loc)

-- | Get the types of the arguments of a specific constructor
getConstructorVarTypes :: Pmc vt v loc m => Type vt loc -> ConstructorReference -> m [Type vt loc]

-- | Get a fresh variable
fresh :: Pmc vt v loc m => m v
getPrettyPrintEnv :: Pmc vt v loc m => m PrettyPrintEnv
data EnumeratedConstructors vt v loc
ConstructorType :: [(v, ConstructorReference, Type vt loc)] -> EnumeratedConstructors vt v loc
AbilityType :: Type vt loc -> Map ConstructorReference (v, Type vt loc) -> EnumeratedConstructors vt v loc
SequenceType :: [(ListPat, [Type vt loc])] -> EnumeratedConstructors vt v loc
BooleanType :: EnumeratedConstructors vt v loc
OtherType :: EnumeratedConstructors vt v loc
traverseConstructorTypes :: Applicative f => (v -> ConstructorReference -> Type vt loc -> f (Type vt loc)) -> EnumeratedConstructors vt v loc -> f (EnumeratedConstructors vt v loc)
instance (GHC.Show.Show v, GHC.Show.Show vt) => GHC.Show.Show (Unison.PatternMatchCoverage.Class.EnumeratedConstructors vt v loc)

module Unison.KindInference.Solve.Monad
newtype Solve v loc a
Solve :: (Env -> SolveState v loc -> (a, SolveState v loc)) -> Solve v loc a
[$sel:unSolve:Solve] :: Solve v loc a -> Env -> SolveState v loc -> (a, SolveState v loc)
data Env
Env :: PrettyPrintEnv -> Env
[$sel:prettyPrintEnv:Env] :: Env -> PrettyPrintEnv

-- | The <tt>SolveState</tt> holds all kind constraints gathered for each
--   type. For example, after processing data and effect decls the
--   <tt>typeMap</tt> will hold entries for every decl, and looking up the
--   corresponding <tt>UVar</tt> in <tt>constraints</tt> will return its
--   kind.
--   
--   The other fields, <tt>unifVars</tt> and <tt>newUnifVars</tt>, are
--   relevant when interleaving constraint generation with solving.
--   Constraint generation needs to create fresh unification variables, so
--   it needs the set of bound unification variables from
--   <tt>unifVars</tt>. <tt>newUnifVars</tt> holds the uvars that are
--   candidates for kind defaulting (see <a>defaultUnconstrainedVars</a>).
data SolveState v loc
SolveState :: !Set Symbol -> [UVar v loc] -> !UFMap (UVar v loc) (Descriptor v loc) -> !Map (Type v loc) (NonEmpty (UVar v loc)) -> SolveState v loc
[$sel:unifVars:SolveState] :: SolveState v loc -> !Set Symbol
[$sel:newUnifVars:SolveState] :: SolveState v loc -> [UVar v loc]
[$sel:constraints:SolveState] :: SolveState v loc -> !UFMap (UVar v loc) (Descriptor v loc)
[$sel:typeMap:SolveState] :: SolveState v loc -> !Map (Type v loc) (NonEmpty (UVar v loc))

-- | Constraints associated with a unification variable
data Descriptor v loc
Descriptor :: Maybe (Constraint (UVar v loc) v loc) -> Descriptor v loc
[$sel:descriptorConstraint:Descriptor] :: Descriptor v loc -> Maybe (Constraint (UVar v loc) v loc)
type ConstraintMap v loc = UFMap (UVar v loc) (Descriptor v loc)

-- | Runner for the <tt>Solve</tt> monad
run :: Env -> SolveState v loc -> Solve v loc a -> (a, SolveState v loc)

-- | Initial solve state
emptyState :: SolveState v loc

-- | Lookup the constraints associated with a unification variable
find :: Var v => UVar v loc -> Solve v loc (Maybe (Constraint (UVar v loc) v loc))

-- | Helper for inteleaving constraint generation and solving
genStateL :: Lens' (SolveState v loc) (GenState v loc)

-- | Interleave constraint generation into constraint solving
runGen :: Var v => Gen v loc a -> Solve v loc a

-- | Add a unification variable to the constarint mapping with no
--   constraints. This is done on uvars created during constraint
--   generation to initialize the new uvars (see <a>runGen</a>).
addUnconstrainedVar :: Var v => UVar v loc -> Solve v loc ()
instance Control.Monad.State.Class.MonadState (Unison.KindInference.Solve.Monad.SolveState v loc) (Unison.KindInference.Solve.Monad.Solve v loc)
instance Control.Monad.Reader.Class.MonadReader Unison.KindInference.Solve.Monad.Env (Unison.KindInference.Solve.Monad.Solve v loc)
instance Control.Monad.Fix.MonadFix (Unison.KindInference.Solve.Monad.Solve v loc)
instance GHC.Base.Monad (Unison.KindInference.Solve.Monad.Solve v loc)
instance GHC.Base.Applicative (Unison.KindInference.Solve.Monad.Solve v loc)
instance GHC.Base.Functor (Unison.KindInference.Solve.Monad.Solve v loc)

module Unison.KindInference.Error

-- | Errors that may arise during kind inference
data KindError v loc

-- | A variable is constrained to have an infinite kind
CycleDetected :: loc -> UVar v loc -> ConstraintMap v loc -> KindError v loc

-- | Something of kind * or Effect is applied to an argument
UnexpectedArgument :: loc -> UVar v loc -> UVar v loc -> ConstraintMap v loc -> KindError v loc
ArgumentMismatch :: UVar v loc -> UVar v loc -> UVar v loc -> ConstraintMap v loc -> KindError v loc
ArgumentMismatchArrow :: (loc, Type v loc, Type v loc) -> ConstraintConflict v loc -> ConstraintMap v loc -> KindError v loc

-- | Something appeared in an effect list that isn't of kind Effect
EffectListMismatch :: ConstraintConflict v loc -> ConstraintMap v loc -> KindError v loc

-- | Generic constraint conflict
ConstraintConflict :: GeneratedConstraint v loc -> ConstraintConflict v loc -> ConstraintMap v loc -> KindError v loc
lspLoc :: Semigroup loc => KindError v loc -> loc

-- | Two incompatible constraints on a <tt>UVar</tt>.
data ConstraintConflict v loc
ConstraintConflict' :: UVar v loc -> Constraint (UVar v loc) v loc -> Constraint (UVar v loc) v loc -> ConstraintConflict v loc
[$sel:conflictedVar:ConstraintConflict'] :: ConstraintConflict v loc -> UVar v loc
[$sel:impliedConstraint:ConstraintConflict'] :: ConstraintConflict v loc -> Constraint (UVar v loc) v loc
[$sel:conflictedConstraint:ConstraintConflict'] :: ConstraintConflict v loc -> Constraint (UVar v loc) v loc

-- | Transform generic constraint conflicts into more specific error by
--   examining its <tt>ConstraintContext</tt>.
improveError :: Var v => KindError v loc -> Solve v loc (KindError v loc)
instance GHC.Show.Show (Unison.KindInference.Error.KindError v loc)


module Unison.KindInference.Constraint.Pretty

-- | Pretty print the kind constraint on the given <tt>UVar</tt>.
--   
--   <b>Precondition:</b> The <tt>ConstraintMap</tt> is acyclic.
prettyUVarKind :: Var v => PrettyPrintEnv -> ConstraintMap v loc -> UVar v loc -> Pretty ColorText

-- | Pretty print a <a>Constraint</a>
--   
--   <b>Precondition:</b> The <tt>ConstraintMap</tt> is acyclic.
prettySolvedConstraint :: Var v => PrettyPrintEnv -> ConstraintMap v loc -> Constraint (UVar v loc) v loc -> Pretty ColorText

-- | A pretty printer for cyclic kind constraints on a <tt>UVar</tt>.
--   Expresses the infinite kind by a generating equation.
--   
--   <b>Precondition:</b> The <tt>UVar</tt> has a cyclic constraint.
prettyCyclicUVarKind :: Var v => PrettyPrintEnv -> ConstraintMap v loc -> UVar v loc -> (Pretty ColorText -> Pretty ColorText) -> (Pretty ColorText, Pretty ColorText)

module Unison.KindInference.Error.Pretty

-- | Pretty print a user-facing <tt>KindError</tt>.
prettyKindError :: Var v => (Type v loc -> Pretty ColorText) -> ([(loc, Color)] -> Pretty ColorText) -> Color -> Color -> PrettyPrintEnv -> KindError v loc -> Pretty ColorText

module Unison.PrettyPrintEnv.FQN
type Imports = Map Name Suffix
type Prefix = [Text]
type Suffix = Text
elideFQN :: Imports -> HashQualified Name -> HashQualified Name

module Unison.PrettyPrintEnv.MonadPretty
type MonadPretty v m = (Var v, MonadReader (PrettyPrintEnv, Set v) m)
getPPE :: MonadPretty v m => m PrettyPrintEnv

-- | Run a computation with a modified PrettyPrintEnv, restoring the
--   original
withPPE :: MonadPretty v m => PrettyPrintEnv -> m a -> m a
applyPPE :: MonadPretty v m => (PrettyPrintEnv -> a) -> m a
applyPPE2 :: MonadPretty v m => (PrettyPrintEnv -> a -> b) -> a -> m b
applyPPE3 :: MonadPretty v m => (PrettyPrintEnv -> a -> b -> c) -> a -> b -> m c

-- | Run a computation with a modified PrettyPrintEnv, restoring the
--   original
modifyPPE :: MonadPretty v m => (PrettyPrintEnv -> PrettyPrintEnv) -> m a -> m a
modifyTypeVars :: MonadPretty v m => (Set v -> Set v) -> m a -> m a

-- | Add type variables to the set of variables that need to be avoided
addTypeVars :: MonadPretty v m => [v] -> m a -> m a

-- | Check if a list of type variables contains any variables that need to
--   be avoided
willCapture :: MonadPretty v m => [v] -> m Bool
runPretty :: Var v => PrettyPrintEnv -> Reader (PrettyPrintEnv, Set v) a -> a

module Unison.PrettyPrintEnv.Names

-- | A "namer" associates a set of (possibly hash-qualified) names with a
--   referent / type reference.
data Namer
Namer :: (Referent -> Set (HashQualified Name)) -> (TypeReference -> Set (HashQualified Name)) -> Namer
[$sel:nameTerm:Namer] :: Namer -> Referent -> Set (HashQualified Name)
[$sel:nameType:Namer] :: Namer -> TypeReference -> Set (HashQualified Name)

-- | Make a "namer" out of a collection of names, respecting conflicted
--   names. That is, if references #foo and #bar are both associated with
--   name "baz", then the returned namer maps #foo too "baz"#foo and #bar
--   to "baz"#bar, but otherwise if a reference #qux has a single name
--   "qux", then the returned namer maps #qux to "qux" (not "qux"#qux).
hqNamer :: Int -> Names -> Namer

-- | Make a "namer" out of a collection of names, ignoring conflicted
--   names. That is, if references #foo and #bar are both associated with
--   name "baz", then the returned namer maps #foo too "baz" (not
--   "baz"#foo) and #bar to "baz" (not "baz"#bar).
namer :: Names -> Namer
data Suffixifier
dontSuffixify :: Suffixifier
suffixifyByHash :: Names -> Suffixifier
suffixifyByHashName :: Names -> Suffixifier
suffixifyByName :: Names -> Suffixifier
suffixifyByHashWithUnhashedTermsInScope :: Set Name -> Names -> Suffixifier
makePPE :: Namer -> Suffixifier -> PrettyPrintEnv
makeTermNames :: Namer -> Suffixifier -> Referent -> [(HashQualified Name, HashQualified Name)]
makeTypeNames :: Namer -> Suffixifier -> TypeReference -> [(HashQualified Name, HashQualified Name)]

module Unison.PrettyPrintEnvDecl
data PrettyPrintEnvDecl
PrettyPrintEnvDecl :: PrettyPrintEnv -> PrettyPrintEnv -> PrettyPrintEnvDecl
[$sel:unsuffixifiedPPE:PrettyPrintEnvDecl] :: PrettyPrintEnvDecl -> PrettyPrintEnv
[$sel:suffixifiedPPE:PrettyPrintEnvDecl] :: PrettyPrintEnvDecl -> PrettyPrintEnv

-- | Lifts <a>biasTo</a> over a PrettyPrintEnvDecl
biasTo :: [Name] -> PrettyPrintEnvDecl -> PrettyPrintEnvDecl
empty :: PrettyPrintEnvDecl

-- | Will use names from the fallback pped if no names were found in the
--   primary. <tt>addFallback primary fallback</tt>
addFallback :: PrettyPrintEnvDecl -> PrettyPrintEnvDecl -> PrettyPrintEnvDecl
instance GHC.Show.Show Unison.PrettyPrintEnvDecl.PrettyPrintEnvDecl
instance GHC.Generics.Generic Unison.PrettyPrintEnvDecl.PrettyPrintEnvDecl

module Unison.PrettyPrintEnv.Util
declarationPPE :: PrettyPrintEnvDecl -> Reference -> PrettyPrintEnv
declarationPPEDecl :: PrettyPrintEnvDecl -> Reference -> PrettyPrintEnvDecl

module Unison.PrettyPrintEnvDecl.Names
makePPED :: Namer -> Suffixifier -> PrettyPrintEnvDecl


-- | Types related to Share and Codeservers.
module Unison.Share.Types

-- | This type is expanded out into all of its fields because we require
--   certain pieces which are optional in a URI, and also to make it more
--   typesafe to eventually convert into a BaseURL for servant clients.
data CodeserverURI
CodeserverURI :: Scheme -> String -> String -> Maybe Int -> [String] -> CodeserverURI
[$sel:codeserverScheme:CodeserverURI] :: CodeserverURI -> Scheme
[$sel:codeserverUserInfo:CodeserverURI] :: CodeserverURI -> String
[$sel:codeserverRegName:CodeserverURI] :: CodeserverURI -> String
[$sel:codeserverPort:CodeserverURI] :: CodeserverURI -> Maybe Int
[$sel:codeserverPath:CodeserverURI] :: CodeserverURI -> [String]

-- | This is distinct from the codeserver URI in that we store credentials
--   by a normalized ID, since it's much easier to look up that way than
--   from an arbitrary path. We may wish to use explicitly named
--   configurations in the future. This currently uses a stringified
--   uriAuthority.
newtype CodeserverId
CodeserverId :: Text -> CodeserverId
[$sel:codeserverId:CodeserverId] :: CodeserverId -> Text
data Scheme
Http :: Scheme
Https :: Scheme

-- | <pre>
--   &gt;&gt;&gt; import Data.Maybe (fromJust)
--   
--   &gt;&gt;&gt; codeserverFromURI . fromJust $ parseURI "http://localhost:8080"
--   Just http://localhost:8080
--   
--   &gt;&gt;&gt; codeserverFromURI . fromJust $ parseURI "http://localhost:80"
--   Just http://localhost:80
--   
--   &gt;&gt;&gt; codeserverFromURI . fromJust $ parseURI "https://share.unison-lang.org/api"
--   Just https://share.unison-lang.org/api
--   
--   &gt;&gt;&gt; codeserverFromURI . fromJust $ parseURI "http://share.unison-lang.org/api"
--   Just http://share.unison-lang.org/api
--   </pre>
codeserverFromURI :: URI -> Maybe CodeserverURI

-- | Gets the part of the CodeserverURI that we use for identifying that
--   codeserver in credentials files.
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Maybe (fromJust)
--   
--   &gt;&gt;&gt; import Network.URI (parseURI)
--   
--   &gt;&gt;&gt; codeserverIdFromURI (fromJust $ parseURI "http://localhost:5424/api")
--   
--   &gt;&gt;&gt; codeserverIdFromURI (fromJust $ parseURI "https://share.unison-lang.org/api")
--   Right "localhost:5424"
--   Right "share.unison-lang.org"
--   </pre>
codeserverIdFromURI :: URI -> Either Text CodeserverId
codeserverToURI :: CodeserverURI -> URI

-- | Gets the CodeserverId for a given CodeserverURI
codeserverIdFromCodeserverURI :: CodeserverURI -> CodeserverId

-- | Builds a servant-compatible BaseUrl for a given CodeserverURI.
codeserverBaseURL :: CodeserverURI -> BaseUrl
instance GHC.Show.Show Unison.Share.Types.Scheme
instance GHC.Classes.Ord Unison.Share.Types.Scheme
instance GHC.Classes.Eq Unison.Share.Types.Scheme
instance GHC.Classes.Ord Unison.Share.Types.CodeserverURI
instance GHC.Classes.Eq Unison.Share.Types.CodeserverURI
instance Data.Aeson.Types.FromJSON.FromJSONKey Unison.Share.Types.CodeserverId
instance Data.Aeson.Types.ToJSON.ToJSONKey Unison.Share.Types.CodeserverId
instance Data.Aeson.Types.FromJSON.FromJSON Unison.Share.Types.CodeserverId
instance Data.Aeson.Types.ToJSON.ToJSON Unison.Share.Types.CodeserverId
instance GHC.Classes.Ord Unison.Share.Types.CodeserverId
instance GHC.Classes.Eq Unison.Share.Types.CodeserverId
instance GHC.Show.Show Unison.Share.Types.CodeserverId
instance GHC.Show.Show Unison.Share.Types.CodeserverURI

module Unison.Codebase.Editor.RemoteRepo
data ShareCodeserver
DefaultCodeserver :: ShareCodeserver
CustomCodeserver :: CodeserverURI -> ShareCodeserver
newtype ShareUserHandle
ShareUserHandle :: Text -> ShareUserHandle
[$sel:shareUserHandleToText:ShareUserHandle] :: ShareUserHandle -> Text

-- | <pre>
--   &gt;&gt;&gt; :set -XOverloadedLists
--   
--   &gt;&gt;&gt; import Data.Maybe (fromJust)
--   
--   &gt;&gt;&gt; import Network.URI
--   
--   &gt;&gt;&gt; displayShareCodeserver DefaultCodeserver "share" ["base", "List"]
--   "share.base.List"
--   
--   &gt;&gt;&gt; displayShareCodeserver DefaultCodeserver "share" []
--   "share"
--   
--   &gt;&gt;&gt; displayShareCodeserver (CustomCodeserver . fromJust $ parseURI "https://share-next.unison-lang.org/api" &gt;&gt;= codeserverFromURI ) "unison" ["base", "List"]
--   "share(https://share-next.unison-lang.org:443/api).unison.base.List"
--   </pre>
displayShareCodeserver :: ShareCodeserver -> ShareUserHandle -> Path -> Text

-- | print remote namespace
printReadRemoteNamespace :: (a -> Text) -> ReadRemoteNamespace a -> Text

-- | Render a <tt>WriteRemoteNamespace</tt> as text.
printWriteRemoteNamespace :: ProjectAndBranch ProjectName ProjectBranchName -> Text
maybePrintPath :: Path -> Text
data ReadRemoteNamespace a
ReadShare'LooseCode :: !ReadShareLooseCode -> ReadRemoteNamespace a

-- | A remote project+branch, specified by name (e.g.
--   @unison<i>base</i>main). Currently assumed to be hosted on Share,
--   though we could include a ShareCodeserver in here, too.
ReadShare'ProjectBranch :: !a -> ReadRemoteNamespace a
data ReadShareLooseCode
ReadShareLooseCode :: !ShareCodeserver -> !ShareUserHandle -> !Path -> ReadShareLooseCode
[$sel:server:ReadShareLooseCode] :: ReadShareLooseCode -> !ShareCodeserver
[$sel:repo:ReadShareLooseCode] :: ReadShareLooseCode -> !ShareUserHandle
[$sel:path:ReadShareLooseCode] :: ReadShareLooseCode -> !Path
isPublic :: ReadShareLooseCode -> Bool
instance GHC.Show.Show Unison.Codebase.Editor.RemoteRepo.ShareCodeserver
instance GHC.Classes.Ord Unison.Codebase.Editor.RemoteRepo.ShareCodeserver
instance GHC.Classes.Eq Unison.Codebase.Editor.RemoteRepo.ShareCodeserver
instance GHC.Show.Show Unison.Codebase.Editor.RemoteRepo.ShareUserHandle
instance GHC.Classes.Ord Unison.Codebase.Editor.RemoteRepo.ShareUserHandle
instance GHC.Classes.Eq Unison.Codebase.Editor.RemoteRepo.ShareUserHandle
instance GHC.Show.Show Unison.Codebase.Editor.RemoteRepo.ReadShareLooseCode
instance GHC.Classes.Eq Unison.Codebase.Editor.RemoteRepo.ReadShareLooseCode
instance GHC.Generics.Generic (Unison.Codebase.Editor.RemoteRepo.ReadRemoteNamespace a)
instance GHC.Show.Show a => GHC.Show.Show (Unison.Codebase.Editor.RemoteRepo.ReadRemoteNamespace a)
instance GHC.Base.Functor Unison.Codebase.Editor.RemoteRepo.ReadRemoteNamespace
instance GHC.Classes.Eq a => GHC.Classes.Eq (Unison.Codebase.Editor.RemoteRepo.ReadRemoteNamespace a)

module Unison.Syntax.NamePrinter
type SyntaxText = SyntaxText' Reference
prettyName :: IsString s => Name -> Pretty s
prettyHashQualified :: HashQualified Name -> Pretty SyntaxText
prettyHashQualified' :: HashQualified Name -> Pretty SyntaxText
prettyHashQualified0 :: IsString s => HashQualified Name -> Pretty s

-- | Pretty-print a reference as a name and the given number of characters
--   of its hash.
prettyNamedReference :: Int -> Name -> Reference -> Pretty SyntaxText

-- | Pretty-print a referent as a name and the given number of characters
--   of its hash.
prettyNamedReferent :: Int -> Name -> Referent -> Pretty SyntaxText

-- | Pretty-print a reference as the given number of characters of its
--   hash.
prettyReference :: Int -> Reference -> Pretty SyntaxText

-- | Pretty-print a referent as the given number of characters of its hash.
prettyReferent :: Int -> Referent -> Pretty SyntaxText
prettyLabeledDependency :: Int -> LabeledDependency -> Pretty SyntaxText
prettyShortHash :: IsString s => ShortHash -> Pretty s
styleHashQualified :: IsString s => (Pretty s -> Pretty s) -> HashQualified Name -> Pretty s
styleHashQualified' :: IsString s => (Pretty s -> Pretty s) -> (Pretty s -> Pretty s) -> HashQualified Name -> Pretty s
styleHashQualified'' :: (Pretty SyntaxText -> Pretty SyntaxText) -> HashQualified Name -> Pretty SyntaxText
fmt :: Element r -> Pretty (SyntaxText' r) -> Pretty (SyntaxText' r)

module Unison.Syntax.Precedence
infixRules :: Map Text Precedence

-- | Indicates this is the RHS of a top-level definition.
isTopLevelPrecedence :: Precedence -> Bool
increment :: Precedence -> Precedence
data Precedence

-- | The lowest precedence, used for top-level bindings
Basement :: Precedence

-- | Used for terms that never need parentheses
Bottom :: Precedence

-- | Type annotations
Annotation :: Precedence

-- | A statement in a block
Statement :: Precedence

-- | Control flow constructs like `if`, <tt>match</tt>, `case`
Control :: Precedence

-- | Infix operators
InfixOp :: InfixPrecedence -> Precedence

-- | Function application
Application :: Precedence

-- | Prefix operators like `'`, <tt>!</tt>
Prefix :: Precedence

-- | The highest precedence, used for let bindings and blocks
Top :: Precedence
data InfixPrecedence
Lowest :: InfixPrecedence
Level :: Int -> InfixPrecedence
Highest :: InfixPrecedence
infixLevels :: [[Text]]

-- | Returns the precedence of an infix operator, if it has one.
operatorPrecedence :: Text -> Maybe Precedence
instance GHC.Show.Show Unison.Syntax.Precedence.InfixPrecedence
instance GHC.Classes.Ord Unison.Syntax.Precedence.InfixPrecedence
instance GHC.Classes.Eq Unison.Syntax.Precedence.InfixPrecedence
instance GHC.Show.Show Unison.Syntax.Precedence.Precedence
instance GHC.Classes.Ord Unison.Syntax.Precedence.Precedence
instance GHC.Classes.Eq Unison.Syntax.Precedence.Precedence

module Unison.Typechecker.Components

-- | Algorithm for minimizing cycles of a `let rec`. This can improve
--   generalization during typechecking and may also be more efficient for
--   execution.
--   
--   For instance:
--   
--   minimize (let rec id x = x; g = id 42; y = id "hi" in g) ==&gt; Just
--   (let id x = x; g = id 42; y = id "hi" in g)
--   
--   Gets rid of the let rec and replaces it with an ordinary `let`, such
--   that <a>id</a> is suitably generalized.
--   
--   Fails on the left if there are duplicate definitions.
minimize :: Var v => Term' vt v a -> Either (NonEmpty (v, [a])) (Maybe (Term' vt v a))
minimize' :: Var v => Term' vt v a -> Either (NonEmpty (v, [a])) (Term' vt v a)

module Unison.Typechecker.TypeLookup
data TypeLookup v a
TypeLookup :: Map TermReference (Type v a) -> Map TypeReference (DataDeclaration v a) -> Map TypeReference (EffectDeclaration v a) -> TypeLookup v a
[$sel:typeOfTerms:TypeLookup] :: TypeLookup v a -> Map TermReference (Type v a)
[$sel:dataDecls:TypeLookup] :: TypeLookup v a -> Map TypeReference (DataDeclaration v a)
[$sel:effectDecls:TypeLookup] :: TypeLookup v a -> Map TypeReference (EffectDeclaration v a)
typeOfReferent :: TypeLookup v a -> Referent -> Maybe (Type v a)
unsafeConstructorType :: TypeLookup v a -> TypeReference -> ConstructorType
constructorType :: TypeLookup v a -> TypeReference -> Maybe ConstructorType
typeOfDataConstructor :: TypeLookup v a -> ConstructorReference -> Maybe (Type v a)
typeOfEffectConstructor :: TypeLookup v a -> ConstructorReference -> Maybe (Type v a)
typeOfTerm :: TypeLookup v a -> TermReference -> Maybe (Type v a)
typeOfTerm' :: TypeLookup v a -> TermReference -> Either TermReference (Type v a)
instance (GHC.Show.Show v, GHC.Show.Show a) => GHC.Show.Show (Unison.Typechecker.TypeLookup.TypeLookup v a)
instance GHC.Base.Semigroup (Unison.Typechecker.TypeLookup.TypeLookup v a)
instance GHC.Base.Monoid (Unison.Typechecker.TypeLookup.TypeLookup v a)
instance GHC.Base.Functor (Unison.Typechecker.TypeLookup.TypeLookup v)

module Unison.Typechecker.TypeVar
data TypeVar b v
Universal :: v -> TypeVar b v
Existential :: b -> v -> TypeVar b v
underlying :: TypeVar b v -> v
liftType :: Ord v => Type v a -> Type (TypeVar b v) a
lowerType :: Ord v => Type (TypeVar b v) a -> Type v a
liftTerm :: Ord v => Term v a -> Term' (TypeVar b v) v a
lowerTerm :: Ord v => Term' (TypeVar b v) v a -> Term v a
instance GHC.Base.Functor (Unison.Typechecker.TypeVar.TypeVar b)
instance GHC.Classes.Eq v => GHC.Classes.Eq (Unison.Typechecker.TypeVar.TypeVar b v)
instance GHC.Classes.Ord v => GHC.Classes.Ord (Unison.Typechecker.TypeVar.TypeVar b v)
instance GHC.Show.Show v => GHC.Show.Show (Unison.Typechecker.TypeVar.TypeVar b v)
instance U.Core.ABT.Var.Var v => U.Core.ABT.Var.Var (Unison.Typechecker.TypeVar.TypeVar b v)
instance Unison.Var.Var v => Unison.Var.Var (Unison.Typechecker.TypeVar.TypeVar b v)

module Unison.UnisonFile.Env
data Env v a
Env :: Map v (Id, DataDeclaration v a) -> Map v (Id, EffectDeclaration v a) -> Names -> Env v a
[$sel:datasId:Env] :: Env v a -> Map v (Id, DataDeclaration v a)
[$sel:effectsId:Env] :: Env v a -> Map v (Id, EffectDeclaration v a)
[$sel:names:Env] :: Env v a -> Names
datas :: Env v a -> Map v (Reference, DataDeclaration v a)

module Unison.UnisonFile.Type
data UnisonFile v a
UnisonFileId :: Map v (TypeReferenceId, DataDeclaration v a) -> Map v (TypeReferenceId, EffectDeclaration v a) -> Map v (a, Term v a) -> Map WatchKind [(v, a, Term v a)] -> UnisonFile v a
[$sel:dataDeclarationsId:UnisonFileId] :: UnisonFile v a -> Map v (TypeReferenceId, DataDeclaration v a)
[$sel:effectDeclarationsId:UnisonFileId] :: UnisonFile v a -> Map v (TypeReferenceId, EffectDeclaration v a)
[$sel:terms:UnisonFileId] :: UnisonFile v a -> Map v (a, Term v a)
[$sel:watches:UnisonFileId] :: UnisonFile v a -> Map WatchKind [(v, a, Term v a)]
pattern UnisonFile :: Map v (TypeReference, DataDeclaration v a) -> Map v (TypeReference, EffectDeclaration v a) -> Map v (a, Term v a) -> Map WatchKind [(v, a, Term v a)] -> UnisonFile v a

-- | A UnisonFile after typechecking. Terms are split into groups by cycle
--   and the type of each term is known.
data TypecheckedUnisonFile v a
TypecheckedUnisonFileId :: Map v (TypeReferenceId, DataDeclaration v a) -> Map v (TypeReferenceId, EffectDeclaration v a) -> [[(v, a, Term v a, Type v a)]] -> [(WatchKind, [(v, a, Term v a, Type v a)])] -> Map v (a, TermReferenceId, Maybe WatchKind, Term v a, Type v a) -> TypecheckedUnisonFile v a
[$sel:dataDeclarationsId':TypecheckedUnisonFileId] :: TypecheckedUnisonFile v a -> Map v (TypeReferenceId, DataDeclaration v a)
[$sel:effectDeclarationsId':TypecheckedUnisonFileId] :: TypecheckedUnisonFile v a -> Map v (TypeReferenceId, EffectDeclaration v a)
[$sel:topLevelComponents':TypecheckedUnisonFileId] :: TypecheckedUnisonFile v a -> [[(v, a, Term v a, Type v a)]]
[$sel:watchComponents:TypecheckedUnisonFileId] :: TypecheckedUnisonFile v a -> [(WatchKind, [(v, a, Term v a, Type v a)])]
[$sel:hashTermsId:TypecheckedUnisonFileId] :: TypecheckedUnisonFile v a -> Map v (a, TermReferenceId, Maybe WatchKind, Term v a, Type v a)
pattern TypecheckedUnisonFile :: Map v (TypeReference, DataDeclaration v a) -> Map v (TypeReference, EffectDeclaration v a) -> [[(v, a, Term v a, Type v a)]] -> [(WatchKind, [(v, a, Term v a, Type v a)])] -> Map v (a, TermReference, Maybe WatchKind, Term (F v a a) v a, Term F v a) -> TypecheckedUnisonFile v a
instance (GHC.Show.Show a, GHC.Show.Show v) => GHC.Show.Show (Unison.UnisonFile.Type.UnisonFile v a)
instance GHC.Generics.Generic (Unison.UnisonFile.Type.UnisonFile v a)
instance (GHC.Show.Show a, GHC.Show.Show v) => GHC.Show.Show (Unison.UnisonFile.Type.TypecheckedUnisonFile v a)
instance GHC.Generics.Generic (Unison.UnisonFile.Type.TypecheckedUnisonFile v a)
instance GHC.Classes.Ord v => GHC.Base.Functor (Unison.UnisonFile.Type.TypecheckedUnisonFile v)

module Unison.Util.CycleTable
data CycleTable k v
CycleTable :: BasicHashTable k v -> IOPRef Int -> CycleTable k v
[$sel:table:CycleTable] :: CycleTable k v -> BasicHashTable k v
[$sel:sizeRef:CycleTable] :: CycleTable k v -> IOPRef Int
new :: Int -> IO (CycleTable k v)
lookup :: (Hashable k, Eq k) => k -> CycleTable k v -> IO (Maybe v)
insert :: (Hashable k, Eq k) => k -> v -> CycleTable k v -> IO ()
size :: CycleTable k v -> IO Int
insertEnd :: (Hashable k, Eq k) => k -> CycleTable k Int -> IO ()

module Unison.Util.CyclicEq
class CyclicEq a
cyclicEq :: CyclicEq a => CycleTable Int Int -> CycleTable Int Int -> a -> a -> IO Bool
bothEq' :: (Eq a, CyclicEq b) => CycleTable Int Int -> CycleTable Int Int -> a -> a -> b -> b -> IO Bool
bothEq :: (CyclicEq a, CyclicEq b) => CycleTable Int Int -> CycleTable Int Int -> a -> a -> b -> b -> IO Bool
instance Unison.Util.CyclicEq.CyclicEq a => Unison.Util.CyclicEq.CyclicEq [a]
instance Unison.Util.CyclicEq.CyclicEq a => Unison.Util.CyclicEq.CyclicEq (Data.Sequence.Internal.Seq a)
instance Unison.Util.CyclicEq.CyclicEq a => Unison.Util.CyclicEq.CyclicEq (Data.Vector.Vector a)

module Unison.Util.CyclicOrd
class CyclicOrd a
cyclicOrd :: CyclicOrd a => CycleTable Int Int -> CycleTable Int Int -> a -> a -> IO Ordering
bothOrd' :: (Ord a, CyclicOrd b) => CycleTable Int Int -> CycleTable Int Int -> a -> a -> b -> b -> IO Ordering
bothOrd :: (CyclicOrd a, CyclicOrd b) => CycleTable Int Int -> CycleTable Int Int -> a -> a -> b -> b -> IO Ordering
instance Unison.Util.CyclicOrd.CyclicOrd a => Unison.Util.CyclicOrd.CyclicOrd [a]
instance Unison.Util.CyclicOrd.CyclicOrd a => Unison.Util.CyclicOrd.CyclicOrd (Data.Sequence.Internal.Seq a)
instance Unison.Util.CyclicOrd.CyclicOrd a => Unison.Util.CyclicOrd.CyclicOrd (Data.Vector.Vector a)

module Unison.Util.EnumContainers
data EnumMap k a
data EnumSet k
class EnumKey k
keyToInt :: EnumKey k => k -> Int
intToKey :: EnumKey k => Int -> k
mapFromList :: EnumKey k => [(k, a)] -> EnumMap k a
setFromList :: EnumKey k => [k] -> EnumSet k
setToList :: EnumKey k => EnumSet k -> [k]
mapSingleton :: EnumKey k => k -> a -> EnumMap k a
setSingleton :: EnumKey k => k -> EnumSet k
mapInsert :: EnumKey k => k -> a -> EnumMap k a -> EnumMap k a
unionWith :: EnumKey k => (a -> a -> a) -> EnumMap k a -> EnumMap k a -> EnumMap k a
intersectionWith :: (a -> b -> c) -> EnumMap k a -> EnumMap k b -> EnumMap k c
hasKey :: EnumKey k => k -> EnumMap k a -> Bool
keys :: EnumKey k => EnumMap k a -> [k]
keysSet :: EnumKey k => EnumMap k a -> EnumSet k
restrictKeys :: EnumKey k => EnumMap k a -> EnumSet k -> EnumMap k a
withoutKeys :: EnumKey k => EnumMap k a -> EnumSet k -> EnumMap k a
mapDifference :: EnumKey k => EnumMap k a -> EnumMap k b -> EnumMap k a
member :: EnumKey k => k -> EnumSet k -> Bool
lookup :: EnumKey k => k -> EnumMap k a -> Maybe a
lookupWithDefault :: EnumKey k => a -> k -> EnumMap k a -> a
mapWithKey :: EnumKey k => (k -> a -> b) -> EnumMap k a -> EnumMap k b
foldMapWithKey :: EnumKey k => Monoid m => (k -> a -> m) -> EnumMap k a -> m
mapToList :: EnumKey k => EnumMap k a -> [(k, a)]
(!) :: EnumKey k => EnumMap k a -> k -> a
findMin :: EnumKey k => EnumSet k -> k
interverse :: Applicative f => (a -> b -> f c) -> EnumMap k a -> EnumMap k b -> f (EnumMap k c)
traverseSet_ :: Applicative f => EnumKey k => (k -> f ()) -> EnumSet k -> f ()
traverseWithKey :: Applicative f => EnumKey k => (k -> a -> f b) -> EnumMap k a -> f (EnumMap k b)
setSize :: EnumSet k -> Int
instance GHC.Base.Semigroup (Unison.Util.EnumContainers.EnumMap k a)
instance GHC.Base.Monoid (Unison.Util.EnumContainers.EnumMap k a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Unison.Util.EnumContainers.EnumMap k a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Unison.Util.EnumContainers.EnumMap k a)
instance GHC.Show.Show a => GHC.Show.Show (Unison.Util.EnumContainers.EnumMap k a)
instance Data.Traversable.Traversable (Unison.Util.EnumContainers.EnumMap k)
instance Data.Foldable.Foldable (Unison.Util.EnumContainers.EnumMap k)
instance GHC.Base.Functor (Unison.Util.EnumContainers.EnumMap k)
instance GHC.Base.Semigroup (Unison.Util.EnumContainers.EnumSet k)
instance GHC.Base.Monoid (Unison.Util.EnumContainers.EnumSet k)
instance GHC.Classes.Ord (Unison.Util.EnumContainers.EnumSet k)
instance GHC.Classes.Eq (Unison.Util.EnumContainers.EnumSet k)
instance GHC.Show.Show (Unison.Util.EnumContainers.EnumSet k)
instance Unison.Util.EnumContainers.EnumKey GHC.Word.Word64
instance Unison.Util.EnumContainers.EnumKey GHC.Word.Word16

module Unison.Util.Exception
tryAny :: MonadIO m => IO a -> m (Either SomeException a)
catchAny :: IO a -> (SomeException -> IO a) -> IO a


-- | Small logging library. Typical usage, import qualified:
--   
--   import qualified Unison.Util.Logger as L
--   
--   do logger &lt;- L.atomic . L.atInfo . L.scope "worker" . L.toHandle $
--   stderr L.warn logger "WARNING!!!" L.debug logger "Debug message, will
--   be ignored" let logger2 = L.atDebug logger L.debug logger2 "Debug
--   message, will be printed" logger' &lt;- L.at L.warnLevel
module Unison.Util.Logger
type Level = Int
type Scope = [String]
data Logger
Logger :: !Scope -> (String -> String) -> !Level -> (String -> IO ()) -> Logger
[$sel:getScope:Logger] :: Logger -> !Scope
[$sel:prefix:Logger] :: Logger -> String -> String
[$sel:getLevel:Logger] :: Logger -> !Level
[$sel:raw:Logger] :: Logger -> String -> IO ()

-- | Ensure at most one message is logged at the same time
atomic :: Logger -> IO Logger
toHandle :: Handle -> Logger
toStandardError :: Logger
toStandardOut :: Logger
logHandleAt :: Logger -> Level -> Handle -> IO ()
logAt' :: Logger -> Level -> IO String -> IO ()
logAt :: Logger -> Level -> String -> IO ()
scope :: String -> Logger -> Logger
scope' :: [String] -> Logger -> Logger
logger :: (String -> IO ()) -> Logger
error :: Logger -> String -> IO ()
warn :: Logger -> String -> IO ()
info :: Logger -> String -> IO ()
debug :: Logger -> String -> IO ()
trace :: Logger -> String -> IO ()
error' :: Logger -> IO String -> IO ()
warn' :: Logger -> IO String -> IO ()
info' :: Logger -> IO String -> IO ()
debug' :: Logger -> IO String -> IO ()
trace' :: Logger -> IO String -> IO ()
errorLevel :: Level
warnLevel :: Level
infoLevel :: Level
debugLevel :: Level
traceLevel :: Level
at :: Level -> Logger -> Logger
atError :: Logger -> Logger
atWarn :: Logger -> Logger
atInfo :: Logger -> Logger
atDebug :: Logger -> Logger
atTrace :: Logger -> Logger
increment :: Logger -> Logger
decrement :: Logger -> Logger

module Unison.Util.Pretty.MegaParsec
prettyPrintParseError :: String -> ParseErrorBundle Text Void -> Pretty ColorText
showErrorFancy :: ShowErrorComponent e => ErrorFancy e -> String
showErrorItem :: ErrorItem (Token Text) -> String

module Unison.Util.RefPromise

-- | When performing compare-and-swaps, the <i>ticket</i> encapsulates
--   proof that a thread observed a specific previous value of a mutable
--   variable. It is provided in lieu of the "old" value to
--   compare-and-swap.
--   
--   Design note: <a>Ticket</a>s exist to hide objects from the GHC
--   compiler, which can normally perform many optimizations that change
--   pointer equality. A Ticket, on the other hand, is a first-class object
--   that can be handled by the user, but will not have its pointer
--   identity changed by compiler optimizations (but will of course, change
--   addresses during garbage collection).
data () => Ticket a

-- | A ticket contains or can get the usable Haskell value. This function
--   does just that.
peekTicket :: Ticket a -> a

-- | Ordinary processor load instruction (non-atomic, not implying any
--   memory barriers).
--   
--   The difference between this function and <a>readIORef</a>, is that it
--   returns a <i>ticket</i>, for use in future compare-and-swap
--   operations.
readForCAS :: IORef a -> IO (Ticket a)

-- | Performs a machine-level compare and swap (CAS) operation on an
--   <a>IORef</a>. Returns a tuple containing a <a>Bool</a> which is
--   <a>True</a> when a swap is performed, along with the most
--   <tt>current</tt> value from the <a>IORef</a>. Note that this differs
--   from the more common CAS behavior, which is to return the <i>old</i>
--   value before the CAS occured.
--   
--   The reason for the difference is the ticket API. This function always
--   returns the ticket that you should use in your next CAS attempt. In
--   case of success, this ticket corresponds to the <tt>new</tt> value
--   which you yourself installed in the <a>IORef</a>, whereas in the case
--   of failure it represents the preexisting value currently in the IORef.
--   
--   Note "compare" here means pointer equality in the sense of
--   <a>reallyUnsafePtrEquality#</a>. However, the ticket API absolves the
--   user of this module from needing to worry about the pointer equality
--   of their values, which in general requires reasoning about the details
--   of the Haskell implementation (GHC).
--   
--   By convention this function is strict in the "new" value argument.
--   This isn't absolutely necesary, but we think it's a bad habit to use
--   unevaluated thunks in this context.
casIORef :: IORef a -> Ticket a -> a -> IO (Bool, Ticket a)
data Promise a
newPromise :: IO (Promise a)
readPromise :: Promise a -> IO a
tryReadPromise :: Promise a -> IO (Maybe a)
writePromise :: Promise a -> a -> IO Bool

module Unison.Util.Star2
data Star2 fact d1 d2
Star2 :: Set fact -> Relation fact d1 -> Relation fact d2 -> Star2 fact d1 d2
($sel:fact:Star2) :: Star2 fact d1 d2 -> Set fact
insertD1 :: (Ord fact, Ord d1) => (fact, d1) -> Star2 fact d1 d2 -> Star2 fact d1 d2
insertD2 :: (Ord fact, Ord d2) => (fact, d2) -> Star2 fact d1 d2 -> Star2 fact d1 d2
deleteD1 :: (Ord fact, Ord d1, Ord d2) => d1 -> Star2 fact d1 d2 -> Star2 fact d1 d2
deleteD2 :: (Ord fact, Ord d1, Ord d2) => (fact, d2) -> Star2 fact d1 d2 -> Star2 fact d1 d2
deleteFact :: (Ord fact, Ord d1, Ord d2) => Set fact -> Star2 fact d1 d2 -> Star2 fact d1 d2
deletePrimaryD1 :: (Ord fact, Ord d1, Ord d2) => (fact, d1) -> Star2 fact d1 d2 -> Star2 fact d1 d2
($sel:d1:Star2) :: Star2 fact d1 d2 -> Relation fact d1
($sel:d2:Star2) :: Star2 fact d1 d2 -> Relation fact d2
difference :: (Ord fact, Ord d1, Ord d2) => Star2 fact d1 d2 -> Star2 fact d1 d2 -> Star2 fact d1 d2
lookupD1 :: (Ord fact, Ord d1) => d1 -> Star2 fact d1 d2 -> Set fact
mapD2 :: (Ord fact, Ord d2, Ord d2a) => (d2 -> d2a) -> Star2 fact d1 d2 -> Star2 fact d1 d2a
memberD1 :: (Ord fact, Ord d1) => (fact, d1) -> Star2 fact d1 d2 -> Bool
replaceFacts :: (Ord fact, Ord d1, Ord d2) => (fact -> fact -> Star2 fact d1 d2 -> Star2 fact d1 d2) -> Map fact fact -> Star2 fact d1 d2 -> Star2 fact d1 d2
instance (GHC.Show.Show fact, GHC.Show.Show d1, GHC.Show.Show d2) => GHC.Show.Show (Unison.Util.Star2.Star2 fact d1 d2)
instance (GHC.Classes.Ord fact, GHC.Classes.Ord d1, GHC.Classes.Ord d2) => GHC.Classes.Ord (Unison.Util.Star2.Star2 fact d1 d2)
instance (GHC.Classes.Eq fact, GHC.Classes.Eq d1, GHC.Classes.Eq d2) => GHC.Classes.Eq (Unison.Util.Star2.Star2 fact d1 d2)
instance (GHC.Classes.Ord fact, GHC.Classes.Ord d1, GHC.Classes.Ord d2) => GHC.Base.Semigroup (Unison.Util.Star2.Star2 fact d1 d2)
instance (GHC.Classes.Ord fact, GHC.Classes.Ord d1, GHC.Classes.Ord d2) => GHC.Base.Monoid (Unison.Util.Star2.Star2 fact d1 d2)

module Unison.Codebase.Metadata
type Star a n = Star2 a n Value
type Value = TermReference
insert :: (Ord a, Ord n) => (a, Value) -> Star a n -> Star a n
delete :: (Ord a, Ord n) => (a, Value) -> Star a n -> Star a n

module Unison.Codebase.Branch.Raw
type Star r n = Star r n
type EditHash = Hash
data Raw
Raw :: Star Referent NameSegment -> Star Reference NameSegment -> Map NameSegment Hash -> Map NameSegment EditHash -> Raw
[$sel:_termsR:Raw] :: Raw -> Star Referent NameSegment
[$sel:_typesR:Raw] :: Raw -> Star Reference NameSegment
[$sel:_childrenR:Raw] :: Raw -> Map NameSegment Hash
[$sel:_editsR:Raw] :: Raw -> Map NameSegment EditHash

module Unison.Codebase.Branch.Type

-- | A Hash for a namespace itself, it doesn't incorporate any history.
type NamespaceHash m = HashFor (Branch0 m)
head :: Branch m -> Branch0 m
headHash :: Branch m -> CausalHash
namespaceHash :: Branch m -> NamespaceHash m

-- | A node in the Unison namespace hierarchy along with its history.
newtype Branch m
Branch :: UnwrappedBranch m -> Branch m
[$sel:_history:Branch] :: Branch m -> UnwrappedBranch m

-- | A node in the Unison namespace hierarchy.
--   
--   <a>$sel:_terms:Branch0</a> and <a>$sel:_types:Branch0</a> are the
--   declarations at this level. <a>$sel:_children:Branch0</a> are the
--   nodes one level below us. <a>$sel:_edits:Branch0</a> are the
--   <a>Patch</a>s stored at this node in the code.
--   
--   The remaining fields are derived from the four above. None of the
--   record fields are exported to avoid accidental tweaking without
--   updating the associated derived fields.
--   
--   Use either the lensy accessors or the field getters.
data Branch0 m
branch0 :: forall m. Star Referent NameSegment -> Star TypeReference NameSegment -> Map NameSegment (Branch m) -> Map NameSegment (PatchHash, m Patch) -> Branch0 m
terms :: Lens' (Branch0 m) (Star Referent NameSegment)
types :: Lens' (Branch0 m) (Star TypeReference NameSegment)
children :: Lens' (Branch0 m) (Map NameSegment (Branch m))
nonEmptyChildren :: Branch0 m -> Map NameSegment (Branch m)
history :: Iso' (Branch m) (UnwrappedBranch m)
edits :: Lens' (Branch0 m) (Map NameSegment (PatchHash, m Patch))
isEmpty0 :: Branch0 m -> Bool
deepTerms :: Branch0 m -> Relation Referent Name
deepTypes :: Branch0 m -> Relation TypeReference Name
deepDefns :: Branch0 m -> DefnsF (Relation Name) Referent TypeReference
deepPaths :: Branch0 m -> Set Path
deepEdits :: Branch0 m -> Map Name PatchHash
type Star r n = Star r n
type UnwrappedBranch m = Causal m (Branch0 m)
instance GHC.Classes.Ord (Unison.Codebase.Branch.Type.Branch m)
instance GHC.Classes.Eq (Unison.Codebase.Branch.Type.Branch m)
instance GHC.Classes.Eq (Unison.Codebase.Branch.Type.Branch0 m)


module Unison.Hashing.V2.Convert
type ResolutionResult a r = Either Seq ResolutionFailure a r
hashBranch0 :: Branch0 m -> Hash
hashCausal :: ContentAddressable e => e -> Set CausalHash -> (CausalHash, HashFor e)
hashDataDecls :: Var v => Map v (DataDeclaration v a) -> ResolutionResult a [(v, Id, DataDeclaration v a)]
hashDecls :: Var v => Map v (Decl v a) -> ResolutionResult a [(v, Id, Decl v a)]
hashPatch :: Patch -> Hash
hashClosedTerm :: Var v => Term v a -> Id
hashTermComponents :: forall v a extra. Var v => Map v (Term v a, Type v a, extra) -> Map v (TermReferenceId, Term v a, Type v a, extra)

-- | This shouldn't be used when storing terms in the codebase, as it
--   doesn't incorporate the type into the hash. this should only be used
--   in cases where you just need a way to identify some terms that you
--   have, but won't be saving them.
hashTermComponentsWithoutTypes :: forall v a. Var v => Map v (Term v a) -> Map v (TermReferenceId, Term v a)
typeToReference :: Var v => Type v a -> Reference
typeToReferenceMentions :: Var v => Type v a -> Set Reference

module Unison.Codebase.Causal
data Causal m e
pattern One :: CausalHash -> HashFor e -> e -> Causal m e
pattern Cons :: CausalHash -> HashFor e -> e -> (CausalHash, m (Causal m e)) -> Causal m e
pattern Merge :: CausalHash -> HashFor e -> e -> Map CausalHash (m (Causal m e)) -> Causal m e

-- | Focus the current head, keeping the hash up to date.
head_ :: ContentAddressable e => Lens' (Causal m e) e
one :: ContentAddressable e => e -> Causal m e
cons :: (Applicative m, ContentAddressable e) => e -> Causal m e -> Causal m e
consDistinct :: (Applicative m, Eq e, ContentAddressable e) => e -> Causal m e -> Causal m e

-- | An optimized variant of <a>fromListM</a> for when it is known we have
--   2+ predecessors (merge node).
mergeNode :: ContentAddressable e => e -> Map CausalHash (m (Causal m e)) -> Causal m e
uncons :: Applicative m => Causal m e -> m (Maybe (e, Causal m e))
predecessors :: Causal m e -> Seq (m (Causal m e))
threeWayMerge :: forall m e. (Monad m, ContentAddressable e) => (Maybe e -> e -> e -> m e) -> Causal m e -> Causal m e -> m (Causal m e)
threeWayMerge' :: forall m e. (Monad m, ContentAddressable e) => (Causal m e -> Causal m e -> m (Maybe (Causal m e))) -> (Maybe e -> e -> e -> m e) -> Causal m e -> Causal m e -> m (Causal m e)
squashMerge' :: forall m e. (Monad m, ContentAddressable e, Eq e) => (Causal m e -> Causal m e -> m (Maybe (Causal m e))) -> (e -> m e) -> (Maybe e -> e -> e -> m e) -> Causal m e -> Causal m e -> m (Causal m e)
lca :: Monad m => Causal m e -> Causal m e -> m (Maybe (Causal m e))
stepDistinct :: (Applicative m, Eq e, ContentAddressable e) => (e -> e) -> Causal m e -> Causal m e
stepDistinctM :: (Applicative m, Functor n, Eq e, ContentAddressable e) => (e -> n e) -> Causal m e -> n (Causal m e)
transform :: Functor m => (forall a. m a -> n a) -> Causal m e -> Causal n e
unsafeMapHashPreserving :: forall m e e2. Functor m => (e -> e2) -> Causal m e -> Causal m e2
before :: Monad m => Causal m e -> Causal m e -> m Bool
beforeHash :: forall m e. Monad m => Word -> CausalHash -> Causal m e -> m Bool
instance GHC.Show.Show a => GHC.Show.Show (Unison.Codebase.Causal.FoldHistoryResult a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Unison.Codebase.Causal.FoldHistoryResult a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Unison.Codebase.Causal.FoldHistoryResult a)

module Unison.Builtin.Decls
lookupDeclRef :: Text -> Reference
lookupEffectRef :: Text -> Reference
unitRef :: Reference
pairRef :: Reference
optionalRef :: Reference
eitherRef :: Reference
testResultRef :: Reference
testResultListRef :: Reference
linkRef :: Reference
docRef :: Reference
ioErrorRef :: Reference
stdHandleRef :: Reference
failureRef :: Reference
ioFailureRef :: Reference
tlsFailureRef :: Reference
arrayFailureRef :: Reference
cryptoFailureRef :: Reference
exceptionRef :: Reference
tlsSignedCertRef :: Reference
tlsPrivateKeyRef :: Reference
isPropagatedRef :: Reference
isTestRef :: Reference
runtimeFailureRef :: Reference
arithmeticFailureRef :: Reference
miscFailureRef :: Reference
stmFailureRef :: Reference
threadKilledFailureRef :: Reference
fileModeRef :: Reference
filePathRef :: Reference
bufferModeRef :: Reference
seekModeRef :: Reference
seqViewRef :: Reference
pairCtorRef :: Referent
unitCtorRef :: Referent
constructorId :: Reference -> Text -> Maybe ConstructorId
noneId :: ConstructorId
someId :: ConstructorId
okConstructorId :: ConstructorId
failConstructorId :: ConstructorId
docBlobId :: ConstructorId
docLinkId :: ConstructorId
docSignatureId :: ConstructorId
docSourceId :: ConstructorId
docEvaluateId :: ConstructorId
docJoinId :: ConstructorId
linkTermId :: ConstructorId
linkTypeId :: ConstructorId
eitherRightId :: ConstructorId
eitherLeftId :: ConstructorId
isPropagatedConstructorId :: ConstructorId
isTestConstructorId :: ConstructorId
bufferModeNoBufferingId :: ConstructorId
bufferModeLineBufferingId :: ConstructorId
bufferModeBlockBufferingId :: ConstructorId
bufferModeSizedBlockBufferingId :: ConstructorId
seqViewEmpty :: ConstructorId
seqViewElem :: ConstructorId
okConstructorReferent :: Referent
failConstructorReferent :: Referent
rewriteTermRef :: Reference
pattern RewriteTerm' :: Term2 vt at ap v a -> Term2 vt at ap v a -> Term2 vt at ap v a
unRewriteTerm :: Term2 vt at ap v a -> Maybe (Term2 vt at ap v a, Term2 vt at ap v a)
rewriteCaseRef :: Reference
pattern RewriteCase' :: Term2 vt at ap v a -> Term2 vt at ap v a -> Term2 vt at ap v a
rewriteCase :: Ord v => a -> Term2 vt at ap v a -> Term2 vt at ap v a -> Term2 vt at ap v a
rewriteTerm :: Ord v => a -> Term2 vt at ap v a -> Term2 vt at ap v a -> Term2 vt at ap v a
unRewriteCase :: Term2 vt at ap v a -> Maybe (Term2 vt at ap v a, Term2 vt at ap v a)
rewriteTypeRef :: Reference
pattern RewriteSignature' :: forall vt at ap v a. [vt] -> Type vt at -> Type vt at -> Term2 vt at ap v a
rewriteType :: (Var v, Semigroup a) => a -> [v] -> Type v a -> Type v a -> Term2 v a a v a
unRewriteSignature :: Term2 vt at ap v a -> Maybe ([vt], Type vt at, Type vt at)
rewritesRef :: Reference
pattern Rewrites' :: [Term2 vt at ap v a] -> Term2 vt at ap v a
rewrites :: (Var v, Monoid a) => a -> [Term2 vt at ap v a] -> Term2 vt at ap v a
unRewrites :: Term2 vt at ap v a -> Maybe [Term2 vt at ap v a]

-- | parse some builtin data types, and resolve their free variables using
--   | builtinTypes' and those types defined herein
builtinDataDecls :: [(Symbol, Id, DataDeclaration Symbol ())]
builtinEffectDecls :: [(Symbol, Id, EffectDeclaration Symbol ())]
pattern UnitRef :: Reference
pattern PairRef :: Reference
pattern EitherRef :: Reference
pattern OptionalRef :: Reference
pattern OptionalNone' :: Term (F typeVar typeAnn patternAnn) v a
pattern OptionalSome' :: Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a
pattern TupleType' :: Var v => [Type v a] -> Type v a
pattern TupleTerm' :: [Term2 vt at ap v a] -> Term2 vt at ap v a
pattern TuplePattern :: [Pattern loc] -> Pattern loc
pattern EitherLeft' :: Term2 vt at ap v a -> Term2 vt at ap v a
pattern EitherRight' :: Term2 vt at ap v a -> Term2 vt at ap v a
pattern EitherLeftId :: ConstructorId
pattern EitherRightId :: ConstructorId
unLeftTerm :: Term2 vt at ap v a -> Maybe (Term2 vt at ap v a)
unRightTerm :: Term2 vt at ap v a -> Maybe (Term2 vt at ap v a)
pattern DocRef :: Reference
pattern DocJoin :: Seq (Term (F typeVar typeAnn patternAnn) v a) -> Term (F typeVar typeAnn patternAnn) v a
pattern DocBlob :: Text -> Term (F typeVar typeAnn patternAnn) v a
pattern DocLink :: Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a
pattern DocSource :: Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a
pattern DocSignature :: Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a
pattern DocEvaluate :: Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a
pattern Doc :: Term (F typeVar typeAnn patternAnn) v a
pattern DocSignatureId :: ConstructorId
pattern DocBlobId :: ConstructorId
pattern DocLinkId :: ConstructorId
pattern DocSourceId :: ConstructorId
pattern DocEvaluateId :: ConstructorId
pattern DocJoinId :: ConstructorId
pattern LinkTermId :: ConstructorId
pattern LinkTypeId :: ConstructorId
pattern LinkRef :: Reference
pattern LinkTerm :: Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a
pattern LinkType :: Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a
unitType :: Ord v => a -> Type v a
pairType :: Ord v => a -> Type v a
optionalType :: Ord v => a -> Type v a
testResultListType :: Ord v => a -> Type v a
eitherType :: Ord v => a -> Type v a
ioErrorType :: Ord v => a -> Type v a
fileModeType :: Ord v => a -> Type v a
filePathType :: Ord v => a -> Type v a
bufferModeType :: Ord v => a -> Type v a
seekModeType :: Ord v => a -> Type v a
stdHandleType :: Ord v => a -> Type v a
failureType :: Ord v => a -> Type v a
thunkArgType :: Ord v => a -> Type v a
exceptionType :: Ord v => a -> Type v a
tlsSignedCertType :: Var v => a -> Type v a
unitTerm :: Var v => a -> Term2 vt at ap v a
tupleConsTerm :: (Ord v, Semigroup a) => Term2 vt at ap v a -> Term2 vt at ap v a -> Term2 vt at ap v a
tupleTerm :: (Var v, Monoid a) => [Term2 vt at ap v a] -> Term2 vt at ap v a
forceTerm :: Var v => a -> a -> Term v a -> Term v a
delayTerm :: Var v => a -> a -> Term v a -> Term v a
unTupleTerm :: Term2 vt at ap v a -> Maybe [Term2 vt at ap v a]
unTupleType :: Var v => Type v a -> Maybe [Type v a]
unTuplePattern :: Pattern loc -> Maybe [Pattern loc]
unUnitRef :: Reference -> Bool
unPairRef :: Reference -> Bool
unOptionalRef :: Reference -> Bool

module Unison.UnisonFile
data UnisonFile v a
UnisonFileId :: Map v (TypeReferenceId, DataDeclaration v a) -> Map v (TypeReferenceId, EffectDeclaration v a) -> Map v (a, Term v a) -> Map WatchKind [(v, a, Term v a)] -> UnisonFile v a
[$sel:dataDeclarationsId:UnisonFileId] :: UnisonFile v a -> Map v (TypeReferenceId, DataDeclaration v a)
[$sel:effectDeclarationsId:UnisonFileId] :: UnisonFile v a -> Map v (TypeReferenceId, EffectDeclaration v a)
[$sel:terms:UnisonFileId] :: UnisonFile v a -> Map v (a, Term v a)
[$sel:watches:UnisonFileId] :: UnisonFile v a -> Map WatchKind [(v, a, Term v a)]
pattern UnisonFile :: Map v (TypeReference, DataDeclaration v a) -> Map v (TypeReference, EffectDeclaration v a) -> Map v (a, Term v a) -> Map WatchKind [(v, a, Term v a)] -> UnisonFile v a

-- | An empty Unison file.
emptyUnisonFile :: UnisonFile v a
allWatches :: UnisonFile v a -> [(v, a, Term v a)]
dataDeclarations :: UnisonFile v a -> Map v (Reference, DataDeclaration v a)
declsToTypeLookup :: Var v => UnisonFile v a -> TypeLookup v a
dependencies :: (Monoid a, Var v) => UnisonFile v a -> DefnsF Set TermReference TypeReference
effectDeclarations :: UnisonFile v a -> Map v (Reference, EffectDeclaration v a)
typecheckingTerm :: (Var v, Monoid a) => UnisonFile v a -> Term v a
watchesOfKind :: WatchKind -> UnisonFile v a -> [(v, a, Term v a)]

-- | Get the location of a given definition in the file.
definitionLocation :: Var v => v -> UnisonFile v a -> Maybe a
termBindings :: UnisonFile v a -> [(v, a, Term v a)]
leftBiasedMerge :: forall v a. Ord v => UnisonFile v a -> UnisonFile v a -> UnisonFile v a

-- | A UnisonFile after typechecking. Terms are split into groups by cycle
--   and the type of each term is known.
data TypecheckedUnisonFile v a
TypecheckedUnisonFileId :: Map v (TypeReferenceId, DataDeclaration v a) -> Map v (TypeReferenceId, EffectDeclaration v a) -> [[(v, a, Term v a, Type v a)]] -> [(WatchKind, [(v, a, Term v a, Type v a)])] -> Map v (a, TermReferenceId, Maybe WatchKind, Term v a, Type v a) -> TypecheckedUnisonFile v a
[$sel:dataDeclarationsId':TypecheckedUnisonFileId] :: TypecheckedUnisonFile v a -> Map v (TypeReferenceId, DataDeclaration v a)
[$sel:effectDeclarationsId':TypecheckedUnisonFileId] :: TypecheckedUnisonFile v a -> Map v (TypeReferenceId, EffectDeclaration v a)
[$sel:topLevelComponents':TypecheckedUnisonFileId] :: TypecheckedUnisonFile v a -> [[(v, a, Term v a, Type v a)]]
[$sel:watchComponents:TypecheckedUnisonFileId] :: TypecheckedUnisonFile v a -> [(WatchKind, [(v, a, Term v a, Type v a)])]
[$sel:hashTermsId:TypecheckedUnisonFileId] :: TypecheckedUnisonFile v a -> Map v (a, TermReferenceId, Maybe WatchKind, Term v a, Type v a)

-- | A mapping of all terms in the file by their var name. The returned
--   terms refer to other definitions in the file by their var, not by
--   reference. Includes test watches.
allTerms :: Ord v => TypecheckedUnisonFile v a -> Map v (Term v a)
dataDeclarations' :: TypecheckedUnisonFile v a -> Map v (Reference, DataDeclaration v a)
discardTypes :: Ord v => TypecheckedUnisonFile v a -> UnisonFile v a
effectDeclarations' :: TypecheckedUnisonFile v a -> Map v (Reference, EffectDeclaration v a)
hashConstructors :: forall v a. Ord v => TypecheckedUnisonFile v a -> Map v Id

-- | Returns the set of constructor names for decls whose names in the
--   given Set.
constructorsForDecls :: Ord v => Set v -> TypecheckedUnisonFile v a -> Set v
hashTerms :: TypecheckedUnisonFile v a -> Map v (a, Reference, Maybe WatchKind, Term v a, Type v a)
indexByReference :: TypecheckedUnisonFile v a -> (Map Id (a, Term v a, Type v a), Map Id (Decl v a))
lookupDecl :: Ord v => v -> TypecheckedUnisonFile v a -> Maybe (Id, Decl v a)
nonEmpty :: TypecheckedUnisonFile v a -> Bool
termSignatureExternalLabeledDependencies :: Ord v => TypecheckedUnisonFile v a -> Set LabeledDependency

-- | the top level components (no watches) plus test watches.
topLevelComponents :: TypecheckedUnisonFile v a -> [[(v, a, Term v a, Type v a)]]
typecheckedUnisonFile :: forall v a. Var v => Map v (Id, DataDeclaration v a) -> Map v (Id, EffectDeclaration v a) -> [[(v, a, Term v a, Type v a)]] -> [(WatchKind, [(v, a, Term v a, Type v a)])] -> TypecheckedUnisonFile v a
rewrite :: (Var v, Eq a) => Set v -> (Term v a -> Maybe (Term v a)) -> UnisonFile v a -> ([v], UnisonFile v a)

-- | This function should be called in preparation for a call to
--   UnisonFile.rewrite. It prevents the possibility of accidental variable
--   capture while still allowing the rules to capture variables where
--   that's the intent. For example:
--   
--   f x = x + 42 ex = List.map (x -&gt; Nat.increment x) [1,2,3]
--   
--   rule1 f = <tt>rewrite term (x -&gt; f x) ==&gt; f rule2 = </tt>rewrite
--   term (x -&gt; f x) ==&gt; f
--   
--   Here, <tt>rule1</tt> introduces a variable <tt>f</tt>, which can stand
--   for any definition. Whereas <tt>rule2</tt> refers to the top-level
--   <tt>f</tt> function in the file.
--   
--   This function returns a tuple of: (prepareRule, preparedFile, finish)
--   <tt>prepareRule</tt> should be called on any `@rewrite` block to do
--   prevent accidental capture. It receives the [v] of variables bound
--   locally by the rule (<tt>rule1</tt> above binds <tt>f</tt>).
--   <tt>preparedFile</tt> should be passed to <a>rewrite</a>
--   <tt>finish</tt> should be called on the result of <a>rewrite</a>
--   
--   Internally, the function works by replacing all free variables in the
--   file with a unique reference, performing the rewrite using the ABT
--   machinery, then converting back to a "regular" UnisonFile with free
--   variables in the terms.
prepareRewrite :: (Monoid a, Var v) => UnisonFile v a -> ([v] -> Term v a -> Term v a, UnisonFile v a, UnisonFile v a -> UnisonFile v a)

-- | All bindings in the term namespace: terms, test watches (since those
--   are the only watches that are actually stored in the codebase), data
--   constructors, and effect constructors.
termNamespaceBindings :: Ord v => TypecheckedUnisonFile v a -> Set v

-- | All bindings in the term namespace: data declarations and effect
--   declarations.
typeNamespaceBindings :: Ord v => TypecheckedUnisonFile v a -> Set v

module Unison.UnisonFile.Names
addNamesFromTypeCheckedUnisonFile :: Var v => TypecheckedUnisonFile v a -> Names -> Names
environmentFor :: forall v a. Var v => Names -> Map v (DataDeclaration v a) -> Map v (EffectDeclaration v a) -> ResolutionResult a (Either [Error v a] (Env v a))
toNames :: Var v => UnisonFile v a -> Names

-- | The set of all term and test watch names. No constructors.
toTermAndWatchNames :: Var v => UnisonFile v a -> Set v
typecheckedToNames :: Var v => TypecheckedUnisonFile v a -> Names

module Unison.UnisonFile.Summary

-- | A file that parses might not always type-check, but often we just want
--   to get as much information as we have available. This provides a type
--   where we can summarize the information available in a Unison file.
--   
--   If the file typechecked then all the Ref Ids and types will be filled
--   in, otherwise they will be Nothing.
data FileSummary
FileSummary :: Map Symbol (Id, DataDeclaration Symbol Ann) -> Map Id (Map Symbol (DataDeclaration Symbol Ann)) -> Map Symbol (Id, EffectDeclaration Symbol Ann) -> Map Id (Map Symbol (EffectDeclaration Symbol Ann)) -> Map Symbol (Ann, Maybe Id, Term Symbol Ann, Maybe (Type Symbol Ann)) -> Map (Maybe Id) (Map Symbol (Ann, Term Symbol Ann, Maybe (Type Symbol Ann))) -> [(Ann, Maybe Symbol, Maybe Id, Term Symbol Ann, Maybe (Type Symbol Ann))] -> [(Ann, Maybe Symbol, Maybe Id, Term Symbol Ann, Maybe (Type Symbol Ann), Maybe WatchKind)] -> Names -> FileSummary
[$sel:dataDeclsBySymbol:FileSummary] :: FileSummary -> Map Symbol (Id, DataDeclaration Symbol Ann)
[$sel:dataDeclsByReference:FileSummary] :: FileSummary -> Map Id (Map Symbol (DataDeclaration Symbol Ann))
[$sel:effectDeclsBySymbol:FileSummary] :: FileSummary -> Map Symbol (Id, EffectDeclaration Symbol Ann)
[$sel:effectDeclsByReference:FileSummary] :: FileSummary -> Map Id (Map Symbol (EffectDeclaration Symbol Ann))
[$sel:termsBySymbol:FileSummary] :: FileSummary -> Map Symbol (Ann, Maybe Id, Term Symbol Ann, Maybe (Type Symbol Ann))
[$sel:termsByReference:FileSummary] :: FileSummary -> Map (Maybe Id) (Map Symbol (Ann, Term Symbol Ann, Maybe (Type Symbol Ann)))
[$sel:testWatchSummary:FileSummary] :: FileSummary -> [(Ann, Maybe Symbol, Maybe Id, Term Symbol Ann, Maybe (Type Symbol Ann))]
[$sel:exprWatchSummary:FileSummary] :: FileSummary -> [(Ann, Maybe Symbol, Maybe Id, Term Symbol Ann, Maybe (Type Symbol Ann), Maybe WatchKind)]
[$sel:fileNames:FileSummary] :: FileSummary -> Names
allWatches :: FileSummary -> [(Ann, Maybe Symbol, Maybe Id, Term Symbol Ann, Maybe (Type Symbol Ann), Maybe WatchKind)]
allTypeDecls :: FileSummary -> Map Symbol (Id, Either (EffectDeclaration Symbol Ann) (DataDeclaration Symbol Ann))

-- | Summarize the information available to us from the current state of
--   the file. See <a>FileSummary</a> for more information.
mkFileSummary :: Maybe (UnisonFile Symbol Ann) -> Maybe (TypecheckedUnisonFile Symbol Ann) -> Maybe FileSummary

-- | Compute the location of user defined definitions within the file
fileDefLocations :: FileSummary -> Map Symbol (Set Ann)
instance GHC.Show.Show Unison.UnisonFile.Summary.FileSummary

module Unison.Codebase.CodeLookup.Util
fromTypecheckedUnisonFile :: forall m v a. (Var v, Monad m) => TypecheckedUnisonFile v a -> CodeLookup v m a

module Unison.Syntax.TypePrinter
pretty :: Var v => PrettyPrintEnv -> Type v a -> Pretty ColorText
pretty0 :: forall v a m. MonadPretty v m => Imports -> Int -> Type v a -> m (Pretty SyntaxText)
prettyRaw :: forall v a m. MonadPretty v m => Imports -> Int -> Type v a -> m (Pretty SyntaxText)
prettyStr :: Var v => Maybe Width -> PrettyPrintEnv -> Type v a -> String
prettySyntax :: Var v => PrettyPrintEnv -> Type v a -> Pretty SyntaxText
prettySignaturesST :: Var v => PrettyPrintEnv -> [(Referent, HashQualified Name, Type v a)] -> [Pretty SyntaxText]
prettySignaturesCT :: Var v => PrettyPrintEnv -> [(Referent, HashQualified Name, Type v a)] -> [Pretty ColorText]
prettySignaturesCTCollapsed :: Var v => PrettyPrintEnv -> [(Referent, HashQualified Name, Type v a)] -> Pretty ColorText
prettySignaturesAlt :: Var v => PrettyPrintEnv -> [([HashQualified Name], Type v a)] -> Pretty ColorText
prettySignaturesAlt' :: Var v => PrettyPrintEnv -> [([HashQualified Name], Type v a)] -> [Pretty ColorText]
runPretty :: Var v => PrettyPrintEnv -> Reader (PrettyPrintEnv, Set v) a -> a

module Unison.Syntax.TypeParser
computationType :: (Monad m, Var v) => TypeP v m
valueType :: (Monad m, Var v) => TypeP v m
valueTypeLeaf :: (Monad m, Var v) => TypeP v m

module Unison.Syntax.TermPrinter
emptyAc :: AmbientContext
pretty :: Var v => PrettyPrintEnv -> Term v a -> Pretty ColorText
prettyBlock :: Var v => Bool -> PrettyPrintEnv -> Term v a -> Pretty ColorText
prettyBlock' :: Var v => Bool -> PrettyPrintEnv -> Term v a -> Pretty SyntaxText
pretty' :: Var v => Maybe Width -> PrettyPrintEnv -> Term v a -> ColorText

-- | Render a binding, producing output of the form
--   
--   foo : t -&gt; u foo a = ...
--   
--   The first line is only output if the term has a type annotation as the
--   outermost constructor.
--   
--   Binary functions with symbolic names are output infix, as follows:
--   
--   (+) : t -&gt; t -&gt; t a + b = ...
prettyBinding :: Var v => PrettyPrintEnv -> HashQualified Name -> Term2 v at ap v a -> Pretty SyntaxText
prettyBinding' :: Var v => PrettyPrintEnv -> Width -> HashQualified Name -> Term v a -> ColorText

-- | Like <a>prettyBinding</a>, but elides the type signature (if any).
prettyBindingWithoutTypeSignature :: Var v => PrettyPrintEnv -> HashQualified Name -> Term2 v at ap v a -> Pretty SyntaxText
prettyDoc2 :: forall v m. MonadPretty v m => AmbientContext -> Term3 v PrintAnnotation -> m (Maybe (Pretty SyntaxText))
pretty0 :: forall v m. MonadPretty v m => AmbientContext -> Term3 v PrintAnnotation -> m (Pretty SyntaxText)
runPretty :: Var v => PrettyPrintEnv -> Reader (PrettyPrintEnv, Set v) a -> a
prettyPattern :: forall v loc. Var v => PrettyPrintEnv -> AmbientContext -> Precedence -> [v] -> Pattern loc -> (Pretty SyntaxText, [v])
instance GHC.Show.Show Unison.Syntax.TermPrinter.BlockContext
instance GHC.Classes.Eq Unison.Syntax.TermPrinter.BlockContext
instance GHC.Show.Show Unison.Syntax.TermPrinter.InfixContext
instance GHC.Classes.Eq Unison.Syntax.TermPrinter.InfixContext
instance GHC.Show.Show Unison.Syntax.TermPrinter.DocLiteralContext
instance GHC.Classes.Eq Unison.Syntax.TermPrinter.DocLiteralContext
instance GHC.Show.Show Unison.Syntax.TermPrinter.PrintAnnotation
instance GHC.Base.Semigroup Unison.Syntax.TermPrinter.PrintAnnotation
instance GHC.Base.Monoid Unison.Syntax.TermPrinter.PrintAnnotation

module Unison.PatternMatchCoverage.Pretty
prettyVar :: Var v => v -> Pretty ColorText
prettyConstructorReference :: PrettyPrintEnv -> ConstructorReference -> Pretty ColorText

module Unison.PatternMatchCoverage.PmGrd
data PmGrd vt v loc

-- | <tt>PmCon x Con xs ys</tt> corresponds to the constraint <tt>Con ys
--   &lt;- x</tt>
PmCon :: v -> ConstructorReference -> [(v, Type vt loc)] -> PmGrd vt v loc
PmEffect :: v -> ConstructorReference -> [(v, Type vt loc)] -> PmGrd vt v loc
PmEffectPure :: v -> (v, Type vt loc) -> PmGrd vt v loc
PmLit :: v -> PmLit -> PmGrd vt v loc
PmListHead :: v -> Int -> v -> Type vt loc -> PmGrd vt v loc
PmListTail :: v -> Int -> v -> Type vt loc -> PmGrd vt v loc

-- | The size of the list must fall within this inclusive range
PmListInterval :: v -> Int -> Int -> PmGrd vt v loc

-- | If a guard performs an effect
PmBang :: v -> PmGrd vt v loc

-- | <tt>PmLet x expr</tt> corresponds to a <tt>let x = expr</tt> guard.
--   This actually <i>binds</i> <tt>x</tt>.
PmLet :: v -> Term' vt v loc -> Type vt loc -> PmGrd vt v loc
prettyPmGrd :: (Var vt, Var v) => PrettyPrintEnv -> PmGrd vt v loc -> Pretty ColorText
instance (GHC.Show.Show v, GHC.Show.Show vt) => GHC.Show.Show (Unison.PatternMatchCoverage.PmGrd.PmGrd vt v loc)

module Unison.PatternMatchCoverage.Desugar

-- | Desugar a match into a <a>GrdTree</a>
desugarMatch :: forall loc vt v m. Pmc vt v loc m => Type vt loc -> v -> [MatchCase loc (Term' vt v loc)] -> m (GrdTree (PmGrd vt v loc) loc)
instance GHC.Base.Functor (Unison.PatternMatchCoverage.Desugar.NormalizedListF loc)

module Unison.PatternMatchCoverage.EffectHandler
data EffectHandler
NoEffect :: EffectHandler
Effect :: ConstructorReference -> EffectHandler
prettyEffectHandler :: PrettyPrintEnv -> EffectHandler -> Pretty ColorText
instance GHC.Generics.Generic Unison.PatternMatchCoverage.EffectHandler.EffectHandler
instance GHC.Classes.Ord Unison.PatternMatchCoverage.EffectHandler.EffectHandler
instance GHC.Classes.Eq Unison.PatternMatchCoverage.EffectHandler.EffectHandler
instance GHC.Show.Show Unison.PatternMatchCoverage.EffectHandler.EffectHandler

module Unison.PatternMatchCoverage.Constraint

-- | A constraint to add to a <a>normalized constraint set</a> (fig 6) See
--   <a>addConstraint</a>
data Constraint vt v loc

-- | Positive constraint regarding data type. States that the given
--   variable must be the given constructor, and it also binds variables
--   corresponding to constructor arguments.
PosCon :: v -> ConstructorReference -> [(v, Type vt loc)] -> Constraint vt v loc

-- | Negative constraint concerning data type. States that the given
--   variable must not be the given constructor.
NegCon :: v -> ConstructorReference -> Constraint vt v loc

-- | Positive constraint regarding data type. States that the given
--   variable must be the given constructor, and it also binds variables
--   corresponding to constructor arguments.
PosEffect :: v -> EffectHandler -> [(v, Type vt loc)] -> Constraint vt v loc

-- | Negative constraint concerning data type. States that the given
--   variable must not be the given constructor.
NegEffect :: v -> EffectHandler -> Constraint vt v loc

-- | Positive constraint regarding literal
PosLit :: v -> PmLit -> Constraint vt v loc

-- | Negative constraint regarding literal
NegLit :: v -> PmLit -> Constraint vt v loc

-- | Positive constraint on list element with position relative to head of
--   list
PosListHead :: v -> Int -> v -> Constraint vt v loc

-- | Positive constraint on list element with position relative to end of
--   list
PosListTail :: v -> Int -> v -> Constraint vt v loc

-- | Negative constraint on length of the list (<i>i.e.</i> the list may
--   not be an element of the interval set)
NegListInterval :: v -> IntervalSet -> Constraint vt v loc

-- | An effect is performed
Effectful :: v -> Constraint vt v loc

-- | Equality constraint
Eq :: v -> v -> Constraint vt v loc
prettyConstraint :: forall vt v loc. (Var vt, Var v) => PrettyPrintEnv -> Constraint vt v loc -> Pretty ColorText
instance (U.Core.ABT.Var.Var vt, GHC.Classes.Ord v) => GHC.Classes.Ord (Unison.PatternMatchCoverage.Constraint.Constraint vt v loc)
instance (U.Core.ABT.Var.Var vt, GHC.Classes.Eq v) => GHC.Classes.Eq (Unison.PatternMatchCoverage.Constraint.Constraint vt v loc)

module Unison.PatternMatchCoverage.NormalizedConstraints

-- | Normalized refinement types (fig 6)
--   
--   Each variable may be associated with a number of constraints
--   represented by <a>VarInfo</a>. A <a>NormalizedConstraints</a> is
--   conceptually the conjunction of all constraints in the map.
--   Disjunction is represented by passing a Set of NormalizedConstraints.
--   So, the constraints are normalized into disjunctive normal form and
--   each <tt>NormalizedConstraints</tt> is a DNF term.
--   
--   Additionally, the following invariants are enforced (Section 3.4)
--   
--   <ul>
--   <li>Mutual compatibility: No two constraints should conflict with each
--   other.</li>
--   <li>Inhabitation: There must be at least one value that inhabits each
--   refinement type. (N.B. We don't truly know if a type is inhabited, see
--   <tt>inhabited</tt> in <a>Unison.PatternMatchCoverage.Solve</a> for
--   details. However, the refinement type is inhabited as far as our
--   inhabitation checker is concerned.)</li>
--   </ul>
--   
--   These invariants ensure that each term in our DNF has at least one
--   solution, and it is easy to expand and print these solutions.
data NormalizedConstraints vt v loc
NormalizedConstraints :: UFMap v (VarInfo vt v loc) -> Set v -> NormalizedConstraints vt v loc

-- | Constraints keyed by the variable they constrain. Equality constraints
--   are handled by <a>UFMap</a>.
[$sel:constraintMap:NormalizedConstraints] :: NormalizedConstraints vt v loc -> UFMap v (VarInfo vt v loc)

-- | dirty variables are ones that must be checked for inhabitance
[$sel:dirtySet:NormalizedConstraints] :: NormalizedConstraints vt v loc -> Set v

-- | Normalized constraints on a specific variable
data VarInfo vt v loc
VarInfo :: v -> Type vt loc -> VarConstraints vt v loc -> EffectInfo -> VarInfo vt v loc
[$sel:vi_id:VarInfo] :: VarInfo vt v loc -> v
[$sel:vi_typ:VarInfo] :: VarInfo vt v loc -> Type vt loc
[$sel:vi_con:VarInfo] :: VarInfo vt v loc -> VarConstraints vt v loc
[$sel:vi_eff:VarInfo] :: VarInfo vt v loc -> EffectInfo

-- | The constraints are different for different types, although most of
--   them take the form of an optional positive constraint and a set of
--   negative constraints.
data VarConstraints vt v loc
Vc'Constructor :: Maybe (ConstructorReference, [(v, Type vt loc)]) -> Set ConstructorReference -> VarConstraints vt v loc
Vc'Effect :: Maybe (EffectHandler, [(v, Type vt loc)]) -> Set EffectHandler -> VarConstraints vt v loc
Vc'Boolean :: Maybe Bool -> Set Bool -> VarConstraints vt v loc
Vc'Int :: Maybe Int64 -> Set Int64 -> VarConstraints vt v loc
Vc'Nat :: Maybe Word64 -> Set Word64 -> VarConstraints vt v loc
Vc'Float :: Maybe Double -> Set Double -> VarConstraints vt v loc
Vc'Text :: Maybe Text -> Set Text -> VarConstraints vt v loc
Vc'Char :: Maybe Char -> Set Char -> VarConstraints vt v loc
Vc'ListRoot :: Type vt loc -> Seq v -> Seq v -> IntervalSet -> VarConstraints vt v loc
data EffectInfo
IsEffectful :: EffectInfo
IsNotEffectful :: EffectInfo

-- | Mark a variable as requiring a new test for inhabitation.
markDirty :: Ord v => v -> NormalizedConstraints vt v loc -> NormalizedConstraints vt v loc
emptyNormalizedConstraints :: Ord v => NormalizedConstraints vt v loc

-- | Generic function to lookup or alter constraints in the constraint map.
--   Throws an error if the variable is not in the map.
updateF :: forall vt v loc f. (Var v, Functor f) => v -> (v -> VarInfo vt v loc -> f (ConstraintUpdate (VarInfo vt v loc))) -> NormalizedConstraints vt v loc -> f (NormalizedConstraints vt v loc)
data ConstraintUpdate a
Update :: a -> ConstraintUpdate a
Ignore :: ConstraintUpdate a

-- | Lookup the canonical value of <tt>v</tt> from the constraint map.
--   Throws an error if the variable is not in the map.
expectCanon :: forall vt v loc. Var v => v -> NormalizedConstraints vt v loc -> (v, VarInfo vt v loc, NormalizedConstraints vt v loc)

-- | Install a new variable into the constraint map. Throws an error if the
--   variable already exists in the map.
declVar :: forall vt v loc. Var v => v -> Type vt loc -> (VarInfo vt v loc -> VarInfo vt v loc) -> NormalizedConstraints vt v loc -> NormalizedConstraints vt v loc
prettyNormalizedConstraints :: forall vt v loc. (Var v, Var vt) => PrettyPrintEnv -> NormalizedConstraints vt v loc -> Pretty ColorText
prettyDnf :: (Var v, Var vt) => PrettyPrintEnv -> Set (NormalizedConstraints vt v loc) -> Pretty ColorText
instance GHC.Base.Functor Unison.PatternMatchCoverage.NormalizedConstraints.ConstraintUpdate
instance GHC.Generics.Generic (Unison.PatternMatchCoverage.NormalizedConstraints.VarConstraints vt v loc)
instance (U.Core.ABT.Var.Var vt, GHC.Classes.Ord v) => GHC.Classes.Ord (Unison.PatternMatchCoverage.NormalizedConstraints.VarConstraints vt v loc)
instance (U.Core.ABT.Var.Var vt, GHC.Classes.Eq v) => GHC.Classes.Eq (Unison.PatternMatchCoverage.NormalizedConstraints.VarConstraints vt v loc)
instance (GHC.Show.Show v, GHC.Show.Show vt) => GHC.Show.Show (Unison.PatternMatchCoverage.NormalizedConstraints.VarConstraints vt v loc)
instance GHC.Classes.Ord Unison.PatternMatchCoverage.NormalizedConstraints.EffectInfo
instance GHC.Classes.Eq Unison.PatternMatchCoverage.NormalizedConstraints.EffectInfo
instance GHC.Show.Show Unison.PatternMatchCoverage.NormalizedConstraints.EffectInfo
instance GHC.Generics.Generic (Unison.PatternMatchCoverage.NormalizedConstraints.VarInfo vt v loc)
instance (U.Core.ABT.Var.Var vt, GHC.Classes.Ord v) => GHC.Classes.Ord (Unison.PatternMatchCoverage.NormalizedConstraints.VarInfo vt v loc)
instance (U.Core.ABT.Var.Var vt, GHC.Classes.Eq v) => GHC.Classes.Eq (Unison.PatternMatchCoverage.NormalizedConstraints.VarInfo vt v loc)
instance (GHC.Show.Show v, GHC.Show.Show vt) => GHC.Show.Show (Unison.PatternMatchCoverage.NormalizedConstraints.VarInfo vt v loc)
instance (GHC.Show.Show v, GHC.Show.Show vt) => GHC.Show.Show (Unison.PatternMatchCoverage.NormalizedConstraints.NormalizedConstraints vt v loc)
instance (U.Core.ABT.Var.Var vt, GHC.Classes.Ord v) => GHC.Classes.Ord (Unison.PatternMatchCoverage.NormalizedConstraints.NormalizedConstraints vt v loc)
instance (U.Core.ABT.Var.Var vt, GHC.Classes.Eq v) => GHC.Classes.Eq (Unison.PatternMatchCoverage.NormalizedConstraints.NormalizedConstraints vt v loc)

module Unison.PatternMatchCoverage.Literal

-- | Refinement type literals (fig 3)
data Literal vt v loc

-- | True
T :: Literal vt v loc

-- | False
F :: Literal vt v loc

-- | Positive constraint regarding data type. States that the given
--   variable must be the given constructor, and it also binds variables
--   corresponding to constructor arguments.
PosCon :: v -> ConstructorReference -> [(v, Type vt loc)] -> Literal vt v loc

-- | Negative constraint concerning data type. States that the given
--   variable must not be the given constructor.
NegCon :: v -> ConstructorReference -> Literal vt v loc

-- | Positive constraint regarding data type. States that the given
--   variable must be the given constructor, and it also binds variables
--   corresponding to constructor arguments.
PosEffect :: v -> EffectHandler -> [(v, Type vt loc)] -> Literal vt v loc

-- | Negative constraint concerning data type. States that the given
--   variable must not be the given constructor.
NegEffect :: v -> EffectHandler -> Literal vt v loc

-- | Positive constraint regarding literal
PosLit :: v -> PmLit -> Literal vt v loc

-- | Negative constraint regarding literal
NegLit :: v -> PmLit -> Literal vt v loc

-- | Positive constraint on list element with position relative to head of
--   list
PosListHead :: v -> Int -> v -> Type vt loc -> Literal vt v loc

-- | Positive constraint on list element with position relative to end of
--   list
PosListTail :: v -> Int -> v -> Type vt loc -> Literal vt v loc

-- | Negative constraint on length of the list (<i>i.e.</i> the list may
--   not be an element of the interval set)
NegListInterval :: v -> IntervalSet -> Literal vt v loc

-- | An effect is performed
Effectful :: v -> Literal vt v loc

-- | Introduce a binding for a term
Let :: v -> Term' vt v loc -> Type vt loc -> Literal vt v loc
prettyLiteral :: Var v => Literal (TypeVar b v) v loc -> Pretty ColorText
instance (GHC.Show.Show v, GHC.Show.Show vt) => GHC.Show.Show (Unison.PatternMatchCoverage.Literal.Literal vt v loc)

module Unison.Syntax.TermParser

-- | Rules for the annotation of the resulting binding is as follows: * If
--   the binding has a type signature, the top level scope of the
--   annotation for the type Ann node will contain the _entire_ binding,
--   including the type signature. * The body expression of the binding
--   contains the entire lhs (including the name of the binding) and the
--   entire body. * If the binding is a lambda, the lambda node includes
--   the entire LHS of the binding, including the name as well.
binding :: forall m v. (Monad m, Var v) => P v m ((Ann, v), Term v Ann)
blockTerm :: (Monad m, Var v) => TermP v m

-- | Syntax for documentation v2 blocks, which are surrounded by
--   <tt>{{</tt> <tt>}}</tt>. The lexer does most of the heavy lifting so
--   there's not a lot for the parser to do. For instance, in
--   
--   <pre>
--   {{
--   Hi there!
--   
--   goodbye.
--   }}
--   </pre>
--   
--   the lexer will produce:
--   
--   <pre>
--   [ Doc
--     ( DocUntitledSection
--       (DocParagraph (DocWord "Hi" :| [DocWord "there!"]))
--       (DocParagraph (DocWord "goodbye" :| []))
--     )
--   ]
--   </pre>
--   
--   The parser will parse this into the Unison expression:
--   
--   <pre>
--   syntax.docUntitledSection [
--     syntax.docParagraph [syntax.docWord "Hi", syntax.docWord "there!"],
--     syntax.docParagraph [syntax.docWord "goodbye"]
--   ]
--   </pre>
--   
--   Where <tt>syntax.doc{Paragraph, UntitledSection,...}</tt> are all
--   ordinary term variables that will be looked up in the environment like
--   anything else. This means that the documentation syntax can have its
--   meaning changed by overriding what functions the names
--   <tt>syntax.doc*</tt> correspond to.
doc2Block :: forall m v. (Monad m, Var v) => P v m (Ann, Term v Ann)
imports :: (Monad m, Var v) => P v m (Names, [(v, v)])
lam :: Var v => TermP v m -> TermP v m
substImports :: Var v => Names -> [(v, v)] -> Term v Ann -> Term v Ann
term :: (Monad m, Var v) => TermP v m
verifyRelativeVarName :: Var v => P v m (Token v) -> P v m (Token v)
instance GHC.Show.Show Unison.Syntax.TermParser.UnbreakCase
instance GHC.Classes.Eq Unison.Syntax.TermParser.UnbreakCase
instance U.Core.ABT.Var.Var v => GHC.Classes.Ord (Unison.Syntax.TermParser.InfixParse v)
instance U.Core.ABT.Var.Var v => GHC.Classes.Eq (Unison.Syntax.TermParser.InfixParse v)
instance GHC.Show.Show v => GHC.Show.Show (Unison.Syntax.TermParser.InfixParse v)
instance GHC.Show.Show v => GHC.Show.Show (Unison.Syntax.TermParser.BlockElement v)

module Unison.Syntax.DeclParser
declarations :: (Monad m, Var v) => P v m (Map v (DataDeclaration v Ann), Map v (EffectDeclaration v Ann), Accessors v)

module Unison.Syntax.FileParser
file :: forall m v. (Monad m, Var v) => P v m (UnisonFile v Ann)
instance GHC.Base.Functor (Unison.Syntax.FileParser.Stanza v)
instance Data.Traversable.Traversable (Unison.Syntax.FileParser.Stanza v)
instance Data.Foldable.Foldable (Unison.Syntax.FileParser.Stanza v)

module Unison.PatternMatchCoverage.Solve

-- | top-down traversal of the <a>GrdTree</a> that produces:
--   
--   <ul>
--   <li>a refinement type describing values that do not match the
--   <a>GrdTree</a> (the "uncovered" set)</li>
--   <li>a new <a>GrdTree</a> annotated with refinement types at the nodes
--   describing values that cause an effect to be performed and values that
--   match the case at the leaves.</li>
--   </ul>
--   
--   If the former is inhabited then its inhabitants are unmatched values.
--   If the leaves of the latter are inhabited then the case is redundant.
uncoverAnnotate :: forall vt v loc m l. Pmc vt v loc m => Set (NormalizedConstraints vt v loc) -> GrdTree (PmGrd vt v loc) l -> m (Set (NormalizedConstraints vt v loc), GrdTree (Set (NormalizedConstraints vt v loc)) (Set (NormalizedConstraints vt v loc), l))

-- | Collect accessible, inaccessible, and redundant GRHSs
classify :: forall vt v loc l. GrdTree (Set (NormalizedConstraints vt v loc)) (Set (NormalizedConstraints vt v loc), l) -> ([l], [l], [l])

-- | Given a variable and a term in DNF, expand it to an identical DNF
--   expression with enough positive info to print pattern suggestions.
expandSolution :: forall vt v loc m. Pmc vt v loc m => v -> NormalizedConstraints vt v loc -> m (Set (NormalizedConstraints vt v loc))

-- | Expand a full DNF term (i.e. each term identifies exactly one
--   solution) into an inhabiting pattern.
generateInhabitants :: forall vt v loc. Var v => v -> NormalizedConstraints vt v loc -> Pattern ()
instance GHC.Num.Num Unison.PatternMatchCoverage.Solve.Fuel
instance GHC.Enum.Bounded Unison.PatternMatchCoverage.Solve.Fuel
instance GHC.Enum.Enum Unison.PatternMatchCoverage.Solve.Fuel
instance GHC.Classes.Ord Unison.PatternMatchCoverage.Solve.Fuel
instance GHC.Classes.Eq Unison.PatternMatchCoverage.Solve.Fuel
instance GHC.Show.Show Unison.PatternMatchCoverage.Solve.Fuel
instance Control.Monad.Trans.Class.MonadTrans (Unison.PatternMatchCoverage.Solve.C vt v loc)
instance GHC.Base.Monad m => Control.Monad.State.Class.MonadState (Unison.PatternMatchCoverage.NormalizedConstraints.NormalizedConstraints vt v loc) (Unison.PatternMatchCoverage.Solve.C vt v loc m)
instance GHC.Base.Monad m => GHC.Base.Monad (Unison.PatternMatchCoverage.Solve.C vt v loc m)
instance GHC.Base.Monad m => GHC.Base.Applicative (Unison.PatternMatchCoverage.Solve.C vt v loc m)
instance GHC.Base.Functor m => GHC.Base.Functor (Unison.PatternMatchCoverage.Solve.C vt v loc m)


-- | Pattern match coverage checking is implemented following the algorithm
--   described in <a>Lower Your Guards</a>. The goal of pattern match
--   coverage checking is to identify the following problems that may arise
--   in a pattern match:
--   
--   <ul>
--   <li>It is missing clauses (<i>i.e.</i> it is non-exhaustive)</li>
--   <li>It contains redundant patterns (<i>i.e.</i> the case can be
--   deleted without altering the program)</li>
--   <li>It contains inaccessible patterns (<i>i.e</i> the rhs can never be
--   entered)</li>
--   </ul>
--   
--   Furthermore, in the case of a non-exhaustive match, the goal to
--   present the user with concrete values that do not match any of the
--   existing patterns.
--   
--   <i>N.B.</i> An inaccessible pattern in unison would be one that
--   performs effects in a guard although the constraints are
--   unsatisfiable. Such a pattern cannot be deleted without altering the
--   program.
--   
--   <h2>High-level algorithm overview</h2>
--   
--   <ol>
--   <li><a>Desugar</a> a match expression into a <a>GrdTree</a>.</li>
--   <li>Annotate the <tt>GrdTree</tt> leaves with <a>refinement types</a>
--   describing values that match this branch. Redundant and inaccessible
--   patterns are then identified by <tt>GrdTree</tt> leaves with
--   uninhabited refinement types. Inaccessible patterns are distinguished
--   by an effect being performed between the <tt>GrdTree</tt> root and the
--   leaf.</li>
--   <li>Traverse the <tt>GrdTree</tt> building up a refinement type
--   describing uncovered values. If the resulting refinement type is
--   inhabited then the match is missing clauses.</li>
--   <li>Find inhabitants of the uncovered refinement type to present to
--   the user.</li>
--   </ol>
--   
--   Step (1) is implemented by <a>desugarMatch</a>. Steps (2) and (3) are
--   implemented as a single traversal:
--   <a>uncoverAnnotate</a>/<a>classify</a>. Step (4) is implemented by
--   <a>expandSolution</a>/<a>generateInhabitants</a>.
module Unison.PatternMatchCoverage

-- | Perform pattern match coverage checking on a match expression
checkMatch :: forall vt v loc m. Pmc vt v loc m => Type vt loc -> [MatchCase loc (Term' vt v loc)] -> m ([loc], [loc], [Pattern ()])


-- | Handles generating kind constraints to be fed to the kind constraint
--   solver (found in <a>Unison.KindInference.Solve</a>).
module Unison.KindInference.Generate

-- | Generate kind constraints arising from a given type. The given
--   <tt>UVar</tt> is constrained to have the kind of the given type.
typeConstraints :: (Var v, Ord loc) => UVar v loc -> Type v loc -> Gen v loc [GeneratedConstraint v loc]

-- | Check that all annotations in a term are well-kinded
termConstraints :: forall v loc. (Var v, Ord loc) => Term v loc -> Gen v loc [GeneratedConstraint v loc]

-- | Generate kind constraints for a mutally recursive component of decls
declComponentConstraints :: forall v loc. (Var v, Ord loc) => [(Reference, Decl v loc)] -> Gen v loc [GeneratedConstraint v loc]

-- | Constraints on language builtins, used to initialize the kind
--   inference state (<a>initialState</a>)
builtinConstraints :: forall v loc. (Ord loc, BuiltinAnnotation loc, Var v) => Gen v loc [GeneratedConstraint v loc]


-- | Handles solving kind constraints generated by
--   <a>Unison.KindInference.Generate</a>.
module Unison.KindInference.Solve

-- | This is the primary function in the exposed API. <tt>step</tt> applies
--   some generated constraints to a solve state, returning a kind error if
--   detected or a new solve state.
step :: (Var v, Ord loc, Show loc) => Env -> SolveState v loc -> [GeneratedConstraint v loc] -> Either (NonEmpty (KindError v loc)) (SolveState v loc)

-- | Do an occurence check and return an error or the resulting solve state
verify :: Var v => SolveState v loc -> Either (NonEmpty (KindError v loc)) (SolveState v loc)
initialState :: forall v loc. (BuiltinAnnotation loc, Show loc, Ord loc, Var v) => Env -> SolveState v loc

-- | Default any unconstrained vars to <tt>Type</tt>
defaultUnconstrainedVars :: Var v => SolveState v loc -> SolveState v loc

-- | Errors that may arise during kind inference
data KindError v loc

-- | A variable is constrained to have an infinite kind
CycleDetected :: loc -> UVar v loc -> ConstraintMap v loc -> KindError v loc

-- | Something of kind * or Effect is applied to an argument
UnexpectedArgument :: loc -> UVar v loc -> UVar v loc -> ConstraintMap v loc -> KindError v loc
ArgumentMismatch :: UVar v loc -> UVar v loc -> UVar v loc -> ConstraintMap v loc -> KindError v loc
ArgumentMismatchArrow :: (loc, Type v loc, Type v loc) -> ConstraintConflict v loc -> ConstraintMap v loc -> KindError v loc

-- | Something appeared in an effect list that isn't of kind Effect
EffectListMismatch :: ConstraintConflict v loc -> ConstraintMap v loc -> KindError v loc

-- | Generic constraint conflict
ConstraintConflict :: GeneratedConstraint v loc -> ConstraintConflict v loc -> ConstraintMap v loc -> KindError v loc

-- | Two incompatible constraints on a <tt>UVar</tt>.
data ConstraintConflict v loc
ConstraintConflict' :: UVar v loc -> Constraint (UVar v loc) v loc -> Constraint (UVar v loc) v loc -> ConstraintConflict v loc
[$sel:conflictedVar:ConstraintConflict'] :: ConstraintConflict v loc -> UVar v loc
[$sel:impliedConstraint:ConstraintConflict'] :: ConstraintConflict v loc -> Constraint (UVar v loc) v loc
[$sel:conflictedConstraint:ConstraintConflict'] :: ConstraintConflict v loc -> Constraint (UVar v loc) v loc


-- | Kind inference for Unison
--   
--   Unison has Type, -&gt;, and Ability kinds
--   
--   An algorithm sketch: First break all decls into strongly connected
--   components in reverse topological order. Then, for each component,
--   generate kind constraints that arise from the constructors in the decl
--   to discover constraints on the decl vars. These constraints are then
--   given to a constraint solver that determines a unique kind for each
--   type variable. Unconstrained variables are defaulted to kind Type
--   (just like Haskell 98). This is done by <a>inferDecls</a>.
--   
--   Afterwards, the <a>SolveState</a> holds the kinds of all decls and we
--   can check that type annotations in terms that may mention the decls
--   are well-kinded with <a>kindCheckAnnotations</a>.
module Unison.KindInference

-- | Infer the kinds of all decl vars
inferDecls :: forall v loc. (Var v, BuiltinAnnotation loc, Ord loc, Show loc) => PrettyPrintEnv -> Map Reference (Decl v loc) -> Either (NonEmpty (KindError v loc)) (SolveState v loc)

-- | Check that all annotations in a term are well-kinded
kindCheckAnnotations :: forall v loc. (Var v, Ord loc, Show loc, BuiltinAnnotation loc) => PrettyPrintEnv -> SolveState v loc -> Term v loc -> Either (NonEmpty (KindError v loc)) ()

-- | Errors that may arise during kind inference
data KindError v loc

module Unison.Typechecker.Context

-- | public interface to the typechecker
synthesizeClosed :: (BuiltinAnnotation loc, Var v, Ord loc, Show loc) => PrettyPrintEnv -> PatternMatchCoverageCheckAndKindInferenceSwitch -> [Type v loc] -> TypeLookup v loc -> Term v loc -> Result v loc (Type v loc)
data ErrorNote v loc
ErrorNote :: Cause v loc -> Seq (PathElement v loc) -> ErrorNote v loc
[$sel:cause:ErrorNote] :: ErrorNote v loc -> Cause v loc
[$sel:path:ErrorNote] :: ErrorNote v loc -> Seq (PathElement v loc)
data CompilerBug v loc
UnknownDecl :: Unknown -> Reference -> Map Reference (DataDeclaration v loc) -> CompilerBug v loc
UnknownConstructor :: Unknown -> ConstructorReference -> DataDeclaration v loc -> CompilerBug v loc
UndeclaredTermVariable :: v -> Context v loc -> CompilerBug v loc
RetractFailure :: Element v loc -> Context v loc -> CompilerBug v loc
EmptyLetRec :: Term v loc -> CompilerBug v loc
PatternMatchFailure :: CompilerBug v loc
EffectConstructorHadMultipleEffects :: Type v loc -> CompilerBug v loc
FreeVarsInTypeAnnotation :: Set (TypeVar v loc) -> CompilerBug v loc
UnannotatedReference :: Reference -> CompilerBug v loc
MalformedPattern :: Pattern loc -> CompilerBug v loc
UnknownTermReference :: Reference -> CompilerBug v loc
UnknownExistentialVariable :: v -> Context v loc -> CompilerBug v loc
IllegalContextExtension :: Context v loc -> Element v loc -> String -> CompilerBug v loc
OtherBug :: String -> CompilerBug v loc
data InfoNote v loc
SolvedBlank :: Recorded loc -> v -> Type v loc -> InfoNote v loc
Decision :: v -> loc -> Term v loc -> InfoNote v loc
TopLevelComponent :: [(v, Type v loc, RedundantTypeAnnotation)] -> InfoNote v loc
data Cause v loc
TypeMismatch :: Context v loc -> Cause v loc
IllFormedType :: Context v loc -> Cause v loc
UnknownSymbol :: loc -> v -> Cause v loc
UnknownTerm :: loc -> v -> [Suggestion v loc] -> Type v loc -> Cause v loc
AbilityCheckFailure :: [Type v loc] -> [Type v loc] -> Context v loc -> Cause v loc
AbilityEqFailure :: [Type v loc] -> [Type v loc] -> Context v loc -> Cause v loc
EffectConstructorWrongArgCount :: ExpectedArgCount -> ActualArgCount -> ConstructorReference -> Cause v loc
MalformedEffectBind :: Type v loc -> Type v loc -> [Type v loc] -> Cause v loc
PatternArityMismatch :: loc -> Type v loc -> Int -> Cause v loc
DuplicateDefinitions :: NonEmpty (v, [loc]) -> Cause v loc
UnguardedLetRecCycle :: [v] -> [(v, Term v loc)] -> Cause v loc
ConcatPatternWithoutConstantLength :: loc -> Type v loc -> Cause v loc
HandlerOfUnexpectedType :: loc -> Type v loc -> Cause v loc
DataEffectMismatch :: Unknown -> Reference -> DataDeclaration v loc -> Cause v loc
UncoveredPatterns :: loc -> NonEmpty (Pattern ()) -> Cause v loc
RedundantPattern :: loc -> Cause v loc
KindInferenceFailure :: KindError v loc -> Cause v loc
InaccessiblePattern :: loc -> Cause v loc
newtype Context v loc
Context :: [(Element v loc, Info v loc)] -> Context v loc
type ActualArgCount = Int
type ExpectedArgCount = Int
type ConstructorId = Word64

-- | Elements of an ordered algorithmic context
data Element v loc

-- | A variable declaration
Var :: TypeVar v loc -> Element v loc

-- | <tt>v</tt> is solved to some monotype
Solved :: Blank loc -> v -> Monotype v loc -> Element v loc

-- | <tt>v</tt> has type <tt>a</tt>, maybe quantified
Ann :: v -> Type v loc -> Element v loc

-- | used for scoping
Marker :: v -> Element v loc
data PathElement v loc
InSynthesize :: Term v loc -> PathElement v loc
InSubtype :: Type v loc -> Type v loc -> PathElement v loc
InEquate :: Type v loc -> Type v loc -> PathElement v loc
InCheck :: Term v loc -> Type v loc -> PathElement v loc
InInstantiateL :: v -> Type v loc -> PathElement v loc
InInstantiateR :: Type v loc -> v -> PathElement v loc
InSynthesizeApp :: Type v loc -> Term v loc -> Int -> PathElement v loc
InFunctionCall :: [v] -> Term v loc -> Type v loc -> [Term v loc] -> PathElement v loc
InAndApp :: PathElement v loc
InOrApp :: PathElement v loc
InIfCond :: PathElement v loc
InIfBody :: loc -> PathElement v loc
InVectorApp :: loc -> PathElement v loc
InMatch :: loc -> PathElement v loc
InMatchGuard :: PathElement v loc
InMatchBody :: PathElement v loc
type Term v loc = Term' (TypeVar v loc) v loc
type Type v loc = Type (TypeVar v loc) loc
type TypeVar v loc = TypeVar (Blank loc) v
data Result v loc a
Success :: !Seq (InfoNote v loc) -> !a -> Result v loc a
TypeError :: !NESeq (ErrorNote v loc) -> !Seq (InfoNote v loc) -> Result v loc a
CompilerBug :: !CompilerBug v loc -> !Seq (ErrorNote v loc) -> !Seq (InfoNote v loc) -> Result v loc a
data PatternMatchCoverageCheckAndKindInferenceSwitch
PatternMatchCoverageCheckAndKindInferenceSwitch'Enabled :: PatternMatchCoverageCheckAndKindInferenceSwitch
PatternMatchCoverageCheckAndKindInferenceSwitch'Disabled :: PatternMatchCoverageCheckAndKindInferenceSwitch
errorTerms :: ErrorNote v loc -> [Term v loc]
innermostErrorTerm :: ErrorNote v loc -> Maybe (Term v loc)
lookupAnn :: Ord v => Context v loc -> v -> Maybe (Type v loc)
lookupSolved :: Ord v => Context v loc -> v -> Maybe (Monotype v loc)

-- | Replace any existentials with their solution in the context
apply :: (Var v, Ord loc) => Context v loc -> Type v loc -> Type v loc
isEqual :: (Var v, Ord loc) => Type v loc -> Type v loc -> Either (CompilerBug v loc) Bool
isSubtype :: (Var v, Ord loc) => Type v loc -> Type v loc -> Either (CompilerBug v loc) Bool
fitsScheme :: (Var v, Ord loc) => Type v loc -> Type v loc -> Either (CompilerBug v loc) Bool
isRedundant :: (Var v, Ord loc) => Type v loc -> Type v loc -> M v loc Bool
data Suggestion v loc
Suggestion :: Name -> Type v loc -> Replacement v -> SuggestionMatch -> Suggestion v loc
[$sel:suggestionName:Suggestion] :: Suggestion v loc -> Name
[$sel:suggestionType:Suggestion] :: Suggestion v loc -> Type v loc
[$sel:suggestionReplacement:Suggestion] :: Suggestion v loc -> Replacement v
[$sel:suggestionMatch:Suggestion] :: Suggestion v loc -> SuggestionMatch
data Replacement v
ReplacementRef :: Referent -> Replacement v
ReplacementVar :: v -> Replacement v
data SuggestionMatch
Exact :: SuggestionMatch
WrongType :: SuggestionMatch
WrongName :: SuggestionMatch
isExact :: Suggestion v loc -> Bool
typeErrors :: Result v loc a -> Seq (ErrorNote v loc)
infoNotes :: Result v loc a -> Seq (InfoNote v loc)
data Unknown
Data :: Unknown
Effect :: Unknown
relax :: Var v => Ord loc => Type v loc -> Type v loc
generalizeAndUnTypeVar :: Var v => Type v a -> Type v a
instance GHC.Show.Show Unison.Typechecker.Context.Unknown
instance (GHC.Show.Show v, GHC.Show.Show loc) => GHC.Show.Show (Unison.Typechecker.Context.PathElement v loc)
instance GHC.Show.Show Unison.Typechecker.Context.SuggestionMatch
instance GHC.Classes.Eq Unison.Typechecker.Context.SuggestionMatch
instance GHC.Classes.Ord Unison.Typechecker.Context.SuggestionMatch
instance GHC.Show.Show v => GHC.Show.Show (Unison.Typechecker.Context.Replacement v)
instance GHC.Classes.Ord v => GHC.Classes.Ord (Unison.Typechecker.Context.Replacement v)
instance GHC.Classes.Eq v => GHC.Classes.Eq (Unison.Typechecker.Context.Replacement v)
instance GHC.Show.Show v => GHC.Show.Show (Unison.Typechecker.Context.Suggestion v loc)
instance U.Core.ABT.Var.Var v => GHC.Classes.Eq (Unison.Typechecker.Context.Suggestion v loc)
instance (GHC.Show.Show loc, GHC.Show.Show v) => GHC.Show.Show (Unison.Typechecker.Context.InfoNote v loc)
instance (Unison.Var.Var v, GHC.Show.Show loc, GHC.Classes.Ord loc) => GHC.Show.Show (Unison.Typechecker.Context.Cause v loc)
instance (Unison.Var.Var v, GHC.Show.Show loc, GHC.Classes.Ord loc) => GHC.Show.Show (Unison.Typechecker.Context.ErrorNote v loc)
instance (Unison.Var.Var v, GHC.Show.Show loc, GHC.Classes.Ord loc) => GHC.Show.Show (Unison.Typechecker.Context.CompilerBug v loc)
instance GHC.Base.Functor (Unison.Typechecker.Context.Result v loc)
instance GHC.Base.Functor f => GHC.Base.Functor (Unison.Typechecker.Context.MT v loc f)
instance (GHC.Classes.Ord loc, Unison.Var.Var v) => Unison.PatternMatchCoverage.Class.Pmc (Unison.Typechecker.Context.TypeVar v loc) v loc (Control.Monad.Trans.State.Lazy.StateT (Unison.Typechecker.Context.PmcState (Unison.Typechecker.Context.TypeVar v loc) v loc) (Unison.Typechecker.Context.M v loc))
instance GHC.Base.Monad f => GHC.Base.Monad (Unison.Typechecker.Context.MT v loc f)
instance GHC.Base.Monad f => Control.Monad.Fail.MonadFail (Unison.Typechecker.Context.MT v loc f)
instance GHC.Base.Monad f => GHC.Base.Applicative (Unison.Typechecker.Context.MT v loc f)
instance GHC.Base.Monad f => Control.Monad.State.Class.MonadState (Unison.Typechecker.Context.Env v loc) (Unison.Typechecker.Context.MT v loc f)
instance Control.Monad.Fix.MonadFix f => Control.Monad.Fix.MonadFix (Unison.Typechecker.Context.MT v loc f)
instance GHC.Base.Applicative (Unison.Typechecker.Context.Result v loc)
instance GHC.Base.Monad (Unison.Typechecker.Context.Result v loc)
instance Control.Monad.Fix.MonadFix (Unison.Typechecker.Context.Result v loc)
instance (GHC.Classes.Ord loc, Unison.Var.Var v) => GHC.Show.Show (Unison.Typechecker.Context.Context v loc)
instance (GHC.Classes.Ord loc, Unison.Var.Var v) => GHC.Classes.Eq (Unison.Typechecker.Context.Element v loc)
instance Unison.Var.Var v => GHC.Show.Show (Unison.Typechecker.Context.Element v loc)

module Unison.Typechecker.Extractor
type RedundantTypeAnnotation = Bool
type Extractor e a = MaybeT (Reader e) a
type ErrorExtractor v loc a = Extractor (ErrorNote v loc) a
type InfoExtractor v loc a = Extractor (InfoNote v loc) a
type PathExtractor v loc a = Extractor (PathElement v loc) a
type SubseqExtractor v loc a = SubseqExtractor' (ErrorNote v loc) a
extractor :: (e -> Maybe a) -> Extractor e a
extract :: Extractor e a -> e -> Maybe a
subseqExtractor :: (ErrorNote v loc -> [Ranged a]) -> SubseqExtractor v loc a
traceSubseq :: Show a => String -> SubseqExtractor' n a -> SubseqExtractor' n a
traceNote :: Show a => String -> ErrorExtractor v loc a -> ErrorExtractor v loc a
unique :: SubseqExtractor v loc a -> ErrorExtractor v loc a
data SubseqExtractor' n a
SubseqExtractor' :: (n -> [Ranged a]) -> SubseqExtractor' n a
[$sel:runSubseq:SubseqExtractor'] :: SubseqExtractor' n a -> n -> [Ranged a]
data Ranged a
Pure :: a -> Ranged a
Ranged :: a -> Int -> Int -> Ranged a
[$sel:get:Pure] :: Ranged a -> a
[$sel:start:Pure] :: Ranged a -> Int
[$sel:end:Pure] :: Ranged a -> Int

-- | collects the regions where <tt>xa</tt> doesn't match / aka invert a
--   set of intervals unused, but don't want to delete it yet - Aug 30,
--   2018
_no :: SubseqExtractor' n a -> SubseqExtractor' n ()
_any :: SubseqExtractor v loc ()
_any' :: (n -> Int) -> SubseqExtractor' n ()
data DistinctRanged a
DistinctRanged :: a -> Int -> Int -> DistinctRanged a
some :: forall n a. SubseqExtractor' n a -> SubseqExtractor' n [a]
pathStart :: SubseqExtractor' n ()
asPathExtractor :: (PathElement v loc -> Maybe a) -> SubseqExtractor v loc a
inSynthesize :: SubseqExtractor v loc (Term v loc)
inSubtype :: SubseqExtractor v loc (Type v loc, Type v loc)
inEquate :: SubseqExtractor v loc (Type v loc, Type v loc)
inCheck :: SubseqExtractor v loc (Term v loc, Type v loc)
inSynthesizeApp :: SubseqExtractor v loc (Type v loc, Term v loc, Int)
inFunctionCall :: SubseqExtractor v loc ([v], Term v loc, Type v loc, [Term v loc])
inAndApp :: SubseqExtractor v loc ()
inOrApp :: SubseqExtractor v loc ()
inIfCond :: SubseqExtractor v loc ()
inMatchGuard :: SubseqExtractor v loc ()
inMatchBody :: SubseqExtractor v loc ()
inMatch :: SubseqExtractor v loc loc
inVector :: SubseqExtractor v loc loc
inIfBody :: SubseqExtractor v loc loc
cause :: ErrorExtractor v loc (Cause v loc)
duplicateDefinitions :: ErrorExtractor v loc (NonEmpty (v, [loc]))
uncoveredPatterns :: ErrorExtractor v loc (loc, NonEmpty (Pattern ()))
redundantPattern :: ErrorExtractor v loc loc
kindInferenceFailure :: ErrorExtractor v loc (KindError v loc)
typeMismatch :: ErrorExtractor v loc (Context v loc)
illFormedType :: ErrorExtractor v loc (Context v loc)
unknownSymbol :: ErrorExtractor v loc (loc, v)
unknownTerm :: Var v => ErrorExtractor v loc (loc, v, [Suggestion v loc], Type v loc)
abilityCheckFailure :: ErrorExtractor v loc ([Type v loc], [Type v loc], Context v loc)
abilityEqFailure :: ErrorExtractor v loc ([Type v loc], [Type v loc], Context v loc)
effectConstructorWrongArgCount :: ErrorExtractor v loc (ExpectedArgCount, ActualArgCount, ConstructorReference)
malformedEffectBind :: ErrorExtractor v loc (Type v loc, Type v loc, [Type v loc])
solvedBlank :: InfoExtractor v loc (Recorded loc, v, Type v loc)
errorNote :: ErrorExtractor v loc (ErrorNote v loc)
infoNote :: InfoExtractor v loc (InfoNote v loc)
innermostTerm :: ErrorExtractor v loc (Term v loc)
path :: ErrorExtractor v loc [PathElement v loc]
topLevelComponent :: InfoExtractor v loc [(v, Type v loc, RedundantTypeAnnotation)]
instance GHC.Show.Show a => GHC.Show.Show (Unison.Typechecker.Extractor.Ranged a)
instance GHC.Base.Functor Unison.Typechecker.Extractor.Ranged
instance GHC.Classes.Eq (Unison.Typechecker.Extractor.DistinctRanged a)
instance GHC.Classes.Ord (Unison.Typechecker.Extractor.DistinctRanged a)
instance GHC.Base.Functor (Unison.Typechecker.Extractor.SubseqExtractor' n)
instance GHC.Base.Applicative (Unison.Typechecker.Extractor.SubseqExtractor' n)
instance Control.Monad.Fail.MonadFail (Unison.Typechecker.Extractor.SubseqExtractor' n)
instance GHC.Base.Monad (Unison.Typechecker.Extractor.SubseqExtractor' n)
instance GHC.Base.Alternative (Unison.Typechecker.Extractor.SubseqExtractor' n)
instance GHC.Base.MonadPlus (Unison.Typechecker.Extractor.SubseqExtractor' n)
instance GHC.Base.Monoid (Unison.Typechecker.Extractor.SubseqExtractor' n a)
instance GHC.Base.Semigroup (Unison.Typechecker.Extractor.SubseqExtractor' n a)

module Unison.Typechecker.TypeError
data BooleanMismatch
CondMismatch :: BooleanMismatch
AndMismatch :: BooleanMismatch
OrMismatch :: BooleanMismatch
GuardMismatch :: BooleanMismatch
data ExistentialMismatch
IfBody :: ExistentialMismatch
ListBody :: ExistentialMismatch
CaseBody :: ExistentialMismatch
data TypeError v loc
Mismatch :: Type v loc -> Type v loc -> Type v loc -> Type v loc -> Term v loc -> ErrorNote v loc -> TypeError v loc
[$sel:foundType:Mismatch] :: TypeError v loc -> Type v loc
[$sel:expectedType:Mismatch] :: TypeError v loc -> Type v loc
[$sel:foundLeaf:Mismatch] :: TypeError v loc -> Type v loc
[$sel:expectedLeaf:Mismatch] :: TypeError v loc -> Type v loc
[$sel:mismatchSite:Mismatch] :: TypeError v loc -> Term v loc
[$sel:note:Mismatch] :: TypeError v loc -> ErrorNote v loc
BooleanMismatch :: BooleanMismatch -> Term v loc -> Type v loc -> ErrorNote v loc -> TypeError v loc
[$sel:getBooleanMismatch:Mismatch] :: TypeError v loc -> BooleanMismatch
[$sel:mismatchSite:Mismatch] :: TypeError v loc -> Term v loc
[$sel:foundType:Mismatch] :: TypeError v loc -> Type v loc
[$sel:note:Mismatch] :: TypeError v loc -> ErrorNote v loc
ExistentialMismatch :: ExistentialMismatch -> Type v loc -> loc -> Type v loc -> Term v loc -> ErrorNote v loc -> TypeError v loc
[$sel:getExistentialMismatch:Mismatch] :: TypeError v loc -> ExistentialMismatch
[$sel:expectedType:Mismatch] :: TypeError v loc -> Type v loc
[$sel:expectedLoc:Mismatch] :: TypeError v loc -> loc
[$sel:foundType:Mismatch] :: TypeError v loc -> Type v loc
[$sel:mismatchSite:Mismatch] :: TypeError v loc -> Term v loc
[$sel:note:Mismatch] :: TypeError v loc -> ErrorNote v loc
FunctionApplication :: Term v loc -> Type v loc -> Term v loc -> Int -> Type v loc -> Type v loc -> Maybe (Type v loc, Type v loc) -> [(v, Type v loc)] -> ErrorNote v loc -> TypeError v loc
[$sel:f:Mismatch] :: TypeError v loc -> Term v loc
[$sel:ft:Mismatch] :: TypeError v loc -> Type v loc
[$sel:arg:Mismatch] :: TypeError v loc -> Term v loc
[$sel:argNum:Mismatch] :: TypeError v loc -> Int
[$sel:foundType:Mismatch] :: TypeError v loc -> Type v loc
[$sel:expectedType:Mismatch] :: TypeError v loc -> Type v loc
[$sel:leafs:Mismatch] :: TypeError v loc -> Maybe (Type v loc, Type v loc)
[$sel:solvedVars:Mismatch] :: TypeError v loc -> [(v, Type v loc)]
[$sel:note:Mismatch] :: TypeError v loc -> ErrorNote v loc
NotFunctionApplication :: Term v loc -> Type v loc -> ErrorNote v loc -> TypeError v loc
[$sel:f:Mismatch] :: TypeError v loc -> Term v loc
[$sel:ft:Mismatch] :: TypeError v loc -> Type v loc
[$sel:note:Mismatch] :: TypeError v loc -> ErrorNote v loc
AbilityCheckFailure :: [Type v loc] -> [Type v loc] -> loc -> ErrorNote v loc -> TypeError v loc
[$sel:ambient:Mismatch] :: TypeError v loc -> [Type v loc]
[$sel:requested:Mismatch] :: TypeError v loc -> [Type v loc]
[$sel:abilityCheckFailureSite:Mismatch] :: TypeError v loc -> loc
[$sel:note:Mismatch] :: TypeError v loc -> ErrorNote v loc
AbilityEqFailure :: [Type v loc] -> [Type v loc] -> Type v loc -> Type v loc -> loc -> ErrorNote v loc -> TypeError v loc
[$sel:lhs:Mismatch] :: TypeError v loc -> [Type v loc]
[$sel:rhs:Mismatch] :: TypeError v loc -> [Type v loc]
[$sel:tlhs:Mismatch] :: TypeError v loc -> Type v loc
[$sel:trhs:Mismatch] :: TypeError v loc -> Type v loc
[$sel:abilityCheckFailureSite:Mismatch] :: TypeError v loc -> loc
[$sel:note:Mismatch] :: TypeError v loc -> ErrorNote v loc
AbilityEqFailureFromAp :: [Type v loc] -> [Type v loc] -> Type v loc -> Type v loc -> Term v loc -> Term v loc -> ErrorNote v loc -> TypeError v loc
[$sel:lhs:Mismatch] :: TypeError v loc -> [Type v loc]
[$sel:rhs:Mismatch] :: TypeError v loc -> [Type v loc]
[$sel:tlhs:Mismatch] :: TypeError v loc -> Type v loc
[$sel:trhs:Mismatch] :: TypeError v loc -> Type v loc
[$sel:expectedSite:Mismatch] :: TypeError v loc -> Term v loc
[$sel:mismatchSite:Mismatch] :: TypeError v loc -> Term v loc
[$sel:note:Mismatch] :: TypeError v loc -> ErrorNote v loc
UnguardedLetRecCycle :: [v] -> [loc] -> ErrorNote v loc -> TypeError v loc
[$sel:cycle:Mismatch] :: TypeError v loc -> [v]
[$sel:cycleLocs:Mismatch] :: TypeError v loc -> [loc]
[$sel:note:Mismatch] :: TypeError v loc -> ErrorNote v loc
UnknownType :: v -> loc -> ErrorNote v loc -> TypeError v loc
[$sel:unknownTypeV:Mismatch] :: TypeError v loc -> v
[$sel:typeSite:Mismatch] :: TypeError v loc -> loc
[$sel:note:Mismatch] :: TypeError v loc -> ErrorNote v loc
UnknownTerm :: v -> loc -> [Suggestion v loc] -> Type v loc -> ErrorNote v loc -> TypeError v loc
[$sel:unknownTermV:Mismatch] :: TypeError v loc -> v
[$sel:termSite:Mismatch] :: TypeError v loc -> loc
[$sel:suggestions:Mismatch] :: TypeError v loc -> [Suggestion v loc]
[$sel:expectedType:Mismatch] :: TypeError v loc -> Type v loc
[$sel:note:Mismatch] :: TypeError v loc -> ErrorNote v loc
DuplicateDefinitions :: NonEmpty (v, [loc]) -> ErrorNote v loc -> TypeError v loc
[$sel:defns:Mismatch] :: TypeError v loc -> NonEmpty (v, [loc])
[$sel:note:Mismatch] :: TypeError v loc -> ErrorNote v loc
UncoveredPatterns :: loc -> NonEmpty (Pattern ()) -> TypeError v loc
RedundantPattern :: loc -> TypeError v loc
KindInferenceFailure :: KindError v loc -> TypeError v loc
Other :: ErrorNote v loc -> TypeError v loc
type RedundantTypeAnnotation = Bool
data TypeInfo v loc
TopLevelComponent :: [(v, Type v loc, RedundantTypeAnnotation)] -> TypeInfo v loc
[$sel:definitions:TopLevelComponent] :: TypeInfo v loc -> [(v, Type v loc, RedundantTypeAnnotation)]
type TypeNote v loc = Either (TypeError v loc) (TypeInfo v loc)
typeErrorFromNote :: (Ord loc, Show loc, Var v) => ErrorNote v loc -> TypeError v loc
typeInfoFromNote :: (Ord loc, Show loc, Var v) => InfoNote v loc -> Maybe (TypeInfo v loc)
allErrors :: (Var v, Ord loc) => ErrorExtractor v loc (TypeError v loc)
topLevelComponent :: InfoExtractor v a (TypeInfo v a)
redundantPattern :: ErrorExtractor v a (TypeError v a)
kindInferenceFailure :: ErrorExtractor v a (TypeError v a)
uncoveredPatterns :: ErrorExtractor v a (TypeError v a)
abilityCheckFailure :: ErrorExtractor v a (TypeError v a)
abilityEqFailure :: ErrorExtractor v a (TypeError v a)
duplicateDefinitions :: ErrorExtractor v a (TypeError v a)
unknownType :: ErrorExtractor v loc (TypeError v loc)
unknownTerm :: Var v => ErrorExtractor v loc (TypeError v loc)
generalMismatch :: (Var v, Ord loc) => ErrorExtractor v loc (TypeError v loc)
and :: (Var v, Ord loc) => ErrorExtractor v loc (TypeError v loc)
or :: (Var v, Ord loc) => ErrorExtractor v loc (TypeError v loc)
cond :: (Var v, Ord loc) => ErrorExtractor v loc (TypeError v loc)
matchGuard :: (Var v, Ord loc) => ErrorExtractor v loc (TypeError v loc)
unguardedCycle :: ErrorExtractor v loc (TypeError v loc)

-- | helper function to support <a>and</a> <i> <a>or</a> </i> <a>cond</a>
booleanMismatch0 :: (Var v, Ord loc) => BooleanMismatch -> SubseqExtractor v loc () -> ErrorExtractor v loc (TypeError v loc)
existentialMismatch0 :: (Var v, Ord loc) => ExistentialMismatch -> SubseqExtractor v loc loc -> ErrorExtractor v loc (TypeError v loc)
ifBody :: (Var v, Ord loc) => ErrorExtractor v loc (TypeError v loc)
listBody :: (Var v, Ord loc) => ErrorExtractor v loc (TypeError v loc)
matchBody :: (Var v, Ord loc) => ErrorExtractor v loc (TypeError v loc)
applyingNonFunction :: Var v => ErrorExtractor v loc (TypeError v loc)

-- | Want to collect this info: The <tt>n</tt>th argument to
--   <a>$sel:f:Mismatch</a> is <a>$sel:foundType:Mismatch</a>, but I was
--   expecting <a>$sel:expectedType:Mismatch</a>.
--   
--   30 | asdf asdf asdf
--   
--   If you're curious <a>$sel:f:Mismatch</a> has type <tt>blah</tt>, where
--   <tt>a</tt> was chosen as <tt>A</tt> <tt>b</tt> was chosen as
--   <tt>B</tt> <tt>c</tt> was chosen as <tt>C</tt> (many colors / groups)
applyingFunction :: forall v loc. Var v => ErrorExtractor v loc (TypeError v loc)
inSubtypes :: SubseqExtractor v loc (Type v loc, Type v loc, Maybe (Type v loc, Type v loc))
instance GHC.Show.Show Unison.Typechecker.TypeError.BooleanMismatch
instance GHC.Show.Show Unison.Typechecker.TypeError.ExistentialMismatch
instance (Unison.Var.Var v, GHC.Show.Show loc, GHC.Classes.Ord loc) => GHC.Show.Show (Unison.Typechecker.TypeError.TypeError v loc)
instance GHC.Show.Show v => GHC.Show.Show (Unison.Typechecker.TypeError.TypeInfo v loc)

module Unison.Result
type Result notes = ResultT notes Identity
type ResultT notes f = MaybeT (WriterT notes f)
data Note v loc
Parsing :: Err v -> Note v loc
NameResolutionFailures :: [ResolutionFailure loc] -> Note v loc
UnknownSymbol :: v -> loc -> Note v loc
TypeError :: ErrorNote v loc -> Note v loc
TypeInfo :: InfoNote v loc -> Note v loc
CompilerBug :: CompilerBug v loc -> Note v loc
data CompilerBug v loc
TopLevelComponentNotFound :: v -> Term v loc -> CompilerBug v loc
ResolvedNameNotFound :: v -> loc -> Name -> CompilerBug v loc
TypecheckerBug :: CompilerBug v loc -> CompilerBug v loc
result :: Result notes a -> Maybe a
pattern Result :: w -> Maybe a -> MaybeT (WriterT w Identity) a
makeResult :: Applicative m => notes -> Maybe a -> ResultT notes m a
isSuccess :: Functor f => ResultT note f a -> f Bool
isFailure :: Functor f => ResultT note f a -> f Bool
toMaybe :: Functor f => ResultT note f a -> f (Maybe a)
runResultT :: ResultT notes f a -> f (Maybe a, notes)
getResult :: Functor f => ResultT notes f a -> f (Result notes a)
toEither :: Functor f => ResultT notes f a -> ExceptT notes f a
tell1 :: Monad f => note -> ResultT (Seq note) f ()
fromParsing :: Monad f => Either (Err v) a -> ResultT (Seq (Note v loc)) f a
tellAndFail :: Monad f => note -> ResultT (Seq note) f a
compilerBug :: Monad f => CompilerBug v loc -> ResultT (Seq (Note v loc)) f a
hoist :: (Monad f, Monoid notes) => (forall a. f a -> g a) -> ResultT notes f b -> ResultT notes g b
instance (GHC.Show.Show loc, Unison.Var.Var v, GHC.Classes.Ord loc) => GHC.Show.Show (Unison.Result.CompilerBug v loc)
instance (GHC.Show.Show loc, Unison.Var.Var v, GHC.Classes.Ord loc) => GHC.Show.Show (Unison.Result.Note v loc)


-- | This module is the primary interface to the Unison typechecker module
--   Unison.Typechecker (admissibleTypeAt, check, check', checkAdmissible',
--   equals, locals, subtype, isSubtype, synthesize, synthesize', typeAt,
--   wellTyped) where
module Unison.Typechecker

-- | Infer the type of a <a>Term</a>, using a function to resolve the type
--   of <tt>Ref</tt> constructors contained in that term.
synthesize :: (Monad f, Var v, BuiltinAnnotation loc, Ord loc, Show loc) => PrettyPrintEnv -> PatternMatchCoverageCheckAndKindInferenceSwitch -> Env v loc -> Term v loc -> ResultT (Notes v loc) f (Type v loc)

-- | Infer the type of a <a>Term</a>, using type-directed name resolution
--   to attempt to resolve unknown symbols.
synthesizeAndResolve :: (Monad f, Var v, Monoid loc, BuiltinAnnotation loc, Ord loc, Show loc) => PrettyPrintEnv -> Env v loc -> TDNR f v loc (Type v loc)

-- | Check whether a term matches a type, using a function to resolve the
--   type of <tt>Ref</tt> constructors contained in the term. Returns
--   <tt>typ</tt> if successful, and a note about typechecking failure
--   otherwise.
check :: (Monad f, Var v, BuiltinAnnotation loc, Ord loc, Show loc) => PrettyPrintEnv -> Env v loc -> Term v loc -> Type v loc -> ResultT (Notes v loc) f (Type v loc)

-- | <tt>checkAdmissible</tt> e t` tests that `(f : t -&gt; r) e` is
--   well-typed. If <tt>t</tt> has quantifiers, these are moved outside, so
--   if `t : forall a . a`, this will check that `(f : forall a . a -&gt;
--   a) e` is well typed. checkAdmissible' :: Var v =&gt; Term v -&gt; Type
--   v -&gt; Either Note (Type v) checkAdmissible' term typ = synthesize'
--   (Term.blank() <a>ann_</a> tweak typ <a>app_</a> term) where tweak
--   (Type.ForallNamed' v body) = Type.forall() v (tweak body) tweak t =
--   Type.arrow() t t | Returns <a>True</a> if the expression is
--   well-typed, <a>False</a> otherwise
wellTyped :: (Monad f, Var v, BuiltinAnnotation loc, Ord loc, Show loc) => PrettyPrintEnv -> Env v loc -> Term v loc -> f Bool
isEqual :: Var v => Type v loc -> Type v loc -> Bool
isSubtype :: Var v => Type v loc -> Type v loc -> Bool

-- | Similar to <a>isSubtype</a> but treats <tt>t2</tt> as a scheme where
--   the outermost variables are existential rather than universal.
--   
--   For example: <tt> let lhs = Unison.Type.ref ()
--   (Unison.Builtin.Decls.unitRef) rhs = Unison.Type.forall ()
--   (Unison.Var.named "x") (Unison.Type.var () (Unison.Var.named "x")) in
--   fitsScheme </tt>Symbol lhs rhs <tt> is </tt>True@ although the lhs is
--   not a subtype of the rhs.
--   
--   <a>fitsScheme</a> is used to check that runnable types are a subtype
--   of <tt> exists x. '{IO, Exception} x </tt>
fitsScheme :: Var v => Type v loc -> Type v loc -> Bool
data Env v loc
Env :: [Type v loc] -> TypeLookup v loc -> Map Name [Either Name (NamedReference v loc)] -> Map Name (NamedReference v loc) -> Env v loc
[$sel:ambientAbilities:Env] :: Env v loc -> [Type v loc]
[$sel:typeLookup:Env] :: Env v loc -> TypeLookup v loc
[$sel:termsByShortname:Env] :: Env v loc -> Map Name [Either Name (NamedReference v loc)]
[$sel:topLevelComponents:Env] :: Env v loc -> Map Name (NamedReference v loc)
data Notes v loc
Notes :: Seq (CompilerBug v loc) -> Seq (ErrorNote v loc) -> Seq (InfoNote v loc) -> Notes v loc
[$sel:bugs:Notes] :: Notes v loc -> Seq (CompilerBug v loc)
[$sel:errors:Notes] :: Notes v loc -> Seq (ErrorNote v loc)
[$sel:infos:Notes] :: Notes v loc -> Seq (InfoNote v loc)
data Resolution v loc
Resolution :: Text -> Type v loc -> loc -> v -> [Suggestion v loc] -> Resolution v loc
[$sel:resolvedName:Resolution] :: Resolution v loc -> Text
[$sel:inferredType:Resolution] :: Resolution v loc -> Type v loc
[$sel:resolvedLoc:Resolution] :: Resolution v loc -> loc
[$sel:v:Resolution] :: Resolution v loc -> v
[$sel:suggestions:Resolution] :: Resolution v loc -> [Suggestion v loc]
type Name = Text
data NamedReference v loc
NamedReference :: Name -> Type v loc -> Replacement v -> NamedReference v loc
[$sel:fqn:NamedReference] :: NamedReference v loc -> Name
[$sel:fqnType:NamedReference] :: NamedReference v loc -> Type v loc
[$sel:replacement:NamedReference] :: NamedReference v loc -> Replacement v
data PatternMatchCoverageCheckAndKindInferenceSwitch
PatternMatchCoverageCheckAndKindInferenceSwitch'Enabled :: PatternMatchCoverageCheckAndKindInferenceSwitch
PatternMatchCoverageCheckAndKindInferenceSwitch'Disabled :: PatternMatchCoverageCheckAndKindInferenceSwitch
instance (Unison.Var.Var v, GHC.Show.Show loc, GHC.Classes.Ord loc) => GHC.Show.Show (Unison.Typechecker.Notes v loc)
instance GHC.Show.Show v => GHC.Show.Show (Unison.Typechecker.NamedReference v loc)
instance GHC.Generics.Generic (Unison.Typechecker.Env v loc)
instance GHC.Base.Semigroup (Unison.Typechecker.Notes v loc)
instance GHC.Base.Monoid (Unison.Typechecker.Notes v loc)

module Unison.Codebase.TermEdit.Typing
typing :: Var v => Type v loc -> Type v loc -> Typing

module Unison.DataDeclaration.Dependencies
declTypeDependencies :: Ord v => Decl v a -> Set Reference

-- | All references to types mentioned in the given data declaration's
--   fields/constructors Note: Does not include references to the
--   constructors or the decl itself (unless the decl is self-referential)
--   Note: Does NOT include the referents for fields and field accessors.
--   Those must be computed separately because we need access to the
--   typechecker to do so.
typeDependencies :: Ord v => DataDeclaration v a -> Set TypeReference
labeledTypeDependencies :: Ord v => DataDeclaration v a -> Set LabeledDependency
labeledDeclTypeDependencies :: Ord v => Decl v a -> Set LabeledDependency

-- | Compute the dependencies of a data declaration, including the type
--   itself and references for each of its constructors.
--   
--   NOTE: You may prefer
--   labeledDeclDependenciesIncludingSelfAndFieldAccessors in
--   Unison.DataDeclaration.Dependencies, it also includes Referents for
--   accessors of record fields.
labeledDeclDependenciesIncludingSelf :: Ord v => TypeReference -> Decl v a -> Set LabeledDependency

-- | Generate the LabeledDependencies for everything in a Decl, including
--   the Decl itself, all its constructors, all referenced types, and all
--   possible record accessors.
--   
--   Note that we can't actually tell whether the Decl was originally a
--   record or not, so we include all possible accessors, but they may or
--   may not exist in the codebase.
labeledDeclDependenciesIncludingSelfAndFieldAccessors :: Var v => TypeReference -> Decl v a -> Set LabeledDependency

-- | Generate Referents for all possible field accessors of a Decl.
--   
--   Returns <tt>Nothing</tt> if inferring/typechecking of any accessor
--   fails, which shouldn't normally happen, but does when record fields
--   are higher rank, because the higher rank types can't be inferred.
--   
--   See <a>https://github.com/unisonweb/unison/issues/498</a>
hashFieldAccessors :: forall v a. Var v => PrettyPrintEnv -> v -> [v] -> TypeReference -> DataDeclaration v a -> Maybe (Map v (TermReferenceId, Term v (), Type v ()))

module Unison.Syntax.DeclPrinter
prettyDecl :: Var v => PrettyPrintEnvDecl -> TypeReference -> HashQualified Name -> Decl v a -> Pretty SyntaxText
prettyDeclW :: Var v => PrettyPrintEnvDecl -> TypeReference -> HashQualified Name -> Decl v a -> Writer (Set AccessorName) (Pretty SyntaxText)
prettyDeclHeader :: Var v => HashQualified Name -> Either (EffectDeclaration v a) (DataDeclaration v a) -> Pretty SyntaxText
prettyDeclOrBuiltinHeader :: Var v => HashQualified Name -> DeclOrBuiltin v a -> Pretty SyntaxText
getFieldAndAccessorNames :: forall v a. Var v => PrettyPrintEnv -> TypeReference -> HashQualified Name -> DataDeclaration v a -> Maybe ([Name], [Name])
type AccessorName = Name

module Unison.Syntax.FilePrinter

-- | Render definitions destined for a Unison file.
--   
--   This first renders the types (discovering which record accessors will
--   be generated upon parsing), then renders the terms (being careful not
--   to render any record accessors, since those would cause duplicate
--   binding errors upon parsing).
renderDefnsForUnisonFile :: forall a v. (Var v, Monoid a) => DeclNameLookup -> PrettyPrintEnvDecl -> DefnsF (Map Name) (Term v a, Type v a) (TypeReferenceId, Decl v a) -> DefnsF (Map Name) (Pretty ColorText) (Pretty ColorText)

module Unison.Codebase.Editor.DisplayObject
data DisplayObject b a
BuiltinObject :: b -> DisplayObject b a
MissingObject :: ShortHash -> DisplayObject b a
UserObject :: a -> DisplayObject b a
toMaybe :: DisplayObject b a -> Maybe a
termDisplayObjectLabeledDependencies :: TermReference -> DisplayObject (Type Symbol Ann) (Term Symbol Ann) -> Set LabeledDependency
typeDisplayObjectLabeledDependencies :: TypeReference -> DisplayObject () (Decl Symbol Ann) -> Set LabeledDependency
instance Data.Traversable.Traversable (Unison.Codebase.Editor.DisplayObject.DisplayObject b)
instance Data.Foldable.Foldable (Unison.Codebase.Editor.DisplayObject.DisplayObject b)
instance GHC.Generics.Generic (Unison.Codebase.Editor.DisplayObject.DisplayObject b a)
instance GHC.Base.Functor (Unison.Codebase.Editor.DisplayObject.DisplayObject b)
instance (GHC.Show.Show b, GHC.Show.Show a) => GHC.Show.Show (Unison.Codebase.Editor.DisplayObject.DisplayObject b a)
instance (GHC.Classes.Ord b, GHC.Classes.Ord a) => GHC.Classes.Ord (Unison.Codebase.Editor.DisplayObject.DisplayObject b a)
instance (GHC.Classes.Eq b, GHC.Classes.Eq a) => GHC.Classes.Eq (Unison.Codebase.Editor.DisplayObject.DisplayObject b a)
instance Data.Bifunctor.Bifunctor Unison.Codebase.Editor.DisplayObject.DisplayObject
instance Data.Bitraversable.Bitraversable Unison.Codebase.Editor.DisplayObject.DisplayObject
instance Data.Bifoldable.Bifoldable Unison.Codebase.Editor.DisplayObject.DisplayObject

module Unison.Codebase.Runtime
type Error = Pretty ColorText
type Term v = Term v ()
data CompileOpts
COpts :: Bool -> CompileOpts
[$sel:profile:COpts] :: CompileOpts -> Bool
defaultCompileOpts :: CompileOpts
data Runtime v
Runtime :: IO () -> (CodeLookup v IO () -> PrettyPrintEnv -> Term v -> IO (Either Error ([Error], Term v))) -> (CompileOpts -> CodeLookup v IO () -> PrettyPrintEnv -> Reference -> FilePath -> IO (Maybe Error)) -> Type v Ann -> NESet (Type v Ann) -> Runtime v
[$sel:terminate:Runtime] :: Runtime v -> IO ()
[$sel:evaluate:Runtime] :: Runtime v -> CodeLookup v IO () -> PrettyPrintEnv -> Term v -> IO (Either Error ([Error], Term v))
[$sel:compileTo:Runtime] :: Runtime v -> CompileOpts -> CodeLookup v IO () -> PrettyPrintEnv -> Reference -> FilePath -> IO (Maybe Error)
[$sel:mainType:Runtime] :: Runtime v -> Type v Ann
[$sel:ioTestTypes:Runtime] :: Runtime v -> NESet (Type v Ann)
type IsCacheHit = Bool
noCache :: Id -> IO (Maybe (Term v))
type WatchResults v a = (Either Error ([(v, Term v)], [Error], Map v (a, WatchKind, Id, Term v, Term v, IsCacheHit)))
evaluateWatches :: forall v a. Var v => CodeLookup v IO a -> PrettyPrintEnv -> (Id -> IO (Maybe (Term v))) -> Runtime v -> TypecheckedUnisonFile v a -> IO (WatchResults v a)
evaluateTerm' :: (Var v, Monoid a) => CodeLookup v IO a -> (Id -> IO (Maybe (Term v))) -> PrettyPrintEnv -> Runtime v -> Term v a -> IO (Either Error ([Error], Term v))
evaluateTerm :: (Var v, Monoid a) => CodeLookup v IO a -> PrettyPrintEnv -> Runtime v -> Term v a -> IO (Either Error ([Error], Term v))


-- | Find a computation of type '{IO} () in the codebase.
module Unison.Codebase.MainTerm
data MainTerm v
NotFound :: HashQualified Name -> MainTerm v
BadType :: HashQualified Name -> Maybe (Type v Ann) -> MainTerm v
Success :: HashQualified Name -> Term v Ann -> Type v Ann -> MainTerm v
getMainTerm :: (Monad m, Var v) => (Reference -> m (Maybe (Type v Ann))) -> Names -> HashQualified Name -> Type v Ann -> m (MainTerm v)
builtinMain :: Var v => a -> Type v a
builtinMainWithResultType :: Var v => a -> Type v a -> Type v a

-- | All possible IO'ish test types, e.g. '{IO, Exception} [Result] '{IO}
--   [Result]
builtinIOTestTypes :: forall v a. (Ord v, Var v) => a -> NESet (Type v a)

module Unison.Builtin.Terms
builtinTermsRef :: Map Symbol Id
builtinTermsSrc :: a -> [(Symbol, a, Term Symbol a, Type Symbol a)]

module Unison.Builtin
codeLookup :: Applicative m => CodeLookup Symbol m Ann
constructorType :: Reference -> Maybe ConstructorType
names :: Names
builtinDataDecls :: [(Symbol, (Id, DataDeclaration))]
builtinEffectDecls :: [(Symbol, (Id, EffectDeclaration))]
builtinConstructorType :: Map Reference ConstructorType
builtinTypeDependents :: Reference -> Set Reference
builtinTypeDependentsOfComponent :: Hash -> Set Reference
builtinTypes :: [(Name, Reference)]
builtinTermsByType :: Relation Reference Referent
builtinTermsByTypeMention :: Relation Reference Referent
intrinsicTermReferences :: Set Reference
intrinsicTypeReferences :: Set Reference
isBuiltinType :: Reference -> Bool
typeOf :: a -> (Type -> a) -> Reference -> a
typeLookup :: TypeLookup Symbol Ann
termRefTypes :: Map TermReference Type
termRefTypeReferences :: Map TermReference TypeReference
instance GHC.Show.Show Unison.Builtin.BuiltinDSL

module Unison.FileParsers

-- | Should we use type-directed name resolution?
data ShouldUseTndr m
ShouldUseTndr'No :: ShouldUseTndr m
ShouldUseTndr'Yes :: ParsingEnv m -> ShouldUseTndr m

-- | Compute a typechecking environment, given:
--   
--   <ul>
--   <li>Whether or not to use type-directed name resolution during type
--   checking.</li>
--   <li>The abilities that are considered to already have ambient
--   handlers.</li>
--   <li>A function to compute a <tt>TypeLookup</tt> for the given set of
--   type- or term-references.</li>
--   <li>The parsing environment that was used to parse the parsed Unison
--   file.</li>
--   <li>The parsed Unison file for which the typechecking environment is
--   applicable.</li>
--   </ul>
computeTypecheckingEnvironment :: forall m v. (Var v, Monad m) => ShouldUseTndr m -> [Type v] -> (DefnsF Set TermReference TypeReference -> m (TypeLookup v Ann)) -> UnisonFile v -> m (Env v Ann)
synthesizeFile :: forall m v. (Monad m, Var v) => Env v Ann -> UnisonFile v -> ResultT (Seq (Note v Ann)) m (TypecheckedUnisonFile v Ann)

module Unison.Codebase.SqliteCodebase.Branch.Dependencies
type Branches m = [(CausalHash, m (Branch m))]
data Dependencies
Dependencies :: Set PatchHash -> Set Hash -> Set Hash -> Dependencies
[$sel:patches:Dependencies] :: Dependencies -> Set PatchHash
[$sel:terms:Dependencies] :: Dependencies -> Set Hash
[$sel:decls:Dependencies] :: Dependencies -> Set Hash
data Dependencies'
Dependencies' :: [PatchHash] -> [Hash] -> [Hash] -> Dependencies'
[$sel:patches':Dependencies'] :: Dependencies' -> [PatchHash]
[$sel:terms':Dependencies'] :: Dependencies' -> [Hash]
[$sel:decls':Dependencies'] :: Dependencies' -> [Hash]
to' :: Dependencies -> Dependencies'
fromBranch :: Applicative m => Branch m -> (Branches m, Dependencies)
fromBranch0 :: Applicative m => Branch0 m -> (Branches m, Dependencies)
instance GHC.Base.Monoid Unison.Codebase.SqliteCodebase.Branch.Dependencies.Dependencies
instance GHC.Base.Semigroup Unison.Codebase.SqliteCodebase.Branch.Dependencies.Dependencies
instance GHC.Generics.Generic Unison.Codebase.SqliteCodebase.Branch.Dependencies.Dependencies
instance GHC.Show.Show Unison.Codebase.SqliteCodebase.Branch.Dependencies.Dependencies
instance GHC.Base.Monoid Unison.Codebase.SqliteCodebase.Branch.Dependencies.Dependencies'
instance GHC.Base.Semigroup Unison.Codebase.SqliteCodebase.Branch.Dependencies.Dependencies'
instance GHC.Generics.Generic Unison.Codebase.SqliteCodebase.Branch.Dependencies.Dependencies'
instance GHC.Show.Show Unison.Codebase.SqliteCodebase.Branch.Dependencies.Dependencies'
instance GHC.Classes.Eq Unison.Codebase.SqliteCodebase.Branch.Dependencies.Dependencies'

module Unison.Codebase.Branch

-- | A node in the Unison namespace hierarchy along with its history.
newtype Branch m
Branch :: UnwrappedBranch m -> Branch m
[$sel:_history:Branch] :: Branch m -> UnwrappedBranch m
type UnwrappedBranch m = Causal m (Branch0 m)

-- | A node in the Unison namespace hierarchy.
--   
--   <a>$sel:_terms:Branch0</a> and <a>$sel:_types:Branch0</a> are the
--   declarations at this level. <a>$sel:_children:Branch0</a> are the
--   nodes one level below us. <a>$sel:_edits:Branch0</a> are the
--   <a>Patch</a>s stored at this node in the code.
--   
--   The remaining fields are derived from the four above. None of the
--   record fields are exported to avoid accidental tweaking without
--   updating the associated derived fields.
--   
--   Use either the lensy accessors or the field getters.
data Branch0 m
data Raw
type Star r n = Star r n

-- | A Hash for a namespace itself, it doesn't incorporate any history.
type NamespaceHash m = HashFor (Branch0 m)
branch0 :: forall m. Star Referent NameSegment -> Star TypeReference NameSegment -> Map NameSegment (Branch m) -> Map NameSegment (PatchHash, m Patch) -> Branch0 m
one :: Branch0 m -> Branch m
cons :: Applicative m => Branch0 m -> Branch m -> Branch m

-- | Construct a two-parent merge node.
mergeNode :: forall m. Applicative m => Branch0 m -> (CausalHash, m (Branch m)) -> (CausalHash, m (Branch m)) -> Branch m
uncons :: Applicative m => Branch m -> m (Maybe (Branch0 m, Branch m))
empty :: Branch m
empty0 :: Branch0 m

-- | Discards the history of a Branch and its children, recursively
discardHistory :: Applicative m => Branch m -> Branch m

-- | Discards the history of a Branch0's children, recursively
discardHistory0 :: Applicative m => Branch0 m -> Branch0 m
transform :: Functor m => (forall a. m a -> n a) -> Branch m -> Branch n
transform0 :: Functor m => (forall a. m a -> n a) -> Branch0 m -> Branch0 n

-- | Checks whether a branch is empty AND has no history.
isEmpty :: Branch m -> Bool
isEmpty0 :: Branch0 m -> Bool
isOne :: Branch m -> Bool
before :: Monad m => Branch m -> Branch m -> m Bool
lca :: Monad m => Branch m -> Branch m -> m (Maybe (Branch m))
history :: Iso' (Branch m) (UnwrappedBranch m)
head :: Branch m -> Branch0 m

-- | Update the head of the current causal. This re-hashes the current
--   causal head after modifications.
head_ :: Lens' (Branch m) (Branch0 m)
headHash :: Branch m -> CausalHash
children :: Lens' (Branch0 m) (Map NameSegment (Branch m))
nonEmptyChildren :: Branch0 m -> Map NameSegment (Branch m)

-- | a version of <a>deepEdits</a> that returns the `m Patch` as well.
deepEdits' :: Branch0 m -> Map Name (PatchHash, m Patch)

-- | what does this do? —AI
toList0 :: Branch0 m -> [(Path, Branch0 m)]
namespaceStats :: Branch0 m -> NamespaceStats

-- | Perform an update over the current branch and create a new causal
--   step.
step :: Applicative m => (Branch0 m -> Branch0 m) -> Branch m -> Branch m

-- | Run a series of updates at specific locations, aggregating all changes
--   into a single causal step. History is managed according to
--   <a>UpdateStrategy</a>.
stepManyAt :: forall m f. (Monad m, Foldable f) => f (Path, Branch0 m -> Branch0 m) -> Branch m -> Branch m

-- | Run a series of updates at specific locations. History is managed
--   according to the <a>UpdateStrategy</a>
stepManyAtM :: (Monad m, Monad n, Foldable f) => f (Path, Branch0 m -> n (Branch0 m)) -> Branch m -> n (Branch m)
stepEverywhere :: Applicative m => (Branch0 m -> Branch0 m) -> Branch0 m -> Branch0 m

-- | Perform updates over many locations within a branch by batching up
--   operations on sub-branches as much as possible without affecting
--   semantics. This operation does not create any causal conses, the
--   operations are performed directly on the current head of the provided
--   branch and child branches. It's the caller's responsibility to apply
--   updates in history however they choose.
batchUpdates :: forall f m. (Monad m, Foldable f) => f (Path, Branch0 m -> Branch0 m) -> Branch0 m -> Branch0 m

-- | Batch many updates. This allows us to apply the updates while
--   minimizing redundant traversals. Semantics of operations are preserved
--   by ensuring that all updates will always see changes by updates before
--   them in the list.
--   
--   This method does not <a>step</a> any branches on its own, all causal
--   changes must be performed in the updates themselves, or this batch
--   update must be provided to 'stepManyAt(M)'.
batchUpdatesM :: forall m n f. (Monad m, Monad n, Foldable f) => f (Path, Branch0 m -> n (Branch0 m)) -> Branch0 m -> n (Branch0 m)
data UpdateStrategy

-- | Compress all changes into a single causal cons. The resulting branch
--   will have at most one new causal cons at each branch.
--   
--   Note that this does NOT allow updates to add histories at children.
--   E.g. if the root.editme branch has history: A -&gt; B -&gt; C and you
--   use <tt>makeSetBranch</tt> to update it to a new branch with history X
--   -&gt; Y -&gt; Z, CompressHistory will result in a history for
--   root.editme of: A -&gt; B -&gt; C -&gt; Z. A <tt>snapshot</tt> of the
--   most recent state of the updated branch is appended to the existing
--   history, if the new state is equal to the existing state, no new
--   history nodes are appended.
CompressHistory :: UpdateStrategy

-- | Preserves any history changes made within the update.
--   
--   Note that this allows you to clobber the history child branches if you
--   want. E.g. if the root.editme branch has history: A -&gt; B -&gt; C
--   and you use <tt>makeSetBranch</tt> to update it to a new branch with
--   history X -&gt; Y -&gt; Z, AllowRewritingHistory will result in a
--   history for root.editme of: X -&gt; Y -&gt; Z. The history of the
--   updated branch is replaced entirely.
AllowRewritingHistory :: UpdateStrategy
addTermName :: Referent -> NameSegment -> Branch0 m -> Branch0 m
addTypeName :: TypeReference -> NameSegment -> Branch0 m -> Branch0 m
deleteTermName :: Referent -> NameSegment -> Branch0 m -> Branch0 m
annihilateTermName :: NameSegment -> Branch0 m -> Branch0 m
annihilateTypeName :: NameSegment -> Branch0 m -> Branch0 m
deleteTypeName :: TypeReference -> NameSegment -> Branch0 m -> Branch0 m
setChildBranch :: NameSegment -> Branch m -> Branch0 m -> Branch0 m
replacePatch :: Applicative m => NameSegment -> Patch -> Branch0 m -> Branch0 m
deletePatch :: NameSegment -> Branch0 m -> Branch0 m
getMaybePatch :: Applicative m => NameSegment -> Branch0 m -> m (Maybe Patch)
getPatch :: Applicative m => NameSegment -> Branch0 m -> m Patch
modifyPatches :: Monad m => NameSegment -> (Patch -> Patch) -> Branch0 m -> m (Branch0 m)
getAt :: Path -> Branch m -> Maybe (Branch m)
getAt' :: Path -> Branch m -> Branch m
getAt0 :: Path -> Branch0 m -> Branch0 m
modifyAt :: Applicative m => Path -> (Branch m -> Branch m) -> Branch m -> Branch m
modifyAtM :: forall n m. (Functor n, Applicative m) => Path -> (Branch m -> n (Branch m)) -> Branch m -> n (Branch m)

-- | Traverse the head branch of all direct children. The index of the
--   traversal is the name of that child branch according to the parent.
children0 :: IndexedTraversal' NameSegment (Branch0 m) (Branch0 m)

-- | Remove any lib subtrees reachable within the branch. Note: This DOES
--   affect the hash.
withoutLib :: Branch0 m -> Branch0 m

-- | Remove any transitive libs reachable within the branch. Note: This
--   DOES affect the hash.
withoutTransitiveLibs :: Branch0 m -> Branch0 m

-- | <tt>deleteLibdep name branch</tt> deletes the libdep named
--   <tt>name</tt> from <tt>branch</tt>, if it exists.
deleteLibdep :: NameSegment -> Branch0 m -> Branch0 m

-- | <tt>deleteLibdeps branch</tt> deletes all libdeps from
--   <tt>branch</tt>.
deleteLibdeps :: Branch0 m -> Branch0 m
terms :: Lens' (Branch0 m) (Star Referent NameSegment)
types :: Lens' (Branch0 m) (Star TypeReference NameSegment)
edits :: Lens' (Branch0 m) (Map NameSegment (PatchHash, m Patch))
deepTerms :: Branch0 m -> Relation Referent Name
deepTypes :: Branch0 m -> Relation TypeReference Name
deepDefns :: Branch0 m -> DefnsF (Relation Name) Referent TypeReference
deepEdits :: Branch0 m -> Map Name PatchHash
deepPaths :: Branch0 m -> Set Path
deepReferents :: Branch0 m -> Set Referent
deepTermReferences :: Branch0 m -> Set TermReference
deepTermReferenceIds :: Branch0 m -> Set TermReferenceId
deepTypeReferences :: Branch0 m -> Set TypeReference
deepTypeReferenceIds :: Branch0 m -> Set TypeReferenceId

-- | <tt>head <a>consBranchSnapshot</a> base</tt> Cons's the current state
--   of <tt>head</tt> onto <tt>base</tt> as-is. Consider whether you really
--   want this behaviour or the behaviour of <a>squashMerge</a> That is, it
--   does not perform any common ancestor detection, or change
--   reconciliation, it sets the current state of the base branch to the
--   new state as a new causal step (or returns the existing base if there
--   are no)
consBranchSnapshot :: forall m. Monad m => Branch m -> Branch m -> Branch m
instance GHC.Classes.Eq Unison.Codebase.Branch.ActionLocation
instance Control.Lens.Empty.AsEmpty (Unison.Codebase.Branch.Type.Branch m)
instance Unison.Hashing.ContentAddressable.ContentAddressable (Unison.Codebase.Branch.Type.Branch0 m)

module Unison.Codebase.Type

-- | Abstract interface to a user's codebase.
data Codebase m v a
Codebase :: (TermReferenceId -> Transaction (Maybe (Term v a))) -> (TermReferenceId -> Transaction (Maybe (Type v a))) -> (TypeReferenceId -> Transaction (Maybe (Decl v a))) -> (TypeReference -> Transaction ConstructorType) -> (TermReferenceId -> Term v a -> Type v a -> Transaction ()) -> (Hash -> [(Term v a, Type v a)] -> Transaction ()) -> (TypeReferenceId -> Decl v a -> Transaction ()) -> (Hash -> [Decl v a] -> Transaction ()) -> (Hash -> Transaction (Maybe [(Term v a, Type v a)])) -> (CausalHash -> m (Maybe (Branch m))) -> (Branch m -> m ()) -> (WatchKind -> TermReferenceId -> Transaction (Maybe (Term v a))) -> (Reference -> Transaction (Set Id)) -> (Reference -> Transaction (Set Id)) -> (TypeReference -> Set Id -> Transaction (Set Id)) -> (TypeReference -> Set Id -> Transaction (Set Id)) -> (ShortHash -> Transaction (Set Id)) -> (forall x. (Connection -> m x) -> m x) -> (forall x. (Connection -> IO x) -> IO x) -> (CausalHash -> m ()) -> Codebase m v a

-- | Get a user-defined term from the codebase.
--   
--   Note that it is possible to call <a>$sel:putTerm:Codebase</a>, then
--   <a>$sel:getTerm:Codebase</a>, and receive <tt>Nothing</tt>, per the
--   semantics of <a>$sel:putTerm:Codebase</a>.
[$sel:getTerm:Codebase] :: Codebase m v a -> TermReferenceId -> Transaction (Maybe (Term v a))

-- | Get the type of a user-defined term.
--   
--   Note that it is possible to call <a>$sel:putTerm:Codebase</a>, then
--   <a>$sel:getTypeOfTermImpl:Codebase</a>, and receive <tt>Nothing</tt>,
--   per the semantics of <a>$sel:putTerm:Codebase</a>.
[$sel:getTypeOfTermImpl:Codebase] :: Codebase m v a -> TermReferenceId -> Transaction (Maybe (Type v a))

-- | Get a type declaration.
--   
--   Note that it is possible to call
--   <a>$sel:putTypeDeclaration:Codebase</a>, then
--   <a>$sel:getTypeDeclaration:Codebase</a>, and receive <tt>Nothing</tt>,
--   per the semantics of <a>$sel:putTypeDeclaration:Codebase</a>.
[$sel:getTypeDeclaration:Codebase] :: Codebase m v a -> TypeReferenceId -> Transaction (Maybe (Decl v a))

-- | Get the type of a given decl.
[$sel:getDeclType:Codebase] :: Codebase m v a -> TypeReference -> Transaction ConstructorType

-- | Enqueue the put of a user-defined term (with its type) into the
--   codebase, if it doesn't already exist. The implementation may choose
--   to delay the put until all of the term's (and its type's) references
--   are stored as well.
[$sel:putTerm:Codebase] :: Codebase m v a -> TermReferenceId -> Term v a -> Type v a -> Transaction ()
[$sel:putTermComponent:Codebase] :: Codebase m v a -> Hash -> [(Term v a, Type v a)] -> Transaction ()

-- | Enqueue the put of a type declaration into the codebase, if it doesn't
--   already exist. The implementation may choose to delay the put until
--   all of the type declaration's references are stored as well.
[$sel:putTypeDeclaration:Codebase] :: Codebase m v a -> TypeReferenceId -> Decl v a -> Transaction ()
[$sel:putTypeDeclarationComponent:Codebase] :: Codebase m v a -> Hash -> [Decl v a] -> Transaction ()
[$sel:getTermComponentWithTypes:Codebase] :: Codebase m v a -> Hash -> Transaction (Maybe [(Term v a, Type v a)])
[$sel:getBranchForHash:Codebase] :: Codebase m v a -> CausalHash -> m (Maybe (Branch m))

-- | Put a branch into the codebase, which includes its children, its
--   patches, and the branch itself, if they don't already exist.
--   
--   The terms and type declarations that a branch references must already
--   exist in the codebase.
[$sel:putBranch:Codebase] :: Codebase m v a -> Branch m -> m ()

-- | <tt>getWatch k r</tt> returns watch result <tt>t</tt> that was
--   previously put by <tt>putWatch k r t</tt>.
[$sel:getWatch:Codebase] :: Codebase m v a -> WatchKind -> TermReferenceId -> Transaction (Maybe (Term v a))

-- | Get the set of user-defined terms-or-constructors that have the given
--   type.
[$sel:termsOfTypeImpl:Codebase] :: Codebase m v a -> Reference -> Transaction (Set Id)

-- | Get the set of user-defined terms-or-constructors mention the given
--   type anywhere in their signature.
[$sel:termsMentioningTypeImpl:Codebase] :: Codebase m v a -> Reference -> Transaction (Set Id)

-- | Return the subset of the given set that has the given type.
[$sel:filterTermsByReferenceIdHavingTypeImpl:Codebase] :: Codebase m v a -> TypeReference -> Set Id -> Transaction (Set Id)

-- | Return the subset of the given set that has the given type.
[$sel:filterTermsByReferentIdHavingTypeImpl:Codebase] :: Codebase m v a -> TypeReference -> Set Id -> Transaction (Set Id)

-- | Get the set of user-defined terms-or-constructors whose hash matches
--   the given prefix.
[$sel:termReferentsByPrefix:Codebase] :: Codebase m v a -> ShortHash -> Transaction (Set Id)

-- | Acquire a new connection to the same underlying database file this
--   codebase object connects to.
[$sel:withConnection:Codebase] :: Codebase m v a -> forall x. (Connection -> m x) -> m x

-- | Acquire a new connection to the same underlying database file this
--   codebase object connects to.
[$sel:withConnectionIO:Codebase] :: Codebase m v a -> forall x. (Connection -> IO x) -> IO x

-- | This optimization allows us to pre-fetch a branch from SQLite into the
--   branch cache when we know we'll need it soon, but not immediately.
--   E.g. the user has switched a branch, but hasn't run any commands on it
--   yet.
--   
--   This combinator returns immediately, but warms the cache in the
--   background with the desired branch.
[$sel:preloadBranch:Codebase] :: Codebase m v a -> CausalHash -> m ()

-- | A directory that contains a codebase.
type CodebasePath = FilePath

-- | Whether a codebase is local or remote.
data LocalOrRemote
Local :: LocalOrRemote
Remote :: LocalOrRemote
instance GHC.Classes.Ord Unison.Codebase.Type.LocalOrRemote
instance GHC.Classes.Eq Unison.Codebase.Type.LocalOrRemote
instance GHC.Show.Show Unison.Codebase.Type.LocalOrRemote

module Unison.Codebase.SqliteCodebase.Branch.Cache

-- | A cache of <a>Branch</a> by <a>CausalHash</a>es.
data BranchCache m
BranchCache :: (CausalHash -> m (Maybe (Branch m))) -> (CausalHash -> Branch m -> m ()) -> BranchCache m
[$sel:lookupCachedBranch:BranchCache] :: BranchCache m -> CausalHash -> m (Maybe (Branch m))
[$sel:insertCachedBranch:BranchCache] :: BranchCache m -> CausalHash -> Branch m -> m ()

-- | Creates a <a>BranchCache</a> which uses weak references to only keep
--   branches in the cache for as long as they're reachable by something
--   else in the app.
--   
--   This means you don't need to worry about a Branch not being GC'd
--   because it's in the cache.
newBranchCache :: forall m. MonadIO m => m (BranchCache Transaction)

module Unison.Codebase.SqliteCodebase.Conversions
sch1to2 :: ShortCausalHash -> ShortCausalHash
decltype2to1 :: DeclType -> ConstructorType
decltype1to2 :: ConstructorType -> DeclType
watchKind1to2 :: WatchKind -> WatchKind
watchKind2to1 :: WatchKind -> WatchKind
term1to2 :: Hash -> Term Symbol Ann -> Term Symbol
term2to1 :: forall m. Monad m => Hash -> (Reference -> m ConstructorType) -> Term Symbol -> m (Term Symbol Ann)
termComponent1to2 :: Hash -> [(Term Symbol Ann, Type Symbol a)] -> [(Term Symbol, TypeT Symbol)]
decl2to1 :: Hash -> Decl Symbol -> Decl Symbol Ann
decl1to2 :: Hash -> Decl Symbol a -> Decl Symbol
symbol2to1 :: Symbol -> Symbol
symbol1to2 :: Symbol -> Symbol
rreference2to1 :: Hash -> Reference' Text (Maybe Hash) -> Reference
rreference1to2 :: Hash -> Reference -> Reference' Text (Maybe Hash)
rreferenceid2to1 :: Hash -> Id' (Maybe Hash) -> Id
rreferenceid1to2 :: Hash -> Id -> Id' (Maybe Hash)
branchHash1to2 :: NamespaceHash m -> BranchHash
branchHash2to1 :: forall m. BranchHash -> NamespaceHash m
reference2to1 :: Reference -> Reference
reference1to2 :: Reference -> Reference
referenceid1to2 :: Id -> Id
referenceid2to1 :: Id -> Id
rreferent2to1 :: Applicative m => Hash -> (Reference -> m ConstructorType) -> ReferentH -> m Referent
rreferent1to2 :: Hash -> Referent -> ReferentH
referent2to1 :: Applicative m => (Reference -> m ConstructorType) -> Referent -> m Referent

-- | Like referent2to1, but uses the provided constructor type directly
referent2to1UsingCT :: ConstructorType -> Referent -> Referent
referent1to2 :: Referent -> Referent
referentid1to2 :: Id -> Id
referentid2to1 :: Applicative m => (Reference -> m ConstructorType) -> Id -> m Id
constructorType1to2 :: ConstructorType -> ConstructorType
constructorType2to1 :: ConstructorType -> ConstructorType
ttype2to1 :: Type Symbol -> Type Symbol Ann
dtype2to1 :: Hash -> Type Symbol -> Type Symbol Ann
type2to1' :: (r -> Reference) -> TypeR r Symbol -> Type Symbol Ann
dtype1to2 :: Hash -> Type Symbol a -> TypeD Symbol
ttype1to2 :: Type Symbol a -> TypeT Symbol
type1to2' :: (Reference -> r) -> Type Symbol a -> TypeR r Symbol

-- | forces loading v1 branches even if they may not exist
causalbranch2to1 :: Monad m => BranchCache m -> (Reference -> m ConstructorType) -> CausalBranch m -> m (Branch m)
causalbranch2to1' :: Monad m => BranchCache m -> (Reference -> m ConstructorType) -> CausalBranch m -> m (UnwrappedBranch m)
causalbranch1to2 :: forall m. Monad m => Branch m -> CausalBranch m
patch2to1 :: Patch -> Patch
patch1to2 :: Patch -> Patch
branch2to1 :: Monad m => BranchCache m -> (Reference -> m ConstructorType) -> Branch m -> m (Branch0 m)

-- | Generates a v1 short hash from a v2 referent. Also shortens the hash
--   to the provided length. If <a>Nothing</a>, it will include the full
--   length hash.
referent2toshorthash1 :: Maybe Int -> Referent -> ShortHash

-- | Generates a v1 short hash from a v2 reference. Also shortens the hash
--   to the provided length. If <a>Nothing</a>, it will include the full
--   length hash.
reference2toshorthash1 :: Maybe Int -> Reference -> ShortHash


-- | This module contains sqlite-specific operations on high-level
--   "parser-typechecker" types all in the Transaction monad.
--   
--   The Codebase record-of-functions wraps this functionality, and runs
--   each transaction to IO, so that the operations' are unified with
--   non-sqlite operations in the Codebase interface, like
--   <tt>appendReflog</tt>.
module Unison.Codebase.SqliteCodebase.Operations
createSchema :: Transaction ()
data BufferEntry a
BufferEntry :: Maybe Word64 -> Map Pos a -> Set Hash -> Set Hash -> BufferEntry a
[$sel:beComponentTargetSize:BufferEntry] :: BufferEntry a -> Maybe Word64
[$sel:beComponent:BufferEntry] :: BufferEntry a -> Map Pos a
[$sel:beMissingDependencies:BufferEntry] :: BufferEntry a -> Set Hash
[$sel:beWaitingDependents:BufferEntry] :: BufferEntry a -> Set Hash
prettyBufferEntry :: Show a => Hash -> BufferEntry a -> String
type TermBufferEntry = BufferEntry (Term Symbol Ann, Type Symbol Ann)
type DeclBufferEntry = BufferEntry (Decl Symbol Ann)
getBuffer :: TVar (Map Hash (BufferEntry a)) -> Hash -> IO (BufferEntry a)
putBuffer :: TVar (Map Hash (BufferEntry a)) -> Hash -> BufferEntry a -> IO ()
removeBuffer :: TVar (Map Hash (BufferEntry a)) -> Hash -> IO ()
addBufferDependent :: Hash -> TVar (Map Hash (BufferEntry a)) -> Hash -> IO ()
tryFlushBuffer :: forall a. Show a => TVar (Map Hash (BufferEntry a)) -> (Hash -> [a] -> Transaction ()) -> (Hash -> Transaction ()) -> Hash -> Transaction ()
getTerm :: (Reference -> Transaction ConstructorType) -> Id -> Transaction (Maybe (Term Symbol Ann))
getDeclType :: Reference -> Transaction ConstructorType
expectDeclTypeById :: Id -> Transaction ConstructorType
getTypeOfTermImpl :: Id -> Transaction (Maybe (Type Symbol Ann))
getTermComponentWithTypes :: (Reference -> Transaction ConstructorType) -> Hash -> Transaction (Maybe [(Term Symbol Ann, Type Symbol Ann)])
getTypeDeclaration :: Id -> Transaction (Maybe (Decl Symbol Ann))
getDeclComponent :: Hash -> Transaction (Maybe [Decl Symbol Ann])

-- | Like <a>getDeclComponent</a>, for when the decl component is known to
--   exist in the codebase.
expectDeclComponent :: HasCallStack => Hash -> Transaction [Decl Symbol Ann]
putTermComponent :: TVar (Map Hash TermBufferEntry) -> TVar (Map Hash DeclBufferEntry) -> Hash -> [(Term Symbol Ann, Type Symbol Ann)] -> Transaction ()
putTerm :: TVar (Map Hash TermBufferEntry) -> TVar (Map Hash DeclBufferEntry) -> Id -> Term Symbol Ann -> Type Symbol Ann -> Transaction ()
putTerm_ :: TVar (Map Hash TermBufferEntry) -> TVar (Map Hash DeclBufferEntry) -> Id -> Term Symbol Ann -> Type Symbol Ann -> Transaction ()
tryFlushTermBuffer :: TVar (Map Hash TermBufferEntry) -> Hash -> Transaction ()
addDeclComponentTypeIndex :: ObjectId -> [[Type Symbol Ann]] -> Transaction ()
putTypeDeclarationComponent :: TVar (Map Hash TermBufferEntry) -> TVar (Map Hash DeclBufferEntry) -> Hash -> [Decl Symbol Ann] -> Transaction ()
putTypeDeclaration :: TVar (Map Hash TermBufferEntry) -> TVar (Map Hash DeclBufferEntry) -> Id -> Decl Symbol Ann -> Transaction ()
putTypeDeclaration_ :: TVar (Map Hash DeclBufferEntry) -> Id -> Decl Symbol Ann -> Transaction ()
tryFlushDeclBuffer :: TVar (Map Hash TermBufferEntry) -> TVar (Map Hash DeclBufferEntry) -> Hash -> Transaction ()
getBranchForHash :: BranchCache Transaction -> (Reference -> Transaction ConstructorType) -> CausalHash -> Transaction (Maybe (Branch Transaction))
putBranch :: Branch Transaction -> Transaction ()

-- | Check whether the given branch exists in the codebase.
branchExists :: CausalHash -> Transaction Bool
getPatch :: PatchHash -> Transaction (Maybe Patch)

-- | Put a patch into the codebase.
--   
--   Note that <a>putBranch</a> may also put patches.
putPatch :: PatchHash -> Patch -> Transaction ()

-- | Check whether the given patch exists in the codebase.
patchExists :: PatchHash -> Transaction Bool
dependentsImpl :: DependentsSelector -> Reference -> Transaction (Set Id)
dependentsOfComponentImpl :: Hash -> Transaction (Set Id)

-- | <tt>watches k</tt> returns all of the references <tt>r</tt> that were
--   previously put by a <tt>putWatch k r t</tt>. <tt>t</tt> can be
--   retrieved by <tt>getWatch k r</tt>.
watches :: WatchKind -> Transaction [Id]
getWatch :: (Reference -> Transaction ConstructorType) -> WatchKind -> Id -> Transaction (Maybe (Term Symbol Ann))

-- | <tt>putWatch k r t</tt> puts a watch of kind <tt>k</tt>, with
--   hash-of-expression <tt>r</tt> and decompiled result <tt>t</tt> into
--   the codebase.
--   
--   For example, in the watch expression below, <tt>k</tt> is
--   <a>Regular</a>, <tt>r</tt> is the hash of <tt>x</tt>, and <tt>t</tt>
--   is <tt>7</tt>.
--   
--   <pre>
--   &gt; x = 3 + 4
--     ⧩
--     7
--   </pre>
putWatch :: WatchKind -> Id -> Term Symbol Ann -> Transaction ()
standardWatchKinds :: [WatchKind]
termsOfTypeImpl :: (Reference -> Transaction ConstructorType) -> Reference -> Transaction (Set Id)
termsMentioningTypeImpl :: (Reference -> Transaction ConstructorType) -> Reference -> Transaction (Set Id)
filterReferencesHavingTypeImpl :: Reference -> Set Id -> Transaction (Set Id)
filterReferentsHavingTypeImpl :: (Reference -> Transaction ConstructorType) -> Reference -> Set Id -> Transaction (Set Id)

-- | The number of base32 characters needed to distinguish any two
--   references in the codebase.
hashLength :: Transaction Int

-- | The number of base32 characters needed to distinguish any two branch
--   in the codebase.
branchHashLength :: Transaction Int
defnReferencesByPrefix :: ObjectType -> ShortHash -> Transaction (Set Id)
termReferencesByPrefix :: ShortHash -> Transaction (Set Id)

-- | Get the set of type declarations whose hash matches the given prefix.
typeReferencesByPrefix :: ShortHash -> Transaction (Set Id)
referentsByPrefix :: (Reference -> Transaction ConstructorType) -> ShortHash -> Transaction (Set Id)

-- | Get the set of branches whose hash matches the given prefix.
causalHashesByPrefix :: ShortCausalHash -> Transaction (Set CausalHash)
termExists :: Hash -> Transaction Bool
declExists :: Hash -> Transaction Bool
before :: CausalHash -> CausalHash -> Transaction Bool

-- | Construct a <tt>ScopedNames</tt> which can produce names which are
--   relative to the provided Path.
--   
--   NOTE: this method requires an up-to-date name lookup index
namesAtPath :: BranchHash -> Path -> Transaction Names

-- | Add an index for the provided branch hash if one doesn't already
--   exist.
ensureNameLookupForBranchHash :: (Reference -> Transaction ConstructorType) -> Maybe BranchHash -> BranchHash -> Transaction ()

-- | Regenerate the name lookup index for the given branch hash from
--   scratch. This shouldn't be necessary in normal operation, but it's
--   useful to fix name lookups if they somehow get corrupt, or during
--   local testing and debugging.
regenerateNameLookup :: (Reference -> Transaction ConstructorType) -> BranchHash -> Transaction ()

-- | Given a transaction, return a transaction that first checks a
--   semispace cache of the given size.
--   
--   The transaction should probably be read-only, as we (of course) don't
--   hit SQLite on a cache hit.
makeCachedTransaction :: (Ord a, MonadIO m) => Word -> (a -> Transaction b) -> m (a -> Transaction b)

-- | Like <a>makeCachedTransaction</a>, but for when the transaction
--   returns a Maybe; only cache the Justs.
makeMaybeCachedTransaction :: (Ord a, MonadIO m) => Word -> (a -> Transaction (Maybe b)) -> m (a -> Transaction (Maybe b))

-- | Creates a project by name if one doesn't already exist, creates a
--   branch in that project, then returns the project and branch ids. Fails
--   if a branch by that name already exists in the project.
insertProjectAndBranch :: ProjectName -> ProjectBranchName -> CausalHashId -> Transaction (Project, ProjectBranch)

-- | Often we need to assign something to an empty causal, this ensures the
--   empty causal exists in the codebase and returns its hash.
emptyCausalHash :: Transaction (CausalHash, CausalHashId)
instance GHC.Show.Show a => GHC.Show.Show (Unison.Codebase.SqliteCodebase.Operations.BufferEntry a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Unison.Codebase.SqliteCodebase.Operations.BufferEntry a)

module Unison.Codebase.SqliteCodebase.Migrations.MigrateSchema1To2
migrateSchema1To2 :: (Reference -> Transaction ConstructorType) -> TVar (Map Hash TermBufferEntry) -> TVar (Map Hash DeclBufferEntry) -> Transaction ()
instance GHC.Show.Show Unison.Codebase.SqliteCodebase.Migrations.MigrateSchema1To2.Entity
instance GHC.Classes.Ord Unison.Codebase.SqliteCodebase.Migrations.MigrateSchema1To2.Entity
instance GHC.Classes.Eq Unison.Codebase.SqliteCodebase.Migrations.MigrateSchema1To2.Entity
instance Data.Traversable.Traversable Unison.Codebase.SqliteCodebase.Migrations.MigrateSchema1To2.SomeReference
instance Data.Foldable.Foldable Unison.Codebase.SqliteCodebase.Migrations.MigrateSchema1To2.SomeReference
instance GHC.Show.Show ref => GHC.Show.Show (Unison.Codebase.SqliteCodebase.Migrations.MigrateSchema1To2.SomeReference ref)
instance GHC.Classes.Ord ref => GHC.Classes.Ord (Unison.Codebase.SqliteCodebase.Migrations.MigrateSchema1To2.SomeReference ref)
instance GHC.Generics.Generic (Unison.Codebase.SqliteCodebase.Migrations.MigrateSchema1To2.SomeReference ref)
instance GHC.Base.Functor Unison.Codebase.SqliteCodebase.Migrations.MigrateSchema1To2.SomeReference
instance GHC.Classes.Eq ref => GHC.Classes.Eq (Unison.Codebase.SqliteCodebase.Migrations.MigrateSchema1To2.SomeReference ref)
instance GHC.Generics.Generic Unison.Codebase.SqliteCodebase.Migrations.MigrateSchema1To2.MigrationState

module Unison.Codebase.BranchUtil

-- | Creates a branch containing all of the given names, with a single
--   history node.
fromNames :: Monad m => Names -> Branch m
getBranch :: Split -> Branch0 m -> Maybe (Branch m)
getTerm :: HQSplit -> Branch0 m -> Set Referent
getType :: HQSplit -> Branch0 m -> Set TypeReference
makeSetBranch :: Split -> Branch m -> (Path, Branch0 m -> Branch0 m)
makeAddTypeName :: (p, NameSegment) -> Reference -> (p, Branch0 m -> Branch0 m)
makeDeleteTypeName :: (p, NameSegment) -> Reference -> (p, Branch0 m -> Branch0 m)
makeAnnihilateTypeName :: Split -> (Path, Branch0 m -> Branch0 m)
makeAddTermName :: (p, NameSegment) -> Referent -> (p, Branch0 m -> Branch0 m)
makeDeleteTermName :: (p, NameSegment) -> Referent -> (p, Branch0 m -> Branch0 m)
makeAnnihilateTermName :: Split -> (Path, Branch0 m -> Branch0 m)

module Unison.Codebase.BranchDiff
data DiffType a
Create :: a -> DiffType a
Delete :: a -> DiffType a
Modify :: a -> DiffType a
data DiffSlice r
DiffSlice :: Map Name (Set r, Set r) -> Relation r Name -> Relation r Name -> Map r (Set Name, Set Name) -> DiffSlice r
[$sel:tallnamespaceUpdates:DiffSlice] :: DiffSlice r -> Map Name (Set r, Set r)
[$sel:talladds:DiffSlice] :: DiffSlice r -> Relation r Name
[$sel:tallremoves:DiffSlice] :: DiffSlice r -> Relation r Name
[$sel:trenames:DiffSlice] :: DiffSlice r -> Map r (Set Name, Set Name)
data BranchDiff
BranchDiff :: DiffSlice Referent -> DiffSlice Reference -> Map Name (DiffType PatchDiff) -> BranchDiff
[$sel:termsDiff:BranchDiff] :: BranchDiff -> DiffSlice Referent
[$sel:typesDiff:BranchDiff] :: BranchDiff -> DiffSlice Reference
[$sel:patchesDiff:BranchDiff] :: BranchDiff -> Map Name (DiffType PatchDiff)
diff0 :: forall m. Monad m => Branch0 m -> Branch0 m -> m BranchDiff
patchDiff :: forall m. Monad m => Branch0 m -> Branch0 m -> m (Map Name (DiffType PatchDiff))
computeSlices :: Relation Referent Name -> Relation Referent Name -> Relation Reference Name -> Relation Reference Name -> (DiffSlice Referent, DiffSlice Reference)
namespaceUpdates :: Ord r => DiffSlice r -> Map Name (Set r, Set r)
instance GHC.Show.Show a => GHC.Show.Show (Unison.Codebase.BranchDiff.DiffType a)
instance GHC.Show.Show r => GHC.Show.Show (Unison.Codebase.BranchDiff.DiffSlice r)
instance GHC.Generics.Generic (Unison.Codebase.BranchDiff.DiffSlice r)
instance GHC.Show.Show Unison.Codebase.BranchDiff.BranchDiff
instance GHC.Generics.Generic Unison.Codebase.BranchDiff.BranchDiff

module Unison.Codebase.Branch.Names
namesDiff :: Branch m -> Branch m -> Diff

-- | Get the names in the provided branch.
toNames :: Branch0 m -> Names

-- | Get the pretty-printing environment for names in the provided branch.
toPrettyPrintEnvDecl :: Int -> Branch0 m -> PrettyPrintEnvDecl

module Unison.Codebase.Branch.BranchDiff
type Star r n = Star r n
data BranchDiff
BranchDiff :: Star Referent NameSegment -> Star Referent NameSegment -> Star Reference NameSegment -> Star Reference NameSegment -> Map NameSegment PatchDiff -> BranchDiff
[$sel:addedTerms:BranchDiff] :: BranchDiff -> Star Referent NameSegment
[$sel:removedTerms:BranchDiff] :: BranchDiff -> Star Referent NameSegment
[$sel:addedTypes:BranchDiff] :: BranchDiff -> Star Reference NameSegment
[$sel:removedTypes:BranchDiff] :: BranchDiff -> Star Reference NameSegment
[$sel:changedPatches:BranchDiff] :: BranchDiff -> Map NameSegment PatchDiff
diff0 :: Monad m => Branch0 m -> Branch0 m -> m BranchDiff
instance GHC.Show.Show Unison.Codebase.Branch.BranchDiff.BranchDiff
instance GHC.Classes.Ord Unison.Codebase.Branch.BranchDiff.BranchDiff
instance GHC.Classes.Eq Unison.Codebase.Branch.BranchDiff.BranchDiff
instance GHC.Base.Semigroup Unison.Codebase.Branch.BranchDiff.BranchDiff
instance GHC.Base.Monoid Unison.Codebase.Branch.BranchDiff.BranchDiff

module Unison.Codebase.Branch.Merge
data MergeMode
RegularMerge :: MergeMode
SquashMerge :: MergeMode
merge'' :: forall m. Monad m => (Branch m -> Branch m -> m (Maybe (Branch m))) -> MergeMode -> Branch m -> Branch m -> m (Branch m)
instance GHC.Show.Show Unison.Codebase.Branch.Merge.MergeMode
instance GHC.Classes.Ord Unison.Codebase.Branch.Merge.MergeMode
instance GHC.Classes.Eq Unison.Codebase.Branch.Merge.MergeMode

module Unison.Codebase

-- | Abstract interface to a user's codebase.
data Codebase m v a
expectCurrentProjectPath :: HasCallStack => Transaction ProjectPath
setCurrentProjectPath :: ProjectPathIds -> Transaction ()

-- | Hydrate the project and branch from IDs.
resolveProjectPathIds :: ProjectPathIds -> Transaction ProjectPath

-- | Get a user-defined term from the codebase.
--   
--   Note that it is possible to call <a>$sel:putTerm:Codebase</a>, then
--   <a>$sel:getTerm:Codebase</a>, and receive <tt>Nothing</tt>, per the
--   semantics of <a>$sel:putTerm:Codebase</a>.
($sel:getTerm:Codebase) :: Codebase m v a -> TermReferenceId -> Transaction (Maybe (Term v a))

-- | Like <a>$sel:getTerm:Codebase</a>, for when the term is known to exist
--   in the codebase.
unsafeGetTerm :: HasCallStack => Codebase m v a -> Id -> Transaction (Term v a)

-- | Like <a>unsafeGetTerm</a>, but returns the type of the term, too.
unsafeGetTermWithType :: HasCallStack => Codebase m v a -> Id -> Transaction (Term v a, Type v a)
($sel:getTermComponentWithTypes:Codebase) :: Codebase m v a -> Hash -> Transaction (Maybe [(Term v a, Type v a)])

-- | Like <a>$sel:getTermComponentWithTypes:Codebase</a>, for when the term
--   component is known to exist in the codebase.
unsafeGetTermComponent :: HasCallStack => Codebase m v a -> Hash -> Transaction [(Term v a, Type v a)]

-- | Get the type of a term.
--   
--   Note that it is possible to call <a>$sel:putTerm:Codebase</a>, then
--   <a>getTypeOfTerm</a>, and receive <tt>Nothing</tt>, per the semantics
--   of <a>$sel:putTerm:Codebase</a>.
getTypeOfTerm :: BuiltinAnnotation a => Codebase m Symbol a -> Reference -> Transaction (Maybe (Type Symbol a))

-- | Get the type of a given decl.
($sel:getDeclType:Codebase) :: Codebase m v a -> TypeReference -> Transaction ConstructorType

-- | Like <a>getTypeOfTerm</a>, but for when the term is known to exist in
--   the codebase.
unsafeGetTypeOfTermById :: HasCallStack => Codebase m v a -> Id -> Transaction (Type v a)

-- | Check whether a reference is a term.
isTerm :: BuiltinAnnotation a => Codebase m Symbol a -> Reference -> Transaction Bool

-- | Enqueue the put of a user-defined term (with its type) into the
--   codebase, if it doesn't already exist. The implementation may choose
--   to delay the put until all of the term's (and its type's) references
--   are stored as well.
($sel:putTerm:Codebase) :: Codebase m v a -> TermReferenceId -> Term v a -> Type v a -> Transaction ()
($sel:putTermComponent:Codebase) :: Codebase m v a -> Hash -> [(Term v a, Type v a)] -> Transaction ()

-- | Get the type of a referent.
getTypeOfReferent :: BuiltinAnnotation a => Codebase m Symbol a -> Referent -> Transaction (Maybe (Type Symbol a))

-- | Get the set of terms-or-constructors that have the given type.
termsOfType :: Var v => Codebase m v a -> Type v a -> Transaction (Set Referent)
filterTermsByReferenceIdHavingType :: Var v => Codebase m v a -> Type v a -> Set TermReferenceId -> Transaction (Set TermReferenceId)
filterTermsByReferentHavingType :: Var v => Codebase m v a -> Type v a -> Set Referent -> Transaction (Set Referent)

-- | Get the set of terms-or-constructors mention the given type anywhere
--   in their signature.
termsMentioningType :: Var v => Codebase m v a -> Type v a -> Transaction (Set Referent)
termReferencesByPrefix :: ShortHash -> Transaction (Set Id)

-- | Get the set of user-defined terms-or-constructors whose hash matches
--   the given prefix.
($sel:termReferentsByPrefix:Codebase) :: Codebase m v a -> ShortHash -> Transaction (Set Id)

-- | Get a type declaration.
--   
--   Note that it is possible to call
--   <a>$sel:putTypeDeclaration:Codebase</a>, then
--   <a>$sel:getTypeDeclaration:Codebase</a>, and receive <tt>Nothing</tt>,
--   per the semantics of <a>$sel:putTypeDeclaration:Codebase</a>.
($sel:getTypeDeclaration:Codebase) :: Codebase m v a -> TypeReferenceId -> Transaction (Maybe (Decl v a))

-- | Like <a>$sel:getTypeDeclaration:Codebase</a>, for when the type
--   declaration is known to exist in the codebase.
unsafeGetTypeDeclaration :: HasCallStack => Codebase m v a -> Id -> Transaction (Decl v a)
getDeclComponent :: Hash -> Transaction (Maybe [Decl Symbol Ann])

-- | Enqueue the put of a type declaration into the codebase, if it doesn't
--   already exist. The implementation may choose to delay the put until
--   all of the type declaration's references are stored as well.
($sel:putTypeDeclaration:Codebase) :: Codebase m v a -> TypeReferenceId -> Decl v a -> Transaction ()
($sel:putTypeDeclarationComponent:Codebase) :: Codebase m v a -> Hash -> [Decl v a] -> Transaction ()

-- | Get the set of type declarations whose hash matches the given prefix.
typeReferencesByPrefix :: ShortHash -> Transaction (Set Id)
isType :: Codebase m v a -> Reference -> Transaction Bool

-- | Check whether the given branch exists in the codebase.
branchExists :: CausalHash -> Transaction Bool
($sel:getBranchForHash:Codebase) :: Codebase m v a -> CausalHash -> m (Maybe (Branch m))

-- | Like <a>$sel:getBranchForHash:Codebase</a>, but for when the hash is
--   known to be in the codebase.
expectBranchForHash :: Monad m => Codebase m v a -> CausalHash -> m (Branch m)

-- | Put a branch into the codebase, which includes its children, its
--   patches, and the branch itself, if they don't already exist.
--   
--   The terms and type declarations that a branch references must already
--   exist in the codebase.
($sel:putBranch:Codebase) :: Codebase m v a -> Branch m -> m ()

-- | Get the set of branches whose hash matches the given prefix.
causalHashesByPrefix :: ShortCausalHash -> Transaction (Set CausalHash)

-- | Get the lowest common ancestor of two branches, i.e. the most recent
--   branch that is an ancestor of both branches.
lca :: MonadIO m => Codebase m v a -> Branch m -> Branch m -> m (Maybe (Branch m))
before :: CausalHash -> CausalHash -> Transaction Bool

-- | Recursively descend into causals following the given path, Use the
--   root causal if none is provided.
getShallowBranchAtPath :: Path -> Branch Transaction -> Transaction (Branch Transaction)

-- | Recursively descend into causals following the given path, Use the
--   root causal if none is provided.
getMaybeShallowBranchAtPath :: Path -> Branch Transaction -> Transaction (Maybe (Branch Transaction))

-- | Recursively descend into causals following the given path, Use the
--   root causal if none is provided.
getShallowCausalAtPath :: Path -> CausalBranch Transaction -> Transaction (CausalBranch Transaction)
expectCausalBranchByCausalHash :: CausalHash -> Transaction (CausalBranch Transaction)
getShallowCausalAtPathFromRootHash :: CausalHash -> Path -> Transaction (CausalBranch Transaction)
getShallowProjectBranchRoot :: ProjectBranch -> Transaction (Maybe (Branch Transaction))
expectShallowProjectBranchRoot :: ProjectBranch -> Transaction (Branch Transaction)

-- | Recursively descend into causals following the given path, Use the
--   root causal if none is provided.
getShallowBranchAtProjectPath :: ProjectPath -> Transaction (Branch Transaction)

-- | Recursively descend into causals following the given path, Use the
--   root causal if none is provided.
getMaybeShallowBranchAtProjectPath :: ProjectPath -> Transaction (Maybe (Branch Transaction))
getShallowProjectRootByNames :: ProjectAndBranch ProjectName ProjectBranchName -> Transaction (Maybe (CausalBranch Transaction))
expectProjectBranchRoot :: MonadIO m => Codebase m v a -> ProjectId -> ProjectBranchId -> m (Branch m)
getBranchAtProjectPath :: MonadIO m => Codebase m v a -> ProjectPath -> m (Maybe (Branch m))

-- | Starts loading the given project branch into cache in a background
--   thread without blocking.
preloadProjectBranch :: MonadUnliftIO m => Codebase m v a -> ProjectAndBranch ProjectId ProjectBranchId -> m ()

-- | Construct a <tt>ScopedNames</tt> which can produce names which are
--   relative to the provided Path.
--   
--   NOTE: this method requires an up-to-date name lookup index
namesAtPath :: BranchHash -> Path -> Transaction Names

-- | Check whether the given patch exists in the codebase.
patchExists :: PatchHash -> Transaction Bool
getPatch :: PatchHash -> Transaction (Maybe Patch)

-- | Put a patch into the codebase.
--   
--   Note that <a>putBranch</a> may also put patches.
putPatch :: PatchHash -> Patch -> Transaction ()

-- | <tt>getWatch k r</tt> returns watch result <tt>t</tt> that was
--   previously put by <tt>putWatch k r t</tt>.
($sel:getWatch:Codebase) :: Codebase m v a -> WatchKind -> TermReferenceId -> Transaction (Maybe (Term v a))

-- | Like <a>$sel:getWatch:Codebase</a>, but first looks up the given
--   reference as a regular watch, then as a test watch.
--   
--   <pre>
--   lookupWatchCache codebase ref =
--     runMaybeT do
--       MaybeT (getWatch codebase RegularWatch ref)
--         <a>|</a> MaybeT (getWatch codebase TestWatch ref))
--   </pre>
lookupWatchCache :: Codebase m v a -> Id -> Transaction (Maybe (Term v a))

-- | <tt>watches k</tt> returns all of the references <tt>r</tt> that were
--   previously put by a <tt>putWatch k r t</tt>. <tt>t</tt> can be
--   retrieved by <tt>getWatch k r</tt>.
watches :: WatchKind -> Transaction [Id]

-- | <tt>putWatch k r t</tt> puts a watch of kind <tt>k</tt>, with
--   hash-of-expression <tt>r</tt> and decompiled result <tt>t</tt> into
--   the codebase.
--   
--   For example, in the watch expression below, <tt>k</tt> is
--   <a>Regular</a>, <tt>r</tt> is the hash of <tt>x</tt>, and <tt>t</tt>
--   is <tt>7</tt>.
--   
--   <pre>
--   &gt; x = 3 + 4
--     ⧩
--     7
--   </pre>
putWatch :: WatchKind -> Id -> Term Symbol Ann -> Transaction ()

-- | Delete all watches that were put by <tt>putWatch</tt>.
clearWatches :: Transaction ()

-- | Gets the specified number of reflog entries in chronological order,
--   most recent first.
getDeprecatedRootReflog :: Int -> Transaction [Entry CausalHash Text]

-- | Gets the specified number of reflog entries for the specified
--   ProjectBranch in chronological order, most recent first.
getProjectBranchReflog :: Int -> ProjectBranchId -> Transaction [Entry Project ProjectBranch CausalHash]

-- | Gets the specified number of reflog entries for the given project in
--   chronological order, most recent first.
getProjectReflog :: Int -> ProjectId -> Transaction [Entry Project ProjectBranch CausalHash]

-- | Gets the specified number of reflog entries in chronological order,
--   most recent first.
getGlobalReflog :: Int -> Transaction [Entry Project ProjectBranch CausalHash]

-- | The number of base32 characters needed to distinguish any two
--   references in the codebase.
hashLength :: Transaction Int

-- | The number of base32 characters needed to distinguish any two branch
--   in the codebase.
branchHashLength :: Transaction Int

-- | Get the set of terms, type declarations, and builtin types that depend
--   on the given term, type declaration, or builtin type.
dependents :: DependentsSelector -> Reference -> Transaction (Set Reference)
dependentsOfComponent :: Hash -> Transaction (Set Reference)
getCodebaseDir :: MonadIO m => Maybe CodebasePath -> m CodebasePath

-- | A directory that contains a codebase.
type CodebasePath = FilePath

-- | Run a transaction on a codebase.
runTransaction :: MonadIO m => Codebase m v a -> Transaction b -> m b
runTransactionWithRollback :: MonadIO m => Codebase m v a -> ((forall void. b -> Transaction void) -> Transaction b) -> m b

-- | Acquire a new connection to the same underlying database file this
--   codebase object connects to.
($sel:withConnection:Codebase) :: Codebase m v a -> forall x. (Connection -> m x) -> m x

-- | Acquire a new connection to the same underlying database file this
--   codebase object connects to.
($sel:withConnectionIO:Codebase) :: Codebase m v a -> forall x. (Connection -> IO x) -> IO x
addDefsToCodebase :: forall m v a. (Var v, Show a) => Codebase m v a -> TypecheckedUnisonFile v a -> Transaction ()
componentReferencesForReference :: Reference -> Transaction (Set Reference)

-- | Write all of UCM's dependencies (builtins types and an empty
--   namespace) into the codebase
installUcmDependencies :: Codebase m Symbol Ann -> Transaction ()

-- | Make a <tt>TypeLookup</tt> that is suitable for looking up information
--   about all of the given type-or-term references, and all of their type
--   dependencies, including builtins.
typeLookupForDependencies :: Codebase IO Symbol Ann -> DefnsF Set TermReference TypeReference -> Transaction (TypeLookup Symbol Ann)
unsafeGetComponentLength :: HasCallStack => Hash -> Transaction CycleSize

-- | Often we need to assign something to an empty causal, this ensures the
--   empty causal exists in the codebase and returns its hash.
emptyCausalHash :: Transaction (CausalHash, CausalHashId)

module Unison.PrettyPrintEnvDecl.Sqlite

-- | Given a set of references, return a PPE which contains names for only
--   those references. Names are limited to those within the provided
--   perspective
ppedForReferences :: NamesPerspective -> Set LabeledDependency -> Transaction PrettyPrintEnvDecl

module Unison.Codebase.SqliteCodebase.Paths

-- | Prefer makeCodebasePath or makeCodebaseDirPath when possible.
codebasePath :: FilePath

-- | Makes a path to a sqlite database from a codebase path.
makeCodebasePath :: CodebasePath -> FilePath

-- | Makes a path to the location where sqlite files are stored within a
--   codebase path.
makeCodebaseDirPath :: CodebasePath -> FilePath

-- | Makes a path to store a backup of a sqlite database given the current
--   time.
backupCodebasePath :: SchemaVersion -> NominalDiffTime -> FilePath
lockfilePath :: CodebasePath -> FilePath

module Unison.Codebase.SqliteCodebase.Migrations.MigrateSchema5To6

-- | The 5 to 6 migration adds the reflog as a table in the DB
migrateSchema5To6 :: CodebasePath -> Transaction ()

module Unison.Codebase.SqliteCodebase.Migrations.MigrateSchema16To17

-- | This migration converts the codebase from having all projects in a
--   single codebase root to having separate causal roots for each project
--   branch. It:
--   
--   <ul>
--   <li>Adds the new project reflog table</li>
--   <li>Adds the project-branch head as a causal-hash-id column on the
--   project-branch table, and populates it from all the projects in the
--   project root.</li>
--   <li>Makes a new legacy project from the existing root branch (minus
--   .__projects)</li>
--   <li>Adds a new scratch/main project</li>
--   <li>Adds a currentProjectPath table to replace the most-recent-path
--   functionality.</li>
--   </ul>
--   
--   It requires a Connection argument rather than working inside a
--   Transaction because it needs to temporarily disable foreign key
--   checking, and the foreign_key pragma cannot be set within a
--   transaction.
migrateSchema16To17 :: Connection -> IO ()
instance GHC.Exception.Type.Exception Unison.Codebase.SqliteCodebase.Migrations.MigrateSchema16To17.ForeignKeyFailureException
instance GHC.Show.Show Unison.Codebase.SqliteCodebase.Migrations.MigrateSchema16To17.ForeignKeyFailureException

module Unison.Codebase.Init.Type
data Init m v a
Init :: (DebugName -> CodebasePath -> m (Either Pretty (m (), Codebase m v a))) -> (DebugName -> CodebasePath -> m (Either CreateCodebaseError (m (), Codebase m v a))) -> (CodebasePath -> CodebasePath) -> Init m v a

-- | open an existing codebase
[$sel:openCodebase:Init] :: Init m v a -> DebugName -> CodebasePath -> m (Either Pretty (m (), Codebase m v a))

-- | create a new codebase
[$sel:createCodebase':Init] :: Init m v a -> DebugName -> CodebasePath -> m (Either CreateCodebaseError (m (), Codebase m v a))

-- | given a codebase root, and given that the codebase root may have other
--   junk in it, give the path to the "actual" files; e.g. what a forked
--   transcript should clone.
[$sel:codebasePath:Init] :: Init m v a -> CodebasePath -> CodebasePath

module Unison.Codebase.FileCodebase
codebaseExists :: MonadIO m => CodebasePath -> m Bool

module Unison.Codebase.Init
data Init m v a
Init :: (forall r. DebugName -> CodebasePath -> CodebaseLockOption -> MigrationStrategy -> (Codebase m v a -> m r) -> m (Either OpenCodebaseError r)) -> (forall r. DebugName -> CodebasePath -> CodebaseLockOption -> (Codebase m v a -> m r) -> m (Either CreateCodebaseError r)) -> (CodebasePath -> CodebasePath) -> Init m v a

-- | open an existing codebase
[$sel:withOpenCodebase:Init] :: Init m v a -> forall r. DebugName -> CodebasePath -> CodebaseLockOption -> MigrationStrategy -> (Codebase m v a -> m r) -> m (Either OpenCodebaseError r)

-- | create a new codebase
[$sel:withCreatedCodebase:Init] :: Init m v a -> forall r. DebugName -> CodebasePath -> CodebaseLockOption -> (Codebase m v a -> m r) -> m (Either CreateCodebaseError r)

-- | given a codebase root, and given that the codebase root may have other
--   junk in it, give the path to the "actual" files; e.g. what a forked
--   transcript should clone.
[$sel:codebasePath:Init] :: Init m v a -> CodebasePath -> CodebasePath
type DebugName = String

-- | An error that occurred while initializing a codebase.
data InitError
FoundV1Codebase :: InitError
InitErrorOpen :: OpenCodebaseError -> InitError
CouldntCreateCodebase :: Pretty -> InitError
data CodebaseInitOptions
Home :: CodebasePath -> CodebaseInitOptions
Specified :: SpecifiedCodebase -> CodebaseInitOptions
data CodebaseLockOption
DoLock :: CodebaseLockOption
DontLock :: CodebaseLockOption
data InitResult
OpenedCodebase :: InitResult
CreatedCodebase :: InitResult
data SpecifiedCodebase
CreateWhenMissing :: CodebasePath -> SpecifiedCodebase
DontCreateWhenMissing :: CodebasePath -> SpecifiedCodebase
data MigrationStrategy

-- | Perform a migration immediately if one is required.
MigrateAutomatically :: BackupStrategy -> VacuumStrategy -> MigrationStrategy

-- | Prompt the user that a migration is about to occur, continue after
--   acknownledgment
MigrateAfterPrompt :: BackupStrategy -> VacuumStrategy -> MigrationStrategy

-- | Triggers an <a>OpenCodebaseRequiresMigration</a> error instead of
--   migrating
DontMigrate :: MigrationStrategy
data BackupStrategy
Backup :: BackupStrategy
NoBackup :: BackupStrategy
data VacuumStrategy
Vacuum :: VacuumStrategy
NoVacuum :: VacuumStrategy
type Pretty = Pretty ColorText
createCodebase :: MonadIO m => Init m v a -> DebugName -> CodebasePath -> CodebaseLockOption -> (Codebase m v a -> m r) -> m (Either Pretty r)

-- | try to init a codebase where none exists and then exit regardless
--   (i.e. `ucm --codebase dir init`)
initCodebaseAndExit :: MonadIO m => Init m Symbol Ann -> Verbosity -> DebugName -> Maybe CodebasePath -> CodebaseLockOption -> m ()
withOpenOrCreateCodebase :: MonadIO m => Init m v a -> DebugName -> CodebaseInitOptions -> CodebaseLockOption -> MigrationStrategy -> ((InitResult, CodebasePath, Codebase m v a) -> m r) -> m (Either (CodebasePath, InitError) r)
withNewUcmCodebaseOrExit :: MonadIO m => Init m Symbol Ann -> Verbosity -> DebugName -> CodebasePath -> CodebaseLockOption -> (Codebase m Symbol Ann -> m r) -> m r
withTemporaryUcmCodebase :: MonadUnliftIO m => Init m Symbol Ann -> Verbosity -> DebugName -> CodebaseLockOption -> ((CodebasePath, Codebase m Symbol Ann) -> m r) -> m r
instance GHC.Classes.Ord Unison.Codebase.Init.BackupStrategy
instance GHC.Classes.Eq Unison.Codebase.Init.BackupStrategy
instance GHC.Show.Show Unison.Codebase.Init.BackupStrategy
instance GHC.Classes.Ord Unison.Codebase.Init.VacuumStrategy
instance GHC.Classes.Eq Unison.Codebase.Init.VacuumStrategy
instance GHC.Show.Show Unison.Codebase.Init.VacuumStrategy
instance GHC.Classes.Ord Unison.Codebase.Init.MigrationStrategy
instance GHC.Classes.Eq Unison.Codebase.Init.MigrationStrategy
instance GHC.Show.Show Unison.Codebase.Init.MigrationStrategy
instance GHC.Classes.Eq Unison.Codebase.Init.InitError
instance GHC.Show.Show Unison.Codebase.Init.InitError
instance GHC.Classes.Eq Unison.Codebase.Init.InitResult
instance GHC.Show.Show Unison.Codebase.Init.InitResult

module Unison.Codebase.SqliteCodebase.Migrations

-- | Mapping from schema version to the migration required to get there.
--   E.g. The migration at index 2 must be run on a codebase at version 1.
migrations :: MVar ConsoleRegion -> (Reference -> Transaction ConstructorType) -> TVar (Map Hash TermBufferEntry) -> TVar (Map Hash DeclBufferEntry) -> CodebasePath -> Map SchemaVersion (Connection -> IO ())
data CodebaseVersionStatus
CodebaseUpToDate :: CodebaseVersionStatus
CodebaseUnknownSchemaVersion :: SchemaVersion -> CodebaseVersionStatus
CodebaseRequiresMigration :: SchemaVersion -> SchemaVersion -> CodebaseVersionStatus
checkCodebaseIsUpToDate :: Transaction CodebaseVersionStatus

-- | Migrates a codebase up to the most recent version known to ucm. This
--   is a No-op if it's up to date Returns an error if the schema version
--   is newer than this ucm knows about.
ensureCodebaseIsUpToDate :: MonadIO m => LocalOrRemote -> CodebasePath -> (Reference -> Transaction ConstructorType) -> TVar (Map Hash TermBufferEntry) -> TVar (Map Hash DeclBufferEntry) -> Bool -> BackupStrategy -> VacuumStrategy -> Connection -> m (Either OpenCodebaseError ())

-- | If we need to make a backup, then copy the sqlite database to a new
--   file with a unique name based on current time.
backupCodebaseIfNecessary :: BackupStrategy -> LocalOrRemote -> Connection -> SchemaVersion -> SchemaVersion -> CodebasePath -> IO ()
runIntegrityChecks :: MVar ConsoleRegion -> Transaction ()
instance GHC.Show.Show Unison.Codebase.SqliteCodebase.Migrations.CodebaseVersionStatus
instance GHC.Classes.Ord Unison.Codebase.SqliteCodebase.Migrations.CodebaseVersionStatus
instance GHC.Classes.Eq Unison.Codebase.SqliteCodebase.Migrations.CodebaseVersionStatus

module Unison.Codebase.SqliteCodebase
init :: (HasCallStack, MonadUnliftIO m) => Init m Symbol Ann

-- | Like <a>init</a>, but allows passing in an action to be perform when a
--   new codebase is created.
initWithSetup :: (HasCallStack, MonadUnliftIO m) => Transaction () -> Init m Symbol Ann
data MigrationStrategy

-- | Perform a migration immediately if one is required.
MigrateAutomatically :: BackupStrategy -> VacuumStrategy -> MigrationStrategy

-- | Prompt the user that a migration is about to occur, continue after
--   acknownledgment
MigrateAfterPrompt :: BackupStrategy -> VacuumStrategy -> MigrationStrategy

-- | Triggers an <a>OpenCodebaseRequiresMigration</a> error instead of
--   migrating
DontMigrate :: MigrationStrategy
data BackupStrategy
Backup :: BackupStrategy
NoBackup :: BackupStrategy
data VacuumStrategy
Vacuum :: VacuumStrategy
NoVacuum :: VacuumStrategy
data CodebaseLockOption
DoLock :: CodebaseLockOption
DontLock :: CodebaseLockOption

-- | Given two codebase roots (e.g. "./mycodebase"), safely copy the
--   codebase at the source to the destination. Note: this does not copy
--   the .unisonConfig file.
copyCodebase :: MonadIO m => CodebasePath -> CodebasePath -> m ()
instance GHC.Show.Show (Unison.Codebase.SqliteCodebase.Entity m)

module Unison.Util.TQueue
data TQueue a
TQueue :: TVar (Seq a) -> TVar Word64 -> TQueue a
newIO :: forall a m. MonadIO m => m (TQueue a)
size :: TQueue a -> STM Int
awaitSize :: Int -> TQueue a -> STM ()
peek :: TQueue a -> STM a
dequeue :: TQueue a -> STM a
undequeue :: TQueue a -> a -> STM ()
tryDequeue :: TQueue a -> STM (Maybe a)
dequeueN :: TQueue a -> Int -> STM [a]
enqueueCount :: TQueue a -> STM Word64
flush :: TQueue a -> STM [a]
enqueue :: TQueue a -> a -> STM ()
raceIO :: MonadIO m => STM a -> STM b -> m (Either a b)
tryPeekWhile :: (a -> Bool) -> TQueue a -> STM [a]
takeWhile :: (a -> Bool) -> TQueue a -> STM [a]
peekWhile :: (a -> Bool) -> TQueue a -> STM [a]

module Unison.Util.Text
newtype Text
Text :: Rope Chunk -> Text
data Chunk
Chunk :: {-# UNPACK #-} !Int -> {-# UNPACK #-} !Text -> Chunk
empty :: Text
one :: Char -> Text
singleton :: Char -> Text
appendUnbalanced :: Text -> Text -> Text
threshold :: Int
replicate :: Int -> Text -> Text
toLazyText :: Text -> Text
chunkToText :: Chunk -> Text
chunk :: Text -> Chunk
take :: Int -> Text -> Text
drop :: Int -> Text -> Text
uncons :: Text -> Maybe (Char, Text)
unsnoc :: Text -> Maybe (Text, Char)
unconsChunk :: Text -> Maybe (Chunk, Text)
unsnocChunk :: Text -> Maybe (Text, Chunk)
at :: Int -> Text -> Maybe Char
size :: Text -> Int
reverse :: Text -> Text
toUppercase :: Text -> Text
toLowercase :: Text -> Text
fromUtf8 :: Bytes -> Either String Text
toUtf8 :: Text -> Bytes
fromText :: Text -> Text
pack :: String -> Text
toString :: Text -> String
unpack :: Text -> String
toText :: Text -> Text
indexOf :: Text -> Text -> Maybe Word64

-- | Return the ordinal representation of a number in English. A number
--   ending with '1' must finish with <tt>st</tt> A number ending with '2'
--   must finish with <tt>nd</tt> A number ending with '3' must finish with
--   <tt>rd</tt> _except_ for 11, 12, and 13 which must finish with
--   <tt>th</tt>
ordinal :: IsString s => Int -> s
dropTextWhileMax :: (Char -> Bool) -> Int -> Text -> (Int, Text)
dropWhileMax :: (Char -> Bool) -> Int -> Text -> (Int, Text)
instance GHC.Base.Monoid Unison.Util.Text.Text
instance GHC.Base.Semigroup Unison.Util.Text.Text
instance GHC.Classes.Ord Unison.Util.Text.Text
instance GHC.Classes.Eq Unison.Util.Text.Text
instance Unison.Util.Rope.Sized Unison.Util.Text.Text
instance GHC.Show.Show Unison.Util.Text.Text
instance Data.String.IsString Unison.Util.Text.Text
instance GHC.Classes.Eq Unison.Util.Text.Chunk
instance GHC.Classes.Ord Unison.Util.Text.Chunk
instance GHC.Base.Semigroup Unison.Util.Text.Chunk
instance GHC.Base.Monoid Unison.Util.Text.Chunk
instance Unison.Util.Rope.Sized Unison.Util.Text.Chunk
instance Unison.Util.Rope.Drop Unison.Util.Text.Chunk
instance Unison.Util.Rope.Take Unison.Util.Text.Chunk
instance Unison.Util.Rope.Index Unison.Util.Text.Chunk GHC.Types.Char
instance Unison.Util.Rope.Reverse Unison.Util.Text.Chunk

module Unison.PrintError
type Env = PrettyPrintEnv
defaultWidth :: Width
prettyParseError :: forall v. Var v => String -> Err v -> Pretty ColorText

-- | Pretty prints resolution failure annotations, including a table of
--   disambiguation suggestions.
prettyResolutionFailures :: forall a. (Annotated a, Ord a) => String -> [ResolutionFailure a] -> Pretty ColorText
prettyVar :: Var v => v -> Pretty ColorText
printNoteWithSource :: (Var v, Annotated a, Show a, Ord a) => Env -> String -> Note v a -> Pretty ColorText
renderCompilerBug :: (Var v, Annotated loc, Ord loc, Show loc) => Env -> String -> CompilerBug v loc -> Pretty ColorText
renderNoteAsANSI :: (Var v, Annotated a, Show a, Ord a) => Width -> Env -> String -> Note v a -> String
renderParseErrorAsANSI :: Var v => Width -> String -> Err v -> String
renderParseErrors :: forall v. Var v => String -> Err v -> [(Pretty ColorText, [Range])]

module Unison.Parsers
unsafeGetRightFrom :: (Var v, Show v) => String -> Either (Err v) a -> a
parse :: (Monad m, Var v) => P v m a -> String -> ParsingEnv m -> m (Either (Err v) a)
parseTerm :: (Monad m, Var v) => String -> ParsingEnv m -> m (Either (Err v) (Term v Ann))
parseType :: (Monad m, Var v) => String -> ParsingEnv m -> m (Either (Err v) (Type v Ann))
parseFile :: (Monad m, Var v) => FilePath -> String -> ParsingEnv m -> m (Either (Err v) (UnisonFile v Ann))
readAndParseFile :: (MonadIO m, Var v) => ParsingEnv m -> FilePath -> m (Either (Err v) (UnisonFile v Ann))
unsafeParseTerm :: (Monad m, Var v) => String -> ParsingEnv m -> m (Term v Ann)
unsafeReadAndParseFile :: ParsingEnv IO -> FilePath -> IO (UnisonFile Symbol Ann)
unsafeParseFileBuiltinsOnly :: FilePath -> IO (UnisonFile Symbol Ann)
unsafeParseFile :: Monad m => String -> ParsingEnv m -> m (UnisonFile Symbol Ann)

module Unison.Util.Text.Pattern
data Pattern
Join :: [Pattern] -> Pattern
Or :: Pattern -> Pattern -> Pattern
Capture :: Pattern -> Pattern
CaptureAs :: Text -> Pattern -> Pattern
Many :: Bool -> Pattern -> Pattern
Replicate :: Int -> Int -> Pattern -> Pattern
Eof :: Pattern
Literal :: Text -> Pattern
Char :: CharPattern -> Pattern
data CharPattern
Any :: CharPattern
Not :: CharPattern -> CharPattern
Union :: CharPattern -> CharPattern -> CharPattern
Intersect :: CharPattern -> CharPattern -> CharPattern
CharRange :: Char -> Char -> CharPattern
CharSet :: [Char] -> CharPattern
CharClass :: CharClass -> CharPattern
data CharClass
AlphaNum :: CharClass
Upper :: CharClass
Lower :: CharClass
Whitespace :: CharClass
Control :: CharClass
Printable :: CharClass
MarkChar :: CharClass
Number :: CharClass
Punctuation :: CharClass
Symbol :: CharClass
Separator :: CharClass
Letter :: CharClass
data CPattern
CP :: Pattern -> (Text -> Maybe ([Text], Text)) -> CPattern
cpattern :: Pattern -> CPattern
run :: Pattern -> Text -> Maybe ([Text], Text)
data Stack
Empty :: !Captures -> Stack
Mark :: !Captures -> !Text -> !Stack -> Stack
type Captures = [Text] -> [Text]
stackCaptures :: Stack -> Captures
pushCaptures :: Captures -> Stack -> Stack
pushCapture :: Text -> Stack -> Stack
appendCaptures :: Captures -> Captures -> Captures
emptyCaptures :: Captures
capturesToList :: Captures -> [Text]
type Compiled r = (Stack -> Text -> r) -> (Stack -> Text -> r) -> Stack -> Text -> r
compile :: Pattern -> Compiled r
charInPred :: [Char] -> Char -> Bool
charNotInPred :: [Char] -> Char -> Bool
charPatternPred :: CharPattern -> Char -> Bool
charClassPred :: CharClass -> Char -> Bool
try :: String -> Compiled r -> Compiled r
instance GHC.Classes.Ord Unison.Util.Text.Pattern.CharClass
instance GHC.Classes.Eq Unison.Util.Text.Pattern.CharClass
instance GHC.Show.Show Unison.Util.Text.Pattern.CharClass
instance GHC.Classes.Ord Unison.Util.Text.Pattern.CharPattern
instance GHC.Classes.Eq Unison.Util.Text.Pattern.CharPattern
instance GHC.Show.Show Unison.Util.Text.Pattern.CharPattern
instance GHC.Classes.Ord Unison.Util.Text.Pattern.Pattern
instance GHC.Classes.Eq Unison.Util.Text.Pattern.Pattern
instance GHC.Show.Show Unison.Util.Text.Pattern.Pattern
instance GHC.Classes.Eq Unison.Util.Text.Pattern.CPattern
instance GHC.Classes.Ord Unison.Util.Text.Pattern.CPattern

module Unison.Util.TransitiveClosure
transitiveClosure :: forall m a. (Monad m, Ord a) => (a -> m (Set a)) -> Set a -> m (Set a)
transitiveClosure' :: Ord a => (a -> Set a) -> Set a -> Set a
transitiveClosure1 :: forall m a. (Monad m, Ord a) => (a -> m (Set a)) -> a -> m (Set a)
transitiveClosure1' :: Ord a => (a -> Set a) -> a -> Set a
