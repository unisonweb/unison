-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Monadic parser combinators
--   
--   This is an industrial-strength monadic parser combinator library.
--   Megaparsec is a feature-rich package that tries to find a nice balance
--   between speed, flexibility, and quality of parse errors.
@package megaparsec
@version 9.5.0


-- | Textual source position. The position includes name of file, line
--   number, and column number.
--   
--   You probably do not want to import this module directly because
--   <a>Text.Megaparsec</a> re-exports it anyway.
module Text.Megaparsec.Pos

-- | <a>Pos</a> is the type for positive integers. This is used to
--   represent line number, column number, and similar things like
--   indentation level. <a>Semigroup</a> instance can be used to safely and
--   efficiently add <a>Pos</a>es together.
data Pos

-- | Construction of <a>Pos</a> from <a>Int</a>. The function throws
--   <a>InvalidPosException</a> when given a non-positive argument.
mkPos :: Int -> Pos

-- | Extract <a>Int</a> from <a>Pos</a>.
unPos :: Pos -> Int

-- | Position with value 1.
pos1 :: Pos

-- | Value of tab width used by default. Always prefer this constant when
--   you want to refer to the default tab width because actual value
--   <i>may</i> change in future.
--   
--   Currently:
--   
--   <pre>
--   defaultTabWidth = mkPos 8
--   </pre>
defaultTabWidth :: Pos

-- | The exception is thrown by <a>mkPos</a> when its argument is not a
--   positive number.
newtype InvalidPosException

-- | Contains the actual value that was passed to <a>mkPos</a>
InvalidPosException :: Int -> InvalidPosException

-- | The data type <a>SourcePos</a> represents source positions. It
--   contains the name of the source file, a line number, and a column
--   number. Source line and column positions change intensively during
--   parsing, so we need to make them strict to avoid memory leaks.
data SourcePos
SourcePos :: FilePath -> !Pos -> !Pos -> SourcePos

-- | Name of source file
[sourceName] :: SourcePos -> FilePath

-- | Line number
[sourceLine] :: SourcePos -> !Pos

-- | Column number
[sourceColumn] :: SourcePos -> !Pos

-- | Construct initial position (line 1, column 1) given name of source
--   file.
initialPos :: FilePath -> SourcePos

-- | Pretty-print a <a>SourcePos</a>.
sourcePosPretty :: SourcePos -> String
instance Control.DeepSeq.NFData Text.Megaparsec.Pos.Pos
instance GHC.Generics.Generic Text.Megaparsec.Pos.Pos
instance Data.Data.Data Text.Megaparsec.Pos.Pos
instance GHC.Classes.Ord Text.Megaparsec.Pos.Pos
instance GHC.Classes.Eq Text.Megaparsec.Pos.Pos
instance GHC.Show.Show Text.Megaparsec.Pos.Pos
instance GHC.Generics.Generic Text.Megaparsec.Pos.InvalidPosException
instance Data.Data.Data Text.Megaparsec.Pos.InvalidPosException
instance GHC.Show.Show Text.Megaparsec.Pos.InvalidPosException
instance GHC.Classes.Eq Text.Megaparsec.Pos.InvalidPosException
instance GHC.Generics.Generic Text.Megaparsec.Pos.SourcePos
instance Data.Data.Data Text.Megaparsec.Pos.SourcePos
instance GHC.Classes.Ord Text.Megaparsec.Pos.SourcePos
instance GHC.Classes.Eq Text.Megaparsec.Pos.SourcePos
instance GHC.Read.Read Text.Megaparsec.Pos.SourcePos
instance GHC.Show.Show Text.Megaparsec.Pos.SourcePos
instance Control.DeepSeq.NFData Text.Megaparsec.Pos.SourcePos
instance GHC.Exception.Type.Exception Text.Megaparsec.Pos.InvalidPosException
instance Control.DeepSeq.NFData Text.Megaparsec.Pos.InvalidPosException
instance GHC.Base.Semigroup Text.Megaparsec.Pos.Pos
instance GHC.Read.Read Text.Megaparsec.Pos.Pos


-- | Megaparsec's input stream facilities.
--   
--   You probably do not want to import this module directly because
--   <a>Text.Megaparsec</a> re-exports it anyway.
module Text.Megaparsec.Stream

-- | Type class for inputs that can be consumed by the library.
--   
--   Note that the <a>Stream</a> instances for <tt>Text</tt> and
--   <tt>ByteString</tt> (strict and lazy) default to "input sharing" (see
--   <a>ShareInput</a>, <a>NoShareInput</a>). We plan to move away from
--   input sharing in a future major release; if you want to retain the
--   current behaviour and are concerned with maximum performance you
--   should consider using the <a>ShareInput</a> wrapper explicitly.
--   
--   <b>Note</b>: before the version <i>9.0.0</i> the class included the
--   methods from <a>VisualStream</a> and <a>TraversableStream</a>.
class (Ord (Token s), Ord (Tokens s)) => Stream s where {
    
    -- | Type of token in the stream.
    type Token s :: Type;
    
    -- | Type of “chunk” of the stream.
    type Tokens s :: Type;
}

-- | Lift a single token to chunk of the stream. The default implementation
--   is:
--   
--   <pre>
--   tokenToChunk pxy = tokensToChunk pxy . pure
--   </pre>
--   
--   However for some types of stream there may be a more efficient way to
--   lift.
tokenToChunk :: Stream s => Proxy s -> Token s -> Tokens s

-- | The first method that establishes isomorphism between list of tokens
--   and chunk of the stream. Valid implementation should satisfy:
--   
--   <pre>
--   chunkToTokens pxy (tokensToChunk pxy ts) == ts
--   </pre>
tokensToChunk :: Stream s => Proxy s -> [Token s] -> Tokens s

-- | The second method that establishes isomorphism between list of tokens
--   and chunk of the stream. Valid implementation should satisfy:
--   
--   <pre>
--   tokensToChunk pxy (chunkToTokens pxy chunk) == chunk
--   </pre>
chunkToTokens :: Stream s => Proxy s -> Tokens s -> [Token s]

-- | Return length of a chunk of the stream.
chunkLength :: Stream s => Proxy s -> Tokens s -> Int

-- | Check if a chunk of the stream is empty. The default implementation is
--   in terms of the more general <a>chunkLength</a>:
--   
--   <pre>
--   chunkEmpty pxy ts = chunkLength pxy ts &lt;= 0
--   </pre>
--   
--   However for many streams there may be a more efficient implementation.
chunkEmpty :: Stream s => Proxy s -> Tokens s -> Bool

-- | Extract a single token form the stream. Return <a>Nothing</a> if the
--   stream is empty.
take1_ :: Stream s => s -> Maybe (Token s, s)

-- | <tt><a>takeN_</a> n s</tt> should try to extract a chunk of length
--   <tt>n</tt>, or if the stream is too short, the rest of the stream.
--   Valid implementation should follow the rules:
--   
--   <ul>
--   <li>If the requested length <tt>n</tt> is 0 (or less), <a>Nothing</a>
--   should never be returned, instead <tt><a>Just</a> ("", s)</tt> should
--   be returned, where <tt>""</tt> stands for the empty chunk, and
--   <tt>s</tt> is the original stream (second argument).</li>
--   <li>If the requested length is greater than 0 and the stream is empty,
--   <a>Nothing</a> should be returned indicating end of input.</li>
--   <li>In other cases, take chunk of length <tt>n</tt> (or shorter if the
--   stream is not long enough) from the input stream and return the chunk
--   along with the rest of the stream.</li>
--   </ul>
takeN_ :: Stream s => Int -> s -> Maybe (Tokens s, s)

-- | Extract chunk of the stream taking tokens while the supplied predicate
--   returns <a>True</a>. Return the chunk and the rest of the stream.
--   
--   For many types of streams, the method allows for significant
--   performance improvements, although it is not strictly necessary from
--   conceptual point of view.
takeWhile_ :: Stream s => (Token s -> Bool) -> s -> (Tokens s, s)

-- | This wrapper selects the input-sharing <a>Stream</a> implementation
--   for <a>Text</a> (<a>Text</a>) and <a>ByteString</a>
--   (<a>ByteString</a>). By input sharing we mean that our parsers will
--   use slices whenever possible to avoid having to copy parts of the
--   input. See also the documentation of <a>split</a>.
--   
--   Note that using slices is in general faster than copying; on the other
--   hand it also has the potential for causing surprising memory leaks: if
--   any slice of the input survives in the output, holding on to the
--   output will force the entire input <a>Text</a>/<a>ByteString</a> to
--   stay in memory! Even when using lazy <a>Text</a>/<a>ByteString</a> we
--   will hold on to whole chunks at a time leading to to significantly
--   worse memory residency in some cases.
--   
--   See <a>NoShareInput</a> for a somewhat slower implementation that
--   avoids this memory leak scenario.
newtype ShareInput a
ShareInput :: a -> ShareInput a
[unShareInput] :: ShareInput a -> a

-- | This wrapper selects the no-input-sharing <a>Stream</a> implementation
--   for <a>Text</a> (<a>Text</a>) and <a>ByteString</a>
--   (<a>ByteString</a>). This means that our parsers will create
--   independent copies rather than using slices of the input. See also the
--   documentation of <a>copy</a>.
--   
--   More importantly, any parser output will be independent of the input,
--   and holding on to parts of the output will never prevent the input
--   from being garbage collected.
--   
--   For maximum performance you might consider using <a>ShareInput</a>
--   instead, but beware of its pitfalls!
newtype NoShareInput a
NoShareInput :: a -> NoShareInput a
[unNoShareInput] :: NoShareInput a -> a

-- | Type class for inputs that can also be used for debugging.
class (Stream s) => VisualStream s

-- | Pretty-print non-empty stream of tokens. This function is also used to
--   print single tokens (represented as singleton lists).
showTokens :: VisualStream s => Proxy s -> NonEmpty (Token s) -> String

-- | Return the number of characters that a non-empty stream of tokens
--   spans. The default implementation is sufficient if every token spans
--   exactly 1 character.
tokensLength :: VisualStream s => Proxy s -> NonEmpty (Token s) -> Int

-- | Type class for inputs that can also be used for error reporting.
class (Stream s) => TraversableStream s

-- | Given an offset <tt>o</tt> and initial <a>PosState</a>, adjust the
--   state in such a way that it starts at the offset.
--   
--   Return two values (in order):
--   
--   <ul>
--   <li><a>Maybe</a> <a>String</a> representing the line on which the
--   given offset <tt>o</tt> is located. It can be omitted (i.e.
--   <a>Nothing</a>); in that case error reporting functions will not show
--   offending lines. If returned, the line should satisfy a number of
--   conditions that are described below.</li>
--   <li>The updated <a>PosState</a> which can be in turn used to locate
--   another offset <tt>o'</tt> given that <tt>o' &gt;= o</tt>.</li>
--   </ul>
--   
--   The <a>String</a> representing the offending line in input stream
--   should satisfy the following:
--   
--   <ul>
--   <li>It should adequately represent location of token at the offset of
--   interest, that is, character at <a>sourceColumn</a> of the returned
--   <a>SourcePos</a> should correspond to the token at the offset
--   <tt>o</tt>.</li>
--   <li>It should not include the newline at the end.</li>
--   <li>It should not be empty, if the line happens to be empty, it should
--   be replaced with the string <tt>"&lt;empty line&gt;"</tt>.</li>
--   <li>Tab characters should be replaced by appropriate number of spaces,
--   which is determined by the <a>pstateTabWidth</a> field of
--   <a>PosState</a>.</li>
--   </ul>
--   
--   <b>Note</b>: type signature of the function was changed in the version
--   <i>9.0.0</i>.
reachOffset :: TraversableStream s => Int -> PosState s -> (Maybe String, PosState s)

-- | A version of <a>reachOffset</a> that may be faster because it doesn't
--   need to fetch the line at which the given offset in located.
--   
--   The default implementation is this:
--   
--   <pre>
--   reachOffsetNoLine o pst =
--     snd (reachOffset o pst)
--   </pre>
--   
--   <b>Note</b>: type signature of the function was changed in the version
--   <i>8.0.0</i>.
reachOffsetNoLine :: TraversableStream s => Int -> PosState s -> PosState s
instance Text.Megaparsec.Stream.TraversableStream GHC.Base.String
instance Text.Megaparsec.Stream.TraversableStream Data.ByteString.Internal.Type.ByteString
instance Text.Megaparsec.Stream.TraversableStream Data.ByteString.Lazy.Internal.ByteString
instance Text.Megaparsec.Stream.TraversableStream Data.Text.Internal.Text
instance Text.Megaparsec.Stream.TraversableStream Data.Text.Internal.Lazy.Text
instance Text.Megaparsec.Stream.VisualStream GHC.Base.String
instance Text.Megaparsec.Stream.VisualStream Data.ByteString.Internal.Type.ByteString
instance Text.Megaparsec.Stream.VisualStream Data.ByteString.Lazy.Internal.ByteString
instance Text.Megaparsec.Stream.VisualStream Data.Text.Internal.Text
instance Text.Megaparsec.Stream.VisualStream Data.Text.Internal.Lazy.Text
instance Text.Megaparsec.Stream.Stream (Text.Megaparsec.Stream.NoShareInput Data.ByteString.Internal.Type.ByteString)
instance Text.Megaparsec.Stream.Stream (Text.Megaparsec.Stream.NoShareInput Data.ByteString.Lazy.Internal.ByteString)
instance Text.Megaparsec.Stream.Stream (Text.Megaparsec.Stream.NoShareInput Data.Text.Internal.Text)
instance Text.Megaparsec.Stream.Stream (Text.Megaparsec.Stream.NoShareInput Data.Text.Internal.Lazy.Text)
instance Text.Megaparsec.Stream.Stream (Text.Megaparsec.Stream.ShareInput Data.ByteString.Internal.Type.ByteString)
instance Text.Megaparsec.Stream.Stream (Text.Megaparsec.Stream.ShareInput Data.ByteString.Lazy.Internal.ByteString)
instance Text.Megaparsec.Stream.Stream (Text.Megaparsec.Stream.ShareInput Data.Text.Internal.Text)
instance Text.Megaparsec.Stream.Stream (Text.Megaparsec.Stream.ShareInput Data.Text.Internal.Lazy.Text)
instance Text.Megaparsec.Stream.Stream Data.ByteString.Internal.Type.ByteString
instance Text.Megaparsec.Stream.Stream Data.ByteString.Lazy.Internal.ByteString
instance Text.Megaparsec.Stream.Stream Data.Text.Internal.Text
instance Text.Megaparsec.Stream.Stream Data.Text.Internal.Lazy.Text
instance GHC.Classes.Ord a => Text.Megaparsec.Stream.Stream [a]
instance GHC.Classes.Ord a => Text.Megaparsec.Stream.Stream (Data.Sequence.Internal.Seq a)


-- | Parse errors. The current version of Megaparsec supports typed errors
--   instead of <a>String</a>-based ones. This gives a lot of flexibility
--   in describing what exactly went wrong as well as a way to return
--   arbitrary data in case of failure.
--   
--   You probably do not want to import this module directly because
--   <a>Text.Megaparsec</a> re-exports it anyway.
module Text.Megaparsec.Error

-- | A data type that is used to represent “unexpected/expected” items in
--   <a>ParseError</a>. It is parametrized over the token type <tt>t</tt>.
data ErrorItem t

-- | Non-empty stream of tokens
Tokens :: NonEmpty t -> ErrorItem t

-- | Label (cannot be empty)
Label :: NonEmpty Char -> ErrorItem t

-- | End of input
EndOfInput :: ErrorItem t

-- | Additional error data, extendable by user. When no custom data is
--   necessary, the type is typically indexed by <a>Void</a> to “cancel”
--   the <a>ErrorCustom</a> constructor.
data ErrorFancy e

-- | <a>fail</a> has been used in parser monad
ErrorFail :: String -> ErrorFancy e

-- | Incorrect indentation error: desired ordering between reference level
--   and actual level, reference indentation level, actual indentation
--   level
ErrorIndentation :: Ordering -> Pos -> Pos -> ErrorFancy e

-- | Custom error data
ErrorCustom :: e -> ErrorFancy e

-- | <tt><a>ParseError</a> s e</tt> represents a parse error parametrized
--   over the stream type <tt>s</tt> and the custom data <tt>e</tt>.
--   
--   <a>Semigroup</a> and <a>Monoid</a> instances of the data type allow us
--   to merge parse errors from different branches of parsing. When merging
--   two <a>ParseError</a>s, the longest match is preferred; if positions
--   are the same, custom data sets and collections of message items are
--   combined. Note that fancy errors take precedence over trivial errors
--   in merging.
data ParseError s e

-- | Trivial errors, generated by the Megaparsec's machinery. The data
--   constructor includes the offset of error, unexpected token (if any),
--   and expected tokens.
--   
--   Type of the first argument was changed in the version <i>7.0.0</i>.
TrivialError :: Int -> Maybe (ErrorItem (Token s)) -> Set (ErrorItem (Token s)) -> ParseError s e

-- | Fancy, custom errors.
--   
--   Type of the first argument was changed in the version <i>7.0.0</i>.
FancyError :: Int -> Set (ErrorFancy e) -> ParseError s e

-- | Modify the custom data component in a parse error. This could be done
--   via <a>fmap</a> if not for the <a>Ord</a> constraint.
mapParseError :: Ord e' => (e -> e') -> ParseError s e -> ParseError s e'

-- | Get the offset of a <a>ParseError</a>.
errorOffset :: ParseError s e -> Int

-- | Set the offset of a <a>ParseError</a>.
setErrorOffset :: Int -> ParseError s e -> ParseError s e

-- | A non-empty collection of <a>ParseError</a>s equipped with
--   <a>PosState</a> that allows us to pretty-print the errors efficiently
--   and correctly.
data ParseErrorBundle s e
ParseErrorBundle :: NonEmpty (ParseError s e) -> PosState s -> ParseErrorBundle s e

-- | A collection of <a>ParseError</a>s that is sorted by parse error
--   offsets
[bundleErrors] :: ParseErrorBundle s e -> NonEmpty (ParseError s e)

-- | The state that is used for line/column calculation
[bundlePosState] :: ParseErrorBundle s e -> PosState s

-- | Attach <a>SourcePos</a>es to items in a <a>Traversable</a> container
--   given that there is a projection allowing us to get an offset per
--   item.
--   
--   Items must be in ascending order with respect to their offsets.
attachSourcePos :: (Traversable t, TraversableStream s) => (a -> Int) -> t a -> PosState s -> (t (a, SourcePos), PosState s)

-- | The type class defines how to print a custom component of
--   <a>ParseError</a>.
class (Ord a) => ShowErrorComponent a

-- | Pretty-print a component of <a>ParseError</a>.
showErrorComponent :: ShowErrorComponent a => a -> String

-- | Length of the error component in characters, used for highlighting of
--   parse errors in input string.
errorComponentLen :: ShowErrorComponent a => a -> Int

-- | Pretty-print a <a>ParseErrorBundle</a>. All <a>ParseError</a>s in the
--   bundle will be pretty-printed in order together with the corresponding
--   offending lines by doing a single pass over the input stream. The
--   rendered <a>String</a> always ends with a newline.
errorBundlePretty :: forall s e. (VisualStream s, TraversableStream s, ShowErrorComponent e) => ParseErrorBundle s e -> String

-- | Pretty-print a <a>ParseError</a>. The rendered <a>String</a> always
--   ends with a newline.
parseErrorPretty :: (VisualStream s, ShowErrorComponent e) => ParseError s e -> String

-- | Pretty-print a textual part of a <a>ParseError</a>, that is,
--   everything except for its position. The rendered <a>String</a> always
--   ends with a newline.
parseErrorTextPretty :: forall s e. (VisualStream s, ShowErrorComponent e) => ParseError s e -> String

-- | Pretty-print an <a>ErrorItem</a>.
showErrorItem :: VisualStream s => Proxy s -> ErrorItem (Token s) -> String
instance GHC.Base.Functor Text.Megaparsec.Error.ErrorItem
instance GHC.Generics.Generic (Text.Megaparsec.Error.ErrorItem t)
instance Data.Data.Data t => Data.Data.Data (Text.Megaparsec.Error.ErrorItem t)
instance GHC.Classes.Ord t => GHC.Classes.Ord (Text.Megaparsec.Error.ErrorItem t)
instance GHC.Classes.Eq t => GHC.Classes.Eq (Text.Megaparsec.Error.ErrorItem t)
instance GHC.Read.Read t => GHC.Read.Read (Text.Megaparsec.Error.ErrorItem t)
instance GHC.Show.Show t => GHC.Show.Show (Text.Megaparsec.Error.ErrorItem t)
instance GHC.Base.Functor Text.Megaparsec.Error.ErrorFancy
instance GHC.Generics.Generic (Text.Megaparsec.Error.ErrorFancy e)
instance Data.Data.Data e => Data.Data.Data (Text.Megaparsec.Error.ErrorFancy e)
instance GHC.Classes.Ord e => GHC.Classes.Ord (Text.Megaparsec.Error.ErrorFancy e)
instance GHC.Classes.Eq e => GHC.Classes.Eq (Text.Megaparsec.Error.ErrorFancy e)
instance GHC.Read.Read e => GHC.Read.Read (Text.Megaparsec.Error.ErrorFancy e)
instance GHC.Show.Show e => GHC.Show.Show (Text.Megaparsec.Error.ErrorFancy e)
instance GHC.Generics.Generic (Text.Megaparsec.Error.ParseError s e)
instance GHC.Generics.Generic (Text.Megaparsec.Error.ParseErrorBundle s e)
instance (GHC.Show.Show (Text.Megaparsec.Stream.Token s), GHC.Show.Show e) => GHC.Show.Show (Text.Megaparsec.Error.ParseError s e)
instance (GHC.Classes.Eq (Text.Megaparsec.Stream.Token s), GHC.Classes.Eq e) => GHC.Classes.Eq (Text.Megaparsec.Error.ParseError s e)
instance (Data.Data.Data s, Data.Data.Data (Text.Megaparsec.Stream.Token s), GHC.Classes.Ord (Text.Megaparsec.Stream.Token s), Data.Data.Data e, GHC.Classes.Ord e) => Data.Data.Data (Text.Megaparsec.Error.ParseError s e)
instance (GHC.Show.Show s, GHC.Show.Show (Text.Megaparsec.Stream.Token s), GHC.Show.Show e) => GHC.Show.Show (Text.Megaparsec.Error.ParseErrorBundle s e)
instance (GHC.Classes.Eq s, GHC.Classes.Eq (Text.Megaparsec.Stream.Token s), GHC.Classes.Eq e) => GHC.Classes.Eq (Text.Megaparsec.Error.ParseErrorBundle s e)
instance (Data.Data.Data s, Data.Data.Data (Text.Megaparsec.Stream.Token s), GHC.Classes.Ord (Text.Megaparsec.Stream.Token s), Data.Data.Data e, GHC.Classes.Ord e) => Data.Data.Data (Text.Megaparsec.Error.ParseErrorBundle s e)
instance (GHC.Show.Show s, GHC.Show.Show (Text.Megaparsec.Stream.Token s), GHC.Show.Show e, Text.Megaparsec.Error.ShowErrorComponent e, Text.Megaparsec.Stream.VisualStream s, Data.Typeable.Internal.Typeable s, Data.Typeable.Internal.Typeable e) => GHC.Exception.Type.Exception (Text.Megaparsec.Error.ParseError s e)
instance (GHC.Show.Show s, GHC.Show.Show (Text.Megaparsec.Stream.Token s), GHC.Show.Show e, Text.Megaparsec.Error.ShowErrorComponent e, Text.Megaparsec.Stream.VisualStream s, Text.Megaparsec.Stream.TraversableStream s, Data.Typeable.Internal.Typeable s, Data.Typeable.Internal.Typeable e) => GHC.Exception.Type.Exception (Text.Megaparsec.Error.ParseErrorBundle s e)
instance Text.Megaparsec.Error.ShowErrorComponent GHC.Base.Void
instance (Control.DeepSeq.NFData s, Control.DeepSeq.NFData (Text.Megaparsec.Stream.Token s), Control.DeepSeq.NFData e) => Control.DeepSeq.NFData (Text.Megaparsec.Error.ParseErrorBundle s e)
instance (Control.DeepSeq.NFData (Text.Megaparsec.Stream.Token s), Control.DeepSeq.NFData e) => Control.DeepSeq.NFData (Text.Megaparsec.Error.ParseError s e)
instance (Text.Megaparsec.Stream.Stream s, GHC.Classes.Ord e) => GHC.Base.Semigroup (Text.Megaparsec.Error.ParseError s e)
instance (Text.Megaparsec.Stream.Stream s, GHC.Classes.Ord e) => GHC.Base.Monoid (Text.Megaparsec.Error.ParseError s e)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Text.Megaparsec.Error.ErrorFancy a)
instance Control.DeepSeq.NFData t => Control.DeepSeq.NFData (Text.Megaparsec.Error.ErrorItem t)


-- | A set of helpers that should make construction of <a>ParseError</a>s
--   more concise. This is primarily useful in test suites and for
--   debugging.
module Text.Megaparsec.Error.Builder

-- | Assemble a <a>ParseError</a> from the offset and the <tt><a>ET</a>
--   t</tt> value. <tt><a>ET</a> t</tt> is a monoid and can be assembled by
--   combining primitives provided by this module, see below.
err :: Int -> ET s -> ParseError s e

-- | Like <a>err</a>, but constructs a “fancy” <a>ParseError</a>.
errFancy :: Int -> EF e -> ParseError s e

-- | Construct an “unexpected token” error component.
utok :: Token s -> ET s

-- | Construct an “unexpected tokens” error component. Empty chunk produces
--   <a>EndOfInput</a>.
utoks :: forall s. Stream s => Tokens s -> ET s

-- | Construct an “unexpected label” error component. Do not use with empty
--   strings (for empty strings it's bottom).
ulabel :: String -> ET s

-- | Construct an “unexpected end of input” error component.
ueof :: ET s

-- | Construct an “expected token” error component.
etok :: Token s -> ET s

-- | Construct an “expected tokens” error component. Empty chunk produces
--   <a>EndOfInput</a>.
etoks :: forall s. Stream s => Tokens s -> ET s

-- | Construct an “expected label” error component. Do not use with empty
--   strings.
elabel :: String -> ET s

-- | Construct an “expected end of input” error component.
eeof :: ET s

-- | Construct a custom error component.
fancy :: ErrorFancy e -> EF e

-- | Auxiliary type for construction of trivial parse errors.
data ET s

-- | Auxiliary type for construction of fancy parse errors.
data EF e
instance GHC.Generics.Generic (Text.Megaparsec.Error.Builder.ET s)
instance GHC.Generics.Generic (Text.Megaparsec.Error.Builder.EF e)
instance (Data.Data.Data e, GHC.Classes.Ord e) => Data.Data.Data (Text.Megaparsec.Error.Builder.EF e)
instance GHC.Classes.Ord e => GHC.Classes.Ord (Text.Megaparsec.Error.Builder.EF e)
instance GHC.Classes.Eq e => GHC.Classes.Eq (Text.Megaparsec.Error.Builder.EF e)
instance GHC.Classes.Eq (Text.Megaparsec.Stream.Token s) => GHC.Classes.Eq (Text.Megaparsec.Error.Builder.ET s)
instance GHC.Classes.Ord (Text.Megaparsec.Stream.Token s) => GHC.Classes.Ord (Text.Megaparsec.Error.Builder.ET s)
instance (Data.Data.Data s, Data.Data.Data (Text.Megaparsec.Stream.Token s), GHC.Classes.Ord (Text.Megaparsec.Stream.Token s)) => Data.Data.Data (Text.Megaparsec.Error.Builder.ET s)
instance GHC.Classes.Ord e => GHC.Base.Semigroup (Text.Megaparsec.Error.Builder.EF e)
instance GHC.Classes.Ord e => GHC.Base.Monoid (Text.Megaparsec.Error.Builder.EF e)
instance Text.Megaparsec.Stream.Stream s => GHC.Base.Semigroup (Text.Megaparsec.Error.Builder.ET s)
instance Text.Megaparsec.Stream.Stream s => GHC.Base.Monoid (Text.Megaparsec.Error.Builder.ET s)


-- | Internal definitions. Versioning rules do not apply here. Please do
--   not rely on these unless you really know what you're doing.
module Text.Megaparsec.Internal

-- | <a>Hints</a> represent a collection of <a>ErrorItem</a>s to be
--   included into <a>ParseError</a> (when it's a <a>TrivialError</a>) as
--   “expected” message items when a parser fails without consuming input
--   right after successful parser that produced the hints.
--   
--   For example, without hints you could get:
--   
--   <pre>
--   &gt;&gt;&gt; parseTest (many (char 'r') &lt;* eof) "ra"
--   1:2:
--   unexpected 'a'
--   expecting end of input
--   </pre>
--   
--   We're getting better error messages with the help of hints:
--   
--   <pre>
--   &gt;&gt;&gt; parseTest (many (char 'r') &lt;* eof) "ra"
--   1:2:
--   unexpected 'a'
--   expecting 'r' or end of input
--   </pre>
newtype Hints t
Hints :: Set (ErrorItem t) -> Hints t

-- | All information available after parsing. This includes consumption of
--   input, success (with the returned value) or failure (with the parse
--   error), and parser state at the end of parsing. <a>Reply</a> can also
--   be used to resume parsing.
--   
--   See also: <a>Consumption</a>, <a>Result</a>.
data Reply e s a
Reply :: State s e -> Consumption -> Result s e a -> Reply e s a

-- | Whether the input has been consumed or not.
--   
--   See also: <a>Result</a>, <a>Reply</a>.
data Consumption

-- | Some part of input stream was consumed
Consumed :: Consumption

-- | No input was consumed
NotConsumed :: Consumption

-- | Whether the parser has failed or not. On success we include the
--   resulting value, on failure we include a <a>ParseError</a>.
--   
--   See also: <a>Consumption</a>, <a>Reply</a>.
data Result s e a

-- | Parser succeeded (includes hints)
OK :: Hints (Token s) -> a -> Result s e a

-- | Parser failed
Error :: ParseError s e -> Result s e a

-- | <tt><a>ParsecT</a> e s m a</tt> is a parser with custom data component
--   of error <tt>e</tt>, stream type <tt>s</tt>, underlying monad
--   <tt>m</tt> and return type <tt>a</tt>.
newtype ParsecT e s m a
ParsecT :: (forall b. State s e -> (a -> State s e -> Hints (Token s) -> m b) -> (ParseError s e -> State s e -> m b) -> (a -> State s e -> Hints (Token s) -> m b) -> (ParseError s e -> State s e -> m b) -> m b) -> ParsecT e s m a
[unParser] :: ParsecT e s m a -> forall b. State s e -> (a -> State s e -> Hints (Token s) -> m b) -> (ParseError s e -> State s e -> m b) -> (a -> State s e -> Hints (Token s) -> m b) -> (ParseError s e -> State s e -> m b) -> m b

-- | Convert a <a>ParseError</a> record into <a>Hints</a>.
toHints :: Stream s => Int -> ParseError s e -> Hints (Token s)

-- | <tt><a>withHints</a> hs c</tt> makes “error” continuation <tt>c</tt>
--   use given hints <tt>hs</tt>.
--   
--   <b>Note</b> that if resulting continuation gets <a>ParseError</a> that
--   has custom data in it, hints are ignored.
withHints :: Stream s => Hints (Token s) -> (ParseError s e -> State s e -> m b) -> ParseError s e -> State s e -> m b

-- | <tt><a>accHints</a> hs c</tt> results in “OK” continuation that will
--   add given hints <tt>hs</tt> to third argument of original continuation
--   <tt>c</tt>.
accHints :: Stream s => Hints (Token s) -> (a -> State s e -> Hints (Token s) -> m b) -> a -> State s e -> Hints (Token s) -> m b

-- | Replace the hints with the given <a>ErrorItem</a> (or delete it if
--   <a>Nothing</a> is given). This is used in the <a>MonadParsec</a>
--   primitive.
refreshHints :: Hints t -> Maybe (ErrorItem t) -> Hints t

-- | Low-level unpacking of the <a>ParsecT</a> type.
runParsecT :: Monad m => ParsecT e s m a -> State s e -> m (Reply e s a)

-- | Transform any custom errors thrown by the parser using the given
--   function. Similar in function and purpose to <tt>withExceptT</tt>.
--   
--   <b>Note</b> that the inner parser will start with an empty collection
--   of “delayed” <a>ParseError</a>s. Any delayed <a>ParseError</a>s
--   produced in the inner parser will be lifted by applying the provided
--   function and added to the collection of delayed parse errors of the
--   outer parser.
withParsecT :: forall e e' s m a. Ord e' => (e -> e') -> ParsecT e s m a -> ParsecT e' s m a
instance GHC.Base.Functor (Text.Megaparsec.Internal.Result s e)
instance GHC.Base.Functor (Text.Megaparsec.Internal.Reply e s)
instance (Text.Megaparsec.Stream.Stream s, GHC.Base.Semigroup a) => GHC.Base.Semigroup (Text.Megaparsec.Internal.ParsecT e s m a)
instance (Text.Megaparsec.Stream.Stream s, GHC.Base.Monoid a) => GHC.Base.Monoid (Text.Megaparsec.Internal.ParsecT e s m a)
instance (a GHC.Types.~ Text.Megaparsec.Stream.Tokens s, Data.String.IsString a, GHC.Classes.Eq a, Text.Megaparsec.Stream.Stream s, GHC.Classes.Ord e) => Data.String.IsString (Text.Megaparsec.Internal.ParsecT e s m a)
instance GHC.Base.Functor (Text.Megaparsec.Internal.ParsecT e s m)
instance Text.Megaparsec.Stream.Stream s => GHC.Base.Applicative (Text.Megaparsec.Internal.ParsecT e s m)
instance (GHC.Classes.Ord e, Text.Megaparsec.Stream.Stream s) => GHC.Base.Alternative (Text.Megaparsec.Internal.ParsecT e s m)
instance Text.Megaparsec.Stream.Stream s => GHC.Base.Monad (Text.Megaparsec.Internal.ParsecT e s m)
instance Text.Megaparsec.Stream.Stream s => Control.Monad.Fail.MonadFail (Text.Megaparsec.Internal.ParsecT e s m)
instance (Text.Megaparsec.Stream.Stream s, Control.Monad.IO.Class.MonadIO m) => Control.Monad.IO.Class.MonadIO (Text.Megaparsec.Internal.ParsecT e s m)
instance (Text.Megaparsec.Stream.Stream s, Control.Monad.Reader.Class.MonadReader r m) => Control.Monad.Reader.Class.MonadReader r (Text.Megaparsec.Internal.ParsecT e s m)
instance (Text.Megaparsec.Stream.Stream s, Control.Monad.State.Class.MonadState st m) => Control.Monad.State.Class.MonadState st (Text.Megaparsec.Internal.ParsecT e s m)
instance (Text.Megaparsec.Stream.Stream s, Control.Monad.Writer.Class.MonadWriter w m) => Control.Monad.Writer.Class.MonadWriter w (Text.Megaparsec.Internal.ParsecT e s m)
instance (Text.Megaparsec.Stream.Stream s, Control.Monad.Cont.Class.MonadCont m) => Control.Monad.Cont.Class.MonadCont (Text.Megaparsec.Internal.ParsecT e s m)
instance (Text.Megaparsec.Stream.Stream s, Control.Monad.Error.Class.MonadError e' m) => Control.Monad.Error.Class.MonadError e' (Text.Megaparsec.Internal.ParsecT e s m)
instance (GHC.Classes.Ord e, Text.Megaparsec.Stream.Stream s) => GHC.Base.MonadPlus (Text.Megaparsec.Internal.ParsecT e s m)
instance (Text.Megaparsec.Stream.Stream s, Control.Monad.Fix.MonadFix m) => Control.Monad.Fix.MonadFix (Text.Megaparsec.Internal.ParsecT e s m)
instance Text.Megaparsec.Stream.Stream s => Control.Monad.Trans.Class.MonadTrans (Text.Megaparsec.Internal.ParsecT e s)
instance (GHC.Classes.Ord e, Text.Megaparsec.Stream.Stream s) => Text.Megaparsec.Class.MonadParsec e s (Text.Megaparsec.Internal.ParsecT e s m)
instance GHC.Classes.Ord t => GHC.Base.Semigroup (Text.Megaparsec.Internal.Hints t)
instance GHC.Classes.Ord t => GHC.Base.Monoid (Text.Megaparsec.Internal.Hints t)


-- | Debugging helpers.
module Text.Megaparsec.Debug

-- | Type class describing parser monads that can trace during evaluation.
class (MonadParsec e s m) => MonadParsecDbg e s m

-- | <tt><a>dbg</a> label p</tt> parser works exactly like <tt>p</tt>, but
--   when it's evaluated it prints information useful for debugging. The
--   <tt>label</tt> is only used to refer to this parser in the debugging
--   output. This combinator uses the <a>trace</a> function from
--   <a>Debug.Trace</a> under the hood.
--   
--   Typical usage is to wrap every sub-parser in misbehaving parser with
--   <a>dbg</a> assigning meaningful labels. Then give it a shot and go
--   through the print-out. As of current version, this combinator prints
--   all available information except for <i>hints</i>, which are probably
--   only interesting to the maintainer of Megaparsec itself and may be
--   quite verbose to output in general. Let me know if you would like to
--   be able to see hints in the debugging output.
--   
--   The output itself is pretty self-explanatory, although the following
--   abbreviations should be clarified (they are derived from the low-level
--   source code):
--   
--   <ul>
--   <li><tt>COK</tt>—“consumed OK”. The parser consumed input and
--   succeeded.</li>
--   <li><tt>CERR</tt>—“consumed error”. The parser consumed input and
--   failed.</li>
--   <li><tt>EOK</tt>—“empty OK”. The parser succeeded without consuming
--   input.</li>
--   <li><tt>EERR</tt>—“empty error”. The parser failed without consuming
--   input.</li>
--   </ul>
--   
--   <b>Note</b>: up until the version <i>9.3.0</i> this was a
--   non-polymorphic function that worked only in <a>ParsecT</a>. It was
--   first introduced in the version <i>7.0.0</i>.
dbg :: (MonadParsecDbg e s m, Show a) => String -> m a -> m a

-- | Just like <a>dbg</a>, but doesn't require the return value of the
--   parser to be <a>Show</a>-able.
dbg' :: MonadParsecDbg e s m => String -> m a -> m a
instance GHC.Show.Show (Text.Megaparsec.Debug.Blind x)
instance (Text.Megaparsec.Stream.VisualStream s, Text.Megaparsec.Error.ShowErrorComponent e) => Text.Megaparsec.Debug.MonadParsecDbg e s (Text.Megaparsec.Internal.ParsecT e s m)
instance (GHC.Base.Monoid w, GHC.Show.Show w, GHC.Show.Show st, Text.Megaparsec.Debug.MonadParsecDbg e s m) => Text.Megaparsec.Debug.MonadParsecDbg e s (Control.Monad.Trans.RWS.Lazy.RWST r w st m)
instance (GHC.Base.Monoid w, GHC.Show.Show w, GHC.Show.Show st, Text.Megaparsec.Debug.MonadParsecDbg e s m) => Text.Megaparsec.Debug.MonadParsecDbg e s (Control.Monad.Trans.RWS.Strict.RWST r w st m)
instance (GHC.Show.Show c, GHC.Show.Show a) => GHC.Show.Show (Text.Megaparsec.Debug.ShowComment c a)
instance (GHC.Show.Show st, Text.Megaparsec.Debug.MonadParsecDbg e s m) => Text.Megaparsec.Debug.MonadParsecDbg e s (Control.Monad.Trans.State.Lazy.StateT st m)
instance (GHC.Show.Show st, Text.Megaparsec.Debug.MonadParsecDbg e s m) => Text.Megaparsec.Debug.MonadParsecDbg e s (Control.Monad.Trans.State.Strict.StateT st m)
instance Text.Megaparsec.Debug.MonadParsecDbg e s m => Text.Megaparsec.Debug.MonadParsecDbg e s (Control.Monad.Trans.Reader.ReaderT r m)
instance (GHC.Base.Monoid w, GHC.Show.Show w, Text.Megaparsec.Debug.MonadParsecDbg e s m) => Text.Megaparsec.Debug.MonadParsecDbg e s (Control.Monad.Trans.Writer.Lazy.WriterT w m)
instance (GHC.Base.Monoid w, GHC.Show.Show w, Text.Megaparsec.Debug.MonadParsecDbg e s m) => Text.Megaparsec.Debug.MonadParsecDbg e s (Control.Monad.Trans.Writer.Strict.WriterT w m)
instance Text.Megaparsec.Debug.MonadParsecDbg e s m => Text.Megaparsec.Debug.MonadParsecDbg e s (Control.Monad.Trans.Identity.IdentityT m)


-- | This module includes everything you need to get started writing a
--   parser. If you are new to Megaparsec and don't know where to begin,
--   take a look at the tutorial
--   <a>https://markkarpov.com/tutorial/megaparsec.html</a>.
--   
--   In addition to the <a>Text.Megaparsec</a> module, which exports and
--   re-exports almost everything that you may need, we advise to import
--   <a>Text.Megaparsec.Char</a> if you plan to work with a stream of
--   <a>Char</a> tokens or <a>Text.Megaparsec.Byte</a> if you intend to
--   parse binary data.
--   
--   It is common to start working with the library by defining a type
--   synonym like this:
--   
--   <pre>
--   type Parser = Parsec Void Text
--                        ^    ^
--                        |    |
--   Custom error component    Input stream type
--   </pre>
--   
--   Then you can write type signatures like <tt>Parser <a>Int</a></tt>—for
--   a parser that returns an <a>Int</a> for example.
--   
--   Similarly (since it's known to cause confusion), you should use
--   <a>ParseErrorBundle</a> type parametrized like this:
--   
--   <pre>
--   ParseErrorBundle Text Void
--                    ^    ^
--                    |    |
--    Input stream type    Custom error component (the same you used in Parser)
--   </pre>
--   
--   Megaparsec uses some type-level machinery to provide flexibility
--   without compromising on type safety. Thus type signatures are
--   sometimes necessary to avoid ambiguous types. If you're seeing an
--   error message that reads like “Type variable <tt>e0</tt> is ambiguous
--   …”, you need to give an explicit signature to your parser to resolve
--   the ambiguity. It's a good idea to provide type signatures for all
--   top-level definitions.
module Text.Megaparsec

-- | This is the Megaparsec's state parametrized over stream type
--   <tt>s</tt> and custom error component type <tt>e</tt>.
data State s e
State :: s -> {-# UNPACK #-} !Int -> PosState s -> [ParseError s e] -> State s e

-- | The rest of input to process
[stateInput] :: State s e -> s

-- | Number of processed tokens so far
[stateOffset] :: State s e -> {-# UNPACK #-} !Int

-- | State that is used for line/column calculation
[statePosState] :: State s e -> PosState s

-- | Collection of “delayed” <a>ParseError</a>s in reverse order. This
--   means that the last registered error is the first element of the list.
[stateParseErrors] :: State s e -> [ParseError s e]

-- | A special kind of state that is used to calculate line/column
--   positions on demand.
data PosState s
PosState :: s -> !Int -> !SourcePos -> Pos -> String -> PosState s

-- | The rest of input to process
[pstateInput] :: PosState s -> s

-- | Offset corresponding to beginning of <a>pstateInput</a>
[pstateOffset] :: PosState s -> !Int

-- | Source position corresponding to beginning of <a>pstateInput</a>
[pstateSourcePos] :: PosState s -> !SourcePos

-- | Tab width to use for column calculation
[pstateTabWidth] :: PosState s -> Pos

-- | Prefix to prepend to offending line
[pstateLinePrefix] :: PosState s -> String

-- | <a>Parsec</a> is a non-transformer variant of the more general
--   <a>ParsecT</a> monad transformer.
type Parsec e s = ParsecT e s Identity

-- | <tt><a>ParsecT</a> e s m a</tt> is a parser with custom data component
--   of error <tt>e</tt>, stream type <tt>s</tt>, underlying monad
--   <tt>m</tt> and return type <tt>a</tt>.
data ParsecT e s m a

-- | <tt><a>parse</a> p file input</tt> runs parser <tt>p</tt> over
--   <a>Identity</a> (see <a>runParserT</a> if you're using the
--   <a>ParsecT</a> monad transformer; <a>parse</a> itself is just a
--   synonym for <a>runParser</a>). It returns either a
--   <a>ParseErrorBundle</a> (<a>Left</a>) or a value of type <tt>a</tt>
--   (<a>Right</a>). <a>errorBundlePretty</a> can be used to turn
--   <a>ParseErrorBundle</a> into the string representation of the error
--   message. See <a>Text.Megaparsec.Error</a> if you need to do more
--   advanced error analysis.
--   
--   <pre>
--   main = case parse numbers "" "11,2,43" of
--            Left bundle -&gt; putStr (errorBundlePretty bundle)
--            Right xs -&gt; print (sum xs)
--   
--   numbers = decimal `sepBy` char ','
--   </pre>
--   
--   <a>parse</a> is the same as <a>runParser</a>.
parse :: Parsec e s a -> String -> s -> Either (ParseErrorBundle s e) a

-- | <tt><a>parseMaybe</a> p input</tt> runs the parser <tt>p</tt> on
--   <tt>input</tt> and returns the result inside <a>Just</a> on success
--   and <a>Nothing</a> on failure. This function also parses <a>eof</a>,
--   so if the parser doesn't consume all of its input, it will fail.
--   
--   The function is supposed to be useful for lightweight parsing, where
--   error messages (and thus file names) are not important and entire
--   input should be consumed. For example, it can be used for parsing of a
--   single number according to a specification of its format.
parseMaybe :: (Ord e, Stream s) => Parsec e s a -> s -> Maybe a

-- | The expression <tt><a>parseTest</a> p input</tt> applies the parser
--   <tt>p</tt> on the input <tt>input</tt> and prints the result to
--   stdout. Useful for testing.
parseTest :: (ShowErrorComponent e, Show a, VisualStream s, TraversableStream s) => Parsec e s a -> s -> IO ()

-- | <tt><a>runParser</a> p file input</tt> runs parser <tt>p</tt> on the
--   input stream of tokens <tt>input</tt>, obtained from source
--   <tt>file</tt>. The <tt>file</tt> is only used in error messages and
--   may be the empty string. Returns either a <a>ParseErrorBundle</a>
--   (<a>Left</a>) or a value of type <tt>a</tt> (<a>Right</a>).
--   
--   <pre>
--   parseFromFile p file = runParser p file &lt;$&gt; readFile file
--   </pre>
--   
--   <a>runParser</a> is the same as <a>parse</a>.
runParser :: Parsec e s a -> String -> s -> Either (ParseErrorBundle s e) a

-- | The function is similar to <a>runParser</a> with the difference that
--   it accepts and returns the parser state. This allows us e.g. to
--   specify arbitrary textual position at the beginning of parsing. This
--   is the most general way to run a parser over the <a>Identity</a>
--   monad.
runParser' :: Parsec e s a -> State s e -> (State s e, Either (ParseErrorBundle s e) a)

-- | <tt><a>runParserT</a> p file input</tt> runs parser <tt>p</tt> on the
--   input list of tokens <tt>input</tt>, obtained from source
--   <tt>file</tt>. The <tt>file</tt> is only used in error messages and
--   may be the empty string. Returns a computation in the underlying monad
--   <tt>m</tt> that returns either a <a>ParseErrorBundle</a> (<a>Left</a>)
--   or a value of type <tt>a</tt> (<a>Right</a>).
runParserT :: Monad m => ParsecT e s m a -> String -> s -> m (Either (ParseErrorBundle s e) a)

-- | This function is similar to <a>runParserT</a>, but like
--   <a>runParser'</a> it accepts and returns parser state. This is thus
--   the most general way to run a parser.
runParserT' :: Monad m => ParsecT e s m a -> State s e -> m (State s e, Either (ParseErrorBundle s e) a)

-- | Type class describing monads that implement the full set of primitive
--   parsers.
--   
--   <b>Note</b> that the following primitives are “fast” and should be
--   taken advantage of as much as possible if your aim is a fast parser:
--   <a>tokens</a>, <a>takeWhileP</a>, <a>takeWhile1P</a>, and
--   <a>takeP</a>.
class (Stream s, MonadPlus m) => MonadParsec e s m | m -> e s

-- | Stop parsing and report the <a>ParseError</a>. This is the only way to
--   control position of the error without manipulating the parser state
--   manually.
parseError :: MonadParsec e s m => ParseError s e -> m a

-- | The parser <tt><a>label</a> name p</tt> behaves as parser <tt>p</tt>,
--   but whenever the parser <tt>p</tt> fails <i>without consuming any
--   input</i>, it replaces names of “expected” tokens with the name
--   <tt>name</tt>.
label :: MonadParsec e s m => String -> m a -> m a

-- | <tt><a>hidden</a> p</tt> behaves just like parser <tt>p</tt>, but it
--   doesn't show any “expected” tokens in error message when <tt>p</tt>
--   fails.
--   
--   Please use <a>hidden</a> instead of the old <tt><a>label</a> ""</tt>
--   idiom.
hidden :: MonadParsec e s m => m a -> m a

-- | The parser <tt><a>try</a> p</tt> behaves like the parser <tt>p</tt>,
--   except that it backtracks the parser state when <tt>p</tt> fails
--   (either consuming input or not).
--   
--   This combinator is used whenever arbitrary look ahead is needed. Since
--   it pretends that it hasn't consumed any input when <tt>p</tt> fails,
--   the (<a>&lt;|&gt;</a>) combinator will try its second alternative even
--   if the first parser failed while consuming input.
--   
--   For example, here is a parser that is supposed to parse the word “let”
--   or the word “lexical”:
--   
--   <pre>
--   &gt;&gt;&gt; parseTest (string "let" &lt;|&gt; string "lexical") "lexical"
--   1:1:
--   unexpected "lex"
--   expecting "let"
--   </pre>
--   
--   What happens here? The first parser consumes “le” and fails (because
--   it doesn't see a “t”). The second parser, however, isn't tried, since
--   the first parser has already consumed some input! <a>try</a> fixes
--   this behavior and allows backtracking to work:
--   
--   <pre>
--   &gt;&gt;&gt; parseTest (try (string "let") &lt;|&gt; string "lexical") "lexical"
--   "lexical"
--   </pre>
--   
--   <a>try</a> also improves error messages in case of overlapping
--   alternatives, because Megaparsec's hint system can be used:
--   
--   <pre>
--   &gt;&gt;&gt; parseTest (try (string "let") &lt;|&gt; string "lexical") "le"
--   1:1:
--   unexpected "le"
--   expecting "let" or "lexical"
--   </pre>
--   
--   <b>Note</b> that as of Megaparsec 4.4.0, <a>string</a> backtracks
--   automatically (see <a>tokens</a>), so it does not need <a>try</a>.
--   However, the examples above demonstrate the idea behind <a>try</a> so
--   well that it was decided to keep them. You still need to use
--   <a>try</a> when your alternatives are complex, composite parsers.
try :: MonadParsec e s m => m a -> m a

-- | If <tt>p</tt> in <tt><a>lookAhead</a> p</tt> succeeds (either
--   consuming input or not) the whole parser behaves like <tt>p</tt>
--   succeeded without consuming anything (parser state is not updated as
--   well). If <tt>p</tt> fails, <a>lookAhead</a> has no effect, i.e. it
--   will fail consuming input if <tt>p</tt> fails consuming input. Combine
--   with <a>try</a> if this is undesirable.
lookAhead :: MonadParsec e s m => m a -> m a

-- | <tt><a>notFollowedBy</a> p</tt> only succeeds when the parser
--   <tt>p</tt> fails. This parser <i>never consumes</i> any input and
--   <i>never modifies</i> parser state. It can be used to implement the
--   “longest match” rule.
notFollowedBy :: MonadParsec e s m => m a -> m ()

-- | <tt><a>withRecovery</a> r p</tt> allows us to continue parsing even if
--   the parser <tt>p</tt> fails. In this case <tt>r</tt> is called with
--   the actual <a>ParseError</a> as its argument. Typical usage is to
--   return a value signifying failure to parse this particular object and
--   to consume some part of the input up to the point where the next
--   object starts.
--   
--   Note that if <tt>r</tt> fails, the original error message is reported
--   as if without <a>withRecovery</a>. In no way recovering parser
--   <tt>r</tt> can influence error messages.
withRecovery :: MonadParsec e s m => (ParseError s e -> m a) -> m a -> m a

-- | <tt><a>observing</a> p</tt> allows us to “observe” failure of the
--   <tt>p</tt> parser, should it happen, without actually ending parsing
--   but instead getting the <a>ParseError</a> in <a>Left</a>. On success
--   parsed value is returned in <a>Right</a> as usual. Note that this
--   primitive just allows you to observe parse errors as they happen, it
--   does not backtrack or change how the <tt>p</tt> parser works in any
--   way.
observing :: MonadParsec e s m => m a -> m (Either (ParseError s e) a)

-- | This parser only succeeds at the end of input.
eof :: MonadParsec e s m => m ()

-- | The parser <tt><a>token</a> test expected</tt> accepts tokens for
--   which the matching function <tt>test</tt> returns <a>Just</a> results.
--   If <a>Nothing</a> is returned the <tt>expected</tt> set is used to
--   report the items that were expected.
--   
--   For example, the <a>satisfy</a> parser is implemented as:
--   
--   <pre>
--   satisfy f = token testToken Set.empty
--     where
--       testToken x = if f x then Just x else Nothing
--   </pre>
--   
--   <b>Note</b>: type signature of this primitive was changed in the
--   version <i>7.0.0</i>.
token :: MonadParsec e s m => (Token s -> Maybe a) -> Set (ErrorItem (Token s)) -> m a

-- | The parser <tt><a>tokens</a> test chk</tt> parses a chunk of input
--   <tt>chk</tt> and returns it. The supplied predicate <tt>test</tt> is
--   used to check equality of given and parsed chunks after a candidate
--   chunk of correct length is fetched from the stream.
--   
--   This can be used for example to write <a>chunk</a>:
--   
--   <pre>
--   chunk = tokens (==)
--   </pre>
--   
--   Note that beginning from Megaparsec 4.4.0, this is an
--   auto-backtracking primitive, which means that if it fails, it never
--   consumes any input. This is done to make its consumption model match
--   how error messages for this primitive are reported (which becomes an
--   important thing as user gets more control with primitives like
--   <a>withRecovery</a>):
--   
--   <pre>
--   &gt;&gt;&gt; parseTest (string "abc") "abd"
--   1:1:
--   unexpected "abd"
--   expecting "abc"
--   </pre>
--   
--   This means, in particular, that it's no longer necessary to use
--   <a>try</a> with <a>tokens</a>-based parsers, such as <a>string</a> and
--   <a>string'</a>. This feature <i>does not</i> affect performance in any
--   way.
tokens :: MonadParsec e s m => (Tokens s -> Tokens s -> Bool) -> Tokens s -> m (Tokens s)

-- | Parse <i>zero</i> or more tokens for which the supplied predicate
--   holds. Try to use this as much as possible because for many streams
--   this combinator is much faster than parsers built with <a>many</a> and
--   <a>satisfy</a>.
--   
--   <pre>
--   takeWhileP (Just "foo") f = many (satisfy f &lt;?&gt; "foo")
--   takeWhileP Nothing      f = many (satisfy f)
--   </pre>
--   
--   The combinator never fails, although it may parse the empty chunk.
takeWhileP :: MonadParsec e s m => Maybe String -> (Token s -> Bool) -> m (Tokens s)

-- | Similar to <a>takeWhileP</a>, but fails if it can't parse at least one
--   token. Try to use this as much as possible because for many streams
--   this combinator is much faster than parsers built with <a>some</a> and
--   <a>satisfy</a>.
--   
--   <pre>
--   takeWhile1P (Just "foo") f = some (satisfy f &lt;?&gt; "foo")
--   takeWhile1P Nothing      f = some (satisfy f)
--   </pre>
--   
--   Note that the combinator either succeeds or fails without consuming
--   any input, so <a>try</a> is not necessary with it.
takeWhile1P :: MonadParsec e s m => Maybe String -> (Token s -> Bool) -> m (Tokens s)

-- | Extract the specified number of tokens from the input stream and
--   return them packed as a chunk of stream. If there is not enough tokens
--   in the stream, a parse error will be signaled. It's guaranteed that if
--   the parser succeeds, the requested number of tokens will be returned.
--   
--   The parser is roughly equivalent to:
--   
--   <pre>
--   takeP (Just "foo") n = count n (anySingle &lt;?&gt; "foo")
--   takeP Nothing      n = count n anySingle
--   </pre>
--   
--   Note that if the combinator fails due to insufficient number of tokens
--   in the input stream, it backtracks automatically. No <a>try</a> is
--   necessary with <a>takeP</a>.
takeP :: MonadParsec e s m => Maybe String -> Int -> m (Tokens s)

-- | Return the full parser state as a <a>State</a> record.
getParserState :: MonadParsec e s m => m (State s e)

-- | <tt><a>updateParserState</a> f</tt> applies the function <tt>f</tt> to
--   the parser state.
updateParserState :: MonadParsec e s m => (State s e -> State s e) -> m ()

-- | An escape hatch for defining custom <a>MonadParsec</a> primitives. You
--   will need to import <a>Text.Megaparsec.Internal</a> in order to
--   construct <a>Reply</a>.
mkParsec :: MonadParsec e s m => (State s e -> Reply e s a) -> m a

-- | Stop parsing and report a trivial <a>ParseError</a>.
failure :: MonadParsec e s m => Maybe (ErrorItem (Token s)) -> Set (ErrorItem (Token s)) -> m a

-- | Stop parsing and report a fancy <a>ParseError</a>. To report a single
--   custom parse error, see <a>customFailure</a>.
fancyFailure :: MonadParsec e s m => Set (ErrorFancy e) -> m a

-- | The parser <tt><a>unexpected</a> item</tt> fails with an error message
--   telling about unexpected item <tt>item</tt> without consuming any
--   input.
--   
--   <pre>
--   unexpected item = failure (Just item) Set.empty
--   </pre>
unexpected :: MonadParsec e s m => ErrorItem (Token s) -> m a

-- | Report a custom parse error. For a more general version, see
--   <a>fancyFailure</a>.
--   
--   <pre>
--   customFailure = fancyFailure . Set.singleton . ErrorCustom
--   </pre>
customFailure :: MonadParsec e s m => e -> m a

-- | Specify how to process <a>ParseError</a>s that happen inside of this
--   wrapper. This applies to both normal and delayed <a>ParseError</a>s.
--   
--   As a side-effect of the implementation the inner computation will
--   start with an empty collection of delayed errors and they will be
--   updated and “restored” on the way out of <a>region</a>.
region :: MonadParsec e s m => (ParseError s e -> ParseError s e) -> m a -> m a

-- | Register a <a>ParseError</a> for later reporting. This action does not
--   end parsing and has no effect except for adding the given
--   <a>ParseError</a> to the collection of “delayed” <a>ParseError</a>s
--   which will be taken into consideration at the end of parsing. Only if
--   this collection is empty the parser will succeed. This is the main way
--   to report several parse errors at once.
registerParseError :: MonadParsec e s m => ParseError s e -> m ()

-- | Like <a>failure</a>, but for delayed <a>ParseError</a>s.
registerFailure :: MonadParsec e s m => Maybe (ErrorItem (Token s)) -> Set (ErrorItem (Token s)) -> m ()

-- | Like <a>fancyFailure</a>, but for delayed <a>ParseError</a>s.
registerFancyFailure :: MonadParsec e s m => Set (ErrorFancy e) -> m ()

-- | <tt><a>single</a> t</tt> only matches the single token <tt>t</tt>.
--   
--   <pre>
--   semicolon = single ';'
--   </pre>
--   
--   See also: <a>token</a>, <a>anySingle</a>, <a>char</a>, <a>char</a>.
single :: MonadParsec e s m => Token s -> m (Token s)

-- | The parser <tt><a>satisfy</a> f</tt> succeeds for any token for which
--   the supplied function <tt>f</tt> returns <a>True</a>.
--   
--   <pre>
--   digitChar = satisfy isDigit &lt;?&gt; "digit"
--   oneOf cs  = satisfy (`elem` cs)
--   </pre>
--   
--   <b>Performance note</b>: when you need to parse a single token, it is
--   often a good idea to use <a>satisfy</a> with the right predicate
--   function instead of creating a complex parser using the combinators.
--   
--   See also: <a>anySingle</a>, <a>anySingleBut</a>, <a>oneOf</a>,
--   <a>noneOf</a>.
satisfy :: MonadParsec e s m => (Token s -> Bool) -> m (Token s)

-- | Parse and return a single token. It's a good idea to attach a
--   <a>label</a> to this parser.
--   
--   <pre>
--   anySingle = satisfy (const True)
--   </pre>
--   
--   See also: <a>satisfy</a>, <a>anySingleBut</a>.
anySingle :: MonadParsec e s m => m (Token s)

-- | Match any token but the given one. It's a good idea to attach a
--   <a>label</a> to this parser.
--   
--   <pre>
--   anySingleBut t = satisfy (/= t)
--   </pre>
--   
--   See also: <a>single</a>, <a>anySingle</a>, <a>satisfy</a>.
anySingleBut :: MonadParsec e s m => Token s -> m (Token s)

-- | <tt><a>oneOf</a> ts</tt> succeeds if the current token is in the
--   supplied collection of tokens <tt>ts</tt>. Returns the parsed token.
--   Note that this parser cannot automatically generate the “expected”
--   component of error message, so usually you should label it manually
--   with <a>label</a> or (<a>&lt;?&gt;</a>).
--   
--   <pre>
--   oneOf cs = satisfy (`elem` cs)
--   </pre>
--   
--   See also: <a>satisfy</a>.
--   
--   <pre>
--   digit = oneOf ['0'..'9'] &lt;?&gt; "digit"
--   </pre>
--   
--   <b>Performance note</b>: prefer <a>satisfy</a> when you can because
--   it's faster when you have only a couple of tokens to compare to:
--   
--   <pre>
--   quoteFast = satisfy (\x -&gt; x == '\'' || x == '\"')
--   quoteSlow = oneOf "'\""
--   </pre>
oneOf :: (Foldable f, MonadParsec e s m) => f (Token s) -> m (Token s)

-- | As the dual of <a>oneOf</a>, <tt><a>noneOf</a> ts</tt> succeeds if the
--   current token <i>not</i> in the supplied list of tokens <tt>ts</tt>.
--   Returns the parsed character. Note that this parser cannot
--   automatically generate the “expected” component of error message, so
--   usually you should label it manually with <a>label</a> or
--   (<a>&lt;?&gt;</a>).
--   
--   <pre>
--   noneOf cs = satisfy (`notElem` cs)
--   </pre>
--   
--   See also: <a>satisfy</a>.
--   
--   <b>Performance note</b>: prefer <a>satisfy</a> and <a>anySingleBut</a>
--   when you can because it's faster.
noneOf :: (Foldable f, MonadParsec e s m) => f (Token s) -> m (Token s)

-- | <tt><a>chunk</a> chk</tt> only matches the chunk <tt>chk</tt>.
--   
--   <pre>
--   divOrMod = chunk "div" &lt;|&gt; chunk "mod"
--   </pre>
--   
--   See also: <a>tokens</a>, <a>string</a>, <a>string</a>.
chunk :: MonadParsec e s m => Tokens s -> m (Tokens s)

-- | A synonym for <a>label</a> in the form of an operator.
(<?>) :: MonadParsec e s m => m a -> String -> m a
infix 0 <?>

-- | Return both the result of a parse and a chunk of input that was
--   consumed during parsing. This relies on the change of the
--   <a>stateOffset</a> value to evaluate how many tokens were consumed. If
--   you mess with it manually in the argument parser, prepare for
--   troubles.
match :: MonadParsec e s m => m a -> m (Tokens s, a)

-- | Consume the rest of the input and return it as a chunk. This parser
--   never fails, but may return the empty chunk.
--   
--   <pre>
--   takeRest = takeWhileP Nothing (const True)
--   </pre>
takeRest :: MonadParsec e s m => m (Tokens s)

-- | Return <a>True</a> when end of input has been reached.
--   
--   <pre>
--   atEnd = option False (True &lt;$ hidden eof)
--   </pre>
atEnd :: MonadParsec e s m => m Bool

-- | Return the current input.
getInput :: MonadParsec e s m => m s

-- | <tt><a>setInput</a> input</tt> continues parsing with <tt>input</tt>.
setInput :: MonadParsec e s m => s -> m ()

-- | Return the current source position. This function <i>is not cheap</i>,
--   do not call it e.g. on matching of every token, that's a bad idea.
--   Still you can use it to get <a>SourcePos</a> to attach to things that
--   you parse.
--   
--   The function works under the assumption that we move in the input
--   stream only forwards and never backwards, which is always true unless
--   the user abuses the library.
getSourcePos :: (TraversableStream s, MonadParsec e s m) => m SourcePos

-- | Get the number of tokens processed so far.
--   
--   See also: <a>setOffset</a>.
getOffset :: MonadParsec e s m => m Int

-- | Set the number of tokens processed so far.
--   
--   See also: <a>getOffset</a>.
setOffset :: MonadParsec e s m => Int -> m ()

-- | <tt><a>setParserState</a> st</tt> sets the parser state to
--   <tt>st</tt>.
--   
--   See also: <a>getParserState</a>, <a>updateParserState</a>.
setParserState :: MonadParsec e s m => State s e -> m ()


-- | Commonly used character parsers.
module Text.Megaparsec.Char

-- | Parse a newline character.
newline :: (MonadParsec e s m, Token s ~ Char) => m (Token s)

-- | Parse a carriage return character followed by a newline character.
--   Return the sequence of characters parsed.
crlf :: forall e s m. (MonadParsec e s m, Token s ~ Char) => m (Tokens s)

-- | Parse a CRLF (see <a>crlf</a>) or LF (see <a>newline</a>) end of line.
--   Return the sequence of characters parsed.
eol :: forall e s m. (MonadParsec e s m, Token s ~ Char) => m (Tokens s)

-- | Parse a tab character.
tab :: (MonadParsec e s m, Token s ~ Char) => m (Token s)

-- | Skip <i>zero</i> or more white space characters.
--   
--   See also: <a>skipMany</a> and <a>spaceChar</a>.
space :: (MonadParsec e s m, Token s ~ Char) => m ()

-- | Like <a>space</a>, but does not accept newlines and carriage returns.
hspace :: (MonadParsec e s m, Token s ~ Char) => m ()

-- | Skip <i>one</i> or more white space characters.
--   
--   See also: <a>skipSome</a> and <a>spaceChar</a>.
space1 :: (MonadParsec e s m, Token s ~ Char) => m ()

-- | Like <a>space1</a>, but does not accept newlines and carriage returns.
hspace1 :: (MonadParsec e s m, Token s ~ Char) => m ()

-- | Parse a control character (a non-printing character of the Latin-1
--   subset of Unicode).
controlChar :: (MonadParsec e s m, Token s ~ Char) => m (Token s)

-- | Parse a Unicode space character, and the control characters: tab,
--   newline, carriage return, form feed, and vertical tab.
spaceChar :: (MonadParsec e s m, Token s ~ Char) => m (Token s)

-- | Parse an upper-case or title-case alphabetic Unicode character. Title
--   case is used by a small number of letter ligatures like the
--   single-character form of Lj.
upperChar :: (MonadParsec e s m, Token s ~ Char) => m (Token s)

-- | Parse a lower-case alphabetic Unicode character.
lowerChar :: (MonadParsec e s m, Token s ~ Char) => m (Token s)

-- | Parse an alphabetic Unicode character: lower-case, upper-case, or
--   title-case letter, or a letter of case-less scripts/modifier letter.
letterChar :: (MonadParsec e s m, Token s ~ Char) => m (Token s)

-- | Parse an alphabetic or numeric digit Unicode characters.
--   
--   Note that the numeric digits outside the ASCII range are parsed by
--   this parser but not by <a>digitChar</a>. Such digits may be part of
--   identifiers but are not used by the printer and reader to represent
--   numbers.
alphaNumChar :: (MonadParsec e s m, Token s ~ Char) => m (Token s)

-- | Parse a printable Unicode character: letter, number, mark,
--   punctuation, symbol or space.
printChar :: (MonadParsec e s m, Token s ~ Char) => m (Token s)

-- | Parse an ASCII digit, i.e between “0” and “9”.
digitChar :: (MonadParsec e s m, Token s ~ Char) => m (Token s)

-- | Parse a binary digit, i.e. "0" or "1".
binDigitChar :: (MonadParsec e s m, Token s ~ Char) => m (Token s)

-- | Parse an octal digit, i.e. between “0” and “7”.
octDigitChar :: (MonadParsec e s m, Token s ~ Char) => m (Token s)

-- | Parse a hexadecimal digit, i.e. between “0” and “9”, or “a” and “f”,
--   or “A” and “F”.
hexDigitChar :: (MonadParsec e s m, Token s ~ Char) => m (Token s)

-- | Parse a Unicode mark character (accents and the like), which combines
--   with preceding characters.
markChar :: (MonadParsec e s m, Token s ~ Char) => m (Token s)

-- | Parse a Unicode numeric character, including digits from various
--   scripts, Roman numerals, etc.
numberChar :: (MonadParsec e s m, Token s ~ Char) => m (Token s)

-- | Parse a Unicode punctuation character, including various kinds of
--   connectors, brackets and quotes.
punctuationChar :: (MonadParsec e s m, Token s ~ Char) => m (Token s)

-- | Parse a Unicode symbol characters, including mathematical and currency
--   symbols.
symbolChar :: (MonadParsec e s m, Token s ~ Char) => m (Token s)

-- | Parse a Unicode space and separator characters.
separatorChar :: (MonadParsec e s m, Token s ~ Char) => m (Token s)

-- | Parse a character from the first 128 characters of the Unicode
--   character set, corresponding to the ASCII character set.
asciiChar :: (MonadParsec e s m, Token s ~ Char) => m (Token s)

-- | Parse a character from the first 256 characters of the Unicode
--   character set, corresponding to the ISO 8859-1 (Latin-1) character
--   set.
latin1Char :: (MonadParsec e s m, Token s ~ Char) => m (Token s)

-- | <tt><a>charCategory</a> cat</tt> parses character in Unicode General
--   Category <tt>cat</tt>, see <a>GeneralCategory</a>.
charCategory :: (MonadParsec e s m, Token s ~ Char) => GeneralCategory -> m (Token s)

-- | Return the human-readable name of Unicode General Category.
categoryName :: GeneralCategory -> String

-- | A type-constrained version of <a>single</a>.
--   
--   <pre>
--   semicolon = char ';'
--   </pre>
char :: (MonadParsec e s m, Token s ~ Char) => Token s -> m (Token s)

-- | The same as <a>char</a> but case-insensitive. This parser returns the
--   actually parsed character preserving its case.
--   
--   <pre>
--   &gt;&gt;&gt; parseTest (char' 'e') "E"
--   'E'
--   
--   &gt;&gt;&gt; parseTest (char' 'e') "G"
--   1:1:
--   unexpected 'G'
--   expecting 'E' or 'e'
--   </pre>
char' :: (MonadParsec e s m, Token s ~ Char) => Token s -> m (Token s)

-- | A synonym for <a>chunk</a>.
string :: MonadParsec e s m => Tokens s -> m (Tokens s)

-- | The same as <a>string</a>, but case-insensitive. On success returns
--   string cased as the parsed input.
--   
--   <pre>
--   &gt;&gt;&gt; parseTest (string' "foobar") "foObAr"
--   "foObAr"
--   </pre>
string' :: (MonadParsec e s m, FoldCase (Tokens s)) => Tokens s -> m (Tokens s)


-- | High-level parsers to help you write your lexer. The module doesn't
--   impose how you should write your parser, but certain approaches may be
--   more elegant than others.
--   
--   Parsing of white space is an important part of any parser. We propose
--   a convention where <b>every lexeme parser assumes no spaces before
--   the</b> <b>lexeme and consumes all spaces after the lexeme</b>; this
--   is what the <a>lexeme</a> combinator does, and so it's enough to wrap
--   every lexeme parser with <a>lexeme</a> to achieve this. Note that
--   you'll need to call <a>space</a> manually to consume any white space
--   before the first lexeme (i.e. at the beginning of the file).
--   
--   This module is intended to be imported qualified:
--   
--   <pre>
--   import qualified Text.Megaparsec.Char.Lexer as L
--   </pre>
--   
--   To do lexing of byte streams, see <a>Text.Megaparsec.Byte.Lexer</a>.
module Text.Megaparsec.Char.Lexer

-- | <tt><a>space</a> sc lineComment blockComment</tt> produces a parser
--   that can parse white space in general. It's expected that you create
--   such a parser once and pass it to other functions in this module as
--   needed (when you see <tt>spaceConsumer</tt> in documentation, usually
--   it means that something like <a>space</a> is expected there).
--   
--   <tt>sc</tt> is used to parse blocks of space characters. You can use
--   <a>space1</a> from <a>Text.Megaparsec.Char</a> for this purpose as
--   well as your own parser (if you don't want to automatically consume
--   newlines, for example). Make sure that the parser does not succeed on
--   the empty input though. In an earlier version of the library
--   <a>spaceChar</a> was recommended, but now parsers based on
--   <a>takeWhile1P</a> are preferred because of their speed.
--   
--   <tt>lineComment</tt> is used to parse line comments. You can use
--   <tt>skipLineComment</tt> if you don't need anything special.
--   
--   <tt>blockComment</tt> is used to parse block (multi-line) comments.
--   You can use <tt>skipBlockComment</tt> or
--   <tt>skipBlockCommentNested</tt> if you don't need anything special.
--   
--   If you don't want to allow a kind of comment, simply pass <a>empty</a>
--   which will fail instantly when parsing of that sort of comment is
--   attempted and <a>space</a> will just move on or finish depending on
--   whether there is more white space for it to consume.
space :: MonadParsec e s m => m () -> m () -> m () -> m ()

-- | This is a wrapper for lexemes. The typical usage is to supply the
--   first argument (parser that consumes white space, probably defined via
--   <a>space</a>) and use the resulting function to wrap parsers for every
--   lexeme.
--   
--   <pre>
--   lexeme  = L.lexeme spaceConsumer
--   integer = lexeme L.decimal
--   </pre>
lexeme :: MonadParsec e s m => m () -> m a -> m a

-- | This is a helper to parse symbols, i.e. verbatim strings. You pass the
--   first argument (parser that consumes white space, probably defined via
--   <a>space</a>) and then you can use the resulting function to parse
--   strings:
--   
--   <pre>
--   symbol    = L.symbol spaceConsumer
--   
--   parens    = between (symbol "(") (symbol ")")
--   braces    = between (symbol "{") (symbol "}")
--   angles    = between (symbol "&lt;") (symbol "&gt;")
--   brackets  = between (symbol "[") (symbol "]")
--   semicolon = symbol ";"
--   comma     = symbol ","
--   colon     = symbol ":"
--   dot       = symbol "."
--   </pre>
symbol :: MonadParsec e s m => m () -> Tokens s -> m (Tokens s)

-- | A case-insensitive version of <a>symbol</a>. This may be helpful if
--   you're working with case-insensitive languages.
symbol' :: (MonadParsec e s m, FoldCase (Tokens s)) => m () -> Tokens s -> m (Tokens s)

-- | Given a comment prefix this function returns a parser that skips line
--   comments. Note that it stops just before the newline character but
--   doesn't consume the newline. Newline is either supposed to be consumed
--   by <a>space</a> parser or picked up manually.
skipLineComment :: (MonadParsec e s m, Token s ~ Char) => Tokens s -> m ()

-- | <tt><a>skipBlockComment</a> start end</tt> skips non-nested block
--   comment starting with <tt>start</tt> and ending with <tt>end</tt>.
skipBlockComment :: MonadParsec e s m => Tokens s -> Tokens s -> m ()

-- | <tt><a>skipBlockCommentNested</a> start end</tt> skips possibly nested
--   block comment starting with <tt>start</tt> and ending with
--   <tt>end</tt>.
skipBlockCommentNested :: (MonadParsec e s m, Token s ~ Char) => Tokens s -> Tokens s -> m ()

-- | Return the current indentation level.
--   
--   The function is a simple shortcut defined as:
--   
--   <pre>
--   indentLevel = sourceColumn &lt;$&gt; getPosition
--   </pre>
indentLevel :: (TraversableStream s, MonadParsec e s m) => m Pos

-- | Fail reporting incorrect indentation error. The error has attached
--   information:
--   
--   <ul>
--   <li>Desired ordering between reference level and actual level</li>
--   <li>Reference indentation level</li>
--   <li>Actual indentation level</li>
--   </ul>
incorrectIndent :: MonadParsec e s m => Ordering -> Pos -> Pos -> m a

-- | <tt><a>indentGuard</a> spaceConsumer ord ref</tt> first consumes all
--   white space (indentation) with <tt>spaceConsumer</tt> parser, then it
--   checks the column position. Ordering between current indentation level
--   and the reference indentation level <tt>ref</tt> should be
--   <tt>ord</tt>, otherwise the parser fails. On success the current
--   column position is returned.
--   
--   When you want to parse a block of indentation, first run this parser
--   with arguments like <tt><a>indentGuard</a> spaceConsumer <a>GT</a>
--   <a>pos1</a></tt>—this will make sure you have some indentation. Use
--   returned value to check indentation on every subsequent line according
--   to syntax of your language.
indentGuard :: (TraversableStream s, MonadParsec e s m) => m () -> Ordering -> Pos -> m Pos

-- | Parse a non-indented construction. This ensures that there is no
--   indentation before actual data. Useful, for example, as a wrapper for
--   top-level function definitions.
nonIndented :: (TraversableStream s, MonadParsec e s m) => m () -> m a -> m a

-- | Behaviors for parsing of indented tokens. This is used in
--   <a>indentBlock</a>, which see.
data IndentOpt m a b

-- | Parse no indented tokens, just return the value
IndentNone :: a -> IndentOpt m a b

-- | Parse many indented tokens (possibly zero), use given indentation
--   level (if <a>Nothing</a>, use level of the first indented token); the
--   second argument tells how to get the final result, and the third
--   argument describes how to parse an indented token
IndentMany :: Maybe Pos -> ([b] -> m a) -> m b -> IndentOpt m a b

-- | Just like <a>IndentMany</a>, but requires at least one indented token
--   to be present
IndentSome :: Maybe Pos -> ([b] -> m a) -> m b -> IndentOpt m a b

-- | Parse a “reference” token and a number of other tokens that have a
--   greater (but the same for all of them) level of indentation than that
--   of the “reference” token. The reference token can influence parsing,
--   see <a>IndentOpt</a> for more information.
--   
--   <b>Note</b>: the first argument of this function <i>must</i> consume
--   newlines among other white space characters.
indentBlock :: (TraversableStream s, MonadParsec e s m, Token s ~ Char) => m () -> m (IndentOpt m a b) -> m a

-- | Create a parser that supports line-folding. The first argument is used
--   to consume white space between components of line fold, thus it
--   <i>must</i> consume newlines in order to work properly. The second
--   argument is a callback that receives a custom space-consuming parser
--   as an argument. This parser should be used after separate components
--   of line fold that can be put on different lines.
--   
--   An example should clarify the usage pattern:
--   
--   <pre>
--   sc = L.space (void spaceChar) empty empty
--   
--   myFold = L.lineFold sc $ \sc' -&gt; do
--     L.symbol sc' "foo"
--     L.symbol sc' "bar"
--     L.symbol sc  "baz" -- for the last symbol we use normal space consumer
--   </pre>
lineFold :: (TraversableStream s, MonadParsec e s m) => m () -> (m () -> m a) -> m a

-- | The lexeme parser parses a single literal character without quotes.
--   The purpose of this parser is to help with parsing of conventional
--   escape sequences. It's your responsibility to take care of character
--   literal syntax in your language (by surrounding it with single quotes
--   or similar).
--   
--   The literal character is parsed according to the grammar rules defined
--   in the Haskell report.
--   
--   Note that you can use this parser as a building block to parse various
--   string literals:
--   
--   <pre>
--   stringLiteral = char '"' &gt;&gt; manyTill L.charLiteral (char '"')
--   </pre>
--   
--   <b>Performance note</b>: the parser is not particularly efficient at
--   the moment.
charLiteral :: (MonadParsec e s m, Token s ~ Char) => m Char

-- | Parse an integer in the decimal representation according to the format
--   of integer literals described in the Haskell report.
--   
--   If you need to parse signed integers, see the <a>signed</a>
--   combinator.
--   
--   <b>Note</b>: before the version <i>6.0.0</i> the function returned
--   <a>Integer</a>, i.e. it wasn't polymorphic in its return type.
--   
--   <b>Warning</b>: this function does not perform range checks.
decimal :: (MonadParsec e s m, Token s ~ Char, Num a) => m a

-- | Parse an integer in binary representation. The binary number is
--   expected to be a non-empty sequence of zeroes “0” and ones “1”.
--   
--   You could of course parse some prefix before the actual number:
--   
--   <pre>
--   binary = char '0' &gt;&gt; char' 'b' &gt;&gt; L.binary
--   </pre>
--   
--   <b>Warning</b>: this function does not perform range checks.
binary :: forall e s m a. (MonadParsec e s m, Token s ~ Char, Num a) => m a

-- | Parse an integer in the octal representation. The format of the octal
--   number is expected to be according to the Haskell report except for
--   the fact that this parser doesn't parse “0o” or “0O” prefix. It is a
--   responsibility of the programmer to parse correct prefix before
--   parsing the number itself.
--   
--   For example you can make it conform to the Haskell report like this:
--   
--   <pre>
--   octal = char '0' &gt;&gt; char' 'o' &gt;&gt; L.octal
--   </pre>
--   
--   <b>Note</b>: before version <i>6.0.0</i> the function returned
--   <a>Integer</a>, i.e. it wasn't polymorphic in its return type.
--   
--   <b>Warning</b>: this function does not perform range checks.
octal :: forall e s m a. (MonadParsec e s m, Token s ~ Char, Num a) => m a

-- | Parse an integer in the hexadecimal representation. The format of the
--   hexadecimal number is expected to be according to the Haskell report
--   except for the fact that this parser doesn't parse “0x” or “0X”
--   prefix. It is a responsibility of the programmer to parse correct
--   prefix before parsing the number itself.
--   
--   For example you can make it conform to the Haskell report like this:
--   
--   <pre>
--   hexadecimal = char '0' &gt;&gt; char' 'x' &gt;&gt; L.hexadecimal
--   </pre>
--   
--   <b>Note</b>: before version <i>6.0.0</i> the function returned
--   <a>Integer</a>, i.e. it wasn't polymorphic in its return type.
--   
--   <b>Warning</b>: this function does not perform range checks.
hexadecimal :: forall e s m a. (MonadParsec e s m, Token s ~ Char, Num a) => m a

-- | Parse a floating point value as a <a>Scientific</a> number.
--   <a>Scientific</a> is great for parsing of arbitrary precision numbers
--   coming from an untrusted source. See documentation in
--   <a>Data.Scientific</a> for more information.
--   
--   The parser can be used to parse integers or floating point values. Use
--   functions like <a>floatingOrInteger</a> from <a>Data.Scientific</a> to
--   test and extract integer or real values.
--   
--   This function does not parse sign, if you need to parse signed
--   numbers, see <a>signed</a>.
scientific :: forall e s m. (MonadParsec e s m, Token s ~ Char) => m Scientific

-- | Parse a floating point number according to the syntax for floating
--   point literals described in the Haskell report.
--   
--   This function does not parse sign, if you need to parse signed
--   numbers, see <a>signed</a>.
--   
--   <b>Note</b>: before version <i>6.0.0</i> the function returned
--   <a>Double</a>, i.e. it wasn't polymorphic in its return type.
--   
--   <b>Note</b>: in versions <i>6.0.0</i>–<i>6.1.1</i> this function
--   accepted plain integers.
float :: (MonadParsec e s m, Token s ~ Char, RealFloat a) => m a

-- | <tt><a>signed</a> space p</tt> parses an optional sign character (“+”
--   or “-”), then if there is a sign it consumes optional white space
--   (using the <tt>space</tt> parser), then it runs the parser <tt>p</tt>
--   which should return a number. Sign of the number is changed according
--   to the previously parsed sign character.
--   
--   For example, to parse signed integer you can write:
--   
--   <pre>
--   lexeme        = L.lexeme spaceConsumer
--   integer       = lexeme L.decimal
--   signedInteger = L.signed spaceConsumer integer
--   </pre>
signed :: (MonadParsec e s m, Token s ~ Char, Num a) => m () -> m a -> m a


-- | Binary-format number parsers.
module Text.Megaparsec.Byte.Binary

-- | Data types that can be converted to little- or big- endian numbers.
class BinaryChunk chunk
convertChunkBE :: (BinaryChunk chunk, Bits a, Num a) => chunk -> a
convertChunkLE :: (BinaryChunk chunk, Bits a, Num a) => chunk -> a

-- | Parse a little-endian number.
--   
--   You may wish to call this with a visible type application:
--   
--   <pre>
--   number &lt;- anyLE (Just "little-endian 32 bit word") @Word32
--   </pre>
anyLE :: forall a e s m. (MonadParsec e s m, FiniteBits a, Num a, BinaryChunk (Tokens s)) => Maybe String -> m a

-- | Parse a big-endian number.
--   
--   You may wish to call this with a visible type application:
--   
--   <pre>
--   number &lt;- anyBE (Just "big-endian 32 bit word") @Word32
--   </pre>
anyBE :: forall a e s m. (MonadParsec e s m, FiniteBits a, Num a, BinaryChunk (Tokens s)) => Maybe String -> m a

-- | Parse a <a>Word8</a>.
word8 :: (MonadParsec e s m, BinaryChunk (Tokens s)) => m Word8

-- | Parse a little-endian <a>Word16</a>.
word16le :: (MonadParsec e s m, BinaryChunk (Tokens s)) => m Word16

-- | Parse a big-endian <a>Word16</a>.
word16be :: (MonadParsec e s m, BinaryChunk (Tokens s)) => m Word16

-- | Parse a little-endian <a>Word32</a>.
word32le :: (MonadParsec e s m, BinaryChunk (Tokens s)) => m Word32

-- | Parse a big-endian <a>Word32</a>.
word32be :: (MonadParsec e s m, BinaryChunk (Tokens s)) => m Word32

-- | Parse a little-endian <a>Word64</a>.
word64le :: (MonadParsec e s m, BinaryChunk (Tokens s)) => m Word64

-- | Parse a big-endian <a>Word64</a>.
word64be :: (MonadParsec e s m, BinaryChunk (Tokens s)) => m Word64

-- | Parse a <a>Int8</a>.
int8 :: (MonadParsec e s m, BinaryChunk (Tokens s)) => m Int8

-- | Parse a little-endian <a>Int16</a>.
int16le :: (MonadParsec e s m, BinaryChunk (Tokens s)) => m Int16

-- | Parse a big-endian <a>Int16</a>.
int16be :: (MonadParsec e s m, BinaryChunk (Tokens s)) => m Int16

-- | Parse a little-endian <a>Int32</a>.
int32le :: (MonadParsec e s m, BinaryChunk (Tokens s)) => m Int32

-- | Parse a big-endian <a>Int32</a>.
int32be :: (MonadParsec e s m, BinaryChunk (Tokens s)) => m Int32

-- | Parse a little-endian <a>Int64</a>.
int64le :: (MonadParsec e s m, BinaryChunk (Tokens s)) => m Int64

-- | Parse a big-endian <a>Int64</a>.
int64be :: (MonadParsec e s m, BinaryChunk (Tokens s)) => m Int64
instance Text.Megaparsec.Byte.Binary.BinaryChunk Data.ByteString.Internal.Type.ByteString
instance Text.Megaparsec.Byte.Binary.BinaryChunk Data.ByteString.Lazy.Internal.ByteString


-- | Commonly used binary parsers.
module Text.Megaparsec.Byte

-- | Parse a newline byte.
newline :: (MonadParsec e s m, Token s ~ Word8) => m (Token s)

-- | Parse a carriage return character followed by a newline character.
--   Return the sequence of characters parsed.
crlf :: forall e s m. (MonadParsec e s m, Token s ~ Word8) => m (Tokens s)

-- | Parse a CRLF (see <a>crlf</a>) or LF (see <a>newline</a>) end of line.
--   Return the sequence of characters parsed.
eol :: forall e s m. (MonadParsec e s m, Token s ~ Word8) => m (Tokens s)

-- | Parse a tab character.
tab :: (MonadParsec e s m, Token s ~ Word8) => m (Token s)

-- | Skip <i>zero</i> or more white space characters.
--   
--   See also: <a>skipMany</a> and <a>spaceChar</a>.
space :: (MonadParsec e s m, Token s ~ Word8) => m ()

-- | Like <a>space</a>, but does not accept newlines and carriage returns.
hspace :: (MonadParsec e s m, Token s ~ Word8) => m ()

-- | Skip <i>one</i> or more white space characters.
--   
--   See also: <a>skipSome</a> and <a>spaceChar</a>.
space1 :: (MonadParsec e s m, Token s ~ Word8) => m ()

-- | Like <a>space1</a>, but does not accept newlines and carriage returns.
hspace1 :: (MonadParsec e s m, Token s ~ Word8) => m ()

-- | Parse a control character.
controlChar :: (MonadParsec e s m, Token s ~ Word8) => m (Token s)

-- | Parse a space character, and the control characters: tab, newline,
--   carriage return, form feed, and vertical tab.
spaceChar :: (MonadParsec e s m, Token s ~ Word8) => m (Token s)

-- | Parse an upper-case character.
upperChar :: (MonadParsec e s m, Token s ~ Word8) => m (Token s)

-- | Parse a lower-case alphabetic character.
lowerChar :: (MonadParsec e s m, Token s ~ Word8) => m (Token s)

-- | Parse an alphabetic character: lower-case or upper-case.
letterChar :: (MonadParsec e s m, Token s ~ Word8) => m (Token s)

-- | Parse an alphabetic or digit characters.
alphaNumChar :: (MonadParsec e s m, Token s ~ Word8) => m (Token s)

-- | Parse a printable character: letter, number, mark, punctuation, symbol
--   or space.
printChar :: (MonadParsec e s m, Token s ~ Word8) => m (Token s)

-- | Parse an ASCII digit, i.e between “0” and “9”.
digitChar :: (MonadParsec e s m, Token s ~ Word8) => m (Token s)

-- | Parse a binary digit, i.e. “0” or “1”.
binDigitChar :: (MonadParsec e s m, Token s ~ Word8) => m (Token s)

-- | Parse an octal digit, i.e. between “0” and “7”.
octDigitChar :: (MonadParsec e s m, Token s ~ Word8) => m (Token s)

-- | Parse a hexadecimal digit, i.e. between “0” and “9”, or “a” and “f”,
--   or “A” and “F”.
hexDigitChar :: (MonadParsec e s m, Token s ~ Word8) => m (Token s)

-- | Parse a character from the first 128 characters of the Unicode
--   character set, corresponding to the ASCII character set.
asciiChar :: (MonadParsec e s m, Token s ~ Word8) => m (Token s)

-- | A type-constrained version of <a>single</a>.
--   
--   <pre>
--   newline = char 10
--   </pre>
char :: (MonadParsec e s m, Token s ~ Word8) => Token s -> m (Token s)

-- | The same as <a>char</a> but case-insensitive. This parser returns the
--   actually parsed character preserving its case.
--   
--   <pre>
--   &gt;&gt;&gt; parseTest (char' 101) "E"
--   69 -- 'E'
--   
--   &gt;&gt;&gt; parseTest (char' 101) "G"
--   1:1:
--   unexpected 'G'
--   expecting 'E' or 'e'
--   </pre>
char' :: (MonadParsec e s m, Token s ~ Word8) => Token s -> m (Token s)

-- | A synonym for <a>chunk</a>.
string :: MonadParsec e s m => Tokens s -> m (Tokens s)

-- | The same as <a>string</a>, but case-insensitive. On success returns
--   string cased as the parsed input.
--   
--   <pre>
--   &gt;&gt;&gt; parseTest (string' "foobar") "foObAr"
--   "foObAr"
--   </pre>
string' :: (MonadParsec e s m, FoldCase (Tokens s)) => Tokens s -> m (Tokens s)


-- | Stripped-down version of <a>Text.Megaparsec.Char.Lexer</a> for streams
--   of bytes.
--   
--   This module is intended to be imported qualified:
--   
--   <pre>
--   import qualified Text.Megaparsec.Byte.Lexer as L
--   </pre>
module Text.Megaparsec.Byte.Lexer

-- | <tt><a>space</a> sc lineComment blockComment</tt> produces a parser
--   that can parse white space in general. It's expected that you create
--   such a parser once and pass it to other functions in this module as
--   needed (when you see <tt>spaceConsumer</tt> in documentation, usually
--   it means that something like <a>space</a> is expected there).
--   
--   <tt>sc</tt> is used to parse blocks of space characters. You can use
--   <a>space1</a> from <a>Text.Megaparsec.Char</a> for this purpose as
--   well as your own parser (if you don't want to automatically consume
--   newlines, for example). Make sure that the parser does not succeed on
--   the empty input though. In an earlier version of the library
--   <a>spaceChar</a> was recommended, but now parsers based on
--   <a>takeWhile1P</a> are preferred because of their speed.
--   
--   <tt>lineComment</tt> is used to parse line comments. You can use
--   <tt>skipLineComment</tt> if you don't need anything special.
--   
--   <tt>blockComment</tt> is used to parse block (multi-line) comments.
--   You can use <tt>skipBlockComment</tt> or
--   <tt>skipBlockCommentNested</tt> if you don't need anything special.
--   
--   If you don't want to allow a kind of comment, simply pass <a>empty</a>
--   which will fail instantly when parsing of that sort of comment is
--   attempted and <a>space</a> will just move on or finish depending on
--   whether there is more white space for it to consume.
space :: MonadParsec e s m => m () -> m () -> m () -> m ()

-- | This is a wrapper for lexemes. The typical usage is to supply the
--   first argument (parser that consumes white space, probably defined via
--   <a>space</a>) and use the resulting function to wrap parsers for every
--   lexeme.
--   
--   <pre>
--   lexeme  = L.lexeme spaceConsumer
--   integer = lexeme L.decimal
--   </pre>
lexeme :: MonadParsec e s m => m () -> m a -> m a

-- | This is a helper to parse symbols, i.e. verbatim strings. You pass the
--   first argument (parser that consumes white space, probably defined via
--   <a>space</a>) and then you can use the resulting function to parse
--   strings:
--   
--   <pre>
--   symbol    = L.symbol spaceConsumer
--   
--   parens    = between (symbol "(") (symbol ")")
--   braces    = between (symbol "{") (symbol "}")
--   angles    = between (symbol "&lt;") (symbol "&gt;")
--   brackets  = between (symbol "[") (symbol "]")
--   semicolon = symbol ";"
--   comma     = symbol ","
--   colon     = symbol ":"
--   dot       = symbol "."
--   </pre>
symbol :: MonadParsec e s m => m () -> Tokens s -> m (Tokens s)

-- | A case-insensitive version of <a>symbol</a>. This may be helpful if
--   you're working with case-insensitive languages.
symbol' :: (MonadParsec e s m, FoldCase (Tokens s)) => m () -> Tokens s -> m (Tokens s)

-- | Given a comment prefix this function returns a parser that skips line
--   comments. Note that it stops just before the newline character but
--   doesn't consume the newline. Newline is either supposed to be consumed
--   by <a>space</a> parser or picked up manually.
skipLineComment :: (MonadParsec e s m, Token s ~ Word8) => Tokens s -> m ()

-- | <tt><a>skipBlockComment</a> start end</tt> skips non-nested block
--   comment starting with <tt>start</tt> and ending with <tt>end</tt>.
skipBlockComment :: MonadParsec e s m => Tokens s -> Tokens s -> m ()

-- | <tt><a>skipBlockCommentNested</a> start end</tt> skips possibly nested
--   block comment starting with <tt>start</tt> and ending with
--   <tt>end</tt>.
skipBlockCommentNested :: (MonadParsec e s m, Token s ~ Word8) => Tokens s -> Tokens s -> m ()

-- | Parse an integer in the decimal representation according to the format
--   of integer literals described in the Haskell report.
--   
--   If you need to parse signed integers, see the <a>signed</a>
--   combinator.
--   
--   <b>Warning</b>: this function does not perform range checks.
decimal :: forall e s m a. (MonadParsec e s m, Token s ~ Word8, Num a) => m a

-- | Parse an integer in the binary representation. The binary number is
--   expected to be a non-empty sequence of zeroes “0” and ones “1”.
--   
--   You could of course parse some prefix before the actual number:
--   
--   <pre>
--   binary = char 48 &gt;&gt; char' 98 &gt;&gt; L.binary
--   </pre>
--   
--   <b>Warning</b>: this function does not perform range checks.
binary :: forall e s m a. (MonadParsec e s m, Token s ~ Word8, Num a) => m a

-- | Parse an integer in the octal representation. The format of the octal
--   number is expected to be according to the Haskell report except for
--   the fact that this parser doesn't parse “0o” or “0O” prefix. It is a
--   responsibility of the programmer to parse correct prefix before
--   parsing the number itself.
--   
--   For example you can make it conform to the Haskell report like this:
--   
--   <pre>
--   octal = char 48 &gt;&gt; char' 111 &gt;&gt; L.octal
--   </pre>
--   
--   <b>Warning</b>: this function does not perform range checks.
octal :: forall e s m a. (MonadParsec e s m, Token s ~ Word8, Num a) => m a

-- | Parse an integer in the hexadecimal representation. The format of the
--   hexadecimal number is expected to be according to the Haskell report
--   except for the fact that this parser doesn't parse “0x” or “0X”
--   prefix. It is a responsibility of the programmer to parse correct
--   prefix before parsing the number itself.
--   
--   For example you can make it conform to the Haskell report like this:
--   
--   <pre>
--   hexadecimal = char 48 &gt;&gt; char' 120 &gt;&gt; L.hexadecimal
--   </pre>
--   
--   <b>Warning</b>: this function does not perform range checks.
hexadecimal :: forall e s m a. (MonadParsec e s m, Token s ~ Word8, Num a) => m a

-- | Parse a floating point value as a <a>Scientific</a> number.
--   <a>Scientific</a> is great for parsing of arbitrary precision numbers
--   coming from an untrusted source. See documentation in
--   <a>Data.Scientific</a> for more information.
--   
--   The parser can be used to parse integers or floating point values. Use
--   functions like <a>floatingOrInteger</a> from <a>Data.Scientific</a> to
--   test and extract integer or real values.
--   
--   This function does not parse sign, if you need to parse signed
--   numbers, see <a>signed</a>.
scientific :: forall e s m. (MonadParsec e s m, Token s ~ Word8) => m Scientific

-- | Parse a floating point number according to the syntax for floating
--   point literals described in the Haskell report.
--   
--   This function does not parse sign, if you need to parse signed
--   numbers, see <a>signed</a>.
--   
--   <b>Note</b>: in versions <i>6.0.0</i>–<i>6.1.1</i> this function
--   accepted plain integers.
float :: (MonadParsec e s m, Token s ~ Word8, RealFloat a) => m a

-- | <tt><a>signed</a> space p</tt> parser parses an optional sign
--   character (“+” or “-”), then if there is a sign it consumes optional
--   white space (using <tt>space</tt> parser), then it runs parser
--   <tt>p</tt> which should return a number. Sign of the number is changed
--   according to the previously parsed sign character.
--   
--   For example, to parse signed integer you can write:
--   
--   <pre>
--   lexeme        = L.lexeme spaceConsumer
--   integer       = lexeme L.decimal
--   signedInteger = L.signed spaceConsumer integer
--   </pre>
signed :: (MonadParsec e s m, Token s ~ Word8, Num a) => m () -> m a -> m a
