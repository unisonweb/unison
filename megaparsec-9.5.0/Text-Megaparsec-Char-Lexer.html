<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><title>Text.Megaparsec.Char.Lexer</title><link href="linuwial.css" rel="stylesheet" type="text/css" title="Linuwial" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400i,700" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { processClass: "mathjax", ignoreClass: ".*" } });</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><span class="caption">megaparsec-9.5.0: Monadic parser combinators</span><ul class="links" id="page-menu"><li><a href="src/Text.Megaparsec.Char.Lexer.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul></div><div id="content"><div id="module-header"><table class="info"><tr><th valign="top">Copyright</th><td>&#169; 2015&#8211;present Megaparsec contributors<br />&#169; 2007 Paolo Martini<br />&#169; 1999&#8211;2001 Daan Leijen</td></tr><tr><th>License</th><td>FreeBSD</td></tr><tr><th>Maintainer</th><td>Mark Karpov &lt;markkarpov92@gmail.com&gt;</td></tr><tr><th>Stability</th><td>experimental</td></tr><tr><th>Portability</th><td>non-portable</td></tr><tr><th>Safe Haskell</th><td>Safe</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">Text.Megaparsec.Char.Lexer</p></div><div id="table-of-contents"><div id="contents-list"><p class="caption" onclick="window.scrollTo(0,0)">Contents</p><ul><li><a href="#g:1">White space</a></li><li><a href="#g:2">Indentation</a></li><li><a href="#g:3">Character and string literals</a></li><li><a href="#g:4">Numbers</a></li></ul></div></div><div id="description"><p class="caption">Description</p><div class="doc"><p>High-level parsers to help you write your lexer. The module doesn't
 impose how you should write your parser, but certain approaches may be
 more elegant than others.</p><p>Parsing of white space is an important part of any parser. We propose a
 convention where <strong>every lexeme parser assumes no spaces before the</strong>
 <strong>lexeme and consumes all spaces after the lexeme</strong>; this is what the
 <code><a href="Text-Megaparsec-Char-Lexer.html#v:lexeme" title="Text.Megaparsec.Char.Lexer">lexeme</a></code> combinator does, and so it's enough to wrap every lexeme parser
 with <code><a href="Text-Megaparsec-Char-Lexer.html#v:lexeme" title="Text.Megaparsec.Char.Lexer">lexeme</a></code> to achieve this. Note that you'll need to call <code><a href="Text-Megaparsec-Char-Lexer.html#v:space" title="Text.Megaparsec.Char.Lexer">space</a></code>
 manually to consume any white space before the first lexeme (i.e. at the
 beginning of the file).</p><p>This module is intended to be imported qualified:</p><pre>import qualified Text.Megaparsec.Char.Lexer as L</pre><p>To do lexing of byte streams, see <a href="Text-Megaparsec-Byte-Lexer.html">Text.Megaparsec.Byte.Lexer</a>.</p></div></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"><li class="src short"><a href="#v:space">space</a> :: <a href="Text-Megaparsec.html#t:MonadParsec" title="Text.Megaparsec">MonadParsec</a> e s m =&gt; m () -&gt; m () -&gt; m () -&gt; m ()</li><li class="src short"><a href="#v:lexeme">lexeme</a> :: <a href="Text-Megaparsec.html#t:MonadParsec" title="Text.Megaparsec">MonadParsec</a> e s m =&gt; m () -&gt; m a -&gt; m a</li><li class="src short"><a href="#v:symbol">symbol</a> :: <a href="Text-Megaparsec.html#t:MonadParsec" title="Text.Megaparsec">MonadParsec</a> e s m =&gt; m () -&gt; <a href="Text-Megaparsec-Stream.html#t:Tokens" title="Text.Megaparsec.Stream">Tokens</a> s -&gt; m (<a href="Text-Megaparsec-Stream.html#t:Tokens" title="Text.Megaparsec.Stream">Tokens</a> s)</li><li class="src short"><a href="#v:symbol-39-">symbol'</a> :: (<a href="Text-Megaparsec.html#t:MonadParsec" title="Text.Megaparsec">MonadParsec</a> e s m, <a href="../case-insensitive-1.2.1.0/Data-CaseInsensitive.html#t:FoldCase" title="Data.CaseInsensitive">FoldCase</a> (<a href="Text-Megaparsec-Stream.html#t:Tokens" title="Text.Megaparsec.Stream">Tokens</a> s)) =&gt; m () -&gt; <a href="Text-Megaparsec-Stream.html#t:Tokens" title="Text.Megaparsec.Stream">Tokens</a> s -&gt; m (<a href="Text-Megaparsec-Stream.html#t:Tokens" title="Text.Megaparsec.Stream">Tokens</a> s)</li><li class="src short"><a href="#v:skipLineComment">skipLineComment</a> :: (<a href="Text-Megaparsec.html#t:MonadParsec" title="Text.Megaparsec">MonadParsec</a> e s m, <a href="Text-Megaparsec-Stream.html#t:Token" title="Text.Megaparsec.Stream">Token</a> s <a href="../base-4.18.2.1/Data-Type-Equality.html#t:-126-" title="Data.Type.Equality">~</a> <a href="../base-4.18.2.1/Data-Char.html#t:Char" title="Data.Char">Char</a>) =&gt; <a href="Text-Megaparsec-Stream.html#t:Tokens" title="Text.Megaparsec.Stream">Tokens</a> s -&gt; m ()</li><li class="src short"><a href="#v:skipBlockComment">skipBlockComment</a> :: <a href="Text-Megaparsec.html#t:MonadParsec" title="Text.Megaparsec">MonadParsec</a> e s m =&gt; <a href="Text-Megaparsec-Stream.html#t:Tokens" title="Text.Megaparsec.Stream">Tokens</a> s -&gt; <a href="Text-Megaparsec-Stream.html#t:Tokens" title="Text.Megaparsec.Stream">Tokens</a> s -&gt; m ()</li><li class="src short"><a href="#v:skipBlockCommentNested">skipBlockCommentNested</a> :: (<a href="Text-Megaparsec.html#t:MonadParsec" title="Text.Megaparsec">MonadParsec</a> e s m, <a href="Text-Megaparsec-Stream.html#t:Token" title="Text.Megaparsec.Stream">Token</a> s <a href="../base-4.18.2.1/Data-Type-Equality.html#t:-126-" title="Data.Type.Equality">~</a> <a href="../base-4.18.2.1/Data-Char.html#t:Char" title="Data.Char">Char</a>) =&gt; <a href="Text-Megaparsec-Stream.html#t:Tokens" title="Text.Megaparsec.Stream">Tokens</a> s -&gt; <a href="Text-Megaparsec-Stream.html#t:Tokens" title="Text.Megaparsec.Stream">Tokens</a> s -&gt; m ()</li><li class="src short"><a href="#v:indentLevel">indentLevel</a> :: (<a href="Text-Megaparsec-Stream.html#t:TraversableStream" title="Text.Megaparsec.Stream">TraversableStream</a> s, <a href="Text-Megaparsec.html#t:MonadParsec" title="Text.Megaparsec">MonadParsec</a> e s m) =&gt; m <a href="Text-Megaparsec-Pos.html#t:Pos" title="Text.Megaparsec.Pos">Pos</a></li><li class="src short"><a href="#v:incorrectIndent">incorrectIndent</a> :: <a href="Text-Megaparsec.html#t:MonadParsec" title="Text.Megaparsec">MonadParsec</a> e s m =&gt; <a href="../base-4.18.2.1/Data-Ord.html#t:Ordering" title="Data.Ord">Ordering</a> -&gt; <a href="Text-Megaparsec-Pos.html#t:Pos" title="Text.Megaparsec.Pos">Pos</a> -&gt; <a href="Text-Megaparsec-Pos.html#t:Pos" title="Text.Megaparsec.Pos">Pos</a> -&gt; m a</li><li class="src short"><a href="#v:indentGuard">indentGuard</a> :: (<a href="Text-Megaparsec-Stream.html#t:TraversableStream" title="Text.Megaparsec.Stream">TraversableStream</a> s, <a href="Text-Megaparsec.html#t:MonadParsec" title="Text.Megaparsec">MonadParsec</a> e s m) =&gt; m () -&gt; <a href="../base-4.18.2.1/Data-Ord.html#t:Ordering" title="Data.Ord">Ordering</a> -&gt; <a href="Text-Megaparsec-Pos.html#t:Pos" title="Text.Megaparsec.Pos">Pos</a> -&gt; m <a href="Text-Megaparsec-Pos.html#t:Pos" title="Text.Megaparsec.Pos">Pos</a></li><li class="src short"><a href="#v:nonIndented">nonIndented</a> :: (<a href="Text-Megaparsec-Stream.html#t:TraversableStream" title="Text.Megaparsec.Stream">TraversableStream</a> s, <a href="Text-Megaparsec.html#t:MonadParsec" title="Text.Megaparsec">MonadParsec</a> e s m) =&gt; m () -&gt; m a -&gt; m a</li><li class="src short"><span class="keyword">data</span> <a href="#t:IndentOpt">IndentOpt</a> m a b<ul class="subs"><li>= <a href="#v:IndentNone">IndentNone</a> a</li><li>| <a href="#v:IndentMany">IndentMany</a> (<a href="../base-4.18.2.1/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> <a href="Text-Megaparsec-Pos.html#t:Pos" title="Text.Megaparsec.Pos">Pos</a>) ([b] -&gt; m a) (m b)</li><li>| <a href="#v:IndentSome">IndentSome</a> (<a href="../base-4.18.2.1/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> <a href="Text-Megaparsec-Pos.html#t:Pos" title="Text.Megaparsec.Pos">Pos</a>) ([b] -&gt; m a) (m b)</li></ul></li><li class="src short"><a href="#v:indentBlock">indentBlock</a> :: (<a href="Text-Megaparsec-Stream.html#t:TraversableStream" title="Text.Megaparsec.Stream">TraversableStream</a> s, <a href="Text-Megaparsec.html#t:MonadParsec" title="Text.Megaparsec">MonadParsec</a> e s m, <a href="Text-Megaparsec-Stream.html#t:Token" title="Text.Megaparsec.Stream">Token</a> s <a href="../base-4.18.2.1/Data-Type-Equality.html#t:-126-" title="Data.Type.Equality">~</a> <a href="../base-4.18.2.1/Data-Char.html#t:Char" title="Data.Char">Char</a>) =&gt; m () -&gt; m (<a href="Text-Megaparsec-Char-Lexer.html#t:IndentOpt" title="Text.Megaparsec.Char.Lexer">IndentOpt</a> m a b) -&gt; m a</li><li class="src short"><a href="#v:lineFold">lineFold</a> :: (<a href="Text-Megaparsec-Stream.html#t:TraversableStream" title="Text.Megaparsec.Stream">TraversableStream</a> s, <a href="Text-Megaparsec.html#t:MonadParsec" title="Text.Megaparsec">MonadParsec</a> e s m) =&gt; m () -&gt; (m () -&gt; m a) -&gt; m a</li><li class="src short"><a href="#v:charLiteral">charLiteral</a> :: (<a href="Text-Megaparsec.html#t:MonadParsec" title="Text.Megaparsec">MonadParsec</a> e s m, <a href="Text-Megaparsec-Stream.html#t:Token" title="Text.Megaparsec.Stream">Token</a> s <a href="../base-4.18.2.1/Data-Type-Equality.html#t:-126-" title="Data.Type.Equality">~</a> <a href="../base-4.18.2.1/Data-Char.html#t:Char" title="Data.Char">Char</a>) =&gt; m <a href="../base-4.18.2.1/Data-Char.html#t:Char" title="Data.Char">Char</a></li><li class="src short"><a href="#v:decimal">decimal</a> :: (<a href="Text-Megaparsec.html#t:MonadParsec" title="Text.Megaparsec">MonadParsec</a> e s m, <a href="Text-Megaparsec-Stream.html#t:Token" title="Text.Megaparsec.Stream">Token</a> s <a href="../base-4.18.2.1/Data-Type-Equality.html#t:-126-" title="Data.Type.Equality">~</a> <a href="../base-4.18.2.1/Data-Char.html#t:Char" title="Data.Char">Char</a>, <a href="../base-4.18.2.1/Prelude.html#t:Num" title="Prelude">Num</a> a) =&gt; m a</li><li class="src short"><a href="#v:binary">binary</a> :: <span class="keyword">forall</span> e s m a. (<a href="Text-Megaparsec.html#t:MonadParsec" title="Text.Megaparsec">MonadParsec</a> e s m, <a href="Text-Megaparsec-Stream.html#t:Token" title="Text.Megaparsec.Stream">Token</a> s <a href="../base-4.18.2.1/Data-Type-Equality.html#t:-126-" title="Data.Type.Equality">~</a> <a href="../base-4.18.2.1/Data-Char.html#t:Char" title="Data.Char">Char</a>, <a href="../base-4.18.2.1/Prelude.html#t:Num" title="Prelude">Num</a> a) =&gt; m a</li><li class="src short"><a href="#v:octal">octal</a> :: <span class="keyword">forall</span> e s m a. (<a href="Text-Megaparsec.html#t:MonadParsec" title="Text.Megaparsec">MonadParsec</a> e s m, <a href="Text-Megaparsec-Stream.html#t:Token" title="Text.Megaparsec.Stream">Token</a> s <a href="../base-4.18.2.1/Data-Type-Equality.html#t:-126-" title="Data.Type.Equality">~</a> <a href="../base-4.18.2.1/Data-Char.html#t:Char" title="Data.Char">Char</a>, <a href="../base-4.18.2.1/Prelude.html#t:Num" title="Prelude">Num</a> a) =&gt; m a</li><li class="src short"><a href="#v:hexadecimal">hexadecimal</a> :: <span class="keyword">forall</span> e s m a. (<a href="Text-Megaparsec.html#t:MonadParsec" title="Text.Megaparsec">MonadParsec</a> e s m, <a href="Text-Megaparsec-Stream.html#t:Token" title="Text.Megaparsec.Stream">Token</a> s <a href="../base-4.18.2.1/Data-Type-Equality.html#t:-126-" title="Data.Type.Equality">~</a> <a href="../base-4.18.2.1/Data-Char.html#t:Char" title="Data.Char">Char</a>, <a href="../base-4.18.2.1/Prelude.html#t:Num" title="Prelude">Num</a> a) =&gt; m a</li><li class="src short"><a href="#v:scientific">scientific</a> :: <span class="keyword">forall</span> e s m. (<a href="Text-Megaparsec.html#t:MonadParsec" title="Text.Megaparsec">MonadParsec</a> e s m, <a href="Text-Megaparsec-Stream.html#t:Token" title="Text.Megaparsec.Stream">Token</a> s <a href="../base-4.18.2.1/Data-Type-Equality.html#t:-126-" title="Data.Type.Equality">~</a> <a href="../base-4.18.2.1/Data-Char.html#t:Char" title="Data.Char">Char</a>) =&gt; m <a href="../scientific-0.3.7.0/Data-Scientific.html#t:Scientific" title="Data.Scientific">Scientific</a></li><li class="src short"><a href="#v:float">float</a> :: (<a href="Text-Megaparsec.html#t:MonadParsec" title="Text.Megaparsec">MonadParsec</a> e s m, <a href="Text-Megaparsec-Stream.html#t:Token" title="Text.Megaparsec.Stream">Token</a> s <a href="../base-4.18.2.1/Data-Type-Equality.html#t:-126-" title="Data.Type.Equality">~</a> <a href="../base-4.18.2.1/Data-Char.html#t:Char" title="Data.Char">Char</a>, <a href="../base-4.18.2.1/Prelude.html#t:RealFloat" title="Prelude">RealFloat</a> a) =&gt; m a</li><li class="src short"><a href="#v:signed">signed</a> :: (<a href="Text-Megaparsec.html#t:MonadParsec" title="Text.Megaparsec">MonadParsec</a> e s m, <a href="Text-Megaparsec-Stream.html#t:Token" title="Text.Megaparsec.Stream">Token</a> s <a href="../base-4.18.2.1/Data-Type-Equality.html#t:-126-" title="Data.Type.Equality">~</a> <a href="../base-4.18.2.1/Data-Char.html#t:Char" title="Data.Char">Char</a>, <a href="../base-4.18.2.1/Prelude.html#t:Num" title="Prelude">Num</a> a) =&gt; m () -&gt; m a -&gt; m a</li></ul></details></div><div id="interface"><a href="#g:1" id="g:1"><h1>White space</h1></a><div class="top"><p class="src"><a id="v:space" class="def">space</a> <a href="src/Text.Megaparsec.Lexer.html#space" class="link">Source</a> <a href="#v:space" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="Text-Megaparsec.html#t:MonadParsec" title="Text.Megaparsec">MonadParsec</a> e s m</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; m ()</td><td class="doc"><p>A parser for space characters which does not accept empty
 input (e.g. <code><a href="Text-Megaparsec-Char.html#v:space1" title="Text.Megaparsec.Char">space1</a></code>)</p></td></tr><tr><td class="src">-&gt; m ()</td><td class="doc"><p>A parser for a line comment (e.g. <code>skipLineComment</code>)</p></td></tr><tr><td class="src">-&gt; m ()</td><td class="doc"><p>A parser for a block comment (e.g. <code>skipBlockComment</code>)</p></td></tr><tr><td class="src">-&gt; m ()</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p><code><code><a href="Text-Megaparsec-Char-Lexer.html#v:space" title="Text.Megaparsec.Char.Lexer">space</a></code> sc lineComment blockComment</code> produces a parser that can parse
 white space in general. It's expected that you create such a parser once
 and pass it to other functions in this module as needed (when you see
 <code>spaceConsumer</code> in documentation, usually it means that something like
 <code><a href="Text-Megaparsec-Char-Lexer.html#v:space" title="Text.Megaparsec.Char.Lexer">space</a></code> is expected there).</p><p><code>sc</code> is used to parse blocks of space characters. You can use
 <code><a href="Text-Megaparsec-Char.html#v:space1" title="Text.Megaparsec.Char">space1</a></code> from <a href="Text-Megaparsec-Char.html">Text.Megaparsec.Char</a> for this
 purpose as well as your own parser (if you don't want to automatically
 consume newlines, for example). Make sure that the parser does not
 succeed on the empty input though. In an earlier version of the library
 <code><a href="Text-Megaparsec-Char.html#v:spaceChar" title="Text.Megaparsec.Char">spaceChar</a></code> was recommended, but now parsers based
 on <code><a href="Text-Megaparsec.html#v:takeWhile1P" title="Text.Megaparsec">takeWhile1P</a></code> are preferred because of their speed.</p><p><code>lineComment</code> is used to parse line comments. You can use
 <code>skipLineComment</code> if you don't need anything special.</p><p><code>blockComment</code> is used to parse block (multi-line) comments. You can use
 <code>skipBlockComment</code> or <code>skipBlockCommentNested</code> if you don't need anything
 special.</p><p>If you don't want to allow a kind of comment, simply pass <code><a href="../base-4.18.2.1/Control-Applicative.html#v:empty" title="Control.Applicative">empty</a></code> which
 will fail instantly when parsing of that sort of comment is attempted and
 <code><a href="Text-Megaparsec-Char-Lexer.html#v:space" title="Text.Megaparsec.Char.Lexer">space</a></code> will just move on or finish depending on whether there is more
 white space for it to consume.</p></div></div><div class="top"><p class="src"><a id="v:lexeme" class="def">lexeme</a> <a href="src/Text.Megaparsec.Lexer.html#lexeme" class="link">Source</a> <a href="#v:lexeme" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="Text-Megaparsec.html#t:MonadParsec" title="Text.Megaparsec">MonadParsec</a> e s m</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; m ()</td><td class="doc"><p>How to consume white space after lexeme</p></td></tr><tr><td class="src">-&gt; m a</td><td class="doc"><p>How to parse actual lexeme</p></td></tr><tr><td class="src">-&gt; m a</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>This is a wrapper for lexemes. The typical usage is to supply the first
 argument (parser that consumes white space, probably defined via <code><a href="Text-Megaparsec-Char-Lexer.html#v:space" title="Text.Megaparsec.Char.Lexer">space</a></code>)
 and use the resulting function to wrap parsers for every lexeme.</p><pre>lexeme  = L.lexeme spaceConsumer
integer = lexeme L.decimal</pre></div></div><div class="top"><p class="src"><a id="v:symbol" class="def">symbol</a> <a href="src/Text.Megaparsec.Lexer.html#symbol" class="link">Source</a> <a href="#v:symbol" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="Text-Megaparsec.html#t:MonadParsec" title="Text.Megaparsec">MonadParsec</a> e s m</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; m ()</td><td class="doc"><p>How to consume white space after lexeme</p></td></tr><tr><td class="src">-&gt; <a href="Text-Megaparsec-Stream.html#t:Tokens" title="Text.Megaparsec.Stream">Tokens</a> s</td><td class="doc"><p>Symbol to parse</p></td></tr><tr><td class="src">-&gt; m (<a href="Text-Megaparsec-Stream.html#t:Tokens" title="Text.Megaparsec.Stream">Tokens</a> s)</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>This is a helper to parse symbols, i.e. verbatim strings. You pass the
 first argument (parser that consumes white space, probably defined via
 <code><a href="Text-Megaparsec-Char-Lexer.html#v:space" title="Text.Megaparsec.Char.Lexer">space</a></code>) and then you can use the resulting function to parse strings:</p><pre>symbol    = L.symbol spaceConsumer

parens    = between (symbol &quot;(&quot;) (symbol &quot;)&quot;)
braces    = between (symbol &quot;{&quot;) (symbol &quot;}&quot;)
angles    = between (symbol &quot;&lt;&quot;) (symbol &quot;&gt;&quot;)
brackets  = between (symbol &quot;[&quot;) (symbol &quot;]&quot;)
semicolon = symbol &quot;;&quot;
comma     = symbol &quot;,&quot;
colon     = symbol &quot;:&quot;
dot       = symbol &quot;.&quot;</pre></div></div><div class="top"><p class="src"><a id="v:symbol-39-" class="def">symbol'</a> <a href="src/Text.Megaparsec.Lexer.html#symbol%27" class="link">Source</a> <a href="#v:symbol-39-" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (<a href="Text-Megaparsec.html#t:MonadParsec" title="Text.Megaparsec">MonadParsec</a> e s m, <a href="../case-insensitive-1.2.1.0/Data-CaseInsensitive.html#t:FoldCase" title="Data.CaseInsensitive">FoldCase</a> (<a href="Text-Megaparsec-Stream.html#t:Tokens" title="Text.Megaparsec.Stream">Tokens</a> s))</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; m ()</td><td class="doc"><p>How to consume white space after lexeme</p></td></tr><tr><td class="src">-&gt; <a href="Text-Megaparsec-Stream.html#t:Tokens" title="Text.Megaparsec.Stream">Tokens</a> s</td><td class="doc"><p>Symbol to parse (case-insensitive)</p></td></tr><tr><td class="src">-&gt; m (<a href="Text-Megaparsec-Stream.html#t:Tokens" title="Text.Megaparsec.Stream">Tokens</a> s)</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>A case-insensitive version of <code><a href="Text-Megaparsec-Char-Lexer.html#v:symbol" title="Text.Megaparsec.Char.Lexer">symbol</a></code>. This may be helpful if you're
 working with case-insensitive languages.</p></div></div><div class="top"><p class="src"><a id="v:skipLineComment" class="def">skipLineComment</a> <a href="src/Text.Megaparsec.Char.Lexer.html#skipLineComment" class="link">Source</a> <a href="#v:skipLineComment" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (<a href="Text-Megaparsec.html#t:MonadParsec" title="Text.Megaparsec">MonadParsec</a> e s m, <a href="Text-Megaparsec-Stream.html#t:Token" title="Text.Megaparsec.Stream">Token</a> s <a href="../base-4.18.2.1/Data-Type-Equality.html#t:-126-" title="Data.Type.Equality">~</a> <a href="../base-4.18.2.1/Data-Char.html#t:Char" title="Data.Char">Char</a>)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; <a href="Text-Megaparsec-Stream.html#t:Tokens" title="Text.Megaparsec.Stream">Tokens</a> s</td><td class="doc"><p>Line comment prefix</p></td></tr><tr><td class="src">-&gt; m ()</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Given a comment prefix this function returns a parser that skips line
 comments. Note that it stops just before the newline character but
 doesn't consume the newline. Newline is either supposed to be consumed by
 <code><a href="Text-Megaparsec-Char-Lexer.html#v:space" title="Text.Megaparsec.Char.Lexer">space</a></code> parser or picked up manually.</p></div></div><div class="top"><p class="src"><a id="v:skipBlockComment" class="def">skipBlockComment</a> <a href="src/Text.Megaparsec.Char.Lexer.html#skipBlockComment" class="link">Source</a> <a href="#v:skipBlockComment" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="Text-Megaparsec.html#t:MonadParsec" title="Text.Megaparsec">MonadParsec</a> e s m</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; <a href="Text-Megaparsec-Stream.html#t:Tokens" title="Text.Megaparsec.Stream">Tokens</a> s</td><td class="doc"><p>Start of block comment</p></td></tr><tr><td class="src">-&gt; <a href="Text-Megaparsec-Stream.html#t:Tokens" title="Text.Megaparsec.Stream">Tokens</a> s</td><td class="doc"><p>End of block comment</p></td></tr><tr><td class="src">-&gt; m ()</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p><code><code><a href="Text-Megaparsec-Char-Lexer.html#v:skipBlockComment" title="Text.Megaparsec.Char.Lexer">skipBlockComment</a></code> start end</code> skips non-nested block comment starting
 with <code>start</code> and ending with <code>end</code>.</p></div></div><div class="top"><p class="src"><a id="v:skipBlockCommentNested" class="def">skipBlockCommentNested</a> <a href="src/Text.Megaparsec.Char.Lexer.html#skipBlockCommentNested" class="link">Source</a> <a href="#v:skipBlockCommentNested" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (<a href="Text-Megaparsec.html#t:MonadParsec" title="Text.Megaparsec">MonadParsec</a> e s m, <a href="Text-Megaparsec-Stream.html#t:Token" title="Text.Megaparsec.Stream">Token</a> s <a href="../base-4.18.2.1/Data-Type-Equality.html#t:-126-" title="Data.Type.Equality">~</a> <a href="../base-4.18.2.1/Data-Char.html#t:Char" title="Data.Char">Char</a>)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; <a href="Text-Megaparsec-Stream.html#t:Tokens" title="Text.Megaparsec.Stream">Tokens</a> s</td><td class="doc"><p>Start of block comment</p></td></tr><tr><td class="src">-&gt; <a href="Text-Megaparsec-Stream.html#t:Tokens" title="Text.Megaparsec.Stream">Tokens</a> s</td><td class="doc"><p>End of block comment</p></td></tr><tr><td class="src">-&gt; m ()</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p><code><code><a href="Text-Megaparsec-Char-Lexer.html#v:skipBlockCommentNested" title="Text.Megaparsec.Char.Lexer">skipBlockCommentNested</a></code> start end</code> skips possibly nested block
 comment starting with <code>start</code> and ending with <code>end</code>.</p><p><em>Since: 5.0.0</em></p></div></div><a href="#g:2" id="g:2"><h1>Indentation</h1></a><div class="top"><p class="src"><a id="v:indentLevel" class="def">indentLevel</a> :: (<a href="Text-Megaparsec-Stream.html#t:TraversableStream" title="Text.Megaparsec.Stream">TraversableStream</a> s, <a href="Text-Megaparsec.html#t:MonadParsec" title="Text.Megaparsec">MonadParsec</a> e s m) =&gt; m <a href="Text-Megaparsec-Pos.html#t:Pos" title="Text.Megaparsec.Pos">Pos</a> <a href="src/Text.Megaparsec.Char.Lexer.html#indentLevel" class="link">Source</a> <a href="#v:indentLevel" class="selflink">#</a></p><div class="doc"><p>Return the current indentation level.</p><p>The function is a simple shortcut defined as:</p><pre>indentLevel = sourceColumn &lt;$&gt; getPosition</pre><p><em>Since: 4.3.0</em></p></div></div><div class="top"><p class="src"><a id="v:incorrectIndent" class="def">incorrectIndent</a> <a href="src/Text.Megaparsec.Char.Lexer.html#incorrectIndent" class="link">Source</a> <a href="#v:incorrectIndent" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="Text-Megaparsec.html#t:MonadParsec" title="Text.Megaparsec">MonadParsec</a> e s m</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; <a href="../base-4.18.2.1/Data-Ord.html#t:Ordering" title="Data.Ord">Ordering</a></td><td class="doc"><p>Desired ordering between reference level and actual level</p></td></tr><tr><td class="src">-&gt; <a href="Text-Megaparsec-Pos.html#t:Pos" title="Text.Megaparsec.Pos">Pos</a></td><td class="doc"><p>Reference indentation level</p></td></tr><tr><td class="src">-&gt; <a href="Text-Megaparsec-Pos.html#t:Pos" title="Text.Megaparsec.Pos">Pos</a></td><td class="doc"><p>Actual indentation level</p></td></tr><tr><td class="src">-&gt; m a</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Fail reporting incorrect indentation error. The error has attached
 information:</p><ul><li>Desired ordering between reference level and actual level</li><li>Reference indentation level</li><li>Actual indentation level</li></ul><p><em>Since: 5.0.0</em></p></div></div><div class="top"><p class="src"><a id="v:indentGuard" class="def">indentGuard</a> <a href="src/Text.Megaparsec.Char.Lexer.html#indentGuard" class="link">Source</a> <a href="#v:indentGuard" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (<a href="Text-Megaparsec-Stream.html#t:TraversableStream" title="Text.Megaparsec.Stream">TraversableStream</a> s, <a href="Text-Megaparsec.html#t:MonadParsec" title="Text.Megaparsec">MonadParsec</a> e s m)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; m ()</td><td class="doc"><p>How to consume indentation (white space)</p></td></tr><tr><td class="src">-&gt; <a href="../base-4.18.2.1/Data-Ord.html#t:Ordering" title="Data.Ord">Ordering</a></td><td class="doc"><p>Desired ordering between reference level and actual level</p></td></tr><tr><td class="src">-&gt; <a href="Text-Megaparsec-Pos.html#t:Pos" title="Text.Megaparsec.Pos">Pos</a></td><td class="doc"><p>Reference indentation level</p></td></tr><tr><td class="src">-&gt; m <a href="Text-Megaparsec-Pos.html#t:Pos" title="Text.Megaparsec.Pos">Pos</a></td><td class="doc"><p>Current column (indentation level)</p></td></tr></table></div><div class="doc"><p><code><code><a href="Text-Megaparsec-Char-Lexer.html#v:indentGuard" title="Text.Megaparsec.Char.Lexer">indentGuard</a></code> spaceConsumer ord ref</code> first consumes all white space
 (indentation) with <code>spaceConsumer</code> parser, then it checks the column
 position. Ordering between current indentation level and the reference
 indentation level <code>ref</code> should be <code>ord</code>, otherwise the parser fails. On
 success the current column position is returned.</p><p>When you want to parse a block of indentation, first run this parser with
 arguments like <code><code><a href="Text-Megaparsec-Char-Lexer.html#v:indentGuard" title="Text.Megaparsec.Char.Lexer">indentGuard</a></code> spaceConsumer <code><a href="../base-4.18.2.1/Data-Ord.html#v:GT" title="Data.Ord">GT</a></code> <code><a href="Text-Megaparsec-Pos.html#v:pos1" title="Text.Megaparsec.Pos">pos1</a></code></code>&#8212;this will make
 sure you have some indentation. Use returned value to check indentation
 on every subsequent line according to syntax of your language.</p></div></div><div class="top"><p class="src"><a id="v:nonIndented" class="def">nonIndented</a> <a href="src/Text.Megaparsec.Char.Lexer.html#nonIndented" class="link">Source</a> <a href="#v:nonIndented" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (<a href="Text-Megaparsec-Stream.html#t:TraversableStream" title="Text.Megaparsec.Stream">TraversableStream</a> s, <a href="Text-Megaparsec.html#t:MonadParsec" title="Text.Megaparsec">MonadParsec</a> e s m)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; m ()</td><td class="doc"><p>How to consume indentation (white space)</p></td></tr><tr><td class="src">-&gt; m a</td><td class="doc"><p>How to parse actual data</p></td></tr><tr><td class="src">-&gt; m a</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Parse a non-indented construction. This ensures that there is no
 indentation before actual data. Useful, for example, as a wrapper for
 top-level function definitions.</p><p><em>Since: 4.3.0</em></p></div></div><div class="top"><p class="src"><span class="keyword">data</span> <a id="t:IndentOpt" class="def">IndentOpt</a> m a b <a href="src/Text.Megaparsec.Char.Lexer.html#IndentOpt" class="link">Source</a> <a href="#t:IndentOpt" class="selflink">#</a></p><div class="doc"><p>Behaviors for parsing of indented tokens. This is used in
 <code><a href="Text-Megaparsec-Char-Lexer.html#v:indentBlock" title="Text.Megaparsec.Char.Lexer">indentBlock</a></code>, which see.</p><p><em>Since: 4.3.0</em></p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a id="v:IndentNone" class="def">IndentNone</a> a</td><td class="doc"><p>Parse no indented tokens, just return the value</p></td></tr><tr><td class="src"><a id="v:IndentMany" class="def">IndentMany</a> (<a href="../base-4.18.2.1/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> <a href="Text-Megaparsec-Pos.html#t:Pos" title="Text.Megaparsec.Pos">Pos</a>) ([b] -&gt; m a) (m b)</td><td class="doc"><p>Parse many indented tokens (possibly zero), use given indentation
 level (if <code><a href="../base-4.18.2.1/Data-Maybe.html#v:Nothing" title="Data.Maybe">Nothing</a></code>, use level of the first indented token); the
 second argument tells how to get the final result, and the third
 argument describes how to parse an indented token</p></td></tr><tr><td class="src"><a id="v:IndentSome" class="def">IndentSome</a> (<a href="../base-4.18.2.1/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> <a href="Text-Megaparsec-Pos.html#t:Pos" title="Text.Megaparsec.Pos">Pos</a>) ([b] -&gt; m a) (m b)</td><td class="doc"><p>Just like <code><a href="Text-Megaparsec-Char-Lexer.html#v:IndentMany" title="Text.Megaparsec.Char.Lexer">IndentMany</a></code>, but requires at least one indented token to
 be present</p></td></tr></table></div></div><div class="top"><p class="src"><a id="v:indentBlock" class="def">indentBlock</a> <a href="src/Text.Megaparsec.Char.Lexer.html#indentBlock" class="link">Source</a> <a href="#v:indentBlock" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (<a href="Text-Megaparsec-Stream.html#t:TraversableStream" title="Text.Megaparsec.Stream">TraversableStream</a> s, <a href="Text-Megaparsec.html#t:MonadParsec" title="Text.Megaparsec">MonadParsec</a> e s m, <a href="Text-Megaparsec-Stream.html#t:Token" title="Text.Megaparsec.Stream">Token</a> s <a href="../base-4.18.2.1/Data-Type-Equality.html#t:-126-" title="Data.Type.Equality">~</a> <a href="../base-4.18.2.1/Data-Char.html#t:Char" title="Data.Char">Char</a>)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; m ()</td><td class="doc"><p>How to consume indentation (white space)</p></td></tr><tr><td class="src">-&gt; m (<a href="Text-Megaparsec-Char-Lexer.html#t:IndentOpt" title="Text.Megaparsec.Char.Lexer">IndentOpt</a> m a b)</td><td class="doc"><p>How to parse &#8220;reference&#8221; token</p></td></tr><tr><td class="src">-&gt; m a</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Parse a &#8220;reference&#8221; token and a number of other tokens that have a
 greater (but the same for all of them) level of indentation than that of
 the &#8220;reference&#8221; token. The reference token can influence parsing, see
 <code><a href="Text-Megaparsec-Char-Lexer.html#t:IndentOpt" title="Text.Megaparsec.Char.Lexer">IndentOpt</a></code> for more information.</p><p><strong>Note</strong>: the first argument of this function <em>must</em> consume newlines
 among other white space characters.</p><p><em>Since: 4.3.0</em></p></div></div><div class="top"><p class="src"><a id="v:lineFold" class="def">lineFold</a> <a href="src/Text.Megaparsec.Char.Lexer.html#lineFold" class="link">Source</a> <a href="#v:lineFold" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (<a href="Text-Megaparsec-Stream.html#t:TraversableStream" title="Text.Megaparsec.Stream">TraversableStream</a> s, <a href="Text-Megaparsec.html#t:MonadParsec" title="Text.Megaparsec">MonadParsec</a> e s m)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; m ()</td><td class="doc"><p>How to consume indentation (white space)</p></td></tr><tr><td class="src">-&gt; (m () -&gt; m a)</td><td class="doc"><p>Callback that uses provided space-consumer</p></td></tr><tr><td class="src">-&gt; m a</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Create a parser that supports line-folding. The first argument is used
 to consume white space between components of line fold, thus it <em>must</em>
 consume newlines in order to work properly. The second argument is a
 callback that receives a custom space-consuming parser as an argument.
 This parser should be used after separate components of line fold that
 can be put on different lines.</p><p>An example should clarify the usage pattern:</p><pre>sc = L.space (void spaceChar) empty empty

myFold = L.lineFold sc $ \sc' -&gt; do
  L.symbol sc' &quot;foo&quot;
  L.symbol sc' &quot;bar&quot;
  L.symbol sc  &quot;baz&quot; -- for the last symbol we use normal space consumer</pre><p><em>Since: 5.0.0</em></p></div></div><a href="#g:3" id="g:3"><h1>Character and string literals</h1></a><div class="top"><p class="src"><a id="v:charLiteral" class="def">charLiteral</a> :: (<a href="Text-Megaparsec.html#t:MonadParsec" title="Text.Megaparsec">MonadParsec</a> e s m, <a href="Text-Megaparsec-Stream.html#t:Token" title="Text.Megaparsec.Stream">Token</a> s <a href="../base-4.18.2.1/Data-Type-Equality.html#t:-126-" title="Data.Type.Equality">~</a> <a href="../base-4.18.2.1/Data-Char.html#t:Char" title="Data.Char">Char</a>) =&gt; m <a href="../base-4.18.2.1/Data-Char.html#t:Char" title="Data.Char">Char</a> <a href="src/Text.Megaparsec.Char.Lexer.html#charLiteral" class="link">Source</a> <a href="#v:charLiteral" class="selflink">#</a></p><div class="doc"><p>The lexeme parser parses a single literal character without quotes. The
 purpose of this parser is to help with parsing of conventional escape
 sequences. It's your responsibility to take care of character literal
 syntax in your language (by surrounding it with single quotes or
 similar).</p><p>The literal character is parsed according to the grammar rules defined in
 the Haskell report.</p><p>Note that you can use this parser as a building block to parse various
 string literals:</p><pre>stringLiteral = char '&quot;' &gt;&gt; manyTill L.charLiteral (char '&quot;')</pre><p><strong>Performance note</strong>: the parser is not particularly efficient at the
 moment.</p></div></div><a href="#g:4" id="g:4"><h1>Numbers</h1></a><div class="top"><p class="src"><a id="v:decimal" class="def">decimal</a> :: (<a href="Text-Megaparsec.html#t:MonadParsec" title="Text.Megaparsec">MonadParsec</a> e s m, <a href="Text-Megaparsec-Stream.html#t:Token" title="Text.Megaparsec.Stream">Token</a> s <a href="../base-4.18.2.1/Data-Type-Equality.html#t:-126-" title="Data.Type.Equality">~</a> <a href="../base-4.18.2.1/Data-Char.html#t:Char" title="Data.Char">Char</a>, <a href="../base-4.18.2.1/Prelude.html#t:Num" title="Prelude">Num</a> a) =&gt; m a <a href="src/Text.Megaparsec.Char.Lexer.html#decimal" class="link">Source</a> <a href="#v:decimal" class="selflink">#</a></p><div class="doc"><p>Parse an integer in the decimal representation according to the format
 of integer literals described in the Haskell report.</p><p>If you need to parse signed integers, see the <code><a href="Text-Megaparsec-Char-Lexer.html#v:signed" title="Text.Megaparsec.Char.Lexer">signed</a></code> combinator.</p><p><strong>Note</strong>: before the version <em>6.0.0</em> the function returned <code><a href="../base-4.18.2.1/Prelude.html#t:Integer" title="Prelude">Integer</a></code>,
 i.e. it wasn't polymorphic in its return type.</p><p><strong>Warning</strong>: this function does not perform range checks.</p></div></div><div class="top"><p class="src"><a id="v:binary" class="def">binary</a> :: <span class="keyword">forall</span> e s m a. (<a href="Text-Megaparsec.html#t:MonadParsec" title="Text.Megaparsec">MonadParsec</a> e s m, <a href="Text-Megaparsec-Stream.html#t:Token" title="Text.Megaparsec.Stream">Token</a> s <a href="../base-4.18.2.1/Data-Type-Equality.html#t:-126-" title="Data.Type.Equality">~</a> <a href="../base-4.18.2.1/Data-Char.html#t:Char" title="Data.Char">Char</a>, <a href="../base-4.18.2.1/Prelude.html#t:Num" title="Prelude">Num</a> a) =&gt; m a <a href="src/Text.Megaparsec.Char.Lexer.html#binary" class="link">Source</a> <a href="#v:binary" class="selflink">#</a></p><div class="doc"><p>Parse an integer in binary representation. The binary number is
 expected to be a non-empty sequence of zeroes &#8220;0&#8221; and ones &#8220;1&#8221;.</p><p>You could of course parse some prefix before the actual number:</p><pre>binary = char '0' &gt;&gt; char' 'b' &gt;&gt; L.binary</pre><p><strong>Warning</strong>: this function does not perform range checks.</p><p><em>Since: 7.0.0</em></p></div></div><div class="top"><p class="src"><a id="v:octal" class="def">octal</a> :: <span class="keyword">forall</span> e s m a. (<a href="Text-Megaparsec.html#t:MonadParsec" title="Text.Megaparsec">MonadParsec</a> e s m, <a href="Text-Megaparsec-Stream.html#t:Token" title="Text.Megaparsec.Stream">Token</a> s <a href="../base-4.18.2.1/Data-Type-Equality.html#t:-126-" title="Data.Type.Equality">~</a> <a href="../base-4.18.2.1/Data-Char.html#t:Char" title="Data.Char">Char</a>, <a href="../base-4.18.2.1/Prelude.html#t:Num" title="Prelude">Num</a> a) =&gt; m a <a href="src/Text.Megaparsec.Char.Lexer.html#octal" class="link">Source</a> <a href="#v:octal" class="selflink">#</a></p><div class="doc"><p>Parse an integer in the octal representation. The format of the octal
 number is expected to be according to the Haskell report except for the
 fact that this parser doesn't parse &#8220;0o&#8221; or &#8220;0O&#8221; prefix. It is a
 responsibility of the programmer to parse correct prefix before parsing
 the number itself.</p><p>For example you can make it conform to the Haskell report like this:</p><pre>octal = char '0' &gt;&gt; char' 'o' &gt;&gt; L.octal</pre><p><strong>Note</strong>: before version <em>6.0.0</em> the function returned <code><a href="../base-4.18.2.1/Prelude.html#t:Integer" title="Prelude">Integer</a></code>, i.e. it
 wasn't polymorphic in its return type.</p><p><strong>Warning</strong>: this function does not perform range checks.</p></div></div><div class="top"><p class="src"><a id="v:hexadecimal" class="def">hexadecimal</a> :: <span class="keyword">forall</span> e s m a. (<a href="Text-Megaparsec.html#t:MonadParsec" title="Text.Megaparsec">MonadParsec</a> e s m, <a href="Text-Megaparsec-Stream.html#t:Token" title="Text.Megaparsec.Stream">Token</a> s <a href="../base-4.18.2.1/Data-Type-Equality.html#t:-126-" title="Data.Type.Equality">~</a> <a href="../base-4.18.2.1/Data-Char.html#t:Char" title="Data.Char">Char</a>, <a href="../base-4.18.2.1/Prelude.html#t:Num" title="Prelude">Num</a> a) =&gt; m a <a href="src/Text.Megaparsec.Char.Lexer.html#hexadecimal" class="link">Source</a> <a href="#v:hexadecimal" class="selflink">#</a></p><div class="doc"><p>Parse an integer in the hexadecimal representation. The format of the
 hexadecimal number is expected to be according to the Haskell report
 except for the fact that this parser doesn't parse &#8220;0x&#8221; or &#8220;0X&#8221; prefix.
 It is a responsibility of the programmer to parse correct prefix before
 parsing the number itself.</p><p>For example you can make it conform to the Haskell report like this:</p><pre>hexadecimal = char '0' &gt;&gt; char' 'x' &gt;&gt; L.hexadecimal</pre><p><strong>Note</strong>: before version <em>6.0.0</em> the function returned <code><a href="../base-4.18.2.1/Prelude.html#t:Integer" title="Prelude">Integer</a></code>, i.e. it
 wasn't polymorphic in its return type.</p><p><strong>Warning</strong>: this function does not perform range checks.</p></div></div><div class="top"><p class="src"><a id="v:scientific" class="def">scientific</a> :: <span class="keyword">forall</span> e s m. (<a href="Text-Megaparsec.html#t:MonadParsec" title="Text.Megaparsec">MonadParsec</a> e s m, <a href="Text-Megaparsec-Stream.html#t:Token" title="Text.Megaparsec.Stream">Token</a> s <a href="../base-4.18.2.1/Data-Type-Equality.html#t:-126-" title="Data.Type.Equality">~</a> <a href="../base-4.18.2.1/Data-Char.html#t:Char" title="Data.Char">Char</a>) =&gt; m <a href="../scientific-0.3.7.0/Data-Scientific.html#t:Scientific" title="Data.Scientific">Scientific</a> <a href="src/Text.Megaparsec.Char.Lexer.html#scientific" class="link">Source</a> <a href="#v:scientific" class="selflink">#</a></p><div class="doc"><p>Parse a floating point value as a <code><a href="../scientific-0.3.7.0/Data-Scientific.html#t:Scientific" title="Data.Scientific">Scientific</a></code> number. <code><a href="../scientific-0.3.7.0/Data-Scientific.html#t:Scientific" title="Data.Scientific">Scientific</a></code> is
 great for parsing of arbitrary precision numbers coming from an untrusted
 source. See documentation in <a href="../scientific-0.3.7.0/Data-Scientific.html">Data.Scientific</a> for more information.</p><p>The parser can be used to parse integers or floating point values. Use
 functions like <code><a href="../scientific-0.3.7.0/Data-Scientific.html#v:floatingOrInteger" title="Data.Scientific">floatingOrInteger</a></code> from <a href="../scientific-0.3.7.0/Data-Scientific.html">Data.Scientific</a>
 to test and extract integer or real values.</p><p>This function does not parse sign, if you need to parse signed numbers,
 see <code><a href="Text-Megaparsec-Char-Lexer.html#v:signed" title="Text.Megaparsec.Char.Lexer">signed</a></code>.</p><p><em>Since: 5.0.0</em></p></div></div><div class="top"><p class="src"><a id="v:float" class="def">float</a> :: (<a href="Text-Megaparsec.html#t:MonadParsec" title="Text.Megaparsec">MonadParsec</a> e s m, <a href="Text-Megaparsec-Stream.html#t:Token" title="Text.Megaparsec.Stream">Token</a> s <a href="../base-4.18.2.1/Data-Type-Equality.html#t:-126-" title="Data.Type.Equality">~</a> <a href="../base-4.18.2.1/Data-Char.html#t:Char" title="Data.Char">Char</a>, <a href="../base-4.18.2.1/Prelude.html#t:RealFloat" title="Prelude">RealFloat</a> a) =&gt; m a <a href="src/Text.Megaparsec.Char.Lexer.html#float" class="link">Source</a> <a href="#v:float" class="selflink">#</a></p><div class="doc"><p>Parse a floating point number according to the syntax for floating
 point literals described in the Haskell report.</p><p>This function does not parse sign, if you need to parse signed numbers,
 see <code><a href="Text-Megaparsec-Char-Lexer.html#v:signed" title="Text.Megaparsec.Char.Lexer">signed</a></code>.</p><p><strong>Note</strong>: before version <em>6.0.0</em> the function returned <code><a href="../base-4.18.2.1/Prelude.html#t:Double" title="Prelude">Double</a></code>, i.e. it
 wasn't polymorphic in its return type.</p><p><strong>Note</strong>: in versions <em>6.0.0</em>&#8211;<em>6.1.1</em> this function accepted plain
 integers.</p></div></div><div class="top"><p class="src"><a id="v:signed" class="def">signed</a> <a href="src/Text.Megaparsec.Char.Lexer.html#signed" class="link">Source</a> <a href="#v:signed" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (<a href="Text-Megaparsec.html#t:MonadParsec" title="Text.Megaparsec">MonadParsec</a> e s m, <a href="Text-Megaparsec-Stream.html#t:Token" title="Text.Megaparsec.Stream">Token</a> s <a href="../base-4.18.2.1/Data-Type-Equality.html#t:-126-" title="Data.Type.Equality">~</a> <a href="../base-4.18.2.1/Data-Char.html#t:Char" title="Data.Char">Char</a>, <a href="../base-4.18.2.1/Prelude.html#t:Num" title="Prelude">Num</a> a)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; m ()</td><td class="doc"><p>How to consume white space after the sign</p></td></tr><tr><td class="src">-&gt; m a</td><td class="doc"><p>How to parse the number itself</p></td></tr><tr><td class="src">-&gt; m a</td><td class="doc"><p>Parser for signed numbers</p></td></tr></table></div><div class="doc"><p><code><code><a href="Text-Megaparsec-Char-Lexer.html#v:signed" title="Text.Megaparsec.Char.Lexer">signed</a></code> space p</code> parses an optional sign character (&#8220;+&#8221; or &#8220;-&#8221;), then
 if there is a sign it consumes optional white space (using the <code>space</code>
 parser), then it runs the parser <code>p</code> which should return a number. Sign
 of the number is changed according to the previously parsed sign
 character.</p><p>For example, to parse signed integer you can write:</p><pre>lexeme        = L.lexeme spaceConsumer
integer       = lexeme L.decimal
signedInteger = L.signed spaceConsumer integer</pre></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.29.2</p></div></body></html>