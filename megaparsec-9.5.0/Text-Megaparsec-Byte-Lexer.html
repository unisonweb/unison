<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><title>Text.Megaparsec.Byte.Lexer</title><link href="linuwial.css" rel="stylesheet" type="text/css" title="Linuwial" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400i,700" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { processClass: "mathjax", ignoreClass: ".*" } });</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><span class="caption">megaparsec-9.5.0: Monadic parser combinators</span><ul class="links" id="page-menu"><li><a href="src/Text.Megaparsec.Byte.Lexer.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul></div><div id="content"><div id="module-header"><table class="info"><tr><th valign="top">Copyright</th><td>&#169; 2015&#8211;present Megaparsec contributors</td></tr><tr><th>License</th><td>FreeBSD</td></tr><tr><th>Maintainer</th><td>Mark Karpov &lt;markkarpov92@gmail.com&gt;</td></tr><tr><th>Stability</th><td>experimental</td></tr><tr><th>Portability</th><td>portable</td></tr><tr><th>Safe Haskell</th><td>Safe</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">Text.Megaparsec.Byte.Lexer</p></div><div id="table-of-contents"><div id="contents-list"><p class="caption" onclick="window.scrollTo(0,0)">Contents</p><ul><li><a href="#g:1">White space</a></li><li><a href="#g:2">Numbers</a></li></ul></div></div><div id="description"><p class="caption">Description</p><div class="doc"><p>Stripped-down version of <a href="Text-Megaparsec-Char-Lexer.html">Text.Megaparsec.Char.Lexer</a> for streams of
 bytes.</p><p>This module is intended to be imported qualified:</p><pre>import qualified Text.Megaparsec.Byte.Lexer as L</pre></div></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"><li class="src short"><a href="#v:space">space</a> :: <a href="Text-Megaparsec.html#t:MonadParsec" title="Text.Megaparsec">MonadParsec</a> e s m =&gt; m () -&gt; m () -&gt; m () -&gt; m ()</li><li class="src short"><a href="#v:lexeme">lexeme</a> :: <a href="Text-Megaparsec.html#t:MonadParsec" title="Text.Megaparsec">MonadParsec</a> e s m =&gt; m () -&gt; m a -&gt; m a</li><li class="src short"><a href="#v:symbol">symbol</a> :: <a href="Text-Megaparsec.html#t:MonadParsec" title="Text.Megaparsec">MonadParsec</a> e s m =&gt; m () -&gt; <a href="Text-Megaparsec-Stream.html#t:Tokens" title="Text.Megaparsec.Stream">Tokens</a> s -&gt; m (<a href="Text-Megaparsec-Stream.html#t:Tokens" title="Text.Megaparsec.Stream">Tokens</a> s)</li><li class="src short"><a href="#v:symbol-39-">symbol'</a> :: (<a href="Text-Megaparsec.html#t:MonadParsec" title="Text.Megaparsec">MonadParsec</a> e s m, <a href="../case-insensitive-1.2.1.0/Data-CaseInsensitive.html#t:FoldCase" title="Data.CaseInsensitive">FoldCase</a> (<a href="Text-Megaparsec-Stream.html#t:Tokens" title="Text.Megaparsec.Stream">Tokens</a> s)) =&gt; m () -&gt; <a href="Text-Megaparsec-Stream.html#t:Tokens" title="Text.Megaparsec.Stream">Tokens</a> s -&gt; m (<a href="Text-Megaparsec-Stream.html#t:Tokens" title="Text.Megaparsec.Stream">Tokens</a> s)</li><li class="src short"><a href="#v:skipLineComment">skipLineComment</a> :: (<a href="Text-Megaparsec.html#t:MonadParsec" title="Text.Megaparsec">MonadParsec</a> e s m, <a href="Text-Megaparsec-Stream.html#t:Token" title="Text.Megaparsec.Stream">Token</a> s <a href="../base-4.18.2.1/Data-Type-Equality.html#t:-126-" title="Data.Type.Equality">~</a> <a href="../base-4.18.2.1/Data-Word.html#t:Word8" title="Data.Word">Word8</a>) =&gt; <a href="Text-Megaparsec-Stream.html#t:Tokens" title="Text.Megaparsec.Stream">Tokens</a> s -&gt; m ()</li><li class="src short"><a href="#v:skipBlockComment">skipBlockComment</a> :: <a href="Text-Megaparsec.html#t:MonadParsec" title="Text.Megaparsec">MonadParsec</a> e s m =&gt; <a href="Text-Megaparsec-Stream.html#t:Tokens" title="Text.Megaparsec.Stream">Tokens</a> s -&gt; <a href="Text-Megaparsec-Stream.html#t:Tokens" title="Text.Megaparsec.Stream">Tokens</a> s -&gt; m ()</li><li class="src short"><a href="#v:skipBlockCommentNested">skipBlockCommentNested</a> :: (<a href="Text-Megaparsec.html#t:MonadParsec" title="Text.Megaparsec">MonadParsec</a> e s m, <a href="Text-Megaparsec-Stream.html#t:Token" title="Text.Megaparsec.Stream">Token</a> s <a href="../base-4.18.2.1/Data-Type-Equality.html#t:-126-" title="Data.Type.Equality">~</a> <a href="../base-4.18.2.1/Data-Word.html#t:Word8" title="Data.Word">Word8</a>) =&gt; <a href="Text-Megaparsec-Stream.html#t:Tokens" title="Text.Megaparsec.Stream">Tokens</a> s -&gt; <a href="Text-Megaparsec-Stream.html#t:Tokens" title="Text.Megaparsec.Stream">Tokens</a> s -&gt; m ()</li><li class="src short"><a href="#v:decimal">decimal</a> :: <span class="keyword">forall</span> e s m a. (<a href="Text-Megaparsec.html#t:MonadParsec" title="Text.Megaparsec">MonadParsec</a> e s m, <a href="Text-Megaparsec-Stream.html#t:Token" title="Text.Megaparsec.Stream">Token</a> s <a href="../base-4.18.2.1/Data-Type-Equality.html#t:-126-" title="Data.Type.Equality">~</a> <a href="../base-4.18.2.1/Data-Word.html#t:Word8" title="Data.Word">Word8</a>, <a href="../base-4.18.2.1/Prelude.html#t:Num" title="Prelude">Num</a> a) =&gt; m a</li><li class="src short"><a href="#v:binary">binary</a> :: <span class="keyword">forall</span> e s m a. (<a href="Text-Megaparsec.html#t:MonadParsec" title="Text.Megaparsec">MonadParsec</a> e s m, <a href="Text-Megaparsec-Stream.html#t:Token" title="Text.Megaparsec.Stream">Token</a> s <a href="../base-4.18.2.1/Data-Type-Equality.html#t:-126-" title="Data.Type.Equality">~</a> <a href="../base-4.18.2.1/Data-Word.html#t:Word8" title="Data.Word">Word8</a>, <a href="../base-4.18.2.1/Prelude.html#t:Num" title="Prelude">Num</a> a) =&gt; m a</li><li class="src short"><a href="#v:octal">octal</a> :: <span class="keyword">forall</span> e s m a. (<a href="Text-Megaparsec.html#t:MonadParsec" title="Text.Megaparsec">MonadParsec</a> e s m, <a href="Text-Megaparsec-Stream.html#t:Token" title="Text.Megaparsec.Stream">Token</a> s <a href="../base-4.18.2.1/Data-Type-Equality.html#t:-126-" title="Data.Type.Equality">~</a> <a href="../base-4.18.2.1/Data-Word.html#t:Word8" title="Data.Word">Word8</a>, <a href="../base-4.18.2.1/Prelude.html#t:Num" title="Prelude">Num</a> a) =&gt; m a</li><li class="src short"><a href="#v:hexadecimal">hexadecimal</a> :: <span class="keyword">forall</span> e s m a. (<a href="Text-Megaparsec.html#t:MonadParsec" title="Text.Megaparsec">MonadParsec</a> e s m, <a href="Text-Megaparsec-Stream.html#t:Token" title="Text.Megaparsec.Stream">Token</a> s <a href="../base-4.18.2.1/Data-Type-Equality.html#t:-126-" title="Data.Type.Equality">~</a> <a href="../base-4.18.2.1/Data-Word.html#t:Word8" title="Data.Word">Word8</a>, <a href="../base-4.18.2.1/Prelude.html#t:Num" title="Prelude">Num</a> a) =&gt; m a</li><li class="src short"><a href="#v:scientific">scientific</a> :: <span class="keyword">forall</span> e s m. (<a href="Text-Megaparsec.html#t:MonadParsec" title="Text.Megaparsec">MonadParsec</a> e s m, <a href="Text-Megaparsec-Stream.html#t:Token" title="Text.Megaparsec.Stream">Token</a> s <a href="../base-4.18.2.1/Data-Type-Equality.html#t:-126-" title="Data.Type.Equality">~</a> <a href="../base-4.18.2.1/Data-Word.html#t:Word8" title="Data.Word">Word8</a>) =&gt; m <a href="../scientific-0.3.7.0/Data-Scientific.html#t:Scientific" title="Data.Scientific">Scientific</a></li><li class="src short"><a href="#v:float">float</a> :: (<a href="Text-Megaparsec.html#t:MonadParsec" title="Text.Megaparsec">MonadParsec</a> e s m, <a href="Text-Megaparsec-Stream.html#t:Token" title="Text.Megaparsec.Stream">Token</a> s <a href="../base-4.18.2.1/Data-Type-Equality.html#t:-126-" title="Data.Type.Equality">~</a> <a href="../base-4.18.2.1/Data-Word.html#t:Word8" title="Data.Word">Word8</a>, <a href="../base-4.18.2.1/Prelude.html#t:RealFloat" title="Prelude">RealFloat</a> a) =&gt; m a</li><li class="src short"><a href="#v:signed">signed</a> :: (<a href="Text-Megaparsec.html#t:MonadParsec" title="Text.Megaparsec">MonadParsec</a> e s m, <a href="Text-Megaparsec-Stream.html#t:Token" title="Text.Megaparsec.Stream">Token</a> s <a href="../base-4.18.2.1/Data-Type-Equality.html#t:-126-" title="Data.Type.Equality">~</a> <a href="../base-4.18.2.1/Data-Word.html#t:Word8" title="Data.Word">Word8</a>, <a href="../base-4.18.2.1/Prelude.html#t:Num" title="Prelude">Num</a> a) =&gt; m () -&gt; m a -&gt; m a</li></ul></details></div><div id="interface"><a href="#g:1" id="g:1"><h1>White space</h1></a><div class="top"><p class="src"><a id="v:space" class="def">space</a> <a href="src/Text.Megaparsec.Lexer.html#space" class="link">Source</a> <a href="#v:space" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="Text-Megaparsec.html#t:MonadParsec" title="Text.Megaparsec">MonadParsec</a> e s m</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; m ()</td><td class="doc"><p>A parser for space characters which does not accept empty
 input (e.g. <code><a href="Text-Megaparsec-Char.html#v:space1" title="Text.Megaparsec.Char">space1</a></code>)</p></td></tr><tr><td class="src">-&gt; m ()</td><td class="doc"><p>A parser for a line comment (e.g. <code>skipLineComment</code>)</p></td></tr><tr><td class="src">-&gt; m ()</td><td class="doc"><p>A parser for a block comment (e.g. <code>skipBlockComment</code>)</p></td></tr><tr><td class="src">-&gt; m ()</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p><code><code><a href="Text-Megaparsec-Byte-Lexer.html#v:space" title="Text.Megaparsec.Byte.Lexer">space</a></code> sc lineComment blockComment</code> produces a parser that can parse
 white space in general. It's expected that you create such a parser once
 and pass it to other functions in this module as needed (when you see
 <code>spaceConsumer</code> in documentation, usually it means that something like
 <code><a href="Text-Megaparsec-Byte-Lexer.html#v:space" title="Text.Megaparsec.Byte.Lexer">space</a></code> is expected there).</p><p><code>sc</code> is used to parse blocks of space characters. You can use
 <code><a href="Text-Megaparsec-Char.html#v:space1" title="Text.Megaparsec.Char">space1</a></code> from <a href="Text-Megaparsec-Char.html">Text.Megaparsec.Char</a> for this
 purpose as well as your own parser (if you don't want to automatically
 consume newlines, for example). Make sure that the parser does not
 succeed on the empty input though. In an earlier version of the library
 <code><a href="Text-Megaparsec-Char.html#v:spaceChar" title="Text.Megaparsec.Char">spaceChar</a></code> was recommended, but now parsers based
 on <code><a href="Text-Megaparsec.html#v:takeWhile1P" title="Text.Megaparsec">takeWhile1P</a></code> are preferred because of their speed.</p><p><code>lineComment</code> is used to parse line comments. You can use
 <code>skipLineComment</code> if you don't need anything special.</p><p><code>blockComment</code> is used to parse block (multi-line) comments. You can use
 <code>skipBlockComment</code> or <code>skipBlockCommentNested</code> if you don't need anything
 special.</p><p>If you don't want to allow a kind of comment, simply pass <code><a href="../base-4.18.2.1/Control-Applicative.html#v:empty" title="Control.Applicative">empty</a></code> which
 will fail instantly when parsing of that sort of comment is attempted and
 <code><a href="Text-Megaparsec-Byte-Lexer.html#v:space" title="Text.Megaparsec.Byte.Lexer">space</a></code> will just move on or finish depending on whether there is more
 white space for it to consume.</p></div></div><div class="top"><p class="src"><a id="v:lexeme" class="def">lexeme</a> <a href="src/Text.Megaparsec.Lexer.html#lexeme" class="link">Source</a> <a href="#v:lexeme" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="Text-Megaparsec.html#t:MonadParsec" title="Text.Megaparsec">MonadParsec</a> e s m</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; m ()</td><td class="doc"><p>How to consume white space after lexeme</p></td></tr><tr><td class="src">-&gt; m a</td><td class="doc"><p>How to parse actual lexeme</p></td></tr><tr><td class="src">-&gt; m a</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>This is a wrapper for lexemes. The typical usage is to supply the first
 argument (parser that consumes white space, probably defined via <code><a href="Text-Megaparsec-Byte-Lexer.html#v:space" title="Text.Megaparsec.Byte.Lexer">space</a></code>)
 and use the resulting function to wrap parsers for every lexeme.</p><pre>lexeme  = L.lexeme spaceConsumer
integer = lexeme L.decimal</pre></div></div><div class="top"><p class="src"><a id="v:symbol" class="def">symbol</a> <a href="src/Text.Megaparsec.Lexer.html#symbol" class="link">Source</a> <a href="#v:symbol" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="Text-Megaparsec.html#t:MonadParsec" title="Text.Megaparsec">MonadParsec</a> e s m</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; m ()</td><td class="doc"><p>How to consume white space after lexeme</p></td></tr><tr><td class="src">-&gt; <a href="Text-Megaparsec-Stream.html#t:Tokens" title="Text.Megaparsec.Stream">Tokens</a> s</td><td class="doc"><p>Symbol to parse</p></td></tr><tr><td class="src">-&gt; m (<a href="Text-Megaparsec-Stream.html#t:Tokens" title="Text.Megaparsec.Stream">Tokens</a> s)</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>This is a helper to parse symbols, i.e. verbatim strings. You pass the
 first argument (parser that consumes white space, probably defined via
 <code><a href="Text-Megaparsec-Byte-Lexer.html#v:space" title="Text.Megaparsec.Byte.Lexer">space</a></code>) and then you can use the resulting function to parse strings:</p><pre>symbol    = L.symbol spaceConsumer

parens    = between (symbol &quot;(&quot;) (symbol &quot;)&quot;)
braces    = between (symbol &quot;{&quot;) (symbol &quot;}&quot;)
angles    = between (symbol &quot;&lt;&quot;) (symbol &quot;&gt;&quot;)
brackets  = between (symbol &quot;[&quot;) (symbol &quot;]&quot;)
semicolon = symbol &quot;;&quot;
comma     = symbol &quot;,&quot;
colon     = symbol &quot;:&quot;
dot       = symbol &quot;.&quot;</pre></div></div><div class="top"><p class="src"><a id="v:symbol-39-" class="def">symbol'</a> <a href="src/Text.Megaparsec.Lexer.html#symbol%27" class="link">Source</a> <a href="#v:symbol-39-" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (<a href="Text-Megaparsec.html#t:MonadParsec" title="Text.Megaparsec">MonadParsec</a> e s m, <a href="../case-insensitive-1.2.1.0/Data-CaseInsensitive.html#t:FoldCase" title="Data.CaseInsensitive">FoldCase</a> (<a href="Text-Megaparsec-Stream.html#t:Tokens" title="Text.Megaparsec.Stream">Tokens</a> s))</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; m ()</td><td class="doc"><p>How to consume white space after lexeme</p></td></tr><tr><td class="src">-&gt; <a href="Text-Megaparsec-Stream.html#t:Tokens" title="Text.Megaparsec.Stream">Tokens</a> s</td><td class="doc"><p>Symbol to parse (case-insensitive)</p></td></tr><tr><td class="src">-&gt; m (<a href="Text-Megaparsec-Stream.html#t:Tokens" title="Text.Megaparsec.Stream">Tokens</a> s)</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>A case-insensitive version of <code><a href="Text-Megaparsec-Byte-Lexer.html#v:symbol" title="Text.Megaparsec.Byte.Lexer">symbol</a></code>. This may be helpful if you're
 working with case-insensitive languages.</p></div></div><div class="top"><p class="src"><a id="v:skipLineComment" class="def">skipLineComment</a> <a href="src/Text.Megaparsec.Byte.Lexer.html#skipLineComment" class="link">Source</a> <a href="#v:skipLineComment" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (<a href="Text-Megaparsec.html#t:MonadParsec" title="Text.Megaparsec">MonadParsec</a> e s m, <a href="Text-Megaparsec-Stream.html#t:Token" title="Text.Megaparsec.Stream">Token</a> s <a href="../base-4.18.2.1/Data-Type-Equality.html#t:-126-" title="Data.Type.Equality">~</a> <a href="../base-4.18.2.1/Data-Word.html#t:Word8" title="Data.Word">Word8</a>)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; <a href="Text-Megaparsec-Stream.html#t:Tokens" title="Text.Megaparsec.Stream">Tokens</a> s</td><td class="doc"><p>Line comment prefix</p></td></tr><tr><td class="src">-&gt; m ()</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Given a comment prefix this function returns a parser that skips line
 comments. Note that it stops just before the newline character but
 doesn't consume the newline. Newline is either supposed to be consumed by
 <code><a href="Text-Megaparsec-Byte-Lexer.html#v:space" title="Text.Megaparsec.Byte.Lexer">space</a></code> parser or picked up manually.</p></div></div><div class="top"><p class="src"><a id="v:skipBlockComment" class="def">skipBlockComment</a> <a href="src/Text.Megaparsec.Byte.Lexer.html#skipBlockComment" class="link">Source</a> <a href="#v:skipBlockComment" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="Text-Megaparsec.html#t:MonadParsec" title="Text.Megaparsec">MonadParsec</a> e s m</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; <a href="Text-Megaparsec-Stream.html#t:Tokens" title="Text.Megaparsec.Stream">Tokens</a> s</td><td class="doc"><p>Start of block comment</p></td></tr><tr><td class="src">-&gt; <a href="Text-Megaparsec-Stream.html#t:Tokens" title="Text.Megaparsec.Stream">Tokens</a> s</td><td class="doc"><p>End of block comment</p></td></tr><tr><td class="src">-&gt; m ()</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p><code><code><a href="Text-Megaparsec-Byte-Lexer.html#v:skipBlockComment" title="Text.Megaparsec.Byte.Lexer">skipBlockComment</a></code> start end</code> skips non-nested block comment starting
 with <code>start</code> and ending with <code>end</code>.</p></div></div><div class="top"><p class="src"><a id="v:skipBlockCommentNested" class="def">skipBlockCommentNested</a> <a href="src/Text.Megaparsec.Byte.Lexer.html#skipBlockCommentNested" class="link">Source</a> <a href="#v:skipBlockCommentNested" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (<a href="Text-Megaparsec.html#t:MonadParsec" title="Text.Megaparsec">MonadParsec</a> e s m, <a href="Text-Megaparsec-Stream.html#t:Token" title="Text.Megaparsec.Stream">Token</a> s <a href="../base-4.18.2.1/Data-Type-Equality.html#t:-126-" title="Data.Type.Equality">~</a> <a href="../base-4.18.2.1/Data-Word.html#t:Word8" title="Data.Word">Word8</a>)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; <a href="Text-Megaparsec-Stream.html#t:Tokens" title="Text.Megaparsec.Stream">Tokens</a> s</td><td class="doc"><p>Start of block comment</p></td></tr><tr><td class="src">-&gt; <a href="Text-Megaparsec-Stream.html#t:Tokens" title="Text.Megaparsec.Stream">Tokens</a> s</td><td class="doc"><p>End of block comment</p></td></tr><tr><td class="src">-&gt; m ()</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p><code><code><a href="Text-Megaparsec-Byte-Lexer.html#v:skipBlockCommentNested" title="Text.Megaparsec.Byte.Lexer">skipBlockCommentNested</a></code> start end</code> skips possibly nested block
 comment starting with <code>start</code> and ending with <code>end</code>.</p><p><em>Since: 5.0.0</em></p></div></div><a href="#g:2" id="g:2"><h1>Numbers</h1></a><div class="top"><p class="src"><a id="v:decimal" class="def">decimal</a> :: <span class="keyword">forall</span> e s m a. (<a href="Text-Megaparsec.html#t:MonadParsec" title="Text.Megaparsec">MonadParsec</a> e s m, <a href="Text-Megaparsec-Stream.html#t:Token" title="Text.Megaparsec.Stream">Token</a> s <a href="../base-4.18.2.1/Data-Type-Equality.html#t:-126-" title="Data.Type.Equality">~</a> <a href="../base-4.18.2.1/Data-Word.html#t:Word8" title="Data.Word">Word8</a>, <a href="../base-4.18.2.1/Prelude.html#t:Num" title="Prelude">Num</a> a) =&gt; m a <a href="src/Text.Megaparsec.Byte.Lexer.html#decimal" class="link">Source</a> <a href="#v:decimal" class="selflink">#</a></p><div class="doc"><p>Parse an integer in the decimal representation according to the format
 of integer literals described in the Haskell report.</p><p>If you need to parse signed integers, see the <code><a href="Text-Megaparsec-Byte-Lexer.html#v:signed" title="Text.Megaparsec.Byte.Lexer">signed</a></code> combinator.</p><p><strong>Warning</strong>: this function does not perform range checks.</p></div></div><div class="top"><p class="src"><a id="v:binary" class="def">binary</a> :: <span class="keyword">forall</span> e s m a. (<a href="Text-Megaparsec.html#t:MonadParsec" title="Text.Megaparsec">MonadParsec</a> e s m, <a href="Text-Megaparsec-Stream.html#t:Token" title="Text.Megaparsec.Stream">Token</a> s <a href="../base-4.18.2.1/Data-Type-Equality.html#t:-126-" title="Data.Type.Equality">~</a> <a href="../base-4.18.2.1/Data-Word.html#t:Word8" title="Data.Word">Word8</a>, <a href="../base-4.18.2.1/Prelude.html#t:Num" title="Prelude">Num</a> a) =&gt; m a <a href="src/Text.Megaparsec.Byte.Lexer.html#binary" class="link">Source</a> <a href="#v:binary" class="selflink">#</a></p><div class="doc"><p>Parse an integer in the binary representation. The binary number is
 expected to be a non-empty sequence of zeroes &#8220;0&#8221; and ones &#8220;1&#8221;.</p><p>You could of course parse some prefix before the actual number:</p><pre>binary = char 48 &gt;&gt; char' 98 &gt;&gt; L.binary</pre><p><strong>Warning</strong>: this function does not perform range checks.</p><p><em>Since: 7.0.0</em></p></div></div><div class="top"><p class="src"><a id="v:octal" class="def">octal</a> :: <span class="keyword">forall</span> e s m a. (<a href="Text-Megaparsec.html#t:MonadParsec" title="Text.Megaparsec">MonadParsec</a> e s m, <a href="Text-Megaparsec-Stream.html#t:Token" title="Text.Megaparsec.Stream">Token</a> s <a href="../base-4.18.2.1/Data-Type-Equality.html#t:-126-" title="Data.Type.Equality">~</a> <a href="../base-4.18.2.1/Data-Word.html#t:Word8" title="Data.Word">Word8</a>, <a href="../base-4.18.2.1/Prelude.html#t:Num" title="Prelude">Num</a> a) =&gt; m a <a href="src/Text.Megaparsec.Byte.Lexer.html#octal" class="link">Source</a> <a href="#v:octal" class="selflink">#</a></p><div class="doc"><p>Parse an integer in the octal representation. The format of the octal
 number is expected to be according to the Haskell report except for the
 fact that this parser doesn't parse &#8220;0o&#8221; or &#8220;0O&#8221; prefix. It is a
 responsibility of the programmer to parse correct prefix before parsing
 the number itself.</p><p>For example you can make it conform to the Haskell report like this:</p><pre>octal = char 48 &gt;&gt; char' 111 &gt;&gt; L.octal</pre><p><strong>Warning</strong>: this function does not perform range checks.</p></div></div><div class="top"><p class="src"><a id="v:hexadecimal" class="def">hexadecimal</a> :: <span class="keyword">forall</span> e s m a. (<a href="Text-Megaparsec.html#t:MonadParsec" title="Text.Megaparsec">MonadParsec</a> e s m, <a href="Text-Megaparsec-Stream.html#t:Token" title="Text.Megaparsec.Stream">Token</a> s <a href="../base-4.18.2.1/Data-Type-Equality.html#t:-126-" title="Data.Type.Equality">~</a> <a href="../base-4.18.2.1/Data-Word.html#t:Word8" title="Data.Word">Word8</a>, <a href="../base-4.18.2.1/Prelude.html#t:Num" title="Prelude">Num</a> a) =&gt; m a <a href="src/Text.Megaparsec.Byte.Lexer.html#hexadecimal" class="link">Source</a> <a href="#v:hexadecimal" class="selflink">#</a></p><div class="doc"><p>Parse an integer in the hexadecimal representation. The format of the
 hexadecimal number is expected to be according to the Haskell report
 except for the fact that this parser doesn't parse &#8220;0x&#8221; or &#8220;0X&#8221; prefix.
 It is a responsibility of the programmer to parse correct prefix before
 parsing the number itself.</p><p>For example you can make it conform to the Haskell report like this:</p><pre>hexadecimal = char 48 &gt;&gt; char' 120 &gt;&gt; L.hexadecimal</pre><p><strong>Warning</strong>: this function does not perform range checks.</p></div></div><div class="top"><p class="src"><a id="v:scientific" class="def">scientific</a> :: <span class="keyword">forall</span> e s m. (<a href="Text-Megaparsec.html#t:MonadParsec" title="Text.Megaparsec">MonadParsec</a> e s m, <a href="Text-Megaparsec-Stream.html#t:Token" title="Text.Megaparsec.Stream">Token</a> s <a href="../base-4.18.2.1/Data-Type-Equality.html#t:-126-" title="Data.Type.Equality">~</a> <a href="../base-4.18.2.1/Data-Word.html#t:Word8" title="Data.Word">Word8</a>) =&gt; m <a href="../scientific-0.3.7.0/Data-Scientific.html#t:Scientific" title="Data.Scientific">Scientific</a> <a href="src/Text.Megaparsec.Byte.Lexer.html#scientific" class="link">Source</a> <a href="#v:scientific" class="selflink">#</a></p><div class="doc"><p>Parse a floating point value as a <code><a href="../scientific-0.3.7.0/Data-Scientific.html#t:Scientific" title="Data.Scientific">Scientific</a></code> number. <code><a href="../scientific-0.3.7.0/Data-Scientific.html#t:Scientific" title="Data.Scientific">Scientific</a></code> is
 great for parsing of arbitrary precision numbers coming from an untrusted
 source. See documentation in <a href="../scientific-0.3.7.0/Data-Scientific.html">Data.Scientific</a> for more information.</p><p>The parser can be used to parse integers or floating point values. Use
 functions like <code><a href="../scientific-0.3.7.0/Data-Scientific.html#v:floatingOrInteger" title="Data.Scientific">floatingOrInteger</a></code> from <a href="../scientific-0.3.7.0/Data-Scientific.html">Data.Scientific</a>
 to test and extract integer or real values.</p><p>This function does not parse sign, if you need to parse signed numbers,
 see <code><a href="Text-Megaparsec-Byte-Lexer.html#v:signed" title="Text.Megaparsec.Byte.Lexer">signed</a></code>.</p></div></div><div class="top"><p class="src"><a id="v:float" class="def">float</a> :: (<a href="Text-Megaparsec.html#t:MonadParsec" title="Text.Megaparsec">MonadParsec</a> e s m, <a href="Text-Megaparsec-Stream.html#t:Token" title="Text.Megaparsec.Stream">Token</a> s <a href="../base-4.18.2.1/Data-Type-Equality.html#t:-126-" title="Data.Type.Equality">~</a> <a href="../base-4.18.2.1/Data-Word.html#t:Word8" title="Data.Word">Word8</a>, <a href="../base-4.18.2.1/Prelude.html#t:RealFloat" title="Prelude">RealFloat</a> a) =&gt; m a <a href="src/Text.Megaparsec.Byte.Lexer.html#float" class="link">Source</a> <a href="#v:float" class="selflink">#</a></p><div class="doc"><p>Parse a floating point number according to the syntax for floating
 point literals described in the Haskell report.</p><p>This function does not parse sign, if you need to parse signed numbers,
 see <code><a href="Text-Megaparsec-Byte-Lexer.html#v:signed" title="Text.Megaparsec.Byte.Lexer">signed</a></code>.</p><p><strong>Note</strong>: in versions <em>6.0.0</em>&#8211;<em>6.1.1</em> this function accepted plain integers.</p></div></div><div class="top"><p class="src"><a id="v:signed" class="def">signed</a> <a href="src/Text.Megaparsec.Byte.Lexer.html#signed" class="link">Source</a> <a href="#v:signed" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (<a href="Text-Megaparsec.html#t:MonadParsec" title="Text.Megaparsec">MonadParsec</a> e s m, <a href="Text-Megaparsec-Stream.html#t:Token" title="Text.Megaparsec.Stream">Token</a> s <a href="../base-4.18.2.1/Data-Type-Equality.html#t:-126-" title="Data.Type.Equality">~</a> <a href="../base-4.18.2.1/Data-Word.html#t:Word8" title="Data.Word">Word8</a>, <a href="../base-4.18.2.1/Prelude.html#t:Num" title="Prelude">Num</a> a)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; m ()</td><td class="doc"><p>How to consume white space after the sign</p></td></tr><tr><td class="src">-&gt; m a</td><td class="doc"><p>How to parse the number itself</p></td></tr><tr><td class="src">-&gt; m a</td><td class="doc"><p>Parser for signed numbers</p></td></tr></table></div><div class="doc"><p><code><code><a href="Text-Megaparsec-Byte-Lexer.html#v:signed" title="Text.Megaparsec.Byte.Lexer">signed</a></code> space p</code> parser parses an optional sign character (&#8220;+&#8221; or
 &#8220;-&#8221;), then if there is a sign it consumes optional white space (using
 <code>space</code> parser), then it runs parser <code>p</code> which should return a number.
 Sign of the number is changed according to the previously parsed sign
 character.</p><p>For example, to parse signed integer you can write:</p><pre>lexeme        = L.lexeme spaceConsumer
integer       = lexeme L.decimal
signedInteger = L.signed spaceConsumer integer</pre></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.29.2</p></div></body></html>