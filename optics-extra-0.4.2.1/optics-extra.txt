-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Extra utilities and instances for optics-core
--   
--   This package provides extra definitions and instances that extend the
--   <tt><a>optics-core</a></tt> package, without incurring too many
--   dependencies. See the <tt><a>optics</a></tt> package for more
--   documentation.
@package optics-extra
@version 0.4.2.1


-- | This module exists to provide documentation for lenses for working
--   with <a>HashMap</a>, which might otherwise be obscured by their
--   genericity.
--   
--   <a>HashMap</a> is an instance of <a>At</a> and provides <a>at</a> as a
--   lens on values at keys:
--   
--   <pre>
--   &gt;&gt;&gt; HashMap.fromList [(1, "world")] ^. at 1
--   Just "world"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; HashMap.empty &amp; at 1 .~ Just "world"
--   fromList [(1,"world")]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; HashMap.empty &amp; at 0 .~ Just "hello"
--   fromList [(0,"hello")]
--   </pre>
--   
--   We can traverse, fold over, and map over key-value pairs in a
--   <a>HashMap</a>, thanks to indexed traversals, folds and setters.
--   
--   <pre>
--   &gt;&gt;&gt; iover imapped const $ HashMap.fromList [(1, "Venus")]
--   fromList [(1,1)]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ifoldMapOf ifolded (\i _ -&gt; Sum i) $ HashMap.fromList [(2, "Earth"), (3, "Mars")]
--   Sum {getSum = 5}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; itraverseOf_ ifolded (curry print) $ HashMap.fromList [(4, "Jupiter")]
--   (4,"Jupiter")
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; itoListOf ifolded $ HashMap.fromList [(5, "Saturn")]
--   [(5,"Saturn")]
--   </pre>
--   
--   A related class, <a>Ixed</a>, allows us to use <a>ix</a> to traverse a
--   value at a particular key.
--   
--   <pre>
--   &gt;&gt;&gt; HashMap.fromList [(2, "Earth")] &amp; ix 2 %~ ("New " ++)
--   fromList [(2,"New Earth")]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; preview (ix 8) HashMap.empty
--   Nothing
--   </pre>
module Data.HashMap.Optics

-- | Construct a hash map from an <a>IxFold</a>.
--   
--   The construction is left-biased (see <a>union</a>), i.e. the first
--   occurrences of keys in the fold or traversal order are preferred.
--   
--   <pre>
--   &gt;&gt;&gt; toMapOf ifolded ["hello", "world"]
--   fromList [(0,"hello"),(1,"world")]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; toMapOf (folded % ifolded) [('a',"alpha"),('b', "beta")]
--   fromList [('a',"alpha"),('b',"beta")]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; toMapOf (folded % ifolded) [('a', "hello"), ('b', "world"), ('a', "dummy")]
--   fromList [('a',"hello"),('b',"world")]
--   </pre>
toMapOf :: (Is k A_Fold, is `HasSingleIndex` i, Eq i, Hashable i) => Optic' k is s a -> s -> HashMap i a

-- | Version of <a>at</a> strict in the value inside the <a>Just</a>
--   constructor.
--   
--   Example:
--   
--   <pre>
--   &gt;&gt;&gt; (at () .~ Just (error "oops") $ Nothing) `seq` ()
--   ()
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (at' () .~ Just (error "oops") $ Nothing) `seq` ()
--   *** Exception: oops
--   ...
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; view (at ()) (Just $ error "oops") `seq` ()
--   ()
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; view (at' ()) (Just $ error "oops") `seq` ()
--   *** Exception: oops
--   ...
--   </pre>
--   
--   It also works as expected for other data structures:
--   
--   <pre>
--   &gt;&gt;&gt; (at 1 .~ Just (error "oops") $ Map.empty) `seq` ()
--   ()
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (at' 1 .~ Just (error "oops") $ Map.empty) `seq` ()
--   *** Exception: oops
--   ...
--   </pre>
at' :: At m => Index m -> Lens' m (Maybe (IxValue m))


-- | This module defines optics for constructing and manipulating finite
--   <a>HashSet</a>s.
module Data.HashSet.Optics

-- | This <a>Setter</a> can be used to change the type of a <a>HashSet</a>
--   by mapping the elements to new values.
--   
--   Sadly, you can't create a valid <a>Traversal</a> for a <a>HashSet</a>,
--   but you can manipulate it by reading using <a>folded</a> and
--   reindexing it via <a>setmapped</a>.
--   
--   <pre>
--   &gt;&gt;&gt; over setmapped (+1) (HashSet.fromList [1,2,3,4])
--   fromList [2,3,4,5]
--   </pre>
setmapped :: (Eq b, Hashable b) => Setter (HashSet a) (HashSet b) a b

-- | Construct a <a>HashSet</a> from a fold.
--   
--   <pre>
--   &gt;&gt;&gt; setOf folded ["hello","world"]
--   fromList ["hello","world"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; setOf (folded % _2) [("hello",1),("world",2),("!!!",3)]
--   fromList [1,2,3]
--   </pre>
setOf :: (Is k A_Fold, Eq a, Hashable a) => Optic' k is s a -> s -> HashSet a


-- | This module provides <a>Iso</a>s for converting lazy <a>Text</a> to or
--   from a <a>String</a> or <tt>Builder</tt>, and an <a>IxTraversal</a>
--   for traversing the individual characters of a <a>Text</a>.
--   
--   If you need to work with both strict and lazy text,
--   <a>Data.Text.Optics</a> provides combinators that support both
--   varieties using a typeclass.
module Data.Text.Lazy.Optics

-- | This isomorphism can be used to <tt>pack</tt> (or <tt>unpack</tt>)
--   lazy <a>Text</a>.
--   
--   <pre>
--   &gt;&gt;&gt; "hello" ^. packed -- :: Text
--   "hello"
--   </pre>
--   
--   <pre>
--   <tt>pack</tt> x ≡ x <a>^.</a> <a>packed</a>
--   <tt>unpack</tt> x ≡ x <a>^.</a> <a>re</a> <a>packed</a>
--   <a>packed</a> ≡ <a>re</a> <a>unpacked</a>
--   </pre>
packed :: Iso' String Text

-- | This isomorphism can be used to <tt>unpack</tt> (or <tt>pack</tt>)
--   lazy <a>Text</a>.
--   
--   <pre>
--   &gt;&gt;&gt; Text.pack "hello" ^. unpacked -- :: String
--   "hello"
--   </pre>
--   
--   <pre>
--   <tt>pack</tt> x ≡ x <a>^.</a> <a>re</a> <a>unpacked</a>
--   <tt>unpack</tt> x ≡ x <a>^.</a> <a>packed</a>
--   </pre>
--   
--   This <a>Iso</a> is provided for notational convenience rather than out
--   of great need, since
--   
--   <pre>
--   <a>unpacked</a> ≡ <a>re</a> <a>packed</a>
--   </pre>
unpacked :: Iso' Text String

-- | This is an alias for <a>unpacked</a> that makes it clearer how to use
--   it with <tt>(<a>#</a>)</tt>.
--   
--   <pre>
--   <a>_Text</a> = <a>re</a> <a>packed</a>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; _Text # "hello" -- :: Text
--   "hello"
--   </pre>
_Text :: Iso' Text String

-- | Traverse the individual characters in a <a>Text</a>.
--   
--   <pre>
--   &gt;&gt;&gt; anyOf text (=='c') $ Text.pack "chello"
--   True
--   </pre>
--   
--   <pre>
--   <a>text</a> = <a>unpacked</a> % <a>traversed</a>
--   </pre>
--   
--   When the type is unambiguous, you can also use the more general
--   <a>each</a>.
--   
--   <pre>
--   <a>text</a> ≡ <a>each</a>
--   </pre>
--   
--   Note that when just using this as a <a>Setter</a>, <tt><a>sets</a>
--   <a>map</a></tt> can be more efficient.
text :: IxTraversal' Int Text Char

-- | Convert between lazy <a>Text</a> and <tt>Builder</tt> .
--   
--   <pre>
--   <tt>fromLazyText</tt> x ≡ x <a>^.</a> <a>builder</a>
--   <tt>toLazyText</tt> x ≡ x <a>^.</a> <a>re</a> <a>builder</a>
--   </pre>
builder :: Iso' Text Builder

-- | Encode/Decode a lazy <a>Text</a> to/from lazy <a>ByteString</a>, via
--   UTF-8.
--   
--   Note: This function does not decode lazily, as it must consume the
--   entire input before deciding whether or not it fails.
--   
--   <pre>
--   &gt;&gt;&gt; LBS.unpack (utf8 # Text.pack "☃")
--   [226,152,131]
--   </pre>
utf8 :: Prism' ByteString Text
pattern Text :: String -> Text


-- | This module provides <a>Iso</a>s for converting strict <a>Text</a> to
--   or from a <a>String</a> or <tt>Builder</tt>, and an <a>IxTraversal</a>
--   for traversing the individual characters of a <a>Text</a>.
--   
--   If you need to work with both strict and lazy text,
--   <a>Data.Text.Optics</a> provides combinators that support both
--   varieties using a typeclass.
module Data.Text.Strict.Optics

-- | This isomorphism can be used to <tt>pack</tt> (or <tt>unpack</tt>)
--   strict <a>Text</a>.
--   
--   <pre>
--   &gt;&gt;&gt; "hello" ^. packed -- :: Text
--   "hello"
--   </pre>
--   
--   <pre>
--   <tt>pack</tt> x ≡ x <a>^.</a> <a>packed</a>
--   <tt>unpack</tt> x ≡ x <a>^.</a> <a>re</a> <a>packed</a>
--   <a>packed</a> ≡ <a>re</a> <a>unpacked</a>
--   <a>packed</a> ≡ <a>iso</a> <tt>pack</tt> <tt>unpack</tt>
--   </pre>
packed :: Iso' String Text

-- | This isomorphism can be used to <tt>unpack</tt> (or <tt>pack</tt>)
--   strict <a>Text</a>.
--   
--   <pre>
--   &gt;&gt;&gt; Strict.pack "hello" ^. unpacked -- :: String
--   "hello"
--   </pre>
--   
--   This <a>Iso</a> is provided for notational convenience rather than out
--   of great need, since
--   
--   <pre>
--   <a>unpacked</a> ≡ <a>re</a> <a>packed</a>
--   </pre>
--   
--   <pre>
--   <tt>pack</tt> x ≡ x <a>^.</a> <a>re</a> <a>unpacked</a>
--   <tt>unpack</tt> x ≡ x <a>^.</a> <a>packed</a>
--   <a>unpacked</a> ≡ <a>iso</a> <tt>unpack</tt> <tt>pack</tt>
--   </pre>
unpacked :: Iso' Text String

-- | Convert between strict <a>Text</a> and <tt>Builder</tt> .
--   
--   <pre>
--   <tt>fromText</tt> x ≡ x <a>^.</a> <a>builder</a>
--   <a>toStrict</a> (<tt>toLazyText</tt> x) ≡ x <a>^.</a> <a>re</a> <a>builder</a>
--   </pre>
builder :: Iso' Text Builder

-- | Traverse the individual characters in strict <a>Text</a>.
--   
--   <pre>
--   &gt;&gt;&gt; anyOf text (=='o') (Strict.pack "hello")
--   True
--   </pre>
--   
--   When the type is unambiguous, you can also use the more general
--   <a>each</a>.
--   
--   <pre>
--   <a>text</a> ≡ <a>unpacked</a> % <a>traversed</a>
--   <a>text</a> ≡ <a>each</a>
--   </pre>
--   
--   Note that when just using this as a <a>Setter</a>, <tt><a>sets</a>
--   <a>map</a></tt> can be more efficient.
text :: IxTraversal' Int Text Char

-- | Encode/Decode a strict <a>Text</a> to/from strict <a>ByteString</a>,
--   via UTF-8.
--   
--   <pre>
--   &gt;&gt;&gt; utf8 # Strict.pack "☃"
--   "\226\152\131"
--   </pre>
utf8 :: Prism' ByteString Text

-- | This is an alias for <a>unpacked</a> that makes it more obvious how to
--   use it with <a>#</a>
--   
--   <pre>
--   &gt; _Text # "hello" -- :: Text
--   </pre>
--   
--   "hello"
_Text :: Iso' Text String
pattern Text :: String -> Text


-- | This module provides <a>Iso</a>s for converting strict or lazy
--   <a>Text</a> to or from a <a>String</a> or <tt>Builder</tt>, and an
--   <a>IxTraversal</a> for traversing the individual characters of a
--   <a>Text</a>.
--   
--   The same combinators support both strict and lazy text using the
--   <a>IsText</a> typeclass. You can import <a>Data.Text.Strict.Optics</a>
--   or <a>Data.Text.Lazy.Optics</a> instead if you prefer monomorphic
--   versions.
module Data.Text.Optics

-- | Traversals for strict or lazy <a>Text</a>
class IsText t

-- | This isomorphism can be used to <tt>pack</tt> (or <tt>unpack</tt>)
--   strict or lazy <a>Text</a>.
--   
--   <pre>
--   <tt>pack</tt> x ≡ x <a>^.</a> <a>packed</a>
--   <tt>unpack</tt> x ≡ x <a>^.</a> <a>re</a> <a>packed</a>
--   <a>packed</a> ≡ <a>re</a> <a>unpacked</a>
--   </pre>
packed :: IsText t => Iso' String t

-- | Convert between strict or lazy <a>Text</a> and a <tt>Builder</tt>.
--   
--   <pre>
--   <tt>fromText</tt> x ≡ x <a>^.</a> <a>builder</a>
--   </pre>
builder :: IsText t => Iso' t Builder

-- | Traverse the individual characters in strict or lazy <a>Text</a>.
--   
--   <pre>
--   <a>text</a> = <a>unpacked</a> . <a>traversed</a>
--   </pre>
text :: IsText t => IxTraversal' Int t Char

-- | This isomorphism can be used to <tt>unpack</tt> (or <tt>pack</tt>)
--   both strict or lazy <a>Text</a>.
--   
--   <pre>
--   <tt>unpack</tt> x ≡ x <a>^.</a> <a>unpacked</a>
--   <tt>pack</tt> x ≡ x <a>^.</a> <a>re</a> <a>unpacked</a>
--   </pre>
--   
--   This <a>Iso</a> is provided for notational convenience rather than out
--   of great need, since
--   
--   <pre>
--   <a>unpacked</a> ≡ <a>re</a> <a>packed</a>
--   </pre>
unpacked :: IsText t => Iso' t String

-- | This is an alias for <a>unpacked</a> that makes it clearer how to use
--   it with <tt>(<a>#</a>)</tt>.
--   
--   <pre>
--   <a>_Text</a> = <a>re</a> <a>packed</a>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; _Text # "hello" :: Strict.Text
--   "hello"
--   </pre>
_Text :: IsText t => Iso' t String
pattern Text :: IsText t => String -> t
instance Data.Text.Optics.IsText GHC.Base.String
instance Data.Text.Optics.IsText Data.Text.Internal.Text
instance Data.Text.Optics.IsText Data.Text.Internal.Lazy.Text


-- | This module provides optics for <a>Map</a> and <a>Set</a>-like
--   containers, including an <a>AffineTraversal</a> to traverse a key in a
--   map or an element of a sequence:
--   
--   <pre>
--   &gt;&gt;&gt; preview (ix 1) ['a','b','c']
--   Just 'b'
--   </pre>
--   
--   a <a>Lens</a> to get, set or delete a key in a map:
--   
--   <pre>
--   &gt;&gt;&gt; set (at 0) (Just 'b') (Map.fromList [(0, 'a')])
--   fromList [(0,'b')]
--   </pre>
--   
--   and a <a>Lens</a> to insert or remove an element of a set:
--   
--   <pre>
--   &gt;&gt;&gt; IntSet.fromList [1,2,3,4] &amp; contains 3 .~ False
--   fromList [1,2,4]
--   </pre>
--   
--   This module includes the core definitions from <a>Optics.At.Core</a>
--   along with extra (orphan) instances.
module Optics.At

-- | Type family that takes a key-value container type and returns the type
--   of keys (indices) into the container, for example <tt><a>Index</a>
--   (<a>Map</a> k a) ~ k</tt>. This is shared by <a>Ixed</a>, <a>At</a>
--   and <a>Contains</a>.
type family Index s

-- | Type family that takes a key-value container type and returns the type
--   of values stored in the container, for example <tt><a>IxValue</a>
--   (<a>Map</a> k a) ~ a</tt>. This is shared by both <a>Ixed</a> and
--   <a>At</a>.
type family IxValue m

-- | Provides a simple <a>AffineTraversal</a> lets you traverse the value
--   at a given key in a <a>Map</a> or element at an ordinal position in a
--   list or <a>Seq</a>.
class () => Ixed m where {
    
    -- | Type family that takes a key-value container type and returns the kind
    --   of optic to index into it. For most containers, it's
    --   <a>An_AffineTraversal</a>, <tt>Representable</tt> (Naperian)
    --   containers it is <a>A_Lens</a>, and multi-maps would have
    --   <tt>A_Traversal</tt>.
    type family IxKind m;
    type IxKind m = An_AffineTraversal;
}

-- | <i>NB:</i> Setting the value of this <a>AffineTraversal</a> will only
--   set the value in <a>at</a> if it is already present.
--   
--   If you want to be able to insert <i>missing</i> values, you want
--   <a>at</a>.
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,3,4] &amp; ix 2 %~ (*10)
--   [1,2,30,4]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "abcd" &amp; ix 2 .~ 'e'
--   "abed"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "abcd" ^? ix 2
--   Just 'c'
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [] ^? ix 2
--   Nothing
--   </pre>
ix :: Ixed m => Index m -> Optic' (IxKind m) NoIx m (IxValue m)

-- | A definition of <a>ix</a> for types with an <a>At</a> instance. This
--   is the default if you don't specify a definition for <a>ix</a>.
ixAt :: At m => Index m -> AffineTraversal' m (IxValue m)

-- | <a>At</a> provides a <a>Lens</a> that can be used to read, write or
--   delete the value associated with a key in a <a>Map</a>-like container
--   on an ad hoc basis.
--   
--   An instance of <a>At</a> should satisfy:
--   
--   <pre>
--   <a>ix</a> k ≡ <a>at</a> k <a>%</a> <a>_Just</a>
--   </pre>
class (Ixed m, IxKind m ~ An_AffineTraversal) => At m

-- | <pre>
--   &gt;&gt;&gt; Map.fromList [(1,"world")] ^. at 1
--   Just "world"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; at 1 ?~ "hello" $ Map.empty
--   fromList [(1,"hello")]
--   </pre>
--   
--   <i>Note:</i> Usage of this function might introduce space leaks if
--   you're not careful to make sure that values put inside the <a>Just</a>
--   constructor are evaluated. To force the values and avoid such leaks,
--   use <a>at'</a> instead.
--   
--   <i>Note:</i> <a>Map</a>-like containers form a reasonable instance,
--   but not <tt>Array</tt>-like ones, where you cannot satisfy the
--   <a>Lens</a> laws.
at :: At m => Index m -> Lens' m (Maybe (IxValue m))

-- | Version of <a>at</a> strict in the value inside the <a>Just</a>
--   constructor.
--   
--   Example:
--   
--   <pre>
--   &gt;&gt;&gt; (at () .~ Just (error "oops") $ Nothing) `seq` ()
--   ()
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (at' () .~ Just (error "oops") $ Nothing) `seq` ()
--   *** Exception: oops
--   ...
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; view (at ()) (Just $ error "oops") `seq` ()
--   ()
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; view (at' ()) (Just $ error "oops") `seq` ()
--   *** Exception: oops
--   ...
--   </pre>
--   
--   It also works as expected for other data structures:
--   
--   <pre>
--   &gt;&gt;&gt; (at 1 .~ Just (error "oops") $ Map.empty) `seq` ()
--   ()
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (at' 1 .~ Just (error "oops") $ Map.empty) `seq` ()
--   *** Exception: oops
--   ...
--   </pre>
at' :: At m => Index m -> Lens' m (Maybe (IxValue m))

-- | Delete the value associated with a key in a <a>Map</a>-like container
--   
--   <pre>
--   <a>sans</a> k = <a>at</a> k <a>.~</a> Nothing
--   </pre>
sans :: At m => Index m -> m -> m

-- | This class provides a simple <a>Lens</a> that lets you view (and
--   modify) information about whether or not a container contains a given
--   <a>Index</a>. Instances are provided for <a>Set</a>-like containers
--   only.
class () => Contains m

-- | <pre>
--   &gt;&gt;&gt; IntSet.fromList [1,2,3,4] ^. contains 3
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; IntSet.fromList [1,2,3,4] ^. contains 5
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; IntSet.fromList [1,2,3,4] &amp; contains 3 .~ False
--   fromList [1,2,4]
--   </pre>
contains :: Contains m => Index m -> Lens' m Bool
instance (GHC.Classes.Eq a, Data.Hashable.Class.Hashable a) => Optics.At.Core.Contains (Data.HashSet.Internal.HashSet a)
instance (GHC.Classes.Eq k, Data.Hashable.Class.Hashable k) => Optics.At.Core.Ixed (Data.HashMap.Internal.HashMap k a)
instance (GHC.Classes.Eq k, Data.Hashable.Class.Hashable k) => Optics.At.Core.Ixed (Data.HashSet.Internal.HashSet k)
instance Optics.At.Core.Ixed (Data.Vector.Vector a)
instance Data.Primitive.Types.Prim a => Optics.At.Core.Ixed (Data.Vector.Primitive.Vector a)
instance Foreign.Storable.Storable a => Optics.At.Core.Ixed (Data.Vector.Storable.Vector a)
instance Data.Vector.Unboxed.Base.Unbox a => Optics.At.Core.Ixed (Data.Vector.Unboxed.Base.Vector a)
instance Optics.At.Core.Ixed Data.Text.Internal.Text
instance Optics.At.Core.Ixed Data.Text.Internal.Lazy.Text
instance Optics.At.Core.Ixed Data.ByteString.Internal.Type.ByteString
instance Optics.At.Core.Ixed Data.ByteString.Lazy.Internal.ByteString
instance (GHC.Classes.Eq k, Data.Hashable.Class.Hashable k) => Optics.At.Core.At (Data.HashMap.Internal.HashMap k a)
instance (GHC.Classes.Eq k, Data.Hashable.Class.Hashable k) => Optics.At.Core.At (Data.HashSet.Internal.HashSet k)


-- | This module defines the <a>Cons</a> and <a>Snoc</a> classes, which
--   provide <a>Prism</a>s for the leftmost and rightmost elements of a
--   container, respectively.
module Optics.Cons

-- | This class provides a way to attach or detach elements on the left
--   side of a structure in a flexible manner.
class () => Cons s t a b | s -> a, t -> b, s b -> t, t a -> s

-- | <pre>
--   <a>_Cons</a> :: <a>Prism</a> [a] [b] (a, [a]) (b, [b])
--   <a>_Cons</a> :: <a>Prism</a> (<a>Seq</a> a) (<a>Seq</a> b) (a, <a>Seq</a> a) (b, <a>Seq</a> b)
--   <a>_Cons</a> :: <a>Prism</a> (Vector a) (Vector b) (a, Vector a) (b, Vector b)
--   <a>_Cons</a> :: <a>Prism'</a> <a>String</a> (<a>Char</a>, <a>String</a>)
--   <a>_Cons</a> :: <a>Prism'</a> Text (<a>Char</a>, Text)
--   <a>_Cons</a> :: <a>Prism'</a> ByteString (<a>Word8</a>, ByteString)
--   </pre>
_Cons :: Cons s t a b => Prism s t (a, s) (b, t)

-- | <a>cons</a> an element onto a container.
--   
--   This is an infix alias for <a>cons</a>.
--   
--   <pre>
--   &gt;&gt;&gt; 1 &lt;| []
--   [1]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 'a' &lt;| "bc"
--   "abc"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 1 &lt;| []
--   [1]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 1 &lt;| [2, 3]
--   [1,2,3]
--   </pre>
(<|) :: Cons s s a a => a -> s -> s
infixr 5 <|

-- | <a>cons</a> an element onto a container.
--   
--   <pre>
--   &gt;&gt;&gt; cons 'a' ""
--   "a"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; cons 'a' "bc"
--   "abc"
--   </pre>
cons :: Cons s s a a => a -> s -> s
infixr 5 `cons`

-- | Attempt to extract the left-most element from a container, and a
--   version of the container without that element.
--   
--   <pre>
--   &gt;&gt;&gt; uncons []
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; uncons [1, 2, 3]
--   Just (1,[2,3])
--   </pre>
uncons :: Cons s s a a => s -> Maybe (a, s)

-- | An <a>AffineTraversal</a> reading and writing to the <a>head</a> of a
--   <i>non-empty</i> container.
--   
--   <pre>
--   &gt;&gt;&gt; "abc" ^? _head
--   Just 'a'
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "abc" &amp; _head .~ 'd'
--   "dbc"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,3] &amp; _head %~ (*10)
--   [10,2,3]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [] &amp; _head %~ absurd
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,3] ^? _head
--   Just 1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [] ^? _head
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [1,2] ^? _head
--   Just 1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [] &amp; _head .~ 1
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [0] &amp; _head .~ 2
--   [2]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [0,1] &amp; _head .~ 2
--   [2,1]
--   </pre>
_head :: Cons s s a a => AffineTraversal' s a

-- | An <a>AffineTraversal</a> reading and writing to the <a>tail</a> of a
--   <i>non-empty</i> container.
--   
--   <pre>
--   &gt;&gt;&gt; "ab" &amp; _tail .~ "cde"
--   "acde"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [] &amp; _tail .~ [1,2]
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,3,4,5] &amp; _tail % traversed %~ (*10)
--   [1,20,30,40,50]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [1,2] &amp; _tail .~ [3,4,5]
--   [1,3,4,5]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [] &amp; _tail .~ [1,2]
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "abc" ^? _tail
--   Just "bc"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "hello" ^? _tail
--   Just "ello"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "" ^? _tail
--   Nothing
--   </pre>
_tail :: Cons s s a a => AffineTraversal' s s

-- | Pattern synonym for matching on the leftmost element of a structure.
--   
--   <pre>
--   &gt;&gt;&gt; case ['a','b','c'] of (x :&lt; _) -&gt; x
--   'a'
--   </pre>
pattern (:<) :: Cons s s a a => a -> s -> s
infixr 5 :<

-- | This class provides a way to attach or detach elements on the right
--   side of a structure in a flexible manner.
class () => Snoc s t a b | s -> a, t -> b, s b -> t, t a -> s
_Snoc :: Snoc s t a b => Prism s t (s, a) (t, b)

-- | <a>snoc</a> an element onto the end of a container.
--   
--   This is an infix alias for <a>snoc</a>.
--   
--   <pre>
--   &gt;&gt;&gt; "" |&gt; 'a'
--   "a"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "bc" |&gt; 'a'
--   "bca"
--   </pre>
(|>) :: Snoc s s a a => s -> a -> s
infixl 5 |>

-- | <a>snoc</a> an element onto the end of a container.
--   
--   <pre>
--   &gt;&gt;&gt; snoc "hello" '!'
--   "hello!"
--   </pre>
snoc :: Snoc s s a a => s -> a -> s
infixl 5 `snoc`

-- | Attempt to extract the right-most element from a container, and a
--   version of the container without that element.
--   
--   <pre>
--   &gt;&gt;&gt; unsnoc "hello!"
--   Just ("hello",'!')
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; unsnoc ""
--   Nothing
--   </pre>
unsnoc :: Snoc s s a a => s -> Maybe (s, a)

-- | An <a>AffineTraversal</a> reading and replacing all but the a last
--   element of a <i>non-empty</i> container.
--   
--   <pre>
--   &gt;&gt;&gt; "abcd" ^? _init
--   Just "abc"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "" ^? _init
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "ab" &amp; _init .~ "cde"
--   "cdeb"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [] &amp; _init .~ [1,2]
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,3,4] &amp; _init % traversed %~ (*10)
--   [10,20,30,4]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,3] ^? _init
--   Just [1,2]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "hello" ^? _init
--   Just "hell"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [] ^? _init
--   Nothing
--   </pre>
_init :: Snoc s s a a => AffineTraversal' s s

-- | An <a>AffineTraversal</a> reading and writing to the last element of a
--   <i>non-empty</i> container.
--   
--   <pre>
--   &gt;&gt;&gt; "abc" ^? _last
--   Just 'c'
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "" ^? _last
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,3] &amp; _last %~ (+1)
--   [1,2,4]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [1,2] ^? _last
--   Just 2
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [] &amp; _last .~ 1
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [0] &amp; _last .~ 2
--   [2]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [0,1] &amp; _last .~ 2
--   [0,2]
--   </pre>
_last :: Snoc s s a a => AffineTraversal' s a

-- | Pattern synonym for matching on the rightmost element of a structure.
--   
--   <pre>
--   &gt;&gt;&gt; case ['a','b','c'] of (_ :&gt; x) -&gt; x
--   'c'
--   </pre>
pattern (:>) :: Snoc s s a a => s -> a -> s
infixl 5 :>
instance Optics.Cons.Core.Cons Data.ByteString.Internal.Type.ByteString Data.ByteString.Internal.Type.ByteString GHC.Word.Word8 GHC.Word.Word8
instance Optics.Cons.Core.Cons Data.ByteString.Lazy.Internal.ByteString Data.ByteString.Lazy.Internal.ByteString GHC.Word.Word8 GHC.Word.Word8
instance Optics.Cons.Core.Cons Data.Text.Internal.Text Data.Text.Internal.Text GHC.Types.Char GHC.Types.Char
instance Optics.Cons.Core.Cons Data.Text.Internal.Lazy.Text Data.Text.Internal.Lazy.Text GHC.Types.Char GHC.Types.Char
instance Optics.Cons.Core.Cons (Data.Vector.Vector a) (Data.Vector.Vector b) a b
instance (Data.Primitive.Types.Prim a, Data.Primitive.Types.Prim b) => Optics.Cons.Core.Cons (Data.Vector.Primitive.Vector a) (Data.Vector.Primitive.Vector b) a b
instance (Foreign.Storable.Storable a, Foreign.Storable.Storable b) => Optics.Cons.Core.Cons (Data.Vector.Storable.Vector a) (Data.Vector.Storable.Vector b) a b
instance (Data.Vector.Unboxed.Base.Unbox a, Data.Vector.Unboxed.Base.Unbox b) => Optics.Cons.Core.Cons (Data.Vector.Unboxed.Base.Vector a) (Data.Vector.Unboxed.Base.Vector b) a b
instance Optics.Cons.Core.Snoc (Data.Vector.Vector a) (Data.Vector.Vector b) a b
instance (Data.Primitive.Types.Prim a, Data.Primitive.Types.Prim b) => Optics.Cons.Core.Snoc (Data.Vector.Primitive.Vector a) (Data.Vector.Primitive.Vector b) a b
instance (Foreign.Storable.Storable a, Foreign.Storable.Storable b) => Optics.Cons.Core.Snoc (Data.Vector.Storable.Vector a) (Data.Vector.Storable.Vector b) a b
instance (Data.Vector.Unboxed.Base.Unbox a, Data.Vector.Unboxed.Base.Unbox b) => Optics.Cons.Core.Snoc (Data.Vector.Unboxed.Base.Vector a) (Data.Vector.Unboxed.Base.Vector b) a b
instance Optics.Cons.Core.Snoc Data.ByteString.Internal.Type.ByteString Data.ByteString.Internal.Type.ByteString GHC.Word.Word8 GHC.Word.Word8
instance Optics.Cons.Core.Snoc Data.ByteString.Lazy.Internal.ByteString Data.ByteString.Lazy.Internal.ByteString GHC.Word.Word8 GHC.Word.Word8
instance Optics.Cons.Core.Snoc Data.Text.Internal.Text Data.Text.Internal.Text GHC.Types.Char GHC.Types.Char
instance Optics.Cons.Core.Snoc Data.Text.Internal.Lazy.Text Data.Text.Internal.Lazy.Text GHC.Types.Char GHC.Types.Char


-- | This module defines the <a>AsEmpty</a> class, which provides a
--   <a>Prism</a> for a type that may be <a>_Empty</a>.
--   
--   <pre>
--   &gt;&gt;&gt; isn't _Empty [1,2,3]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; case Nothing of { Empty -&gt; True; _ -&gt; False }
--   True
--   </pre>
module Optics.Empty

-- | Class for types that may be <a>_Empty</a>.
class () => AsEmpty a

-- | <pre>
--   &gt;&gt;&gt; isn't _Empty [1,2,3]
--   True
--   </pre>
_Empty :: AsEmpty a => Prism' a ()

-- | Pattern synonym for matching on any type with an <a>AsEmpty</a>
--   instance.
--   
--   <pre>
--   &gt;&gt;&gt; case Nothing of { Empty -&gt; True; _ -&gt; False }
--   True
--   </pre>
pattern Empty :: AsEmpty a => a
instance Optics.Empty.Core.AsEmpty (Data.HashMap.Internal.HashMap k a)
instance Optics.Empty.Core.AsEmpty (Data.HashSet.Internal.HashSet a)
instance Optics.Empty.Core.AsEmpty (Data.Vector.Vector a)
instance Data.Vector.Unboxed.Base.Unbox a => Optics.Empty.Core.AsEmpty (Data.Vector.Unboxed.Base.Vector a)
instance Foreign.Storable.Storable a => Optics.Empty.Core.AsEmpty (Data.Vector.Storable.Vector a)
instance Optics.Empty.Core.AsEmpty Data.ByteString.Internal.Type.ByteString
instance Optics.Empty.Core.AsEmpty Data.ByteString.Lazy.Internal.ByteString
instance Optics.Empty.Core.AsEmpty Data.Text.Internal.Text
instance Optics.Empty.Core.AsEmpty Data.Text.Internal.Lazy.Text


-- | This module spends a lot of time fiddling around with
--   <a>ByteString</a> internals to work around
--   <a>http://hackage.haskell.org/trac/ghc/ticket/7556</a> on older
--   Haskell Platforms and to improve constant and asymptotic factors in
--   our performance.
module Optics.Extra.Internal.ByteString

-- | Traverse a strict <a>ByteString</a> in a relatively balanced fashion,
--   as a balanced tree with biased runs of elements at the leaves.
traversedStrictTree :: IxTraversal' Int64 ByteString Word8

-- | Traverse a strict <a>ByteString</a> in a relatively balanced fashion,
--   as a balanced tree with biased runs of elements at the leaves,
--   pretending the bytes are chars.
traversedStrictTree8 :: IxTraversal' Int64 ByteString Char

-- | An <a>IxTraversal</a> of the individual bytes in a lazy
--   <a>ByteString</a>.
traversedLazy :: IxTraversal' Int64 ByteString Word8

-- | An <a>IxTraversal</a> of the individual bytes in a lazy
--   <a>ByteString</a> pretending the bytes are chars.
traversedLazy8 :: IxTraversal' Int64 ByteString Char

module Data.ByteString.Strict.Optics

-- | <a>pack</a> (or <a>unpack</a>) a list of bytes into a
--   <a>ByteString</a>
--   
--   <pre>
--   <a>packedBytes</a> ≡ <a>re</a> <a>unpackedBytes</a>
--   <a>pack</a> x ≡  x <a>^.</a> <a>packedBytes</a>
--   <a>unpack</a> x ≡ x <a>^.</a> <a>re</a> <a>packedBytes</a>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [104,101,108,108,111] ^. packedBytes
--   "hello"
--   </pre>
packedBytes :: Iso' [Word8] ByteString

-- | <a>unpack</a> (or <a>pack</a>) a <a>ByteString</a> into a list of
--   bytes.
--   
--   <pre>
--   <a>unpackedBytes</a> ≡ <a>re</a> <a>packedBytes</a>
--   <a>unpack</a> x ≡ x <a>^.</a> <a>unpackedBytes</a>
--   <a>pack</a> x ≡  x <a>^.</a> <a>re</a> <a>unpackedBytes</a>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "hello" ^. packedChars % unpackedBytes
--   [104,101,108,108,111]
--   </pre>
unpackedBytes :: Iso' ByteString [Word8]

-- | Traverse each <a>Word8</a> in a <a>ByteString</a>.
--   
--   This <a>Traversal</a> walks the <a>ByteString</a> in a tree-like
--   fashion enable zippers to seek to locations in logarithmic time and
--   accelerating many monoidal queries, but up to associativity (and
--   constant factors) it is equivalent to the much slower:
--   
--   <pre>
--   <a>bytes</a> ≡ <a>unpackedBytes</a> <a>%</a> <a>traversed</a>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; anyOf bytes (== 0x80) (Char8.pack "hello")
--   False
--   </pre>
--   
--   Note that when just using this as a <a>Setter</a>, <tt><a>sets</a>
--   <a>map</a></tt> can be more efficient.
bytes :: IxTraversal' Int64 ByteString Word8

-- | <a>pack</a> (or <a>unpack</a>) a list of characters into a
--   <a>ByteString</a>
--   
--   When writing back to the <a>ByteString</a> it is assumed that every
--   <a>Char</a> lies between <tt>'x00'</tt> and <tt>'xff'</tt>.
--   
--   <pre>
--   <a>packedChars</a> ≡ <a>re</a> <a>unpackedChars</a>
--   <a>pack</a> x ≡ x <a>^.</a> <a>packedChars</a>
--   <a>unpack</a> x ≡ x <a>^.</a> <a>re</a> <a>packedChars</a>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldOf (packedChars % each % to (\w -&gt; let x = showHex w "" in if Prelude.length x == 1 then '0':x else x)) "hello"
--   "68656c6c6f"
--   </pre>
packedChars :: Iso' String ByteString

-- | <a>unpack</a> (or <a>pack</a>) a list of characters into a
--   <a>ByteString</a>
--   
--   When writing back to the <a>ByteString</a> it is assumed that every
--   <a>Char</a> lies between <tt>'x00'</tt> and <tt>'xff'</tt>.
--   
--   <pre>
--   <a>unpackedChars</a> ≡ <a>re</a> <a>packedChars</a>
--   <a>unpack</a> x ≡ x <a>^.</a> <a>unpackedChars</a>
--   <a>pack</a> x ≡ x <a>^.</a> <a>re</a> <a>unpackedChars</a>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [104,101,108,108,111] ^. packedBytes % unpackedChars
--   "hello"
--   </pre>
unpackedChars :: Iso' ByteString String

-- | Traverse the individual bytes in a <a>ByteString</a> as characters.
--   
--   When writing back to the <a>ByteString</a> it is assumed that every
--   <a>Char</a> lies between <tt>'x00'</tt> and <tt>'xff'</tt>.
--   
--   This <a>Traversal</a> walks the <a>ByteString</a> in a tree-like
--   fashion enable zippers to seek to locations in logarithmic time and
--   accelerating many monoidal queries, but up to associativity (and
--   constant factors) it is equivalent to the much slower:
--   
--   <pre>
--   <a>chars</a> = <a>unpackedChars</a> <a>%</a> <a>traversed</a>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; anyOf chars (== 'h') $ Char8.pack "hello"
--   True
--   </pre>
chars :: IxTraversal' Int64 ByteString Char
pattern Bytes :: [Word8] -> ByteString
pattern Chars :: [Char] -> ByteString


-- | Lazy <a>ByteString</a> lenses.
module Data.ByteString.Lazy.Optics

-- | <a>pack</a> (or <a>unpack</a>) a list of bytes into a
--   <a>ByteString</a>.
--   
--   <pre>
--   <a>packedBytes</a> ≡ <a>re</a> <a>unpackedBytes</a>
--   <a>pack</a> x ≡  x <a>^.</a> <a>packedBytes</a>
--   <a>unpack</a> x ≡ x <a>^.</a> <a>re</a> <a>packedBytes</a>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [104,101,108,108,111] ^. packedBytes == Char8.pack "hello"
--   True
--   </pre>
packedBytes :: Iso' [Word8] ByteString

-- | <a>unpack</a> (or <a>pack</a>) a <a>ByteString</a> into a list of
--   bytes.
--   
--   <pre>
--   <a>unpackedBytes</a> ≡ <a>re</a> <a>packedBytes</a>
--   <a>unpack</a> x ≡ x <a>^.</a> <a>unpackedBytes</a>
--   <a>pack</a> x ≡  x <a>^.</a> <a>re</a> <a>unpackedBytes</a>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "hello" ^. packedChars % unpackedBytes
--   [104,101,108,108,111]
--   </pre>
unpackedBytes :: Iso' ByteString [Word8]

-- | Traverse the individual bytes in a <a>ByteString</a>.
--   
--   This <a>Traversal</a> walks each strict <a>ByteString</a> chunk in a
--   tree-like fashion enable zippers to seek to locations more quickly and
--   accelerate many monoidal queries, but up to associativity (and
--   constant factors) it is equivalent to the much slower:
--   
--   <pre>
--   <a>bytes</a> ≡ <a>unpackedBytes</a> <a>%</a> <a>traversed</a>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; anyOf bytes (== 0x80) (Char8.pack "hello")
--   False
--   </pre>
--   
--   Note that when just using this as a <a>Setter</a>, <tt><a>sets</a>
--   <a>map</a></tt> can be more efficient.
bytes :: IxTraversal' Int64 ByteString Word8

-- | <a>pack</a> (or <a>unpack</a>) a list of characters into a
--   <a>ByteString</a>.
--   
--   When writing back to the <a>ByteString</a> it is assumed that every
--   <a>Char</a> lies between <tt>'x00'</tt> and <tt>'xff'</tt>.
--   
--   <pre>
--   <a>packedChars</a> ≡ <a>re</a> <a>unpackedChars</a>
--   <a>pack</a> x ≡ x <a>^.</a> <a>packedChars</a>
--   <a>unpack</a> x ≡ x <a>^.</a> <a>re</a> <a>packedChars</a>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldOf (packedChars % each % to (\w -&gt; let x = showHex w "" in if Prelude.length x == 1 then '0':x else x)) "hello"
--   "68656c6c6f"
--   </pre>
packedChars :: Iso' String ByteString

-- | <a>unpack</a> (or <a>pack</a>) a list of characters into a
--   <a>ByteString</a>
--   
--   When writing back to the <a>ByteString</a> it is assumed that every
--   <a>Char</a> lies between <tt>'x00'</tt> and <tt>'xff'</tt>.
--   
--   <pre>
--   <a>unpackedChars</a> ≡ <a>re</a> <a>packedChars</a>
--   <a>unpack</a> x ≡ x <a>^.</a> <a>unpackedChars</a>
--   <a>pack</a> x ≡ x <a>^.</a> <a>re</a> <a>unpackedChars</a>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [104,101,108,108,111] ^. packedBytes % unpackedChars
--   "hello"
--   </pre>
unpackedChars :: Iso' ByteString String

-- | Traverse the individual bytes in a <a>ByteString</a> as characters.
--   
--   When writing back to the <a>ByteString</a> it is assumed that every
--   <a>Char</a> lies between <tt>'x00'</tt> and <tt>'xff'</tt>.
--   
--   This <a>Traversal</a> walks each strict <a>ByteString</a> chunk in a
--   tree-like fashion enable zippers to seek to locations more quickly and
--   accelerate many monoidal queries, but up to associativity (and
--   constant factors) it is equivalent to:
--   
--   <pre>
--   <a>chars</a> = <a>unpackedChars</a> <a>%</a> <a>traversed</a>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; anyOf chars (== 'h') $ Char8.pack "hello"
--   True
--   </pre>
chars :: IxTraversal' Int64 ByteString Char
pattern Bytes :: [Word8] -> ByteString
pattern Chars :: [Char] -> ByteString

module Data.ByteString.Optics

-- | Traversals for ByteStrings.
class IsByteString t

-- | <a>pack</a> (or <a>unpack</a>) a list of bytes into a strict or lazy
--   <tt>ByteString</tt>.
--   
--   <pre>
--   <a>pack</a> x ≡ x <a>^.</a> <a>packedBytes</a>
--   <a>unpack</a> x ≡ x <a>^.</a> <a>re</a> <a>packedBytes</a>
--   <a>packedBytes</a> ≡ <a>re</a> <a>unpackedBytes</a>
--   </pre>
packedBytes :: IsByteString t => Iso' [Word8] t

-- | <a>pack</a> (or <a>unpack</a>) a list of characters into a strict or
--   lazy <tt>ByteString</tt>.
--   
--   When writing back to the <tt>ByteString</tt> it is assumed that every
--   <a>Char</a> lies between <tt>'x00'</tt> and <tt>'xff'</tt>.
--   
--   <pre>
--   <a>pack</a> x ≡ x <a>^.</a> <a>packedChars</a>
--   <a>unpack</a> x ≡ x <a>^.</a> <a>re</a> <a>packedChars</a>
--   <a>packedChars</a> ≡ <a>re</a> <a>unpackedChars</a>
--   </pre>
packedChars :: IsByteString t => Iso' String t

-- | Traverse each <a>Word8</a> in a strict or lazy <tt>ByteString</tt>
--   
--   This <a>Traversal</a> walks each strict <tt>ByteString</tt> chunk in a
--   tree-like fashion enable zippers to seek to locations more quickly and
--   accelerate many monoidal queries, but up to associativity (and
--   constant factors) it is equivalent to the much slower:
--   
--   <pre>
--   <a>bytes</a> ≡ <a>unpackedBytes</a> <a>.</a> <a>traversed</a>
--   </pre>
--   
--   <pre>
--   <a>anyOf</a> <a>bytes</a> (<a>==</a> 0x80) :: <tt>ByteString</tt> -&gt; <a>Bool</a>
--   </pre>
bytes :: IsByteString t => IxTraversal' Int64 t Word8

-- | Traverse the individual bytes in a strict or lazy <tt>ByteString</tt>
--   as characters.
--   
--   When writing back to the <tt>ByteString</tt> it is assumed that every
--   <a>Char</a> lies between <tt>'x00'</tt> and <tt>'xff'</tt>.
--   
--   This <a>Traversal</a> walks each strict <tt>ByteString</tt> chunk in a
--   tree-like fashion enable zippers to seek to locations more quickly and
--   accelerate many monoidal queries, but up to associativity (and
--   constant factors) it is equivalent to the much slower:
--   
--   <pre>
--   <a>chars</a> ≡ <a>unpackedChars</a> <a>.</a> <a>traversed</a>
--   </pre>
--   
--   <pre>
--   <a>anyOf</a> <a>chars</a> (<a>==</a> 'c') :: <tt>ByteString</tt> -&gt; <a>Bool</a>
--   </pre>
chars :: IsByteString t => IxTraversal' Int64 t Char

-- | <a>unpack</a> (or <a>pack</a>) a <tt>ByteString</tt> into a list of
--   bytes.
--   
--   <pre>
--   <a>unpackedBytes</a> ≡ <a>re</a> <a>packedBytes</a>
--   <a>unpack</a> x ≡ x <a>^.</a> <a>unpackedBytes</a>
--   <a>pack</a> x ≡  x <a>^.</a> <a>re</a> <a>unpackedBytes</a>
--   </pre>
--   
--   <pre>
--   <a>unpackedBytes</a> :: <a>Iso'</a> <a>ByteString</a> [<a>Word8</a>]
--   <a>unpackedBytes</a> :: <a>Iso'</a> <a>ByteString</a> [<a>Word8</a>]
--   </pre>
unpackedBytes :: IsByteString t => Iso' t [Word8]

-- | <a>unpack</a> (or <a>pack</a>) a list of characters into a strict (or
--   lazy) <tt>ByteString</tt>
--   
--   When writing back to the <tt>ByteString</tt> it is assumed that every
--   <a>Char</a> lies between <tt>'x00'</tt> and <tt>'xff'</tt>.
--   
--   <pre>
--   <a>unpackedChars</a> ≡ <a>re</a> <a>packedChars</a>
--   <a>unpack</a> x ≡ x <a>^.</a> <a>unpackedChars</a>
--   <a>pack</a> x ≡ x <a>^.</a> <a>re</a> <a>unpackedChars</a>
--   </pre>
--   
--   <pre>
--   <a>unpackedChars</a> :: <a>Iso'</a> <a>ByteString</a> <a>String</a>
--   <a>unpackedChars</a> :: <a>Iso'</a> <a>ByteString</a> <a>String</a>
--   </pre>
unpackedChars :: IsByteString t => Iso' t String
pattern Bytes :: IsByteString t => [Word8] -> t
pattern Chars :: IsByteString t => [Char] -> t
instance Data.ByteString.Optics.IsByteString Data.ByteString.Internal.Type.ByteString
instance Data.ByteString.Optics.IsByteString Data.ByteString.Lazy.Internal.ByteString

module Optics.Extra.Internal.Vector

-- | Return the the subset of given ordinals within a given bound and in
--   order of the first occurrence seen.
--   
--   Bound: <tt>0 &lt;= x &lt; l</tt>
--   
--   <pre>
--   &gt;&gt;&gt; ordinalNub 3 [-1,2,1,4,2,3]
--   [2,1]
--   </pre>
ordinalNub :: Int -> [Int] -> [Int]


-- | This module provides lenses and traversals for working with generic
--   vectors.
module Data.Vector.Generic.Optics

-- | Similar to <a>toListOf</a>, but returning a <a>Vector</a>.
--   
--   <pre>
--   &gt;&gt;&gt; (toVectorOf each (8,15) :: Vector.Vector Int) == Vector.fromList [8,15]
--   True
--   </pre>
toVectorOf :: (Is k A_Fold, Vector v a) => Optic' k is s a -> s -> v a

-- | Convert a <a>Vector</a> to a version that doesn't retain any extra
--   memory.
forced :: (Vector v a, Vector v b) => Iso (v a) (v b) (v a) (v b)

-- | Convert a list to a <a>Vector</a> (or back.)
--   
--   <pre>
--   &gt;&gt;&gt; ([1,2,3] ^. vector :: Vector.Vector Int) == Vector.fromList [1,2,3]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Vector.fromList [0,8,15] ^. re vector
--   [0,8,15]
--   </pre>
vector :: (Vector v a, Vector v b) => Iso [a] [b] (v a) (v b)

-- | Convert a <a>Vector</a> to a finite <a>Bundle</a> (or back.)
asStream :: (Vector v a, Vector v b) => Iso (v a) (v b) (Bundle v a) (Bundle v b)

-- | Convert a <a>Vector</a> to a finite <a>Bundle</a> from right to left
--   (or back.)
asStreamR :: (Vector v a, Vector v b) => Iso (v a) (v b) (Bundle v a) (Bundle v b)

-- | Convert a <a>Vector</a> back and forth to an initializer that when run
--   produces a copy of the <a>Vector</a>.
cloned :: Vector v a => Iso' (v a) (New v a)

-- | Different vector implementations are isomorphic to each other.
converted :: (Vector v a, Vector w a, Vector v b, Vector w b) => Iso (v a) (v b) (w a) (w b)

-- | <tt>sliced i n</tt> provides a <a>Lens</a> that edits the <tt>n</tt>
--   elements starting at index <tt>i</tt> from a <a>Lens</a>.
--   
--   This is only a valid <a>Lens</a> if you do not change the length of
--   the resulting <a>Vector</a>.
--   
--   Attempting to return a longer or shorter vector will result in
--   violations of the <a>Lens</a> laws.
--   
--   <pre>
--   &gt;&gt;&gt; Vector.fromList [1..10] ^. sliced 2 5 == Vector.fromList [3,4,5,6,7]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (Vector.fromList [1..10] &amp; sliced 2 5 % mapped .~ 0) == Vector.fromList [1,2,0,0,0,0,0,8,9,10]
--   True
--   </pre>
sliced :: Vector v a => Int -> Int -> Lens' (v a) (v a)

-- | This <a>Traversal</a> will ignore any duplicates in the supplied list
--   of indices.
--   
--   <pre>
--   &gt;&gt;&gt; toListOf (ordinals [1,3,2,5,9,10]) $ Vector.fromList [2,4..40]
--   [4,8,6,12,20,22]
--   </pre>
ordinals :: forall v a. Vector v a => [Int] -> IxTraversal' Int (v a) a

-- | Like <a>ix</a> but polymorphic in the vector type.
vectorIx :: Vector v a => Int -> Traversal' (v a) a

-- | Indexed vector traversal for a generic vector.
vectorTraverse :: forall v w a b. (Vector v a, Vector w b) => IxTraversal Int (v a) (w b) a b


-- | This module provides lenses and traversals for working with vectors.
module Data.Vector.Optics

-- | Similar to <a>toListOf</a>, but returning a <a>Vector</a>.
--   
--   <pre>
--   &gt;&gt;&gt; toVectorOf each (8,15) == Vector.fromList [8,15]
--   True
--   </pre>
toVectorOf :: Is k A_Fold => Optic' k is s a -> s -> Vector a

-- | Convert a list to a <a>Vector</a> (or back)
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,3] ^. vector == Vector.fromList [1,2,3]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,3] ^. vector % re vector
--   [1,2,3]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Vector.fromList [0,8,15] ^. re vector % vector == Vector.fromList [0,8,15]
--   True
--   </pre>
vector :: Iso [a] [b] (Vector a) (Vector b)

-- | Convert a <a>Vector</a> to a version that doesn't retain any extra
--   memory.
forced :: Iso (Vector a) (Vector b) (Vector a) (Vector b)

-- | <tt>sliced i n</tt> provides a <a>Lens</a> that edits the <tt>n</tt>
--   elements starting at index <tt>i</tt> from a <a>Lens</a>.
--   
--   This is only a valid <a>Lens</a> if you do not change the length of
--   the resulting <a>Vector</a>.
--   
--   Attempting to return a longer or shorter vector will result in
--   violations of the <a>Lens</a> laws.
--   
--   <pre>
--   &gt;&gt;&gt; Vector.fromList [1..10] ^. sliced 2 5 == Vector.fromList [3,4,5,6,7]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (Vector.fromList [1..10] &amp; sliced 2 5 % mapped .~ 0) == Vector.fromList [1,2,0,0,0,0,0,8,9,10]
--   True
--   </pre>
sliced :: Int -> Int -> Lens' (Vector a) (Vector a)

-- | This <a>Traversal</a> will ignore any duplicates in the supplied list
--   of indices.
--   
--   <pre>
--   &gt;&gt;&gt; toListOf (ordinals [1,3,2,5,9,10]) $ Vector.fromList [2,4..40]
--   [4,8,6,12,20,22]
--   </pre>
ordinals :: forall a. [Int] -> IxTraversal' Int (Vector a) a

module Optics.Extra.Internal.Zoom

-- | Used by <a>Zoom</a> to <a>zoom</a> into <a>StateT</a>.
newtype Focusing m c s
Focusing :: m (c, s) -> Focusing m c s
[unfocusing] :: Focusing m c s -> m (c, s)
stateZoom :: (Is k A_Lens, Monad m) => Optic' k is t s -> (s -> m (c, s)) -> t -> m (c, t)
stateZoomMaybe :: (Is k An_AffineTraversal, Monad m) => Optic' k is t s -> (s -> m (c, s)) -> t -> m (Maybe c, t)
stateZoomMany :: (Is k A_Traversal, Monad m, Monoid c) => Optic' k is t s -> (s -> m (c, s)) -> t -> m (c, t)

-- | Used by <a>Zoom</a> to <a>zoom</a> into <a>RWST</a>.
newtype FocusingWith w m c s
FocusingWith :: m (c, s, w) -> FocusingWith w m c s
[unfocusingWith] :: FocusingWith w m c s -> m (c, s, w)
rwsZoom :: (Is k A_Lens, Monad m) => Optic' k is t s -> (r -> s -> m (c, s, w)) -> r -> t -> m (c, t, w)
rwsZoomMaybe :: (Is k An_AffineTraversal, Monad m, Monoid w) => Optic' k is t s -> (r -> s -> m (c, s, w)) -> r -> t -> m (Maybe c, t, w)
rwsZoomMany :: (Is k A_Traversal, Monad m, Monoid w, Monoid c) => Optic' k is t s -> (r -> s -> m (c, s, w)) -> r -> t -> m (c, t, w)

-- | Make a <a>Monoid</a> out of <a>Maybe</a> for error handling.
newtype May a
May :: Maybe a -> May a
[getMay] :: May a -> Maybe a
shuffleMay :: Maybe (May c) -> May (Maybe c)

-- | Make a <a>Monoid</a> out of <a>Either</a> for error handling.
newtype Err e a
Err :: Either e a -> Err e a
[getErr] :: Err e a -> Either e a
shuffleErr :: Maybe (Err e c) -> Err e (Maybe c)

-- | Wrap a monadic effect.
newtype Effect m r
Effect :: m r -> Effect m r
[getEffect] :: Effect m r -> m r

-- | Wrap a monadic effect. Used when magnifying <a>RWST</a>.
newtype EffectRWS w s m c
EffectRWS :: (s -> m (c, s, w)) -> EffectRWS w s m c
[getEffectRWS] :: EffectRWS w s m c -> s -> m (c, s, w)
rwsMagnify :: Is k A_Getter => Optic' k is a b -> (b -> s -> f (c, s, w)) -> a -> s -> f (c, s, w)
rwsMagnifyMaybe :: (Is k An_AffineFold, Applicative m, Monoid w) => Optic' k is a b -> (b -> s -> m (c, s, w)) -> a -> s -> m (Maybe c, s, w)
rwsMagnifyMany :: (Is k A_Fold, Monad m, Monoid w, Monoid c) => Optic' k is a b -> (b -> s -> m (c, s, w)) -> a -> s -> m (c, s, w)
shuffleS :: s -> Maybe (c, s) -> (Maybe c, s)
shuffleW :: Monoid w => Maybe (c, w) -> (Maybe c, w)
instance (GHC.Base.Semigroup c, GHC.Base.Semigroup w, GHC.Base.Monad m) => GHC.Base.Semigroup (Optics.Extra.Internal.Zoom.EffectRWS w s m c)
instance (GHC.Base.Monoid c, GHC.Base.Monoid w, GHC.Base.Monad m) => GHC.Base.Monoid (Optics.Extra.Internal.Zoom.EffectRWS w s m c)
instance (GHC.Base.Monad m, GHC.Base.Semigroup r) => GHC.Base.Semigroup (Optics.Extra.Internal.Zoom.Effect m r)
instance (GHC.Base.Monad m, GHC.Base.Monoid r) => GHC.Base.Monoid (Optics.Extra.Internal.Zoom.Effect m r)
instance GHC.Base.Semigroup a => GHC.Base.Semigroup (Optics.Extra.Internal.Zoom.Err e a)
instance GHC.Base.Monoid a => GHC.Base.Monoid (Optics.Extra.Internal.Zoom.Err e a)
instance GHC.Base.Semigroup a => GHC.Base.Semigroup (Optics.Extra.Internal.Zoom.May a)
instance GHC.Base.Monoid a => GHC.Base.Monoid (Optics.Extra.Internal.Zoom.May a)
instance GHC.Base.Monad m => GHC.Base.Functor (Optics.Extra.Internal.Zoom.FocusingWith w m s)
instance (GHC.Base.Monad m, GHC.Base.Monoid s, GHC.Base.Monoid w) => GHC.Base.Applicative (Optics.Extra.Internal.Zoom.FocusingWith w m s)
instance GHC.Base.Monad m => GHC.Base.Functor (Optics.Extra.Internal.Zoom.Focusing m c)
instance (GHC.Base.Monad m, GHC.Base.Monoid s) => GHC.Base.Applicative (Optics.Extra.Internal.Zoom.Focusing m s)


-- | This module defines general functionality for indexed optics. See the
--   "Indexed optics" section of the overview documentation in the
--   <tt>Optics</tt> module of the main <tt>optics</tt> package for more
--   details.
--   
--   Unlike <a>Optics.Indexed.Core</a>, this includes the definitions from
--   modules for specific indexed optic flavours such as
--   <a>Optics.IxTraversal</a>, and includes additional instances for
--   <a>FunctorWithIndex</a> and similar classes.
module Optics.Indexed

-- | Class for optic kinds that can have indices.
class () => IxOptic k s t a b

-- | Convert an indexed optic to its unindexed equivalent.
noIx :: forall (is :: IxList). (IxOptic k s t a b, NonEmptyIndices is) => Optic k is s t a b -> Optic k NoIx s t a b

-- | Construct a conjoined indexed optic that provides a separate code path
--   when used without indices. Useful for defining indexed optics that are
--   as efficient as their unindexed equivalents when used without indices.
--   
--   <i>Note:</i> <tt><a>conjoined</a> f g</tt> is well-defined if and only
--   if <tt>f ≡ <a>noIx</a> g</tt>.
conjoined :: forall (is :: IxList) i k s t a b. HasSingleIndex is i => Optic k NoIx s t a b -> Optic k is s t a b -> Optic k is s t a b

-- | Compose two indexed optics. Their indices are composed as a pair.
--   
--   <pre>
--   &gt;&gt;&gt; itoListOf (ifolded &lt;%&gt; ifolded) ["foo", "bar"]
--   [((0,0),'f'),((0,1),'o'),((0,2),'o'),((1,0),'b'),((1,1),'a'),((1,2),'r')]
--   </pre>
(<%>) :: forall k l m s t a b (is :: IxList) i (js :: IxList) j u v. (JoinKinds k l m, IxOptic m s t a b, HasSingleIndex is i, HasSingleIndex js j) => Optic k is s t u v -> Optic l js u v a b -> Optic m (WithIx (i, j)) s t a b
infixl 9 <%>

-- | Compose two indexed optics and drop indices of the left one. (If you
--   want to compose a non-indexed and an indexed optic, you can just use
--   (<a>%</a>).)
--   
--   <pre>
--   &gt;&gt;&gt; itoListOf (ifolded %&gt; ifolded) ["foo", "bar"]
--   [(0,'f'),(1,'o'),(2,'o'),(0,'b'),(1,'a'),(2,'r')]
--   </pre>
(%>) :: forall k l m s t u v (is :: IxList) (js :: IxList) a b. (JoinKinds k l m, IxOptic k s t u v, NonEmptyIndices is) => Optic k is s t u v -> Optic l js u v a b -> Optic m js s t a b
infixl 9 %>

-- | Compose two indexed optics and drop indices of the right one. (If you
--   want to compose an indexed and a non-indexed optic, you can just use
--   (<a>%</a>).)
--   
--   <pre>
--   &gt;&gt;&gt; itoListOf (ifolded &lt;% ifolded) ["foo", "bar"]
--   [(0,'f'),(0,'o'),(0,'o'),(1,'b'),(1,'a'),(1,'r')]
--   </pre>
(<%) :: forall k l m u v a b (js :: IxList) (is :: IxList) s t. (JoinKinds k l m, IxOptic l u v a b, NonEmptyIndices js) => Optic k is s t u v -> Optic l js u v a b -> Optic m is s t a b
infixl 9 <%

-- | Remap the index.
--   
--   <pre>
--   &gt;&gt;&gt; itoListOf (reindexed succ ifolded) "foo"
--   [(1,'f'),(2,'o'),(3,'o')]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; itoListOf (ifolded %&amp; reindexed succ) "foo"
--   [(1,'f'),(2,'o'),(3,'o')]
--   </pre>
reindexed :: forall (is :: IxList) i j k s t a b. HasSingleIndex is i => (i -> j) -> Optic k is s t a b -> Optic k (WithIx j) s t a b

-- | Flatten indices obtained from two indexed optics.
--   
--   <pre>
--   &gt;&gt;&gt; itoListOf (ifolded % ifolded %&amp; icompose (,)) ["foo","bar"]
--   [((0,0),'f'),((0,1),'o'),((0,2),'o'),((1,0),'b'),((1,1),'a'),((1,2),'r')]
--   </pre>
icompose :: (i -> j -> ix) -> Optic k '[i, j] s t a b -> Optic k (WithIx ix) s t a b

-- | Flatten indices obtained from three indexed optics.
--   
--   <pre>
--   &gt;&gt;&gt; itoListOf (ifolded % ifolded % ifolded %&amp; icompose3 (,,)) [["foo","bar"],["xyz"]]
--   [((0,0,0),'f'),((0,0,1),'o'),((0,0,2),'o'),((0,1,0),'b'),((0,1,1),'a'),((0,1,2),'r'),((1,0,0),'x'),((1,0,1),'y'),((1,0,2),'z')]
--   </pre>
icompose3 :: (i1 -> i2 -> i3 -> ix) -> Optic k '[i1, i2, i3] s t a b -> Optic k (WithIx ix) s t a b

-- | Flatten indices obtained from four indexed optics.
icompose4 :: (i1 -> i2 -> i3 -> i4 -> ix) -> Optic k '[i1, i2, i3, i4] s t a b -> Optic k (WithIx ix) s t a b

-- | Flatten indices obtained from five indexed optics.
icompose5 :: (i1 -> i2 -> i3 -> i4 -> i5 -> ix) -> Optic k '[i1, i2, i3, i4, i5] s t a b -> Optic k (WithIx ix) s t a b

-- | Flatten indices obtained from arbitrary number of indexed optics.
icomposeN :: forall k i (is :: IxList) s t a b. (CurryCompose is, NonEmptyIndices is) => Curry is i -> Optic k is s t a b -> Optic k (WithIx i) s t a b

-- | A <a>Functor</a> with an additional index.
--   
--   Instances must satisfy a modified form of the <a>Functor</a> laws:
--   
--   <pre>
--   <a>imap</a> f <a>.</a> <a>imap</a> g ≡ <a>imap</a> (\i -&gt; f i <a>.</a> g i)
--   <a>imap</a> (\_ a -&gt; a) ≡ <a>id</a>
--   </pre>
class Functor f => FunctorWithIndex i (f :: Type -> Type) | f -> i

-- | Map with access to the index.
imap :: FunctorWithIndex i f => (i -> a -> b) -> f a -> f b

-- | A container that supports folding with an additional index.
class Foldable f => FoldableWithIndex i (f :: Type -> Type) | f -> i

-- | Fold a container by mapping value to an arbitrary <a>Monoid</a> with
--   access to the index <tt>i</tt>.
--   
--   When you don't need access to the index then <a>foldMap</a> is more
--   flexible in what it accepts.
--   
--   <pre>
--   <a>foldMap</a> ≡ <a>ifoldMap</a> <a>.</a> <tt>const</tt>
--   </pre>
ifoldMap :: (FoldableWithIndex i f, Monoid m) => (i -> a -> m) -> f a -> m

-- | A variant of <a>ifoldMap</a> that is strict in the accumulator.
--   
--   When you don't need access to the index then <a>foldMap'</a> is more
--   flexible in what it accepts.
--   
--   <pre>
--   <a>foldMap'</a> ≡ <a>ifoldMap'</a> <a>.</a> <tt>const</tt>
--   </pre>
ifoldMap' :: (FoldableWithIndex i f, Monoid m) => (i -> a -> m) -> f a -> m

-- | Right-associative fold of an indexed container with access to the
--   index <tt>i</tt>.
--   
--   When you don't need access to the index then <a>foldr</a> is more
--   flexible in what it accepts.
--   
--   <pre>
--   <a>foldr</a> ≡ <a>ifoldr</a> <a>.</a> <tt>const</tt>
--   </pre>
ifoldr :: FoldableWithIndex i f => (i -> a -> b -> b) -> b -> f a -> b

-- | Left-associative fold of an indexed container with access to the index
--   <tt>i</tt>.
--   
--   When you don't need access to the index then <a>foldl</a> is more
--   flexible in what it accepts.
--   
--   <pre>
--   <a>foldl</a> ≡ <a>ifoldl</a> <a>.</a> <tt>const</tt>
--   </pre>
ifoldl :: FoldableWithIndex i f => (i -> b -> a -> b) -> b -> f a -> b

-- | <i>Strictly</i> fold right over the elements of a structure with
--   access to the index <tt>i</tt>.
--   
--   When you don't need access to the index then <a>foldr'</a> is more
--   flexible in what it accepts.
--   
--   <pre>
--   <a>foldr'</a> ≡ <a>ifoldr'</a> <a>.</a> <tt>const</tt>
--   </pre>
ifoldr' :: FoldableWithIndex i f => (i -> a -> b -> b) -> b -> f a -> b

-- | Fold over the elements of a structure with an index, associating to
--   the left, but <i>strictly</i>.
--   
--   When you don't need access to the index then <a>foldlOf'</a> is more
--   flexible in what it accepts.
--   
--   <pre>
--   <a>foldl'</a> l ≡ <a>ifoldl'</a> l <a>.</a> <tt>const</tt>
--   </pre>
ifoldl' :: FoldableWithIndex i f => (i -> b -> a -> b) -> b -> f a -> b

-- | Traverse elements with access to the index <tt>i</tt>, discarding the
--   results.
--   
--   When you don't need access to the index then <tt>traverse_</tt> is
--   more flexible in what it accepts.
--   
--   <pre>
--   <tt>traverse_</tt> l = <a>itraverse</a> <a>.</a> <tt>const</tt>
--   </pre>
itraverse_ :: (FoldableWithIndex i t, Applicative f) => (i -> a -> f b) -> t a -> f ()

-- | Traverse elements with access to the index <tt>i</tt>, discarding the
--   results (with the arguments flipped).
--   
--   <pre>
--   <a>ifor_</a> ≡ <a>flip</a> <a>itraverse_</a>
--   </pre>
--   
--   When you don't need access to the index then <tt>for_</tt> is more
--   flexible in what it accepts.
--   
--   <pre>
--   <tt>for_</tt> a ≡ <a>ifor_</a> a <a>.</a> <tt>const</tt>
--   </pre>
ifor_ :: (FoldableWithIndex i t, Applicative f) => t a -> (i -> a -> f b) -> f ()

-- | Extract the key-value pairs from a structure.
--   
--   When you don't need access to the indices in the result, then
--   <tt>toList</tt> is more flexible in what it accepts.
--   
--   <pre>
--   <tt>toList</tt> ≡ <a>map</a> <tt>snd</tt> <a>.</a> <a>itoList</a>
--   </pre>
itoList :: FoldableWithIndex i f => f a -> [(i, a)]

-- | A <a>Traversable</a> with an additional index.
--   
--   An instance must satisfy a (modified) form of the <a>Traversable</a>
--   laws:
--   
--   <pre>
--   <a>itraverse</a> (<tt>const</tt> <a>Identity</a>) ≡ <a>Identity</a>
--   <a>fmap</a> (<a>itraverse</a> f) <a>.</a> <a>itraverse</a> g ≡ <a>getCompose</a> <a>.</a> <a>itraverse</a> (\i -&gt; <a>Compose</a> <a>.</a> <a>fmap</a> (f i) <a>.</a> g i)
--   </pre>
class (FunctorWithIndex i t, FoldableWithIndex i t, Traversable t) => TraversableWithIndex i (t :: Type -> Type) | t -> i

-- | Traverse an indexed container.
--   
--   <pre>
--   <a>itraverse</a> ≡ <tt>itraverseOf</tt> <tt>itraversed</tt>
--   </pre>
itraverse :: (TraversableWithIndex i t, Applicative f) => (i -> a -> f b) -> t a -> f (t b)

-- | Traverse with an index (and the arguments flipped).
--   
--   <pre>
--   <tt>for</tt> a ≡ <a>ifor</a> a <tt>.</tt> <tt>const</tt>
--   <a>ifor</a> ≡ <a>flip</a> <a>itraverse</a>
--   </pre>
ifor :: (TraversableWithIndex i t, Applicative f) => t a -> (i -> a -> f b) -> f (t b)


-- | This module defines the <a>Each</a> class, which provides an
--   <a>IxTraversal</a> that extracts <a>each</a> element of a (potentially
--   monomorphic) container.
module Optics.Each

-- | Extract <a>each</a> element of a (potentially monomorphic) container.
--   
--   <pre>
--   &gt;&gt;&gt; over each (*10) (1,2,3)
--   (10,20,30)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; iover each (\i a -&gt; a*10 + succ i) (1,2,3)
--   (11,22,33)
--   </pre>
class () => Each i s t a b | s -> i a, t -> i b, s b -> t, t a -> s
each :: Each i s t a b => IxTraversal i s t a b
instance (k GHC.Types.~ k') => Optics.Each.Core.Each k (Data.HashMap.Internal.HashMap k a) (Data.HashMap.Internal.HashMap k' b) a b
instance Optics.Each.Core.Each GHC.Types.Int (Data.Vector.Vector a) (Data.Vector.Vector b) a b
instance (Data.Primitive.Types.Prim a, Data.Primitive.Types.Prim b) => Optics.Each.Core.Each GHC.Types.Int (Data.Vector.Primitive.Vector a) (Data.Vector.Primitive.Vector b) a b
instance (Foreign.Storable.Storable a, Foreign.Storable.Storable b) => Optics.Each.Core.Each GHC.Types.Int (Data.Vector.Storable.Vector a) (Data.Vector.Storable.Vector b) a b
instance (Data.Vector.Unboxed.Base.Unbox a, Data.Vector.Unboxed.Base.Unbox b) => Optics.Each.Core.Each GHC.Types.Int (Data.Vector.Unboxed.Base.Vector a) (Data.Vector.Unboxed.Base.Vector b) a b
instance (a GHC.Types.~ GHC.Types.Char, b GHC.Types.~ GHC.Types.Char) => Optics.Each.Core.Each GHC.Types.Int Data.Text.Internal.Text Data.Text.Internal.Text a b
instance (a GHC.Types.~ GHC.Types.Char, b GHC.Types.~ GHC.Types.Char) => Optics.Each.Core.Each GHC.Types.Int Data.Text.Internal.Lazy.Text Data.Text.Internal.Lazy.Text a b
instance (a GHC.Types.~ GHC.Word.Word8, b GHC.Types.~ GHC.Word.Word8) => Optics.Each.Core.Each GHC.Int.Int64 Data.ByteString.Internal.Type.ByteString Data.ByteString.Internal.Type.ByteString a b
instance (a GHC.Types.~ GHC.Word.Word8, b GHC.Types.~ GHC.Word.Word8) => Optics.Each.Core.Each GHC.Int.Int64 Data.ByteString.Lazy.Internal.ByteString Data.ByteString.Lazy.Internal.ByteString a b


-- | This module contains utilities for working with <a>Setter</a>s in a
--   <a>MonadState</a> context. If you prefer operator versions, you may
--   wish to import <a>Optics.State.Operators</a>.
module Optics.State

-- | Map over the target(s) of an <a>Optic</a> in our monadic state.
--   
--   <pre>
--   &gt;&gt;&gt; execState (do modifying _1 (*10); modifying _2 $ stimes 5) (6,"o")
--   (60,"ooooo")
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; execState (modifying each $ stimes 2) ("a","b")
--   ("aa","bb")
--   </pre>
modifying :: (Is k A_Setter, MonadState s m) => Optic k is s s a b -> (a -> b) -> m ()

-- | Version of <a>modifying</a> that is strict in both optic application
--   and state modification.
--   
--   <pre>
--   &gt;&gt;&gt; flip evalState ('a','b') $ modifying _1 (errorWithoutStackTrace "oops")
--   ()
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; flip evalState ('a','b') $ modifying' _1 (errorWithoutStackTrace "oops")
--   *** Exception: oops
--   </pre>
modifying' :: (Is k A_Setter, MonadState s m) => Optic k is s s a b -> (a -> b) -> m ()

-- | Replace the target(s) of an <a>Optic</a> in our monadic state with a
--   new value, irrespective of the old.
--   
--   <pre>
--   &gt;&gt;&gt; execState (do assign _1 'c'; assign _2 'd') ('a','b')
--   ('c','d')
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; execState (assign each 'c') ('a','b')
--   ('c','c')
--   </pre>
assign :: (Is k A_Setter, MonadState s m) => Optic k is s s a b -> b -> m ()

-- | Version of <a>assign</a> that is strict in both optic application and
--   state modification.
--   
--   <pre>
--   &gt;&gt;&gt; flip evalState ('a','b') $ assign _1 (errorWithoutStackTrace "oops")
--   ()
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; flip evalState ('a','b') $ assign' _1 (errorWithoutStackTrace "oops")
--   *** Exception: oops
--   </pre>
assign' :: (Is k A_Setter, MonadState s m) => Optic k is s s a b -> b -> m ()

-- | Use the target of a <a>Lens</a>, <a>Iso</a>, or <a>Getter</a> in the
--   current state.
--   
--   <pre>
--   &gt;&gt;&gt; evalState (use _1) ('a','b')
--   'a'
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; evalState (use _2) ("hello","world")
--   "world"
--   </pre>
use :: (Is k A_Getter, MonadState s m) => Optic' k is s a -> m a

-- | Use the target of a <tt>AffineTraveral</tt> or <a>AffineFold</a> in
--   the current state.
--   
--   <pre>
--   &gt;&gt;&gt; evalState (preuse $ _1 % _Right) (Right 'a','b')
--   Just 'a'
--   </pre>
preuse :: (Is k An_AffineFold, MonadState s m) => Optic' k is s a -> m (Maybe a)


-- | EXPERIMENTAL
module Optics.View

-- | Generalized view (even more powerful than <tt>view</tt> from the lens
--   library).
--   
--   View the value(s) pointed to by an optic.
--   
--   The type of the result depends on the optic. You get:
--   
--   <ul>
--   <li>Exactly one result <tt>a</tt> with <a>Iso</a>, <a>Lens</a>,
--   <a>ReversedPrism</a> and <a>Getter</a>.</li>
--   <li>At most one result <tt>Maybe a</tt> with <a>Prism</a>,
--   <a>AffineTraversal</a> and <a>AffineFold</a>.</li>
--   <li>Monoidal summary of all results <tt>Monoid a =&gt; a</tt> with
--   <a>Traversal</a> and <a>Fold</a>.</li>
--   </ul>
--   
--   When in doubt, use specific, flavour restricted versions. This
--   function is mostly useful for things such as <a>passthrough</a>.
class ViewableOptic k r where {
    type ViewResult k r :: Type;
}
gview :: (ViewableOptic k r, MonadReader s m) => Optic' k is s r -> m (ViewResult k r)
gviews :: (ViewableOptic k r, MonadReader s m) => Optic' k is s a -> (a -> r) -> m (ViewResult k r)

-- | Use the target of a <a>Lens</a>, <a>Iso</a>, or <a>Getter</a> in the
--   current state, or use a summary of a <a>Fold</a> or <a>Traversal</a>
--   that points to a monoidal value.
--   
--   <pre>
--   &gt;&gt;&gt; evalState (guse _1) ('a','b')
--   'a'
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; evalState (guse _2) ("hello","world")
--   "world"
--   </pre>
guse :: (ViewableOptic k a, MonadState s m) => Optic' k is s a -> m (ViewResult k a)

-- | Use the target of a <a>Lens</a>, <a>Iso</a> or <a>Getter</a> in the
--   current state, or use a summary of a <a>Fold</a> or <a>Traversal</a>
--   that points to a monoidal value.
--   
--   <pre>
--   &gt;&gt;&gt; evalState (guses _1 length) ("hello","world")
--   5
--   </pre>
guses :: (ViewableOptic k r, MonadState s m) => Optic' k is s a -> (a -> r) -> m (ViewResult k r)

-- | This is a generalized form of <a>listen</a> that only extracts the
--   portion of the log that is focused on by a <a>Getter</a>. If given a
--   <a>Fold</a> or a <a>Traversal</a> then a monoidal summary of the parts
--   of the log that are visited will be returned.
glistening :: (ViewableOptic k r, MonadWriter s m) => Optic' k is s r -> m a -> m (a, ViewResult k r)

-- | This is a generalized form of <a>listen</a> that only extracts the
--   portion of the log that is focused on by a <a>Getter</a>. If given a
--   <a>Fold</a> or a <a>Traversal</a> then a monoidal summary of the parts
--   of the log that are visited will be returned.
glistenings :: (ViewableOptic k r, MonadWriter s m) => Optic' k is s a -> (a -> r) -> m b -> m (b, ViewResult k r)
instance Optics.View.ViewableOptic Optics.Internal.Optic.Types.An_Iso r
instance Optics.View.ViewableOptic Optics.Internal.Optic.Types.A_Lens r
instance Optics.View.ViewableOptic Optics.Internal.Optic.Types.A_ReversedPrism r
instance Optics.View.ViewableOptic Optics.Internal.Optic.Types.A_Getter r
instance Optics.View.ViewableOptic Optics.Internal.Optic.Types.A_Prism r
instance Optics.View.ViewableOptic Optics.Internal.Optic.Types.An_AffineTraversal r
instance Optics.View.ViewableOptic Optics.Internal.Optic.Types.An_AffineFold r
instance GHC.Base.Monoid r => Optics.View.ViewableOptic Optics.Internal.Optic.Types.A_Traversal r
instance GHC.Base.Monoid r => Optics.View.ViewableOptic Optics.Internal.Optic.Types.A_Fold r

module Optics.Passthrough
class (Is k A_Traversal, ViewableOptic k r) => PermeableOptic k r

-- | Modify the target of an <a>Optic</a> returning extra information of
--   type <tt>r</tt>.
passthrough :: PermeableOptic k r => Optic k is s t a b -> (a -> (r, b)) -> s -> (ViewResult k r, t)
instance Optics.Passthrough.PermeableOptic Optics.Internal.Optic.Types.An_Iso r
instance Optics.Passthrough.PermeableOptic Optics.Internal.Optic.Types.A_Lens r
instance Optics.Passthrough.PermeableOptic Optics.Internal.Optic.Types.A_Prism r
instance Optics.Passthrough.PermeableOptic Optics.Internal.Optic.Types.An_AffineTraversal r
instance GHC.Base.Monoid r => Optics.Passthrough.PermeableOptic Optics.Internal.Optic.Types.A_Traversal r


-- | Defines infix operators for the operations in <a>Optics.State</a>.
--   These operators are not exposed by the main <tt>Optics</tt> module,
--   but must be imported explicitly.
module Optics.State.Operators

-- | Replace the target(s) of an <a>Optic</a> in our monadic state with a
--   new value, irrespective of the old.
--   
--   This is an infix version of <a>assign</a>.
(.=) :: (Is k A_Setter, MonadState s m) => Optic k is s s a b -> b -> m ()
infix 4 .=

-- | Replace the target(s) of an <a>Optic</a> in our monadic state with
--   <a>Just</a> a new value, irrespective of the old.
(?=) :: (Is k A_Setter, MonadState s m) => Optic k is s s (Maybe a) (Maybe b) -> b -> m ()
infix 4 ?=

-- | Map over the target(s) of an <a>Optic</a> in our monadic state.
--   
--   This is an infix version of <a>modifying</a>.
(%=) :: (Is k A_Setter, MonadState s m) => Optic k is s s a b -> (a -> b) -> m ()
infix 4 %=

-- | Modify the target of an <a>PermeableOptic</a> in the current state
--   returning some extra information of type depending on the optic
--   (<tt>r</tt>, <tt>Maybe r</tt> or monoidal summary).
(%%=) :: (PermeableOptic k r, MonadState s m) => Optic k is s s a b -> (a -> (r, b)) -> m (ViewResult k r)
infix 4 %%=

-- | Set with pass-through.
--   
--   This is useful for chaining assignment without round-tripping through
--   your <a>Monad</a> stack.
(<.=) :: (PermeableOptic k b, MonadState s m) => Optic k is s s a b -> b -> m (ViewResult k b)
infix 4 <.=

-- | Set <a>Just</a> a value with pass-through.
--   
--   This is useful for chaining assignment without round-tripping through
--   your <a>Monad</a> stack.
(<?=) :: (PermeableOptic k (Maybe b), MonadState s m) => Optic k is s s (Maybe a) (Maybe b) -> b -> m (ViewResult k (Maybe b))
infix 4 <?=

-- | Modify the target of a <a>PermeableOptic</a> into your
--   <tt>Monad'</tt>s state by a user supplied function and return the
--   result.
(<%=) :: (PermeableOptic k b, MonadState s m) => Optic k is s s a b -> (a -> b) -> m (ViewResult k b)
infix 4 <%=

-- | Replace the target of a <a>PermeableOptic</a> into your
--   <tt>Monad'</tt>s state with a user supplied value and return the
--   <i>old</i> value that was replaced.
(<<.=) :: (PermeableOptic k a, MonadState s m) => Optic k is s s a b -> b -> m (ViewResult k a)
infix 4 <<.=

-- | Replace the target of a <a>PermeableOptic</a> into your
--   <tt>Monad'</tt>s state with <a>Just</a> a user supplied value and
--   return the <i>old</i> value that was replaced.
(<<?=) :: (PermeableOptic k (Maybe a), MonadState s m) => Optic k is s s (Maybe a) (Maybe b) -> b -> m (ViewResult k (Maybe a))
infix 4 <<?=

-- | Modify the target of a <a>PermeableOptic</a> into your
--   <tt>Monad'</tt>s state by a user supplied function and return the
--   <i>old</i> value that was replaced.
(<<%=) :: (PermeableOptic k a, MonadState s m) => Optic k is s s a b -> (a -> b) -> m (ViewResult k a)
infix 4 <<%=
class (Is k A_Traversal, ViewableOptic k r) => PermeableOptic k r

-- | Modify the target of an <a>Optic</a> returning extra information of
--   type <tt>r</tt>.
passthrough :: PermeableOptic k r => Optic k is s t a b -> (a -> (r, b)) -> s -> (ViewResult k r, t)

module Optics.Zoom

-- | This class allows us to <a>zoom</a> in, changing the <tt>State</tt>
--   supplied by many different monad transformers, potentially quite deep
--   in a monad transformer stack.
--   
--   Its functions can be used to run a monadic action in a larger
--   <tt>State</tt> than it was defined in, using a <a>Lens'</a>, an
--   <a>AffineTraversal'</a> or a <a>Traversal'</a>.
--   
--   This is commonly used to lift actions in a simpler <tt>State</tt>
--   <a>Monad</a> into a <tt>State</tt> <a>Monad</a> with a larger
--   <tt>State</tt> type.
--   
--   When used with a <a>Traversal'</a> over multiple values, the actions
--   for each target are executed sequentially and the results are
--   aggregated.
--   
--   This can be used to edit pretty much any <a>Monad</a> transformer
--   stack with a <tt>State</tt> in it!
--   
--   <pre>
--   &gt;&gt;&gt; flip L.evalState ('a','b') $ zoom _1 $ use equality
--   'a'
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; flip S.execState ('a','b') $ zoom _1 $ equality .= 'c'
--   ('c','b')
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; flip L.execState [(1,2),(3,4)] $ zoomMany traversed $ _2 %= (*10)
--   [(1,20),(3,40)]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; flip S.runState [('a',"b"),('c',"d")] $ zoomMany traversed $ _2 &lt;%= (\x -&gt; x &lt;&gt; x)
--   ("bbdd",[('a',"bb"),('c',"dd")])
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; flip S.evalState ("a","b") $ zoomMany each (use equality)
--   "ab"
--   </pre>
class (MonadState s m, MonadState t n) => Zoom m n s t | m -> s, n -> t, m t -> n, n s -> m
zoom :: (Zoom m n s t, Is k A_Lens) => Optic' k is t s -> m c -> n c
zoomMaybe :: (Zoom m n s t, Is k An_AffineTraversal) => Optic' k is t s -> m c -> n (Maybe c)
zoomMany :: (Zoom m n s t, Is k A_Traversal, Monoid c) => Optic' k is t s -> m c -> n c
infixr 2 `zoom`
infixr 2 `zoomMaybe`
infixr 2 `zoomMany`

-- | This class allows us to <a>magnify</a> part of the environment,
--   changing the environment supplied by many different <a>Monad</a>
--   transformers. Unlike <a>zoom</a> this can change the environment of a
--   deeply nested <a>Monad</a> transformer.
--   
--   Its functions can be used to run a monadic action in a larger
--   environment than it was defined in, using a <a>Getter</a> or an
--   <a>AffineFold</a>.
--   
--   They act like <a>local</a>, but can in many cases change the type of
--   the environment as well.
--   
--   They're commonly used to lift actions in a simpler <tt>Reader</tt>
--   <a>Monad</a> into a <a>Monad</a> with a larger environment type.
--   
--   They can be used to edit pretty much any <a>Monad</a> transformer
--   stack with an environment in it:
--   
--   <pre>
--   &gt;&gt;&gt; (1,2) &amp; magnify _2 (+1)
--   3
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; flip runReader (1,2) $ magnify _1 ask
--   1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; flip runReader (1,2,[10..20]) $ magnifyMaybe (_3 % _tail) ask
--   Just [11,12,13,14,15,16,17,18,19,20]
--   </pre>
class (MonadReader b m, MonadReader a n) => Magnify m n b a | m -> b, n -> a, m a -> n, n b -> m
magnify :: (Magnify m n b a, Is k A_Getter) => Optic' k is a b -> m c -> n c
magnifyMaybe :: (Magnify m n b a, Is k An_AffineFold) => Optic' k is a b -> m c -> n (Maybe c)
infixr 2 `magnify`
infixr 2 `magnifyMaybe`

-- | Extends <a>Magnify</a> with an ability to magnify using a <a>Fold</a>
--   over multiple targets so that actions for each one are executed
--   sequentially and the results are aggregated.
--   
--   There is however no sensible instance of <a>MagnifyMany</a> for
--   <tt>StateT</tt>.
class (MonadReader b m, MonadReader a n, Magnify m n b a) => MagnifyMany m n b a | m -> b, n -> a, m a -> n, n b -> m
magnifyMany :: (MagnifyMany m n b a, Is k A_Fold, Monoid c) => Optic' k is a b -> m c -> n c
infixr 2 `magnifyMany`
instance Optics.Zoom.MagnifyMany ((->) b) ((->) a) b a
instance GHC.Base.Monad m => Optics.Zoom.MagnifyMany (Control.Monad.Trans.Reader.ReaderT b m) (Control.Monad.Trans.Reader.ReaderT a m) b a
instance (GHC.Base.Monad m, GHC.Base.Monoid w) => Optics.Zoom.MagnifyMany (Control.Monad.Trans.RWS.Strict.RWST b w s m) (Control.Monad.Trans.RWS.Strict.RWST a w s m) b a
instance (GHC.Base.Monad m, GHC.Base.Monoid w) => Optics.Zoom.MagnifyMany (Control.Monad.Trans.RWS.Lazy.RWST b w s m) (Control.Monad.Trans.RWS.Lazy.RWST a w s m) b a
instance Optics.Zoom.MagnifyMany m n b a => Optics.Zoom.MagnifyMany (Control.Monad.Trans.Identity.IdentityT m) (Control.Monad.Trans.Identity.IdentityT n) b a
instance (GHC.Base.Monoid w, Optics.Zoom.MagnifyMany m n b a) => Optics.Zoom.MagnifyMany (Control.Monad.Trans.Writer.Strict.WriterT w m) (Control.Monad.Trans.Writer.Strict.WriterT w n) b a
instance (GHC.Base.Monoid w, Optics.Zoom.MagnifyMany m n b a) => Optics.Zoom.MagnifyMany (Control.Monad.Trans.Writer.Lazy.WriterT w m) (Control.Monad.Trans.Writer.Lazy.WriterT w n) b a
instance Optics.Zoom.MagnifyMany m n b a => Optics.Zoom.MagnifyMany (Control.Monad.Trans.Maybe.MaybeT m) (Control.Monad.Trans.Maybe.MaybeT n) b a
instance Optics.Zoom.MagnifyMany m n b a => Optics.Zoom.MagnifyMany (Control.Monad.Trans.Except.ExceptT e m) (Control.Monad.Trans.Except.ExceptT e n) b a
instance Optics.Zoom.Magnify ((->) b) ((->) a) b a
instance GHC.Base.Monad m => Optics.Zoom.Magnify (Control.Monad.Trans.Reader.ReaderT b m) (Control.Monad.Trans.Reader.ReaderT a m) b a
instance (GHC.Base.Monad m, GHC.Base.Monoid w) => Optics.Zoom.Magnify (Control.Monad.Trans.RWS.Strict.RWST b w s m) (Control.Monad.Trans.RWS.Strict.RWST a w s m) b a
instance (GHC.Base.Monad m, GHC.Base.Monoid w) => Optics.Zoom.Magnify (Control.Monad.Trans.RWS.Lazy.RWST b w s m) (Control.Monad.Trans.RWS.Lazy.RWST a w s m) b a
instance Optics.Zoom.Magnify m n b a => Optics.Zoom.Magnify (Control.Monad.Trans.Identity.IdentityT m) (Control.Monad.Trans.Identity.IdentityT n) b a
instance Optics.Zoom.Magnify m n b a => Optics.Zoom.Magnify (Control.Monad.Trans.State.Strict.StateT s m) (Control.Monad.Trans.State.Strict.StateT s n) b a
instance Optics.Zoom.Magnify m n b a => Optics.Zoom.Magnify (Control.Monad.Trans.State.Lazy.StateT s m) (Control.Monad.Trans.State.Lazy.StateT s n) b a
instance (GHC.Base.Monoid w, Optics.Zoom.Magnify m n b a) => Optics.Zoom.Magnify (Control.Monad.Trans.Writer.Strict.WriterT w m) (Control.Monad.Trans.Writer.Strict.WriterT w n) b a
instance (GHC.Base.Monoid w, Optics.Zoom.Magnify m n b a) => Optics.Zoom.Magnify (Control.Monad.Trans.Writer.Lazy.WriterT w m) (Control.Monad.Trans.Writer.Lazy.WriterT w n) b a
instance Optics.Zoom.Magnify m n b a => Optics.Zoom.Magnify (Control.Monad.Trans.Maybe.MaybeT m) (Control.Monad.Trans.Maybe.MaybeT n) b a
instance Optics.Zoom.Magnify m n b a => Optics.Zoom.Magnify (Control.Monad.Trans.Except.ExceptT e m) (Control.Monad.Trans.Except.ExceptT e n) b a
instance GHC.Base.Monad m => Optics.Zoom.Zoom (Control.Monad.Trans.State.Strict.StateT s m) (Control.Monad.Trans.State.Strict.StateT t m) s t
instance GHC.Base.Monad m => Optics.Zoom.Zoom (Control.Monad.Trans.State.Lazy.StateT s m) (Control.Monad.Trans.State.Lazy.StateT t m) s t
instance Optics.Zoom.Zoom m n s t => Optics.Zoom.Zoom (Control.Monad.Trans.Reader.ReaderT e m) (Control.Monad.Trans.Reader.ReaderT e n) s t
instance Optics.Zoom.Zoom m n s t => Optics.Zoom.Zoom (Control.Monad.Trans.Identity.IdentityT m) (Control.Monad.Trans.Identity.IdentityT n) s t
instance (GHC.Base.Monoid w, GHC.Base.Monad m) => Optics.Zoom.Zoom (Control.Monad.Trans.RWS.Strict.RWST r w s m) (Control.Monad.Trans.RWS.Strict.RWST r w t m) s t
instance (GHC.Base.Monoid w, GHC.Base.Monad m) => Optics.Zoom.Zoom (Control.Monad.Trans.RWS.Lazy.RWST r w s m) (Control.Monad.Trans.RWS.Lazy.RWST r w t m) s t
instance (GHC.Base.Monoid w, Optics.Zoom.Zoom m n s t) => Optics.Zoom.Zoom (Control.Monad.Trans.Writer.Strict.WriterT w m) (Control.Monad.Trans.Writer.Strict.WriterT w n) s t
instance (GHC.Base.Monoid w, Optics.Zoom.Zoom m n s t) => Optics.Zoom.Zoom (Control.Monad.Trans.Writer.Lazy.WriterT w m) (Control.Monad.Trans.Writer.Lazy.WriterT w n) s t
instance Optics.Zoom.Zoom m n s t => Optics.Zoom.Zoom (Control.Monad.Trans.Maybe.MaybeT m) (Control.Monad.Trans.Maybe.MaybeT n) s t
instance Optics.Zoom.Zoom m n s t => Optics.Zoom.Zoom (Control.Monad.Trans.Except.ExceptT e m) (Control.Monad.Trans.Except.ExceptT e n) s t

module Optics.Extra
