-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


@package unison-runtime
@version 0.0.0

module Unison.Runtime.Array

-- | A boxed, unlifted datatype representing a region of raw memory in the
--   garbage-collected heap, which is not scanned for pointers during
--   garbage collection.
--   
--   It is created by freezing a <a>MutableByteArray#</a> with
--   <a>unsafeFreezeByteArray#</a>. Freezing is essentially a no-op, as
--   <a>MutableByteArray#</a> and <a>ByteArray#</a> share the same heap
--   structure under the hood.
--   
--   The immutable and mutable variants are commonly used for scenarios
--   requiring high-performance data structures, like <tt>Text</tt>,
--   <tt>Primitive Vector</tt>, <tt>Unboxed Array</tt>, and
--   <tt>ShortByteString</tt>.
--   
--   Another application of fundamental importance is <tt>Integer</tt>,
--   which is backed by <a>ByteArray#</a>.
--   
--   The representation on the heap of a Byte Array is:
--   
--   <pre>
--   +------------+-----------------+-----------------------+
--   |            |                 |                       |
--   |   HEADER   | SIZE (in bytes) |       PAYLOAD         |
--   |            |                 |                       |
--   +------------+-----------------+-----------------------+
--   </pre>
--   
--   To obtain a pointer to actual payload (e.g., for FFI purposes) use
--   <a>byteArrayContents#</a> or <a>mutableByteArrayContents#</a>.
--   
--   Alternatively, enabling the <tt>UnliftedFFITypes</tt> extension allows
--   to mention <a>ByteArray#</a> and <a>MutableByteArray#</a> in FFI type
--   signatures directly.
data ByteArray# :: UnliftedType

-- | A mutable <tt>ByteAray#</tt>. It can be created in three ways:
--   
--   <ul>
--   <li><a>newByteArray#</a>: Create an unpinned array.</li>
--   <li><a>newPinnedByteArray#</a>: This will create a pinned array,</li>
--   <li><a>newAlignedPinnedByteArray#</a>: This will create a pinned
--   array, with a custom alignment.</li>
--   </ul>
--   
--   Unpinned arrays can be moved around during garbage collection, so you
--   must not store or pass pointers to these values if there is a chance
--   for the garbage collector to kick in. That said, even unpinned arrays
--   can be passed to unsafe FFI calls, because no garbage collection
--   happens during these unsafe calls (see <a>Guaranteed Call Safety</a>
--   in the GHC Manual). For safe FFI calls, byte arrays must be not only
--   pinned, but also kept alive by means of the keepAlive# function for
--   the duration of a call (that's because garbage collection cannot move
--   a pinned array, but is free to scrap it altogether).
data MutableByteArray# a :: UnliftedType

-- | Boxed arrays.
data () => Array a
Array :: Array# a -> Array a
[array#] :: Array a -> Array# a

-- | Lifted wrapper for <a>MutableByteArray#</a>.
--   
--   Since <a>MutableByteArray#</a> is an unlifted type and not a member of
--   kind <a>Type</a>, things like <tt>[MutableByteArray#]</tt> or <tt>IO
--   MutableByteArray#</tt> are ill-typed. To work around this
--   inconvenience this module provides a standard lifted wrapper,
--   inhabiting <a>Type</a>. Clients are expected to use
--   <a>MutableByteArray</a> in higher-level APIs, but wrap and unwrap
--   <a>MutableByteArray</a> internally as they please and use functions
--   from <a>GHC.Exts</a>.
data () => MutableByteArray s
MutableByteArray :: MutableByteArray# s -> MutableByteArray s

-- | Lifted wrapper for <a>ByteArray#</a>.
--   
--   Since <a>ByteArray#</a> is an unlifted type and not a member of kind
--   <a>Type</a>, things like <tt>[ByteArray#]</tt> or <tt>IO
--   ByteArray#</tt> are ill-typed. To work around this inconvenience this
--   module provides a standard lifted wrapper, inhabiting <a>Type</a>.
--   Clients are expected to use <a>ByteArray</a> in higher-level APIs, but
--   wrap and unwrap <a>ByteArray</a> internally as they please and use
--   functions from <a>GHC.Exts</a>.
data () => ByteArray
ByteArray :: ByteArray# -> ByteArray

-- | Mutable boxed arrays associated with a primitive state token.
data () => MutableArray s a
MutableArray :: MutableArray# s a -> MutableArray s a
[marray#] :: MutableArray s a -> MutableArray# s a

-- | Mutable primitive arrays associated with a primitive state token.
--   These can be written to and read from in a monadic context that
--   supports sequencing, such as <a>IO</a> or <a>ST</a>. Typically, a
--   mutable primitive array will be built and then converted to an
--   immutable primitive array using <a>unsafeFreezePrimArray</a>. However,
--   it is also acceptable to simply discard a mutable primitive array
--   since it lives in managed memory and will be garbage collected when no
--   longer referenced.
data () => MutablePrimArray s a
MutablePrimArray :: MutableByteArray# s -> MutablePrimArray s a

-- | Arrays of unboxed elements. This accepts types like <a>Double</a>,
--   <a>Char</a>, <a>Int</a> and <a>Word</a>, as well as their fixed-length
--   variants (<tt>Word8</tt>, <tt>Word16</tt>, etc.). Since the elements
--   are unboxed, a <a>PrimArray</a> is strict in its elements. This
--   differs from the behavior of <a>Array</a>, which is lazy in its
--   elements.
data () => PrimArray a
PrimArray :: ByteArray# -> PrimArray a

-- | The <a>fromList</a> function constructs the structure <tt>l</tt> from
--   the given list of <tt>Item l</tt>
fromList :: IsList l => [Item l] -> l

-- | The <a>fromListN</a> function takes the input list's length and
--   potentially uses it to construct the structure <tt>l</tt> more
--   efficiently compared to <a>fromList</a>. If the given number does not
--   equal to the input list's length the behaviour of <a>fromListN</a> is
--   not specified.
--   
--   <pre>
--   fromListN (length xs) xs == fromList xs
--   </pre>
fromListN :: IsList l => Int -> [Item l] -> l

-- | The empty <a>Array</a>.
emptyArray :: Array a

-- | Create a new mutable array of the specified size and initialise all
--   elements with the given value.
--   
--   <i>Note:</i> this function does not check if the input is
--   non-negative.
newArray :: PrimMonad m => Int -> a -> m (MutableArray (PrimState m) a)

-- | Create a new mutable byte array of the specified size in bytes.
--   
--   <i>Note:</i> this function does not check if the input is
--   non-negative.
newByteArray :: PrimMonad m => Int -> m (MutableByteArray (PrimState m))

-- | Convert a mutable byte array to an immutable one without copying. The
--   array should not be modified after the conversion.
unsafeFreezeByteArray :: PrimMonad m => MutableByteArray (PrimState m) -> m ByteArray

-- | Size of the byte array in bytes.
sizeofByteArray :: ByteArray -> Int

-- | Create a <a>ByteArray</a> from a list of a known length. If the length
--   of the list does not match the given length, this throws an exception.
byteArrayFromListN :: Prim a => Int -> [a] -> ByteArray

-- | The empty <a>ByteArray</a>.
emptyByteArray :: ByteArray

-- | Copy a slice of a byte array to an unmanaged pointer address. These
--   must not overlap. The offset and length are given in elements, not in
--   bytes.
--   
--   <i>Note:</i> this function does not do bounds or overlap checking.
copyByteArrayToPtr :: (PrimMonad m, Prim a) => Ptr a -> ByteArray -> Int -> Int -> m ()

-- | Create a <i>pinned</i> byte array of the specified size in bytes. The
--   garbage collector is guaranteed not to move it.
--   
--   <i>Note:</i> this function does not check if the input is
--   non-negative.
newPinnedByteArray :: PrimMonad m => Int -> m (MutableByteArray (PrimState m))

-- | Fill a slice of a mutable byte array with a value. The offset and
--   length are given in elements of type <tt>a</tt> rather than in bytes.
--   
--   <i>Note:</i> this function does not do bounds checking.
setByteArray :: (Prim a, PrimMonad m) => MutableByteArray (PrimState m) -> Int -> Int -> a -> m ()

-- | The number of elements in an immutable array.
sizeofArray :: Array a -> Int

-- | The number of elements in a mutable array.
sizeofMutableArray :: MutableArray s a -> Int

-- | Read a value from the immutable array at the given index.
--   
--   <i>Note:</i> this function does not do bounds checking.
indexArray :: Array a -> Int -> a

-- | Read a value from the immutable array at the given index, returning
--   the result in an unboxed unary tuple. This is currently used to
--   implement folds.
--   
--   <i>Note:</i> this function does not do bounds checking.
indexArray## :: Array a -> Int -> (# a #)

-- | Monadically read a value from the immutable array at the given index.
--   This allows us to be strict in the array while remaining lazy in the
--   read element which is very useful for collective operations. Suppose
--   we want to copy an array. We could do something like this:
--   
--   <pre>
--   copy marr arr ... = do ...
--                          writeArray marr i (indexArray arr i) ...
--                          ...
--   </pre>
--   
--   But since the arrays are lazy, the calls to <a>indexArray</a> will not
--   be evaluated. Rather, <tt>marr</tt> will be filled with thunks each of
--   which would retain a reference to <tt>arr</tt>. This is definitely not
--   what we want!
--   
--   With <a>indexArrayM</a>, we can instead write
--   
--   <pre>
--   copy marr arr ... = do ...
--                          x &lt;- indexArrayM arr i
--                          writeArray marr i x
--                          ...
--   </pre>
--   
--   Now, indexing is executed immediately although the returned element is
--   still not evaluated.
--   
--   <i>Note:</i> this function does not do bounds checking.
indexArrayM :: Monad m => Array a -> Int -> m a

-- | Create an immutable copy of a slice of an array.
--   
--   This operation makes a copy of the specified section, so it is safe to
--   continue using the mutable array afterward.
--   
--   <i>Note:</i> The provided array should contain the full subrange
--   specified by the two Ints, but this is not checked.
freezeArray :: PrimMonad m => MutableArray (PrimState m) a -> Int -> Int -> m (Array a)

-- | Convert a mutable array to an immutable one without copying. The array
--   should not be modified after the conversion.
unsafeFreezeArray :: PrimMonad m => MutableArray (PrimState m) a -> m (Array a)

-- | Create a mutable array from a slice of an immutable array.
--   
--   This operation makes a copy of the specified slice, so it is safe to
--   use the immutable array afterward.
--   
--   <i>Note:</i> The provided array should contain the full subrange
--   specified by the two Ints, but this is not checked.
thawArray :: PrimMonad m => Array a -> Int -> Int -> m (MutableArray (PrimState m) a)

-- | Convert an immutable array to an mutable one without copying. The
--   immutable array should not be used after the conversion.
unsafeThawArray :: PrimMonad m => Array a -> m (MutableArray (PrimState m) a)

-- | Check whether the two arrays refer to the same memory block.
sameMutableArray :: MutableArray s a -> MutableArray s a -> Bool

-- | Return a newly allocated <a>Array</a> with the specified subrange of
--   the provided <a>Array</a>.
--   
--   <i>Note:</i> The provided array should contain the full subrange
--   specified by the two Ints, but this is not checked.
cloneArray :: Array a -> Int -> Int -> Array a

-- | Execute the monadic action and freeze the resulting array.
--   
--   <pre>
--   runArray m = runST $ m &gt;&gt;= unsafeFreezeArray
--   </pre>
runArray :: (forall s. () => ST s (MutableArray s a)) -> Array a

-- | Create an array of the given size with a default value, apply the
--   monadic function and freeze the result. If the size is 0, return
--   <a>emptyArray</a> (rather than a new copy thereof).
--   
--   <pre>
--   createArray 0 _ _ = emptyArray
--   createArray n x f = runArray $ do
--     mary &lt;- newArray n x
--     f mary
--     pure mary
--   </pre>
createArray :: Int -> a -> (forall s. () => MutableArray s a -> ST s ()) -> Array a

-- | This is the fastest, most straightforward way to traverse an array,
--   but it only works correctly with a sufficiently "affine"
--   <a>PrimMonad</a> instance. In particular, it must only produce
--   <i>one</i> result array. <a>ListT</a>-transformed monads, for example,
--   will not work right at all.
traverseArrayP :: PrimMonad m => (a -> m b) -> Array a -> m (Array b)

-- | Strict map over the elements of the array.
mapArray' :: (a -> b) -> Array a -> Array b

-- | Create an array from a list of a known length. If the length of the
--   list does not match the given length, this throws an exception.
arrayFromListN :: Int -> [a] -> Array a

-- | Create an array from a list.
arrayFromList :: [a] -> Array a

-- | Create a <i>pinned</i> byte array of the specified size in bytes and
--   with the given alignment. The garbage collector is guaranteed not to
--   move it.
--   
--   <i>Note:</i> this function does not check if the input is
--   non-negative.
newAlignedPinnedByteArray :: PrimMonad m => Int -> Int -> m (MutableByteArray (PrimState m))

-- | Yield a pointer to the array's data. This operation is only safe on
--   <i>pinned</i> byte arrays allocated by <a>newPinnedByteArray</a> or
--   <a>newAlignedPinnedByteArray</a>.
byteArrayContents :: ByteArray -> Ptr Word8

-- | Yield a pointer to the array's data. This operation is only safe on
--   <i>pinned</i> byte arrays allocated by <a>newPinnedByteArray</a> or
--   <a>newAlignedPinnedByteArray</a>.
mutableByteArrayContents :: MutableByteArray s -> Ptr Word8

-- | Check if the two arrays refer to the same memory block.
sameMutableByteArray :: MutableByteArray s -> MutableByteArray s -> Bool

-- | Resize a mutable byte array. The new size is given in bytes.
--   
--   This will either resize the array in-place or, if not possible,
--   allocate the contents into a new, unpinned array and copy the original
--   array's contents.
--   
--   To avoid undefined behaviour, the original <a>MutableByteArray</a>
--   shall not be accessed anymore after a <a>resizeMutableByteArray</a>
--   has been performed. Moreover, no reference to the old one should be
--   kept in order to allow garbage collection of the original
--   <a>MutableByteArray</a> in case a new <a>MutableByteArray</a> had to
--   be allocated.
resizeMutableByteArray :: PrimMonad m => MutableByteArray (PrimState m) -> Int -> m (MutableByteArray (PrimState m))

-- | Get the size of a byte array in bytes. Unlike
--   <a>sizeofMutableByteArray</a>, this function ensures sequencing in the
--   presence of resizing.
getSizeofMutableByteArray :: PrimMonad m => MutableByteArray (PrimState m) -> m Int

-- | Create an immutable copy of a slice of a byte array. The offset and
--   length are given in bytes.
--   
--   This operation makes a copy of the specified section, so it is safe to
--   continue using the mutable array afterward.
--   
--   <i>Note:</i> The provided array should contain the full subrange
--   specified by the two Ints, but this is not checked.
freezeByteArray :: PrimMonad m => MutableByteArray (PrimState m) -> Int -> Int -> m ByteArray

-- | Create a mutable byte array from a slice of an immutable byte array.
--   The offset and length are given in bytes.
--   
--   This operation makes a copy of the specified slice, so it is safe to
--   use the immutable array afterward.
--   
--   <i>Note:</i> The provided array should contain the full subrange
--   specified by the two Ints, but this is not checked.
thawByteArray :: PrimMonad m => ByteArray -> Int -> Int -> m (MutableByteArray (PrimState m))

-- | Convert an immutable byte array to a mutable one without copying. The
--   original array should not be used after the conversion.
unsafeThawByteArray :: PrimMonad m => ByteArray -> m (MutableByteArray (PrimState m))

-- | Size of the mutable byte array in bytes. This function's behavior is
--   undefined if <a>resizeMutableByteArray</a> is ever called on the
--   mutable byte array given as the argument. Consequently, use of this
--   function is discouraged. Prefer <a>getSizeofMutableByteArray</a>,
--   which ensures correct sequencing in the presence of resizing.
sizeofMutableByteArray :: MutableByteArray s -> Int

-- | Shrink a mutable byte array. The new size is given in bytes. It must
--   be smaller than the old size. The array will be resized in place.
shrinkMutableByteArray :: PrimMonad m => MutableByteArray (PrimState m) -> Int -> m ()

-- | Check whether or not the byte array is pinned. Pinned byte arrays
--   cannot be moved by the garbage collector. It is safe to use
--   <a>byteArrayContents</a> on such byte arrays.
--   
--   Caution: This function is only available when compiling with GHC 8.2
--   or newer.
isByteArrayPinned :: ByteArray -> Bool

-- | Check whether or not the mutable byte array is pinned.
--   
--   Caution: This function is only available when compiling with GHC 8.2
--   or newer.
isMutableByteArrayPinned :: MutableByteArray s -> Bool

-- | Right-fold over the elements of a <a>ByteArray</a>.
foldrByteArray :: Prim a => (a -> b -> b) -> b -> ByteArray -> b

-- | Create a <a>ByteArray</a> from a list.
--   
--   <pre>
--   byteArrayFromList xs = <a>byteArrayFromListN</a> (length xs) xs
--   </pre>
byteArrayFromList :: Prim a => [a] -> ByteArray

-- | Copy from an unmanaged pointer address to a byte array. These must not
--   overlap. The offset and length are given in elements, not in bytes.
--   
--   <i>Note:</i> this function does not do bounds or overlap checking.
copyPtrToMutableByteArray :: (PrimMonad m, Prim a) => MutableByteArray (PrimState m) -> Int -> Ptr a -> Int -> m ()

-- | Copy a slice of a mutable byte array to an unmanaged pointer address.
--   These must not overlap. The offset and length are given in elements,
--   not in bytes.
--   
--   <i>Note:</i> this function does not do bounds or overlap checking.
copyMutableByteArrayToPtr :: (PrimMonad m, Prim a) => Ptr a -> MutableByteArray (PrimState m) -> Int -> Int -> m ()

-- | Copy a slice of a byte array to an unmanaged address. These must not
--   overlap.
--   
--   Note: This function is just <a>copyByteArrayToPtr</a> where <tt>a</tt>
--   is <a>Word8</a>.
copyByteArrayToAddr :: PrimMonad m => Ptr Word8 -> ByteArray -> Int -> Int -> m ()

-- | Copy a slice of a mutable byte array to an unmanaged address. These
--   must not overlap.
--   
--   Note: This function is just <a>copyMutableByteArrayToPtr</a> where
--   <tt>a</tt> is <a>Word8</a>.
copyMutableByteArrayToAddr :: PrimMonad m => Ptr Word8 -> MutableByteArray (PrimState m) -> Int -> Int -> m ()

-- | Fill a slice of a mutable byte array with a byte.
--   
--   <i>Note:</i> this function does not do bounds checking.
fillByteArray :: PrimMonad m => MutableByteArray (PrimState m) -> Int -> Int -> Word8 -> m ()

-- | Lexicographic comparison of equal-length slices into two byte arrays.
--   This wraps the <tt>compareByteArrays#</tt> primop, which wraps
--   <tt>memcmp</tt>.
compareByteArrays :: ByteArray -> Int -> ByteArray -> Int -> Int -> Ordering

-- | Return a newly allocated array with the specified subrange of the
--   provided array. The provided array should contain the full subrange
--   specified by the two Ints, but this is not checked.
cloneByteArray :: ByteArray -> Int -> Int -> ByteArray

-- | Return a newly allocated mutable array with the specified subrange of
--   the provided mutable array. The provided mutable array should contain
--   the full subrange specified by the two Ints, but this is not checked.
cloneMutableByteArray :: PrimMonad m => MutableByteArray (PrimState m) -> Int -> Int -> m (MutableByteArray (PrimState m))

-- | Execute the monadic action and freeze the resulting array.
--   
--   <pre>
--   runByteArray m = runST $ m &gt;&gt;= unsafeFreezeByteArray
--   </pre>
runByteArray :: (forall s. () => ST s (MutableByteArray s)) -> ByteArray

-- | Read an 8-bit element from the byte array, interpreting it as a
--   Latin-1-encoded character. The offset is given in bytes.
--   
--   <i>Note:</i> this function does not do bounds checking.
readCharArray :: PrimMonad m => MutableByteArray (PrimState m) -> Int -> m Char

-- | Write a character to the byte array, encoding it with Latin-1 as a
--   single byte. Behavior is undefined for codepoints outside of the ASCII
--   and Latin-1 blocks. The offset is given in bytes.
--   
--   <i>Note:</i> this function does not do bounds checking.
writeCharArray :: PrimMonad m => MutableByteArray (PrimState m) -> Int -> Char -> m ()

-- | Read an 8-bit element from the byte array, interpreting it as a
--   Latin-1-encoded character. The offset is given in bytes.
--   
--   <i>Note:</i> this function does not do bounds checking.
indexCharArray :: ByteArray -> Int -> Char

-- | Create a <a>PrimArray</a> from a list.
--   
--   <pre>
--   primArrayFromList vs = <a>primArrayFromListN</a> (length vs) vs
--   </pre>
primArrayFromList :: Prim a => [a] -> PrimArray a

-- | Create a <a>PrimArray</a> from a list of a known length. If the length
--   of the list does not match the given length, this throws an exception.
primArrayFromListN :: Prim a => Int -> [a] -> PrimArray a

-- | Convert a <a>PrimArray</a> to a list.
primArrayToList :: Prim a => PrimArray a -> [a]

-- | The empty <a>PrimArray</a>.
emptyPrimArray :: PrimArray a

-- | Create a new mutable primitive array of the given length. The
--   underlying memory is left uninitialized.
--   
--   <i>Note:</i> this function does not check if the input is
--   non-negative.
newPrimArray :: (PrimMonad m, Prim a) => Int -> m (MutablePrimArray (PrimState m) a)

-- | Resize a mutable primitive array. The new size is given in elements.
--   
--   This will either resize the array in-place or, if not possible,
--   allocate the contents into a new, unpinned array and copy the original
--   array's contents.
--   
--   To avoid undefined behaviour, the original <a>MutablePrimArray</a>
--   shall not be accessed anymore after a <a>resizeMutablePrimArray</a>
--   has been performed. Moreover, no reference to the old one should be
--   kept in order to allow garbage collection of the original
--   <a>MutablePrimArray</a> in case a new <a>MutablePrimArray</a> had to
--   be allocated.
resizeMutablePrimArray :: (PrimMonad m, Prim a) => MutablePrimArray (PrimState m) a -> Int -> m (MutablePrimArray (PrimState m) a)

-- | Shrink a mutable primitive array. The new size is given in elements.
--   It must be smaller than the old size. The array will be resized in
--   place.
shrinkMutablePrimArray :: (PrimMonad m, Prim a) => MutablePrimArray (PrimState m) a -> Int -> m ()

-- | Copy part of a mutable array into another mutable array. In the case
--   that the destination and source arrays are the same, the regions may
--   overlap.
--   
--   <i>Note:</i> this function does not do bounds or overlap checking.
copyMutablePrimArray :: (PrimMonad m, Prim a) => MutablePrimArray (PrimState m) a -> Int -> MutablePrimArray (PrimState m) a -> Int -> Int -> m ()

-- | Copy part of an array into another mutable array.
--   
--   <i>Note:</i> this function does not do bounds or overlap checking.
copyPrimArray :: (PrimMonad m, Prim a) => MutablePrimArray (PrimState m) a -> Int -> PrimArray a -> Int -> Int -> m ()

-- | Copy a slice of an immutable primitive array to a pointer. The offset
--   and length are given in elements of type <tt>a</tt>. This function
--   assumes that the <a>Prim</a> instance of <tt>a</tt> agrees with the
--   <tt>Storable</tt> instance.
--   
--   <i>Note:</i> this function does not do bounds or overlap checking.
copyPrimArrayToPtr :: (PrimMonad m, Prim a) => Ptr a -> PrimArray a -> Int -> Int -> m ()

-- | Copy a slice of a mutable primitive array to a pointer. The offset and
--   length are given in elements of type <tt>a</tt>. This function assumes
--   that the <a>Prim</a> instance of <tt>a</tt> agrees with the
--   <tt>Storable</tt> instance.
--   
--   <i>Note:</i> this function does not do bounds or overlap checking.
copyMutablePrimArrayToPtr :: (PrimMonad m, Prim a) => Ptr a -> MutablePrimArray (PrimState m) a -> Int -> Int -> m ()

-- | Copy from a pointer to a mutable primitive array. The offset and
--   length are given in elements of type <tt>a</tt>. This function assumes
--   that the <a>Prim</a> instance of <tt>a</tt> agrees with the
--   <tt>Storable</tt> instance.
--   
--   <i>Note:</i> this function does not do bounds or overlap checking.
copyPtrToMutablePrimArray :: (PrimMonad m, Prim a) => MutablePrimArray (PrimState m) a -> Int -> Ptr a -> Int -> m ()

-- | Fill a slice of a mutable primitive array with a value.
--   
--   <i>Note:</i> this function does not do bounds checking.
setPrimArray :: (Prim a, PrimMonad m) => MutablePrimArray (PrimState m) a -> Int -> Int -> a -> m ()

-- | Get the size of a mutable primitive array in elements. Unlike
--   <a>sizeofMutablePrimArray</a>, this function ensures sequencing in the
--   presence of resizing.
getSizeofMutablePrimArray :: (PrimMonad m, Prim a) => MutablePrimArray (PrimState m) a -> m Int

-- | Size of the mutable primitive array in elements. This function shall
--   not be used on primitive arrays that are an argument to or a result of
--   <a>resizeMutablePrimArray</a> or <a>shrinkMutablePrimArray</a>.
sizeofMutablePrimArray :: forall s a. Prim a => MutablePrimArray s a -> Int

-- | Check if the two arrays refer to the same memory block.
sameMutablePrimArray :: MutablePrimArray s a -> MutablePrimArray s a -> Bool

-- | Create an immutable copy of a slice of a primitive array. The offset
--   and length are given in elements.
--   
--   This operation makes a copy of the specified section, so it is safe to
--   continue using the mutable array afterward.
--   
--   <i>Note:</i> The provided array should contain the full subrange
--   specified by the two Ints, but this is not checked.
freezePrimArray :: (PrimMonad m, Prim a) => MutablePrimArray (PrimState m) a -> Int -> Int -> m (PrimArray a)

-- | Create a mutable primitive array from a slice of an immutable
--   primitive array. The offset and length are given in elements.
--   
--   This operation makes a copy of the specified slice, so it is safe to
--   use the immutable array afterward.
--   
--   <i>Note:</i> The provided array should contain the full subrange
--   specified by the two Ints, but this is not checked.
thawPrimArray :: (PrimMonad m, Prim a) => PrimArray a -> Int -> Int -> m (MutablePrimArray (PrimState m) a)

-- | Convert a mutable primitive array to an immutable one without copying.
--   The array should not be modified after the conversion.
unsafeFreezePrimArray :: PrimMonad m => MutablePrimArray (PrimState m) a -> m (PrimArray a)

-- | Convert an immutable array to a mutable one without copying. The
--   original array should not be used after the conversion.
unsafeThawPrimArray :: PrimMonad m => PrimArray a -> m (MutablePrimArray (PrimState m) a)

-- | Get the size, in elements, of the primitive array.
sizeofPrimArray :: Prim a => PrimArray a -> Int

-- | Check whether or not the primitive array is pinned. Pinned primitive
--   arrays cannot be moved by the garbage collector. It is safe to use
--   <a>primArrayContents</a> on such arrays. This function is only
--   available when compiling with GHC 8.2 or newer.
isPrimArrayPinned :: PrimArray a -> Bool

-- | Check whether or not the mutable primitive array is pinned. This
--   function is only available when compiling with GHC 8.2 or newer.
isMutablePrimArrayPinned :: MutablePrimArray s a -> Bool

-- | Lazy right-associated fold over the elements of a <a>PrimArray</a>.
foldrPrimArray :: Prim a => (a -> b -> b) -> b -> PrimArray a -> b

-- | Strict right-associated fold over the elements of a <a>PrimArray</a>.
foldrPrimArray' :: Prim a => (a -> b -> b) -> b -> PrimArray a -> b

-- | Lazy left-associated fold over the elements of a <a>PrimArray</a>.
foldlPrimArray :: Prim a => (b -> a -> b) -> b -> PrimArray a -> b

-- | Strict left-associated fold over the elements of a <a>PrimArray</a>.
foldlPrimArray' :: Prim a => (b -> a -> b) -> b -> PrimArray a -> b

-- | Strict left-associated fold over the elements of a <a>PrimArray</a>.
foldlPrimArrayM' :: (Prim a, Monad m) => (b -> a -> m b) -> b -> PrimArray a -> m b

-- | Traverse a primitive array. The traversal forces the resulting values
--   and writes them to the new primitive array as it performs the monadic
--   effects. Consequently:
--   
--   <pre>
--   &gt;&gt;&gt; traversePrimArrayP (\x -&gt; print x $&gt; bool x undefined (x == 2)) (fromList [1, 2, 3 :: Int])
--   1
--   2
--   *** Exception: Prelude.undefined
--   </pre>
--   
--   In many situations, <a>traversePrimArrayP</a> can replace
--   <a>traversePrimArray</a>, changing the strictness characteristics of
--   the traversal but typically improving the performance. Consider the
--   following short-circuiting traversal:
--   
--   <pre>
--   incrPositiveA :: PrimArray Int -&gt; Maybe (PrimArray Int)
--   incrPositiveA xs = traversePrimArray (\x -&gt; bool Nothing (Just (x + 1)) (x &gt; 0)) xs
--   </pre>
--   
--   This can be rewritten using <a>traversePrimArrayP</a>. To do this, we
--   must change the traversal context to <tt>MaybeT (ST s)</tt>, which has
--   a <a>PrimMonad</a> instance:
--   
--   <pre>
--   incrPositiveB :: PrimArray Int -&gt; Maybe (PrimArray Int)
--   incrPositiveB xs = runST $ runMaybeT $ traversePrimArrayP
--     (\x -&gt; bool (MaybeT (return Nothing)) (MaybeT (return (Just (x + 1)))) (x &gt; 0))
--     xs
--   </pre>
--   
--   Benchmarks demonstrate that the second implementation runs 150 times
--   faster than the first. It also results in fewer allocations.
traversePrimArrayP :: (PrimMonad m, Prim a, Prim b) => (a -> m b) -> PrimArray a -> m (PrimArray b)

-- | Filter the primitive array, keeping the elements for which the monadic
--   predicate evaluates to true.
filterPrimArrayP :: (PrimMonad m, Prim a) => (a -> m Bool) -> PrimArray a -> m (PrimArray a)

-- | Map over the primitive array, keeping the elements for which the
--   monadic predicate provides a <a>Just</a>.
mapMaybePrimArrayP :: (PrimMonad m, Prim a, Prim b) => (a -> m (Maybe b)) -> PrimArray a -> m (PrimArray b)

-- | Generate a primitive array by evaluating the monadic generator
--   function at each index.
generatePrimArrayP :: (PrimMonad m, Prim a) => Int -> (Int -> m a) -> m (PrimArray a)

-- | Execute the monadic action the given number of times and store the
--   results in a primitive array.
replicatePrimArrayP :: (PrimMonad m, Prim a) => Int -> m a -> m (PrimArray a)

-- | Map over the elements of a primitive array.
mapPrimArray :: (Prim a, Prim b) => (a -> b) -> PrimArray a -> PrimArray b

-- | Indexed map over the elements of a primitive array.
imapPrimArray :: (Prim a, Prim b) => (Int -> a -> b) -> PrimArray a -> PrimArray b

-- | Filter elements of a primitive array according to a predicate.
filterPrimArray :: Prim a => (a -> Bool) -> PrimArray a -> PrimArray a

-- | Filter the primitive array, keeping the elements for which the monadic
--   predicate evaluates true.
filterPrimArrayA :: (Applicative f, Prim a) => (a -> f Bool) -> PrimArray a -> f (PrimArray a)

-- | Map over the primitive array, keeping the elements for which the
--   applicative predicate provides a <a>Just</a>.
mapMaybePrimArrayA :: (Applicative f, Prim a, Prim b) => (a -> f (Maybe b)) -> PrimArray a -> f (PrimArray b)

-- | Map over a primitive array, optionally discarding some elements. This
--   has the same behavior as <tt>Data.Maybe.mapMaybe</tt>.
mapMaybePrimArray :: (Prim a, Prim b) => (a -> Maybe b) -> PrimArray a -> PrimArray b

-- | Traverse a primitive array. The traversal performs all of the
--   applicative effects <i>before</i> forcing the resulting values and
--   writing them to the new primitive array. Consequently:
--   
--   <pre>
--   &gt;&gt;&gt; traversePrimArray (\x -&gt; print x $&gt; bool x undefined (x == 2)) (fromList [1, 2, 3 :: Int])
--   1
--   2
--   3
--   *** Exception: Prelude.undefined
--   </pre>
--   
--   The function <a>traversePrimArrayP</a> always outperforms this
--   function, but it requires a <a>PrimMonad</a> constraint, and it forces
--   the values as it performs the effects.
traversePrimArray :: (Applicative f, Prim a, Prim b) => (a -> f b) -> PrimArray a -> f (PrimArray b)

-- | Traverse a primitive array with the index of each element.
itraversePrimArray :: (Applicative f, Prim a, Prim b) => (Int -> a -> f b) -> PrimArray a -> f (PrimArray b)

-- | Traverse a primitive array with the indices. The traversal forces the
--   resulting values and writes them to the new primitive array as it
--   performs the monadic effects.
itraversePrimArrayP :: (Prim a, Prim b, PrimMonad m) => (Int -> a -> m b) -> PrimArray a -> m (PrimArray b)

-- | Generate a primitive array.
generatePrimArray :: Prim a => Int -> (Int -> a) -> PrimArray a

-- | Create a primitive array by copying the element the given number of
--   times.
replicatePrimArray :: Prim a => Int -> a -> PrimArray a

-- | Generate a primitive array by evaluating the applicative generator
--   function at each index.
generatePrimArrayA :: (Applicative f, Prim a) => Int -> (Int -> f a) -> f (PrimArray a)

-- | Execute the applicative action the given number of times and store the
--   results in a <a>PrimArray</a>.
replicatePrimArrayA :: (Applicative f, Prim a) => Int -> f a -> f (PrimArray a)

-- | Traverse the primitive array, discarding the results. There is no
--   <a>PrimMonad</a> variant of this function, since it would not provide
--   any performance benefit.
traversePrimArray_ :: (Applicative f, Prim a) => (a -> f b) -> PrimArray a -> f ()

-- | Traverse the primitive array with the indices, discarding the results.
--   There is no <a>PrimMonad</a> variant of this function, since it would
--   not provide any performance benefit.
itraversePrimArray_ :: (Applicative f, Prim a) => (Int -> a -> f b) -> PrimArray a -> f ()

-- | Create a <i>pinned</i> primitive array of the specified size (in
--   elements). The garbage collector is guaranteed not to move it.
newPinnedPrimArray :: (PrimMonad m, Prim a) => Int -> m (MutablePrimArray (PrimState m) a)

-- | Create a <i>pinned</i> primitive array of the specified size (in
--   elements) and with the alignment given by its <a>Prim</a> instance.
--   The garbage collector is guaranteed not to move it.
newAlignedPinnedPrimArray :: (PrimMonad m, Prim a) => Int -> m (MutablePrimArray (PrimState m) a)

-- | Yield a pointer to the array's data. This operation is only safe on
--   <i>pinned</i> prim arrays allocated by <tt>newPinnedByteArray</tt> or
--   <tt>newAlignedPinnedByteArray</tt>.
primArrayContents :: PrimArray a -> Ptr a

-- | Yield a pointer to the array's data. This operation is only safe on
--   <i>pinned</i> byte arrays allocated by <tt>newPinnedByteArray</tt> or
--   <tt>newAlignedPinnedByteArray</tt>.
mutablePrimArrayContents :: MutablePrimArray s a -> Ptr a

-- | Return a newly allocated array with the specified subrange of the
--   provided array. The provided array should contain the full subrange
--   specified by the two Ints, but this is not checked.
clonePrimArray :: Prim a => PrimArray a -> Int -> Int -> PrimArray a

-- | Return a newly allocated mutable array with the specified subrange of
--   the provided mutable array. The provided mutable array should contain
--   the full subrange specified by the two Ints, but this is not checked.
cloneMutablePrimArray :: (PrimMonad m, Prim a) => MutablePrimArray (PrimState m) a -> Int -> Int -> m (MutablePrimArray (PrimState m) a)

-- | Execute the monadic action and freeze the resulting array.
--   
--   <pre>
--   runPrimArray m = runST $ m &gt;&gt;= unsafeFreezePrimArray
--   </pre>
runPrimArray :: (forall s. () => ST s (MutablePrimArray s a)) -> PrimArray a
byteArrayToList :: ByteArray -> [Word8]
readArray :: CheckCtx => PrimMonad m => MutableArray (PrimState m) a -> Int -> m a
writeArray :: CheckCtx => PrimMonad m => MutableArray (PrimState m) a -> Int -> a -> m ()
copyArray :: CheckCtx => PrimMonad m => MutableArray (PrimState m) a -> Int -> Array a -> Int -> Int -> m ()
copyMutableArray :: CheckCtx => PrimMonad m => MutableArray (PrimState m) a -> Int -> MutableArray (PrimState m) a -> Int -> Int -> m ()
cloneMutableArray :: CheckCtx => PrimMonad m => MutableArray (PrimState m) a -> Int -> Int -> m (MutableArray (PrimState m) a)
readByteArray :: forall a m. CheckCtx => PrimMonad m => Prim a => MutableByteArray (PrimState m) -> Int -> m a
writeByteArray :: forall a m. CheckCtx => PrimMonad m => Prim a => MutableByteArray (PrimState m) -> Int -> a -> m ()
indexByteArray :: forall a. CheckCtx => Prim a => ByteArray -> Int -> a
copyByteArray :: CheckCtx => PrimMonad m => MutableByteArray (PrimState m) -> Int -> ByteArray -> Int -> Int -> m ()
copyMutableByteArray :: CheckCtx => PrimMonad m => MutableByteArray (PrimState m) -> Int -> MutableByteArray (PrimState m) -> Int -> Int -> m ()
moveByteArray :: CheckCtx => PrimMonad m => MutableByteArray (PrimState m) -> Int -> MutableByteArray (PrimState m) -> Int -> Int -> m ()
readPrimArray :: CheckCtx => PrimMonad m => Prim a => MutablePrimArray (PrimState m) a -> Int -> m a
writePrimArray :: CheckCtx => PrimMonad m => Prim a => MutablePrimArray (PrimState m) a -> Int -> a -> m ()
indexPrimArray :: CheckCtx => Prim a => PrimArray a -> Int -> a

module Unison.Runtime.ANF
minimizeCyclesOrCrash :: Var v => Term v a -> Term v a
pattern TVar :: Var v => v -> Term ANormalF v
pattern TLit :: Var v => Lit -> Term ANormalF v
pattern TBLit :: Var v => Lit -> Term ANormalF v
pattern TApp :: Var v => Func v -> [v] -> Term ANormalF v
pattern TApv :: Var v => v -> [v] -> Term ANormalF v
pattern TCom :: Var v => Reference -> [v] -> Term ANormalF v
pattern TCon :: Var v => Reference -> CTag -> [v] -> Term ANormalF v
pattern TKon :: Var v => v -> [v] -> Term ANormalF v
pattern TReq :: Var v => Reference -> CTag -> [v] -> Term ANormalF v
pattern TPrm :: Var v => POp -> [v] -> Term ANormalF v
pattern TFOp :: Var v => FOp -> [v] -> Term ANormalF v
pattern THnd :: Var v => [Reference] -> v -> Term ANormalF v -> Term ANormalF v
pattern TLet :: Var v => Direction Word16 -> v -> Mem -> Term ANormalF v -> Term ANormalF v -> Term ANormalF v
pattern TLetD :: Var v => v -> Mem -> Term ANormalF v -> Term ANormalF v -> Term ANormalF v
pattern TFrc :: Var v => v -> Term ANormalF v
pattern TLets :: Var v => Direction Word16 -> [v] -> [Mem] -> Term ANormalF v -> Term ANormalF v -> Term ANormalF v
pattern TName :: Var v => v -> Either Reference v -> [v] -> Term ANormalF v -> Term ANormalF v
pattern TBind :: Var v => Cte v -> ANormal v -> ANormal v
pattern TBinds :: Var v => [Cte v] -> ANormal v -> ANormal v
pattern TShift :: Var v => Reference -> v -> Term ANormalF v -> Term ANormalF v
pattern TMatch :: Var v => v -> Branched (Term ANormalF v) -> Term ANormalF v
data CompileExn
CE :: CallStack -> Pretty ColorText -> CompileExn
internalBug :: HasCallStack => String -> a
data Mem
UN :: Mem
BX :: Mem
data Lit
I :: Int64 -> Lit
N :: Word64 -> Lit
F :: Double -> Lit
T :: Text -> Lit
C :: Char -> Lit
LM :: Referent -> Lit
LY :: Reference -> Lit

-- | Whether the evaluation of a given definition is cacheable or not. i.e.
--   it's a top-level pure value.
data Cacheability
Cacheable :: Cacheability
Uncacheable :: Cacheability
data Direction a
Indirect :: a -> Direction a
Direct :: Direction a
data SuperNormal v
Lambda :: [Mem] -> ANormal v -> SuperNormal v
[$sel:conventions:Lambda] :: SuperNormal v -> [Mem]
[$sel:bound:Lambda] :: SuperNormal v -> ANormal v
data SuperGroup v
Rec :: [(v, SuperNormal v)] -> SuperNormal v -> SuperGroup v
[$sel:group:Rec] :: SuperGroup v -> [(v, SuperNormal v)]
[$sel:entry:Rec] :: SuperGroup v -> SuperNormal v
data POp
ADDI :: POp
SUBI :: POp
MULI :: POp
DIVI :: POp
SGNI :: POp
NEGI :: POp
MODI :: POp
POWI :: POp
SHLI :: POp
SHRI :: POp
INCI :: POp
DECI :: POp
LEQI :: POp
EQLI :: POp
ADDN :: POp
SUBN :: POp
MULN :: POp
DIVN :: POp
MODN :: POp
TZRO :: POp
LZRO :: POp
POPC :: POp
POWN :: POp
SHLN :: POp
SHRN :: POp
ANDN :: POp
IORN :: POp
XORN :: POp
COMN :: POp
INCN :: POp
DECN :: POp
LEQN :: POp
EQLN :: POp
ADDF :: POp
SUBF :: POp
MULF :: POp
DIVF :: POp
MINF :: POp
MAXF :: POp
LEQF :: POp
EQLF :: POp
POWF :: POp
EXPF :: POp
SQRT :: POp
LOGF :: POp
LOGB :: POp
ABSF :: POp
CEIL :: POp
FLOR :: POp
TRNF :: POp
RNDF :: POp
COSF :: POp
ACOS :: POp
COSH :: POp
ACSH :: POp
SINF :: POp
ASIN :: POp
SINH :: POp
ASNH :: POp
TANF :: POp
ATAN :: POp
TANH :: POp
ATNH :: POp
ATN2 :: POp
CATT :: POp
TAKT :: POp
DRPT :: POp
SIZT :: POp
IXOT :: POp
UCNS :: POp
USNC :: POp
EQLT :: POp
LEQT :: POp
PAKT :: POp
UPKT :: POp
CATS :: POp
TAKS :: POp
DRPS :: POp
SIZS :: POp
CONS :: POp
SNOC :: POp
IDXS :: POp
BLDS :: POp
VWLS :: POp
VWRS :: POp
SPLL :: POp
SPLR :: POp
PAKB :: POp
UPKB :: POp
TAKB :: POp
DRPB :: POp
IXOB :: POp
IDXB :: POp
SIZB :: POp
FLTB :: POp
CATB :: POp
ITOF :: POp
NTOF :: POp
ITOT :: POp
NTOT :: POp
TTOI :: POp
TTON :: POp
TTOF :: POp
FTOT :: POp
FORK :: POp
EQLU :: POp
CMPU :: POp
EROR :: POp
MISS :: POp
CACH :: POp
LKUP :: POp
LOAD :: POp
CVLD :: POp
SDBX :: POp
VALU :: POp
TLTT :: POp
PRNT :: POp
INFO :: POp
TRCE :: POp
DBTX :: POp
ATOM :: POp
TFRC :: POp
SDBL :: POp
SDBV :: POp
type FOp = Word64
close :: (Var v, Monoid a) => Set v -> Term v a -> Term v a
saturate :: (Var v, Monoid a) => Map ConstructorReference Int -> Term v a -> Term v a
float :: Var v => Monoid a => Map v Reference -> Term v a -> (Term v a, Map Reference Reference, [(Reference, Term v a)], [(Reference, Term v a)])
floatGroup :: Var v => Monoid a => Map v Reference -> [(v, Term v a)] -> ([(v, Id)], [(Reference, Term v a)], [(Reference, Term v a)])
lamLift :: Var v => Monoid a => Map v Reference -> Term v a -> (Term v a, Map Reference Reference, [(Reference, Term v a)], [(Reference, Term v a)])
lamLiftGroup :: Var v => Monoid a => Map v Reference -> [(v, Term v a)] -> ([(v, Id)], [(Reference, Term v a)], [(Reference, Term v a)])
litRef :: Lit -> Reference
inlineAlias :: Var v => Monoid a => Term v a -> Term v a
addDefaultCases :: Var v => Monoid a => Text -> Term v a -> Term v a
data ANormalF v e
ALet :: Direction Word16 -> [Mem] -> e -> e -> ANormalF v e
AName :: Either Reference v -> [v] -> e -> ANormalF v e
ALit :: Lit -> ANormalF v e
ABLit :: Lit -> ANormalF v e
AMatch :: v -> Branched e -> ANormalF v e
AShift :: Reference -> e -> ANormalF v e
AHnd :: [Reference] -> v -> e -> ANormalF v e
AApp :: Func v -> [v] -> ANormalF v e
AFrc :: v -> ANormalF v e
AVar :: v -> ANormalF v e
pattern AApv :: v -> [v] -> ANormalF v e
pattern ACom :: Reference -> [v] -> ANormalF v e
pattern ACon :: Reference -> CTag -> [v] -> ANormalF v e
pattern AKon :: v -> [v] -> ANormalF v e
pattern AReq :: Reference -> CTag -> [v] -> ANormalF v e
pattern APrm :: POp -> [v] -> ANormalF v e
pattern AFOp :: FOp -> [v] -> ANormalF v e
type ANormal = Term ANormalF
data RTag
data CTag
class Tag t
rawTag :: Tag t => t -> Word64
data GroupRef
GR :: Reference -> Word64 -> GroupRef
data Code
CodeRep :: SuperGroup Symbol -> Cacheability -> Code

-- | A value which is either unboxed or boxed.
type UBValue = Either Word64 Value

-- | A list of either unboxed or boxed values. Each slot is one of unboxed
--   or boxed but not both.
type ValList = [UBValue]
data Value
Partial :: GroupRef -> ValList -> Value
Data :: Reference -> Word64 -> ValList -> Value
Cont :: ValList -> Cont -> Value
BLit :: BLit -> Value
data Cont
KE :: Cont
Mark :: Word64 -> [Reference] -> Map Reference Value -> Cont -> Cont
Push :: Word64 -> Word64 -> GroupRef -> Cont -> Cont
data BLit
Text :: Text -> BLit
List :: Seq Value -> BLit
TmLink :: Referent -> BLit
TyLink :: Reference -> BLit
Bytes :: Bytes -> BLit
Quote :: Value -> BLit
Code :: Code -> BLit
BArr :: ByteArray -> BLit
Pos :: Word64 -> BLit
Neg :: Word64 -> BLit
Char :: Char -> BLit
Float :: Double -> BLit
Arr :: Array Value -> BLit
packTags :: RTag -> CTag -> Word64
unpackTags :: Word64 -> (RTag, CTag)
maskTags :: Word64 -> Word64
type ANFM v = ReaderT (Set v) (State (Word64, Word16, [(v, SuperNormal v)]))
data Branched e
MatchIntegral :: EnumMap Word64 e -> Maybe e -> Branched e
MatchText :: Map Text e -> Maybe e -> Branched e
MatchRequest :: Map Reference (EnumMap CTag ([Mem], e)) -> e -> Branched e
MatchEmpty :: Branched e
MatchData :: Reference -> EnumMap CTag ([Mem], e) -> Maybe e -> Branched e
MatchSum :: EnumMap Word64 ([Mem], e) -> Branched e
MatchNumeric :: Reference -> EnumMap Word64 e -> Maybe e -> Branched e
pattern MatchDataCover :: Reference -> EnumMap CTag ([Mem], e) -> Branched e
data Func v
FVar :: v -> Func v
FComb :: !Reference -> Func v
FCont :: v -> Func v
FCon :: !Reference -> !CTag -> Func v
FReq :: !Reference -> !CTag -> Func v
FPrim :: Either POp FOp -> Func v
data SGEqv v
NumDefns :: SuperGroup v -> SuperGroup v -> SGEqv v
DefnConventions :: SuperNormal v -> SuperNormal v -> SGEqv v
Subterms :: ANormal v -> ANormal v -> SGEqv v
equivocate :: Var v => SuperGroup v -> SuperGroup v -> Either (SGEqv v) ()
superNormalize :: Var v => Term v a -> SuperGroup v
anfTerm :: Var v => Term v a -> ANFM v (DNormal v)
codeGroup :: Code -> SuperGroup Symbol
valueTermLinks :: Value -> [Reference]
valueLinks :: Monoid a => (Bool -> Reference -> a) -> Value -> a
groupTermLinks :: Var v => SuperGroup v -> [Reference]
foldGroup :: Monoid m => (SuperGroup Symbol -> m) -> Code -> m
foldGroupLinks :: (Monoid r, Var v) => (Bool -> Reference -> r) -> SuperGroup v -> r
overGroup :: (SuperGroup Symbol -> SuperGroup Symbol) -> Code -> Code
overGroupLinks :: Var v => (Bool -> Reference -> Reference) -> SuperGroup v -> SuperGroup v
traverseGroup :: Applicative f => (SuperGroup Symbol -> f (SuperGroup Symbol)) -> Code -> f Code
traverseGroupLinks :: (Applicative f, Var v) => (Bool -> Reference -> f Reference) -> SuperGroup v -> f (SuperGroup v)
normalLinks :: (Applicative f, Var v) => (Bool -> Reference -> f Reference) -> SuperNormal v -> f (SuperNormal v)
prettyGroup :: Var v => String -> SuperGroup v -> ShowS
prettySuperNormal :: Var v => Int -> SuperNormal v -> ShowS
prettyANF :: Var v => Bool -> Int -> ANormal v -> ShowS
instance GHC.Show.Show Unison.Runtime.ANF.CompileExn
instance GHC.Show.Show v => GHC.Show.Show (Unison.Runtime.ANF.Prefix v x)
instance GHC.Enum.Enum Unison.Runtime.ANF.Mem
instance GHC.Show.Show Unison.Runtime.ANF.Mem
instance GHC.Classes.Ord Unison.Runtime.ANF.Mem
instance GHC.Classes.Eq Unison.Runtime.ANF.Mem
instance Unison.Util.EnumContainers.EnumKey Unison.Runtime.ANF.RTag
instance GHC.Read.Read Unison.Runtime.ANF.RTag
instance GHC.Show.Show Unison.Runtime.ANF.RTag
instance GHC.Classes.Ord Unison.Runtime.ANF.RTag
instance GHC.Classes.Eq Unison.Runtime.ANF.RTag
instance Unison.Util.EnumContainers.EnumKey Unison.Runtime.ANF.CTag
instance GHC.Read.Read Unison.Runtime.ANF.CTag
instance GHC.Show.Show Unison.Runtime.ANF.CTag
instance GHC.Classes.Ord Unison.Runtime.ANF.CTag
instance GHC.Classes.Eq Unison.Runtime.ANF.CTag
instance GHC.Show.Show Unison.Runtime.ANF.SeqEnd
instance GHC.Enum.Enum Unison.Runtime.ANF.SeqEnd
instance GHC.Classes.Ord Unison.Runtime.ANF.SeqEnd
instance GHC.Classes.Eq Unison.Runtime.ANF.SeqEnd
instance Data.Traversable.Traversable Unison.Runtime.ANF.Branched
instance Data.Foldable.Foldable Unison.Runtime.ANF.Branched
instance GHC.Base.Functor Unison.Runtime.ANF.Branched
instance GHC.Classes.Eq e => GHC.Classes.Eq (Unison.Runtime.ANF.Branched e)
instance GHC.Show.Show e => GHC.Show.Show (Unison.Runtime.ANF.Branched e)
instance GHC.Classes.Eq Unison.Runtime.ANF.Lit
instance GHC.Show.Show Unison.Runtime.ANF.Lit
instance GHC.Enum.Bounded Unison.Runtime.ANF.POp
instance GHC.Enum.Enum Unison.Runtime.ANF.POp
instance GHC.Classes.Ord Unison.Runtime.ANF.POp
instance GHC.Classes.Eq Unison.Runtime.ANF.POp
instance GHC.Show.Show Unison.Runtime.ANF.POp
instance Data.Traversable.Traversable Unison.Runtime.ANF.Func
instance Data.Foldable.Foldable Unison.Runtime.ANF.Func
instance GHC.Base.Functor Unison.Runtime.ANF.Func
instance GHC.Classes.Eq v => GHC.Classes.Eq (Unison.Runtime.ANF.Func v)
instance GHC.Show.Show v => GHC.Show.Show (Unison.Runtime.ANF.Func v)
instance Data.Traversable.Traversable Unison.Runtime.ANF.Direction
instance Data.Foldable.Foldable Unison.Runtime.ANF.Direction
instance GHC.Base.Functor Unison.Runtime.ANF.Direction
instance GHC.Show.Show a => GHC.Show.Show (Unison.Runtime.ANF.Direction a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Unison.Runtime.ANF.Direction a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Unison.Runtime.ANF.Direction a)
instance (GHC.Classes.Eq e, GHC.Classes.Eq v) => GHC.Classes.Eq (Unison.Runtime.ANF.ANormalF v e)
instance (GHC.Show.Show e, GHC.Show.Show v) => GHC.Show.Show (Unison.Runtime.ANF.ANormalF v e)
instance (GHC.Show.Show s, GHC.Show.Show v) => GHC.Show.Show (Unison.Runtime.ANF.CTE v s)
instance U.Core.ABT.Var.Var v => GHC.Classes.Eq (Unison.Runtime.ANF.SuperNormal v)
instance GHC.Show.Show v => GHC.Show.Show (Unison.Runtime.ANF.SuperNormal v)
instance GHC.Show.Show v => GHC.Show.Show (Unison.Runtime.ANF.SuperGroup v)
instance GHC.Show.Show Unison.Runtime.ANF.Cacheability
instance GHC.Classes.Eq Unison.Runtime.ANF.Cacheability
instance GHC.Show.Show Unison.Runtime.ANF.GroupRef
instance GHC.Show.Show Unison.Runtime.ANF.Code
instance GHC.Show.Show Unison.Runtime.ANF.Cont
instance GHC.Show.Show Unison.Runtime.ANF.Value
instance GHC.Show.Show Unison.Runtime.ANF.BLit
instance GHC.Classes.Eq Unison.Runtime.ANF.Code
instance Unison.Var.Var v => GHC.Classes.Eq (Unison.Runtime.ANF.SuperGroup v)
instance GHC.Base.Semigroup (Unison.Runtime.ANF.BranchAccum v)
instance GHC.Base.Monoid (Unison.Runtime.ANF.BranchAccum e)
instance GHC.Base.Functor (Unison.Runtime.ANF.ANormalF v)
instance Data.Bifunctor.Bifunctor Unison.Runtime.ANF.ANormalF
instance Data.Bifoldable.Bifoldable Unison.Runtime.ANF.ANormalF
instance Unison.ABT.Normalized.Align Unison.Runtime.ANF.ANormalF
instance GHC.Base.Semigroup a => GHC.Base.Semigroup (Unison.Runtime.ANF.Direction a)
instance GHC.Base.Semigroup a => GHC.Base.Monoid (Unison.Runtime.ANF.Direction a)
instance Unison.Runtime.ANF.Tag Unison.Runtime.ANF.RTag
instance Unison.Runtime.ANF.Tag Unison.Runtime.ANF.CTag
instance GHC.Enum.Enum Unison.Runtime.ANF.CTag
instance GHC.Num.Num Unison.Runtime.ANF.CTag
instance GHC.Enum.Enum Unison.Runtime.ANF.RTag
instance GHC.Num.Num Unison.Runtime.ANF.RTag
instance GHC.Base.Functor (Unison.Runtime.ANF.Prefix v)
instance GHC.Classes.Ord v => GHC.Base.Applicative (Unison.Runtime.ANF.Prefix v)
instance GHC.Exception.Type.Exception Unison.Runtime.ANF.CompileExn

module Unison.Runtime.Builtin.Types
typeReferences :: [(Reference, Word64)]
builtinTypeNumbering :: Map Reference Word64
builtinTypeBackref :: EnumMap Word64 Reference

module Unison.Runtime.Crypto.Rsa

-- | Parse a RSA public key from a ByteString The input bytestring is a
--   hex-encoded string of the DER file for the public key. It can be
--   generated with those commands: # generate a RSA key of a given size
--   openssl genrsa -out private_key.pem <a>size</a> # output the DER
--   format as a hex string openssl rsa -in private_key.pem -outform DER
--   -pubout | xxd -p
parseRsaPublicKey :: ByteString -> Either Text PublicKey

-- | Parse a RSA private key from a ByteString The input bytestring is a
--   hex-encoded string of the DER file for the private key. It can be
--   generated with those commands: # generate a RSA key of a given size
--   openssl genrsa -out private_key.pem <a>size</a> # output the DER
--   format as a hex string openssl rsa -in private_key.pem -outform DER |
--   xxd -p
parseRsaPrivateKey :: ByteString -> Either Text PrivateKey

-- | Display a RSA Error
rsaErrorToText :: Error -> Text

module Unison.Runtime.Foreign
data Foreign
[Wrap] :: Reference -> !e -> Foreign
data HashAlgorithm
[HashAlgorithm] :: HashAlgorithm a => Reference -> a -> HashAlgorithm
unwrapForeign :: Foreign -> a
maybeUnwrapForeign :: Reference -> Foreign -> Maybe a
wrapBuiltin :: forall f. BuiltinForeign f => f -> Foreign
maybeUnwrapBuiltin :: forall f. BuiltinForeign f => Foreign -> Maybe f
unwrapBuiltin :: BuiltinForeign f => Foreign -> f
class BuiltinForeign f
foreignRef :: BuiltinForeign f => Tagged f Reference
newtype Tls
Tls :: Context -> Tls
data Failure a
Failure :: Reference -> Text -> a -> Failure a
instance Unison.Runtime.Foreign.BuiltinForeign Unison.Runtime.Foreign.HashAlgorithm
instance Unison.Runtime.Foreign.BuiltinForeign Unison.Util.Text.Text
instance Unison.Runtime.Foreign.BuiltinForeign Unison.Util.Bytes.Bytes
instance Unison.Runtime.Foreign.BuiltinForeign GHC.IO.Handle.Types.Handle
instance Unison.Runtime.Foreign.BuiltinForeign System.Process.Common.ProcessHandle
instance Unison.Runtime.Foreign.BuiltinForeign Unison.Referent.Referent
instance Unison.Runtime.Foreign.BuiltinForeign Network.Socket.Types.Socket
instance Unison.Runtime.Foreign.BuiltinForeign Network.UDP.ListenSocket
instance Unison.Runtime.Foreign.BuiltinForeign Network.UDP.ClientSockAddr
instance Unison.Runtime.Foreign.BuiltinForeign Network.UDP.UDPSocket
instance Unison.Runtime.Foreign.BuiltinForeign GHC.Conc.Sync.ThreadId
instance Unison.Runtime.Foreign.BuiltinForeign Network.TLS.Parameters.ClientParams
instance Unison.Runtime.Foreign.BuiltinForeign Network.TLS.Parameters.ServerParams
instance Unison.Runtime.Foreign.BuiltinForeign Data.X509.SignedCertificate
instance Unison.Runtime.Foreign.BuiltinForeign Data.X509.PrivateKey.PrivKey
instance Unison.Runtime.Foreign.BuiltinForeign GHC.IO.FilePath
instance Unison.Runtime.Foreign.BuiltinForeign Network.TLS.Context.Internal.Context
instance Unison.Runtime.Foreign.BuiltinForeign Unison.Runtime.ANF.Code
instance Unison.Runtime.Foreign.BuiltinForeign Unison.Runtime.ANF.Value
instance Unison.Runtime.Foreign.BuiltinForeign System.Clock.TimeSpec
instance Unison.Runtime.Foreign.BuiltinForeign Unison.Util.Text.Pattern.CPattern
instance Unison.Runtime.Foreign.BuiltinForeign Unison.Util.Text.Pattern.CharPattern
instance GHC.Classes.Eq Unison.Runtime.Foreign.Foreign
instance GHC.Classes.Ord Unison.Runtime.Foreign.Foreign
instance GHC.Show.Show Unison.Runtime.Foreign.Foreign

module Unison.Runtime.IOSource
debug :: Bool
parsingEnv :: ParsingEnv Identity
typecheckingEnv :: Env Symbol Ann
parsedFile :: UnisonFile Symbol Ann
typecheckedFile :: TypecheckedUnisonFile Symbol Ann
typecheckedFile' :: TypecheckedUnisonFile Symbol Ann
typecheckedFileTerms :: Map Symbol Reference
termNamed :: String -> Reference
codeLookup :: CodeLookup Symbol Identity Ann
codeLookupM :: Applicative m => CodeLookup Symbol m Ann
typeNamedId :: String -> Id
typeNamed :: String -> Reference
abilityNamedId :: String -> Id
eitherReference :: Reference
optionReference :: Reference
isTestReference :: Reference
isPropagatedReference :: Reference
isTest :: (Reference, Reference)
isIOTest :: (Reference, Reference)
isPropagatedValue :: Reference
eitherLeftId :: ConstructorId
eitherRightId :: ConstructorId
someId :: ConstructorId
noneId :: ConstructorId
authorRef :: Reference
guidRef :: Reference
copyrightHolderRef :: Reference
doc2Ref :: Reference
doc2SpecialFormRef :: Reference
doc2TermRef :: Reference
prettyRef :: Reference
prettyAnnotatedRef :: Reference
ansiColorRef :: Reference
consoleTextRef :: Reference
pattern Doc2Ref :: Reference
doc2WordId :: ConstructorId
doc2CodeId :: ConstructorId
doc2CodeBlockId :: ConstructorId
doc2BoldId :: ConstructorId
doc2ItalicId :: ConstructorId
doc2StrikethroughId :: ConstructorId
doc2StyleId :: ConstructorId
doc2AnchorId :: ConstructorId
doc2BlockquoteId :: ConstructorId
doc2BlanklineId :: ConstructorId
doc2LinebreakId :: ConstructorId
doc2SectionBreakId :: ConstructorId
doc2TooltipId :: ConstructorId
doc2AsideId :: ConstructorId
doc2CalloutId :: ConstructorId
doc2TableId :: ConstructorId
doc2FoldedId :: ConstructorId
doc2ParagraphId :: ConstructorId
doc2BulletedListId :: ConstructorId
doc2NumberedListId :: ConstructorId
doc2SectionId :: ConstructorId
doc2NamedLinkId :: ConstructorId
doc2ImageId :: ConstructorId
doc2SpecialId :: ConstructorId
doc2JoinId :: ConstructorId
doc2UntitledSectionId :: ConstructorId
doc2ColumnId :: ConstructorId
doc2GroupId :: ConstructorId
doc2MediaSourceRef :: Reference
pattern Doc2MediaSourceRef :: Reference
doc2VideoRef :: Reference
pattern Doc2VideoRef :: Reference
doc2FrontMatterRef :: Reference
pattern Doc2FrontMatterRef :: Reference
doc2LaTeXInlineRef :: Reference
pattern Doc2LaTeXInlineRef :: Reference
doc2SvgRef :: Reference
pattern Doc2SvgRef :: Reference
pattern Doc2Word :: Text -> Term (F typeVar typeAnn patternAnn) v a
pattern Doc2Code :: Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a
pattern Doc2CodeBlock :: Text -> Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a
pattern Doc2Bold :: Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a
pattern Doc2Italic :: Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a
pattern Doc2Strikethrough :: Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a
pattern Doc2Style :: Text -> Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a
pattern Doc2Anchor :: Text -> Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a
pattern Doc2Blockquote :: Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a
pattern Doc2Blankline :: Term (F typeVar typeAnn patternAnn) v a
pattern Doc2Linebreak :: Term (F typeVar typeAnn patternAnn) v a
pattern Doc2SectionBreak :: Term (F typeVar typeAnn patternAnn) v a
pattern Doc2Tooltip :: Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a
pattern Doc2Aside :: Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a
pattern Doc2Callout :: Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a
pattern Doc2Table :: [Term (F typeVar typeAnn patternAnn) v a] -> Term (F typeVar typeAnn patternAnn) v a
pattern Doc2Folded :: Bool -> Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a
pattern Doc2Paragraph :: [Term (F typeVar typeAnn patternAnn) v a] -> Term (F typeVar typeAnn patternAnn) v a
pattern Doc2BulletedList :: [Term (F typeVar typeAnn patternAnn) v a] -> Term (F typeVar typeAnn patternAnn) v a
pattern Doc2NumberedList :: Word64 -> [Term (F typeVar typeAnn patternAnn) v a] -> Term2 typeVar typeAnn patternAnn v a
pattern Doc2Section :: Term2 typeVar typeAnn patternAnn v a -> [Term (F typeVar typeAnn patternAnn) v a] -> Term2 typeVar typeAnn patternAnn v a
pattern Doc2NamedLink :: Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a
pattern Doc2Image :: Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a
pattern Doc2Special :: Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a
pattern Doc2Join :: [Term (F typeVar typeAnn patternAnn) v a] -> Term (F typeVar typeAnn patternAnn) v a
pattern Doc2UntitledSection :: [Term (F typeVar typeAnn patternAnn) v a] -> Term (F typeVar typeAnn patternAnn) v a
pattern Doc2Column :: [Term (F typeVar typeAnn patternAnn) v a] -> Term (F typeVar typeAnn patternAnn) v a
pattern Doc2Group :: Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a
pattern Doc2SpecialFormRef :: Reference
doc2SpecialFormSourceId :: ConstructorId
doc2SpecialFormFoldedSourceId :: ConstructorId
doc2SpecialFormExampleId :: ConstructorId
doc2SpecialFormExampleBlockId :: ConstructorId
doc2SpecialFormLinkId :: ConstructorId
doc2SpecialFormSignatureId :: ConstructorId
doc2SpecialFormSignatureInlineId :: ConstructorId
doc2SpecialFormEvalId :: ConstructorId
doc2SpecialFormEvalInlineId :: ConstructorId
doc2SpecialFormEmbedId :: ConstructorId
doc2SpecialFormEmbedInlineId :: ConstructorId
pattern Doc2SpecialFormSource :: Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a
pattern Doc2SpecialFormFoldedSource :: Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a
pattern Doc2SpecialFormExample :: Word64 -> Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a
pattern Doc2SpecialFormExampleBlock :: Word64 -> Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a
pattern Doc2SpecialFormLink :: Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a
pattern Doc2SpecialFormSignature :: Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a
pattern Doc2SpecialFormSignatureInline :: Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a
pattern Doc2SpecialFormEval :: Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a
pattern Doc2SpecialFormEvalInline :: Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a
pattern Doc2SpecialFormEmbed :: Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a
pattern Doc2SpecialFormEmbedInline :: Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a
pattern Doc2MediaSource :: Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a
pattern Doc2SpecialFormEmbedVideo :: [Term (F typeVar typeAnn patternAnn) v a] -> [Term (F typeVar typeAnn patternAnn) v a] -> Term (F typeVar typeAnn patternAnn) v a
pattern Doc2SpecialFormEmbedFrontMatter :: [Term (F typeVar typeAnn patternAnn) v a] -> Term (F typeVar typeAnn patternAnn) v a
pattern Doc2SpecialFormEmbedLaTeXInline :: Text -> Term (F typeVar typeAnn patternAnn) v a
pattern Doc2SpecialFormEmbedSvg :: Text -> Term (F typeVar typeAnn patternAnn) v a
pattern Doc2Example :: forall {vt} {at} {ap} {v} {a}. [v] -> Term2 vt at ap v a -> Term (F vt at ap) v a
pattern Doc2Term :: Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a
pattern Doc2TermRef :: Reference
pattern PrettyAnnotatedRef :: Reference
prettyEmptyId :: ConstructorId
prettyGroupId :: ConstructorId
prettyLitId :: ConstructorId
prettyWrapId :: ConstructorId
prettyOrElseId :: ConstructorId
prettyIndentId :: ConstructorId
prettyAppendId :: ConstructorId
prettyTableId :: ConstructorId
pattern PrettyEmpty :: Term (F typeVar typeAnn patternAnn) v a
pattern PrettyGroup :: Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a
pattern PrettyLit :: Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a
pattern PrettyWrap :: Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a
pattern PrettyIndent :: Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a
pattern PrettyOrElse :: Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a
pattern PrettyTable :: Term2 typeVar typeAnn patternAnn v a -> Seq (Term (F typeVar typeAnn patternAnn) v a) -> Term2 typeVar typeAnn patternAnn v a
pattern PrettyAppend :: Term2 typeVar typeAnn patternAnn v a -> Seq (Term (F typeVar typeAnn patternAnn) v a) -> Term2 typeVar typeAnn patternAnn v a
pattern PrettyRef :: Reference
prettyGetRef :: Reference
doc2FormatConsoleRef :: Reference
pattern AnsiColorRef :: Reference
ansiColorBlackId :: ConstructorId
pattern AnsiColorBlack :: Term (F typeVar typeAnn patternAnn) v a
pattern AnsiColorRed :: Term (F typeVar typeAnn patternAnn) v a
pattern AnsiColorGreen :: Term (F typeVar typeAnn patternAnn) v a
pattern AnsiColorYellow :: Term (F typeVar typeAnn patternAnn) v a
pattern AnsiColorBlue :: Term (F typeVar typeAnn patternAnn) v a
pattern AnsiColorMagenta :: Term (F typeVar typeAnn patternAnn) v a
pattern AnsiColorCyan :: Term (F typeVar typeAnn patternAnn) v a
pattern AnsiColorWhite :: Term (F typeVar typeAnn patternAnn) v a
pattern AnsiColorBrightBlack :: Term (F typeVar typeAnn patternAnn) v a
pattern AnsiColorBrightRed :: Term (F typeVar typeAnn patternAnn) v a
pattern AnsiColorBrightGreen :: Term (F typeVar typeAnn patternAnn) v a
pattern AnsiColorBrightYellow :: Term (F typeVar typeAnn patternAnn) v a
pattern AnsiColorBrightBlue :: Term (F typeVar typeAnn patternAnn) v a
pattern AnsiColorBrightMagenta :: Term (F typeVar typeAnn patternAnn) v a
pattern AnsiColorBrightCyan :: Term (F typeVar typeAnn patternAnn) v a
pattern AnsiColorBrightWhite :: Term (F typeVar typeAnn patternAnn) v a
pattern ConsoleTextRef :: Reference
consoleTextPlainId :: ConstructorId
consoleTextForegroundId :: ConstructorId
consoleTextBackgroundId :: ConstructorId
consoleTextBoldId :: ConstructorId
consoleTextUnderlineId :: ConstructorId
consoleTextInvertId :: ConstructorId
pattern ConsoleTextPlain :: Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a
pattern ConsoleTextForeground :: Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a
pattern ConsoleTextBackground :: Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a -> Term2 typeVar typeAnn patternAnn v a
pattern ConsoleTextBold :: Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a
pattern ConsoleTextUnderline :: Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a
pattern ConsoleTextInvert :: Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a
iarrayFromListRef :: Reference
ibarrayFromBytesRef :: Reference
constructorNamed :: Reference -> Text -> ConstructorId
constructorName :: Reference -> ConstructorId -> Text
sourceString :: String
source :: Text
type Note = Note Symbol Ann
type TFile = TypecheckedUnisonFile Symbol Ann
type SynthResult = Result (Seq Note) (Either (UnisonFile Symbol Ann) TFile)
type EitherResult = Either String TFile
showNotes :: Foldable f => String -> Env -> f Note -> String
ppEnv :: PrettyPrintEnv


-- | Execute a computation of type '{IO} () that has been previously added
--   to the codebase, without setting up an interactive environment.
--   
--   This allows one to run standalone applications implemented in the
--   Unison language.
module Unison.Codebase.Execute
execute :: Codebase IO Symbol Ann -> Runtime Symbol -> ProjectPathNames -> IO (Either Error ())
codebaseToCodeLookup :: MonadIO m => Codebase m Symbol Ann -> CodeLookup Symbol m Ann

module Unison.Runtime.MCode
data Args'
Arg1 :: !Int -> Args'
Arg2 :: !Int -> !Int -> Args'
ArgN :: {-# UNPACK #-} !PrimArray Int -> Args'
ArgR :: !Int -> !Int -> Args'
data Args
ZArgs :: Args
VArg1 :: !Int -> Args
VArg2 :: !Int -> !Int -> Args
VArgR :: !Int -> !Int -> Args
VArgN :: {-# UNPACK #-} !PrimArray Int -> Args
VArgV :: !Int -> Args
data RefNums
RN :: (Reference -> Word64) -> (Reference -> Word64) -> RefNums
[$sel:dnum:RN] :: RefNums -> Reference -> Word64
[$sel:cnum:RN] :: RefNums -> Reference -> Word64
data MLit
MI :: !Int -> MLit
MD :: !Double -> MLit
MT :: !Text -> MLit
MM :: !Referent -> MLit
MY :: !Reference -> MLit
data GInstr comb
UPrim1 :: !UPrim1 -> !Int -> GInstr comb
UPrim2 :: !UPrim2 -> !Int -> !Int -> GInstr comb
BPrim1 :: !BPrim1 -> !Int -> GInstr comb
BPrim2 :: !BPrim2 -> !Int -> !Int -> GInstr comb
ForeignCall :: !Bool -> !Word64 -> !Args -> GInstr comb
SetDyn :: !Word64 -> !Int -> GInstr comb
Capture :: !Word64 -> GInstr comb
Name :: !GRef comb -> !Args -> GInstr comb
Info :: !String -> GInstr comb
Pack :: !Reference -> !Word64 -> !Args -> GInstr comb
Lit :: !MLit -> GInstr comb
BLit :: !Reference -> !Word64 -> !MLit -> GInstr comb
Print :: !Int -> GInstr comb
Reset :: !EnumSet Word64 -> GInstr comb
Fork :: !Int -> GInstr comb
Atomically :: !Int -> GInstr comb
Seq :: !Args -> GInstr comb
TryForce :: !Int -> GInstr comb
type Instr = GInstr CombIx
type RInstr clos = GInstr (RComb clos)
data GSection comb
App :: !Bool -> !GRef comb -> !Args -> GSection comb
Call :: !Bool -> !CombIx -> comb -> !Args -> GSection comb
Jump :: !Int -> !Args -> GSection comb
Match :: !Int -> !GBranch comb -> GSection comb
Yield :: !Args -> GSection comb
Ins :: !GInstr comb -> !GSection comb -> GSection comb
Let :: !GSection comb -> !CombIx -> !Int -> !GSection comb -> GSection comb
Die :: String -> GSection comb
Exit :: GSection comb
DMatch :: !Maybe Reference -> !Int -> !GBranch comb -> GSection comb
NMatch :: !Maybe Reference -> !Int -> !GBranch comb -> GSection comb
RMatch :: !Int -> !GSection comb -> !EnumMap Word64 (GBranch comb) -> GSection comb
pattern MatchT :: Int -> GSection comb -> Map Text (GSection comb) -> GSection comb
pattern MatchW :: Int -> GSection comb -> EnumMap Word64 (GSection comb) -> GSection comb
type RSection clos = GSection (RComb clos)
type Section = GSection CombIx
data GComb clos comb
Comb :: {-# UNPACK #-} !GCombInfo comb -> GComb clos comb
CachedClosure :: !Word64 -> !clos -> GComb clos comb
pattern Lam :: Int -> Int -> GSection comb -> GComb clos comb
data GCombInfo comb
LamI :: !Int -> !Int -> !GSection comb -> GCombInfo comb
type Comb = GComb Void CombIx

-- | The fixed point of a GComb where all references to a Comb are
--   themselves Combs.
newtype RComb clos
RComb :: GComb clos (RComb clos) -> RComb clos
[$sel:unRComb:RComb] :: RComb clos -> GComb clos (RComb clos)
type RCombInfo clos = GCombInfo (RComb clos)

-- | Map of combinators, parameterized by comb reference type
type GCombs clos comb = EnumMap Word64 (GComb clos comb)
type RCombs clos = GCombs clos (RComb clos)
data CombIx
CIx :: !Reference -> !Word64 -> !Word64 -> CombIx
data GRef comb
Stk :: !Int -> GRef comb
Env :: !CombIx -> comb -> GRef comb
Dyn :: !Word64 -> GRef comb
type RRef clos = GRef (RComb clos)

-- | A reference to a combinator, parameterized by comb
type Ref = GRef CombIx
data UPrim1
DECI :: UPrim1
INCI :: UPrim1
NEGI :: UPrim1
SGNI :: UPrim1
LZRO :: UPrim1
TZRO :: UPrim1
COMN :: UPrim1
POPC :: UPrim1
ABSF :: UPrim1
EXPF :: UPrim1
LOGF :: UPrim1
SQRT :: UPrim1
COSF :: UPrim1
ACOS :: UPrim1
COSH :: UPrim1
ACSH :: UPrim1
SINF :: UPrim1
ASIN :: UPrim1
SINH :: UPrim1
ASNH :: UPrim1
TANF :: UPrim1
ATAN :: UPrim1
TANH :: UPrim1
ATNH :: UPrim1
ITOF :: UPrim1
NTOF :: UPrim1
CEIL :: UPrim1
FLOR :: UPrim1
TRNF :: UPrim1
RNDF :: UPrim1
data UPrim2
ADDI :: UPrim2
SUBI :: UPrim2
MULI :: UPrim2
DIVI :: UPrim2
MODI :: UPrim2
DIVN :: UPrim2
MODN :: UPrim2
SHLI :: UPrim2
SHRI :: UPrim2
SHRN :: UPrim2
POWI :: UPrim2
EQLI :: UPrim2
LEQI :: UPrim2
LEQN :: UPrim2
ANDN :: UPrim2
IORN :: UPrim2
XORN :: UPrim2
EQLF :: UPrim2
LEQF :: UPrim2
ADDF :: UPrim2
SUBF :: UPrim2
MULF :: UPrim2
DIVF :: UPrim2
ATN2 :: UPrim2
POWF :: UPrim2
LOGB :: UPrim2
MAXF :: UPrim2
MINF :: UPrim2
data BPrim1
SIZT :: BPrim1
USNC :: BPrim1
UCNS :: BPrim1
ITOT :: BPrim1
NTOT :: BPrim1
FTOT :: BPrim1
TTOI :: BPrim1
TTON :: BPrim1
TTOF :: BPrim1
PAKT :: BPrim1
UPKT :: BPrim1
VWLS :: BPrim1
VWRS :: BPrim1
SIZS :: BPrim1
PAKB :: BPrim1
UPKB :: BPrim1
SIZB :: BPrim1
FLTB :: BPrim1
MISS :: BPrim1
CACH :: BPrim1
LKUP :: BPrim1
LOAD :: BPrim1
CVLD :: BPrim1
VALU :: BPrim1
TLTT :: BPrim1
DBTX :: BPrim1
SDBL :: BPrim1
data BPrim2
EQLU :: BPrim2
CMPU :: BPrim2
DRPT :: BPrim2
CATT :: BPrim2
TAKT :: BPrim2
IXOT :: BPrim2
EQLT :: BPrim2
LEQT :: BPrim2
LEST :: BPrim2
DRPS :: BPrim2
CATS :: BPrim2
TAKS :: BPrim2
CONS :: BPrim2
SNOC :: BPrim2
IDXS :: BPrim2
SPLL :: BPrim2
SPLR :: BPrim2
TAKB :: BPrim2
DRPB :: BPrim2
IDXB :: BPrim2
CATB :: BPrim2
IXOB :: BPrim2
THRO :: BPrim2
TRCE :: BPrim2
SDBX :: BPrim2
SDBV :: BPrim2
data GBranch comb
Test1 :: !Word64 -> !GSection comb -> !GSection comb -> GBranch comb
Test2 :: !Word64 -> !GSection comb -> !Word64 -> !GSection comb -> !GSection comb -> GBranch comb
TestW :: !GSection comb -> !EnumMap Word64 (GSection comb) -> GBranch comb
TestT :: !GSection comb -> !Map Text (GSection comb) -> GBranch comb
type Branch = GBranch CombIx
type RBranch clos = GBranch (RComb clos)
emitCombs :: Var v => RefNums -> Reference -> Word64 -> SuperGroup v -> EnumMap Word64 Comb
emitComb :: Var v => RefNums -> Reference -> Word64 -> RCtx v -> (Word64, SuperNormal v) -> EnumMap Word64 Comb

-- | lazily replace all references to combinators with the combinators
--   themselves, tying the knot recursively when necessary.
resolveCombs :: Maybe (EnumMap Word64 (RCombs clos)) -> EnumMap Word64 (GCombs clos CombIx) -> EnumMap Word64 (RCombs clos)
absurdCombs :: EnumMap Word64 (EnumMap Word64 (GComb Void cix)) -> EnumMap Word64 (GCombs any cix)
emptyRNs :: RefNums
argsToLists :: Args -> [Int]
countArgs :: Args -> Int
combRef :: CombIx -> Reference
combDeps :: GComb clos comb -> [Word64]
combTypes :: GComb any comb -> [Word64]
prettyCombs :: Word64 -> EnumMap Word64 Comb -> ShowS
prettyComb :: (Show clos, Show comb) => Word64 -> Word64 -> GComb clos comb -> ShowS
instance GHC.Show.Show Unison.Runtime.MCode.Args'
instance GHC.Classes.Ord Unison.Runtime.MCode.Args
instance GHC.Classes.Eq Unison.Runtime.MCode.Args
instance GHC.Show.Show Unison.Runtime.MCode.Args
instance GHC.Classes.Ord Unison.Runtime.MCode.UPrim1
instance GHC.Classes.Eq Unison.Runtime.MCode.UPrim1
instance GHC.Show.Show Unison.Runtime.MCode.UPrim1
instance GHC.Classes.Ord Unison.Runtime.MCode.UPrim2
instance GHC.Classes.Eq Unison.Runtime.MCode.UPrim2
instance GHC.Show.Show Unison.Runtime.MCode.UPrim2
instance GHC.Classes.Ord Unison.Runtime.MCode.BPrim1
instance GHC.Classes.Eq Unison.Runtime.MCode.BPrim1
instance GHC.Show.Show Unison.Runtime.MCode.BPrim1
instance GHC.Classes.Ord Unison.Runtime.MCode.BPrim2
instance GHC.Classes.Eq Unison.Runtime.MCode.BPrim2
instance GHC.Show.Show Unison.Runtime.MCode.BPrim2
instance GHC.Classes.Ord Unison.Runtime.MCode.MLit
instance GHC.Classes.Eq Unison.Runtime.MCode.MLit
instance GHC.Show.Show Unison.Runtime.MCode.MLit
instance GHC.Show.Show Unison.Runtime.MCode.CombIx
instance GHC.Classes.Ord Unison.Runtime.MCode.CombIx
instance GHC.Classes.Eq Unison.Runtime.MCode.CombIx
instance Data.Traversable.Traversable Unison.Runtime.MCode.GRef
instance Data.Foldable.Foldable Unison.Runtime.MCode.GRef
instance GHC.Base.Functor Unison.Runtime.MCode.GRef
instance GHC.Classes.Ord comb => GHC.Classes.Ord (Unison.Runtime.MCode.GRef comb)
instance GHC.Classes.Eq comb => GHC.Classes.Eq (Unison.Runtime.MCode.GRef comb)
instance GHC.Show.Show comb => GHC.Show.Show (Unison.Runtime.MCode.GRef comb)
instance Data.Traversable.Traversable Unison.Runtime.MCode.GInstr
instance Data.Foldable.Foldable Unison.Runtime.MCode.GInstr
instance GHC.Base.Functor Unison.Runtime.MCode.GInstr
instance GHC.Classes.Ord comb => GHC.Classes.Ord (Unison.Runtime.MCode.GInstr comb)
instance GHC.Classes.Eq comb => GHC.Classes.Eq (Unison.Runtime.MCode.GInstr comb)
instance GHC.Show.Show comb => GHC.Show.Show (Unison.Runtime.MCode.GInstr comb)
instance Data.Traversable.Traversable Unison.Runtime.MCode.GSection
instance Data.Foldable.Foldable Unison.Runtime.MCode.GSection
instance GHC.Base.Functor Unison.Runtime.MCode.GSection
instance GHC.Classes.Ord comb => GHC.Classes.Ord (Unison.Runtime.MCode.GSection comb)
instance GHC.Classes.Eq comb => GHC.Classes.Eq (Unison.Runtime.MCode.GSection comb)
instance GHC.Show.Show comb => GHC.Show.Show (Unison.Runtime.MCode.GSection comb)
instance Data.Traversable.Traversable Unison.Runtime.MCode.GBranch
instance Data.Foldable.Foldable Unison.Runtime.MCode.GBranch
instance GHC.Base.Functor Unison.Runtime.MCode.GBranch
instance GHC.Classes.Ord comb => GHC.Classes.Ord (Unison.Runtime.MCode.GBranch comb)
instance GHC.Classes.Eq comb => GHC.Classes.Eq (Unison.Runtime.MCode.GBranch comb)
instance GHC.Show.Show comb => GHC.Show.Show (Unison.Runtime.MCode.GBranch comb)
instance Data.Traversable.Traversable Unison.Runtime.MCode.GCombInfo
instance Data.Foldable.Foldable Unison.Runtime.MCode.GCombInfo
instance GHC.Base.Functor Unison.Runtime.MCode.GCombInfo
instance GHC.Classes.Ord comb => GHC.Classes.Ord (Unison.Runtime.MCode.GCombInfo comb)
instance GHC.Classes.Eq comb => GHC.Classes.Eq (Unison.Runtime.MCode.GCombInfo comb)
instance GHC.Show.Show comb => GHC.Show.Show (Unison.Runtime.MCode.GCombInfo comb)
instance Data.Traversable.Traversable (Unison.Runtime.MCode.GComb clos)
instance Data.Foldable.Foldable (Unison.Runtime.MCode.GComb clos)
instance GHC.Base.Functor (Unison.Runtime.MCode.GComb clos)
instance (GHC.Classes.Ord comb, GHC.Classes.Ord clos) => GHC.Classes.Ord (Unison.Runtime.MCode.GComb clos comb)
instance (GHC.Classes.Eq comb, GHC.Classes.Eq clos) => GHC.Classes.Eq (Unison.Runtime.MCode.GComb clos comb)
instance (GHC.Show.Show comb, GHC.Show.Show clos) => GHC.Show.Show (Unison.Runtime.MCode.GComb clos comb)
instance GHC.Show.Show v => GHC.Show.Show (Unison.Runtime.MCode.Ctx v)
instance GHC.Base.Functor Unison.Runtime.MCode.Counted
instance GHC.Base.Functor Unison.Runtime.MCode.Emit
instance GHC.Base.Applicative Unison.Runtime.MCode.Emit
instance GHC.Base.Applicative Unison.Runtime.MCode.Counted
instance GHC.Show.Show (Unison.Runtime.MCode.RComb clos)
instance Data.Bifunctor.Bifunctor Unison.Runtime.MCode.GComb
instance Data.Bifoldable.Bifoldable Unison.Runtime.MCode.GComb
instance Data.Bitraversable.Bitraversable Unison.Runtime.MCode.GComb

module Unison.Runtime.Debug
traceComb :: (Show clos, Show comb) => Bool -> Word64 -> GComb clos comb -> Bool
traceCombs :: Word64 -> Bool -> EnumMap Word64 Comb -> EnumMap Word64 Comb
tracePretty :: Var v => PrettyPrintEnv -> Bool -> Term v -> Term v
tracePrettyGroup :: Var v => Word64 -> Bool -> SuperGroup v -> SuperGroup v

module Unison.Runtime.Pattern
type DataSpec = Map Reference (Either Cons Cons)
splitPatterns :: Var v => DataSpec -> Term v -> Term v
builtinDataSpec :: DataSpec
instance GHC.Show.Show v => GHC.Show.Show (Unison.Runtime.Pattern.PatternRow v)
instance GHC.Show.Show v => GHC.Show.Show (Unison.Runtime.Pattern.PatternMatrix v)
instance GHC.Show.Show Unison.Runtime.Pattern.SeqMatch
instance GHC.Classes.Ord Unison.Runtime.Pattern.SeqMatch
instance GHC.Classes.Eq Unison.Runtime.Pattern.SeqMatch
instance GHC.Base.Semigroup Unison.Runtime.Pattern.PType
instance GHC.Base.Monoid Unison.Runtime.Pattern.PType

module Unison.Runtime.SparseVector
data SparseVector bits a
SparseVector :: !bits -> !Vector a -> SparseVector bits a
[$sel:indices:SparseVector] :: SparseVector bits a -> !bits
[$sel:elements:SparseVector] :: SparseVector bits a -> !Vector a
map :: (Unbox a, Unbox b) => (a -> b) -> SparseVector bits a -> SparseVector bits b
mask :: forall a bits. (Unbox a, FiniteBits bits) => bits -> SparseVector bits a -> SparseVector bits a
zipWith :: (Unbox a, Unbox b, Unbox c, FiniteBits bits) => (a -> b -> c) -> SparseVector bits a -> SparseVector bits b -> SparseVector bits c
_1 :: (Unbox a, Unbox b) => SparseVector bits (a, b) -> SparseVector bits a
_2 :: (Unbox a, Unbox b) => SparseVector bits (a, b) -> SparseVector bits b
unzip :: (Unbox a, Unbox b) => SparseVector bits (a, b) -> (SparseVector bits a, SparseVector bits b)
choose :: (FiniteBits bits, Unbox a) => bits -> SparseVector bits a -> SparseVector bits a -> SparseVector bits a
merge :: forall a bits. (FiniteBits bits, Unbox a) => SparseVector bits a -> SparseVector bits a -> SparseVector bits a
eq :: a -> a -> Bool

module Unison.Runtime.Stack
data K
KE :: K
CB :: Callback -> K
Mark :: !Int -> !EnumSet Word64 -> !EnumMap Word64 Closure -> !K -> K
Push :: !Int -> !Int -> !CombIx -> !Int -> !RSection Closure -> !K -> K
data GClosure comb
GPAp :: !CombIx -> {-# UNPACK #-} !GCombInfo comb -> {-# UNPACK #-} !Seg -> GClosure comb
GEnum :: !Reference -> !Word64 -> GClosure comb
GDataU1 :: !Reference -> !Word64 -> !Int -> GClosure comb
GDataU2 :: !Reference -> !Word64 -> !Int -> !Int -> GClosure comb
GDataB1 :: !Reference -> !Word64 -> !GClosure comb -> GClosure comb
GDataB2 :: !Reference -> !Word64 -> !GClosure comb -> !GClosure comb -> GClosure comb
GDataUB :: !Reference -> !Word64 -> !Int -> !GClosure comb -> GClosure comb
GDataBU :: !Reference -> !Word64 -> !GClosure comb -> !Int -> GClosure comb
GDataG :: !Reference -> !Word64 -> {-# UNPACK #-} !Seg -> GClosure comb
GCaptured :: !K -> !Int -> {-# UNPACK #-} !Seg -> GClosure comb
GForeign :: !Foreign -> GClosure comb
GBlackHole :: GClosure comb
newtype Closure
Closure :: GClosure (RComb Closure) -> Closure
[$sel:unClosure:Closure] :: Closure -> GClosure (RComb Closure)
pattern DataC :: Reference -> Word64 -> SegList -> Closure
pattern PApV :: CombIx -> RCombInfo Closure -> SegList -> Closure
pattern CapV :: K -> Int -> SegList -> Closure
pattern PAp :: CombIx -> GCombInfo (RComb Closure) -> Seg -> Closure
pattern Enum :: Reference -> Word64 -> Closure
pattern DataU1 :: Reference -> Word64 -> Int -> Closure
pattern DataU2 :: Reference -> Word64 -> Int -> Int -> Closure
pattern DataB1 :: Reference -> Word64 -> Closure -> Closure
pattern DataB2 :: Reference -> Word64 -> Closure -> Closure -> Closure
pattern DataUB :: Reference -> Word64 -> Int -> Closure -> Closure
pattern DataBU :: Reference -> Word64 -> Closure -> Int -> Closure
pattern DataG :: Reference -> Word64 -> Seg -> Closure
pattern Captured :: K -> Int -> Seg -> Closure
pattern Foreign :: Foreign -> Closure
pattern BlackHole :: Closure
type IxClosure = GClosure CombIx
newtype Callback
Hook :: (Stack -> IO ()) -> Callback
data Augment
I :: Augment
K :: Augment
C :: Augment
data Dump
A :: Dump
F :: Int -> Int -> Dump
S :: Dump
data Stack
Stack :: !Int -> !Int -> !Int -> {-# UNPACK #-} !MutableByteArray (PrimState IO) -> {-# UNPACK #-} !MutableArray (PrimState IO) Closure -> Stack
[$sel:ap:Stack] :: Stack -> !Int
[$sel:fp:Stack] :: Stack -> !Int
[$sel:sp:Stack] :: Stack -> !Int
[$sel:ustk:Stack] :: Stack -> {-# UNPACK #-} !MutableByteArray (PrimState IO)
[$sel:bstk:Stack] :: Stack -> {-# UNPACK #-} !MutableArray (PrimState IO) Closure
type Off = Int
type SZ = Int
type FP = Int
type Seg = (USeg, BSeg)
type USeg = ByteArray
type BSeg = Array Closure
traceK :: Reference -> K -> [(Reference, Int)]
frameDataSize :: K -> Int
marshalToForeign :: HasCallStack => Closure -> Foreign
unull :: USeg
bnull :: BSeg
nullSeg :: Seg
peekD :: Stack -> IO Double
peekOffD :: Stack -> Int -> IO Double
pokeD :: Stack -> Double -> IO ()
pokeOffD :: Stack -> Int -> Double -> IO ()
peekN :: Stack -> IO Word64
peekOffN :: Stack -> Int -> IO Word64
pokeN :: Stack -> Word64 -> IO ()
pokeOffN :: Stack -> Int -> Word64 -> IO ()
peekBi :: BuiltinForeign b => Stack -> IO b
peekOffBi :: BuiltinForeign b => Stack -> Int -> IO b
pokeBi :: BuiltinForeign b => Stack -> b -> IO ()
pokeOffBi :: BuiltinForeign b => Stack -> Int -> b -> IO ()
peekOffS :: Stack -> Int -> IO (Seq Closure)
pokeS :: Stack -> Seq Closure -> IO ()
pokeOffS :: Stack -> Int -> Seq Closure -> IO ()
frameView :: Stack -> IO ()
scount :: Seg -> Int
closureTermRefs :: Monoid m => (Reference -> m) -> Closure -> m
dumpAP :: Int -> Int -> Int -> Dump -> Int
dumpFP :: Int -> Int -> Dump -> Int
alloc :: IO Stack
peek :: Stack -> IO Elem
upeek :: Stack -> IO UElem
bpeek :: Stack -> IO BElem
peekOff :: Stack -> Off -> IO Elem
upeekOff :: Stack -> Off -> IO UElem
bpeekOff :: Stack -> Off -> IO BElem

-- | Store a boxed value. We don't bother nulling out the unboxed stack,
--   it's extra work and there's nothing to garbage collect.
bpoke :: Stack -> BElem -> IO ()
bpokeOff :: Stack -> Off -> BElem -> IO ()

-- | Store an unboxed value and null out the boxed stack at that location,
--   both so we know there's no value there, and so garbage collection can
--   clean up any value that was referenced there.
upoke :: Stack -> UElem -> IO ()
upokeOff :: Stack -> Off -> UElem -> IO ()
bump :: Stack -> IO Stack
bumpn :: Stack -> SZ -> IO Stack

-- | Eats up arguments
grab :: Stack -> SZ -> IO (Seg, Stack)
ensure :: Stack -> SZ -> IO Stack
duplicate :: Stack -> IO Stack
discardFrame :: Stack -> IO Stack
saveFrame :: Stack -> IO (Stack, SZ, SZ)
saveArgs :: Stack -> IO (Stack, SZ)
restoreFrame :: Stack -> SZ -> SZ -> IO Stack
prepareArgs :: Stack -> Args' -> IO Stack
acceptArgs :: Stack -> Int -> IO Stack
frameArgs :: Stack -> IO Stack
augSeg :: Augment -> Stack -> Seg -> Maybe Args' -> IO Seg
dumpSeg :: Stack -> Seg -> Dump -> IO Stack
adjustArgs :: Stack -> SZ -> IO Stack
fsize :: Stack -> SZ
asize :: Stack -> SZ
instance Data.Traversable.Traversable Unison.Runtime.Stack.GClosure
instance Data.Foldable.Foldable Unison.Runtime.Stack.GClosure
instance GHC.Base.Functor Unison.Runtime.Stack.GClosure
instance GHC.Show.Show comb => GHC.Show.Show (Unison.Runtime.Stack.GClosure comb)
instance GHC.Classes.Ord Unison.Runtime.Stack.Closure
instance GHC.Classes.Eq Unison.Runtime.Stack.Closure
instance GHC.Show.Show Unison.Runtime.Stack.Closure
instance GHC.Classes.Eq Unison.Runtime.Stack.Callback
instance GHC.Classes.Ord Unison.Runtime.Stack.Callback
instance GHC.Classes.Eq Unison.Runtime.Stack.K
instance GHC.Classes.Ord Unison.Runtime.Stack.K
instance GHC.Classes.Eq (Unison.Runtime.Stack.GClosure comb)
instance GHC.Classes.Ord (Unison.Runtime.Stack.GClosure comb)
instance GHC.Show.Show Unison.Runtime.Stack.Stack
instance GHC.Show.Show Unison.Runtime.Stack.K

module Unison.Runtime.Exception
data RuntimeExn
PE :: CallStack -> Pretty ColorText -> RuntimeExn
BU :: [(Reference, Int)] -> Text -> Closure -> RuntimeExn
die :: HasCallStack => String -> IO a
dieP :: HasCallStack => Pretty ColorText -> IO a
exn :: HasCallStack => String -> a
instance GHC.Show.Show Unison.Runtime.Exception.RuntimeExn
instance GHC.Exception.Type.Exception Unison.Runtime.Exception.RuntimeExn

module Unison.Runtime.Serialize
unknownTag :: MonadGet m => String -> Word8 -> m a
class Tag t
tag2word :: Tag t => t -> Word8
word2tag :: (Tag t, MonadGet m) => Word8 -> m t
putTag :: MonadPut m => Tag t => t -> m ()
getTag :: MonadGet m => Tag t => m t
putChar :: MonadPut m => Char -> m ()
getChar :: MonadGet m => m Char
putFloat :: MonadPut m => Double -> m ()
getFloat :: MonadGet m => m Double
putBool :: MonadPut m => Bool -> m ()
getBool :: MonadGet m => m Bool
putNat :: MonadPut m => Word64 -> m ()
getNat :: MonadGet m => m Word64
putInt :: MonadPut m => Int64 -> m ()
getInt :: MonadGet m => m Int64
putLength :: (MonadPut m, Integral n, Integral (Unsigned n), Bits n, Bits (Unsigned n)) => n -> m ()
getLength :: (MonadGet m, Integral n, Integral (Unsigned n), Bits n, Bits (Unsigned n)) => m n
putPositive :: (MonadPut m, Bits n, Bits (Unsigned n), Integral n, Integral (Unsigned n)) => n -> m ()
getPositive :: forall m n. (Bounded n, Integral n, MonadGet m) => m n
putFoldable :: (Foldable f, MonadPut m) => (a -> m ()) -> f a -> m ()
putMap :: MonadPut m => (a -> m ()) -> (b -> m ()) -> Map a b -> m ()
getList :: MonadGet m => m a -> m [a]
getMap :: (MonadGet m, Ord a) => m a -> m b -> m (Map a b)
putEnumMap :: MonadPut m => EnumKey k => (k -> m ()) -> (v -> m ()) -> EnumMap k v -> m ()
getEnumMap :: MonadGet m => EnumKey k => m k -> m v -> m (EnumMap k v)
putEnumSet :: MonadPut m => EnumKey k => (k -> m ()) -> EnumSet k -> m ()
getEnumSet :: MonadGet m => EnumKey k => m k -> m (EnumSet k)
putMaybe :: MonadPut m => Maybe a -> (a -> m ()) -> m ()
getMaybe :: MonadGet m => m a -> m (Maybe a)
putPair :: MonadPut m => (a -> m ()) -> (b -> m ()) -> (a, b) -> m ()
getPair :: MonadGet m => m a -> m b -> m (a, b)
getBytes :: MonadGet m => m Bytes
putBytes :: MonadPut m => Bytes -> m ()
getByteArray :: MonadGet m => m ByteArray
putByteArray :: MonadPut m => ByteArray -> m ()
getArray :: MonadGet m => m a -> m (Array a)
putArray :: MonadPut m => (a -> m ()) -> Array a -> m ()
getBlock :: MonadGet m => m Chunk
putBlock :: MonadPut m => Chunk -> m ()
putHash :: MonadPut m => Hash -> m ()
getHash :: MonadGet m => m Hash
putReferent :: MonadPut m => Referent -> m ()
getReferent :: MonadGet m => m Referent
getConstructorType :: MonadGet m => m ConstructorType
putConstructorType :: MonadPut m => ConstructorType -> m ()
putText :: MonadPut m => Text -> m ()
getText :: MonadGet m => m Text
putReference :: MonadPut m => Reference -> m ()
getReference :: MonadGet m => m Reference
putConstructorReference :: MonadPut m => ConstructorReference -> m ()
getConstructorReference :: MonadGet m => m ConstructorReference
instance Unison.Runtime.Serialize.Tag Unison.Runtime.MCode.UPrim1
instance Unison.Runtime.Serialize.Tag Unison.Runtime.MCode.UPrim2
instance Unison.Runtime.Serialize.Tag Unison.Runtime.MCode.BPrim1
instance Unison.Runtime.Serialize.Tag Unison.Runtime.MCode.BPrim2

module Unison.Runtime.MCode.Serialize
putComb :: MonadPut m => (clos -> m ()) -> GComb clos comb -> m ()
getComb :: MonadGet m => m (GComb Void CombIx)
putCombIx :: MonadPut m => CombIx -> m ()
getCombIx :: MonadGet m => m CombIx
instance Unison.Runtime.Serialize.Tag Unison.Runtime.MCode.Serialize.BranchT
instance Unison.Runtime.Serialize.Tag Unison.Runtime.MCode.Serialize.MLitT
instance Unison.Runtime.Serialize.Tag Unison.Runtime.MCode.Serialize.RefT
instance Unison.Runtime.Serialize.Tag Unison.Runtime.MCode.Serialize.ArgsT
instance Unison.Runtime.Serialize.Tag Unison.Runtime.MCode.Serialize.InstrT
instance Unison.Runtime.Serialize.Tag Unison.Runtime.MCode.Serialize.SectionT
instance Unison.Runtime.Serialize.Tag Unison.Runtime.MCode.Serialize.CombT

module Unison.Runtime.Foreign.Function
data ForeignFunc
[FF] :: (Stack -> Args -> IO a) -> (Stack -> r -> IO Stack) -> (a -> IO r) -> ForeignFunc
class ForeignConvention a
readForeign :: ForeignConvention a => [Int] -> Stack -> IO ([Int], a)
writeForeign :: ForeignConvention a => Stack -> a -> IO Stack
mkForeign :: (ForeignConvention a, ForeignConvention r) => (a -> IO r) -> ForeignFunc
instance Unison.Runtime.Foreign.Function.ForeignConvention GHC.Types.Int
instance Unison.Runtime.Foreign.Function.ForeignConvention GHC.Word.Word64
instance Unison.Runtime.Foreign.Function.ForeignConvention GHC.Word.Word8
instance Unison.Runtime.Foreign.Function.ForeignConvention GHC.Word.Word16
instance Unison.Runtime.Foreign.Function.ForeignConvention GHC.Word.Word32
instance Unison.Runtime.Foreign.Function.ForeignConvention GHC.Types.Char
instance Unison.Runtime.Foreign.Function.ForeignConvention Unison.Runtime.Stack.Closure
instance Unison.Runtime.Foreign.Function.ForeignConvention Unison.Util.Text.Text
instance Unison.Runtime.Foreign.Function.ForeignConvention Unison.Util.Bytes.Bytes
instance Unison.Runtime.Foreign.Function.ForeignConvention Network.Socket.Types.Socket
instance Unison.Runtime.Foreign.Function.ForeignConvention Network.UDP.UDPSocket
instance Unison.Runtime.Foreign.Function.ForeignConvention GHC.Conc.Sync.ThreadId
instance Unison.Runtime.Foreign.Function.ForeignConvention GHC.IO.Handle.Types.Handle
instance Unison.Runtime.Foreign.Function.ForeignConvention Data.Time.Clock.Internal.POSIXTime.POSIXTime
instance Unison.Runtime.Foreign.Function.ForeignConvention a => Unison.Runtime.Foreign.Function.ForeignConvention (GHC.Maybe.Maybe a)
instance (Unison.Runtime.Foreign.Function.ForeignConvention a, Unison.Runtime.Foreign.Function.ForeignConvention b) => Unison.Runtime.Foreign.Function.ForeignConvention (Data.Either.Either a b)
instance Unison.Runtime.Foreign.Function.ForeignConvention GHC.IO.Exception.IOException
instance Unison.Runtime.Foreign.Function.ForeignConvention GHC.Types.Double
instance Unison.Runtime.Foreign.Function.ForeignConvention GHC.Types.Bool
instance Unison.Runtime.Foreign.Function.ForeignConvention GHC.Base.String
instance Unison.Runtime.Foreign.Function.ForeignConvention GHC.IO.Device.SeekMode
instance Unison.Runtime.Foreign.Function.ForeignConvention GHC.IO.IOMode.IOMode
instance Unison.Runtime.Foreign.Function.ForeignConvention ()
instance (Unison.Runtime.Foreign.Function.ForeignConvention a, Unison.Runtime.Foreign.Function.ForeignConvention b) => Unison.Runtime.Foreign.Function.ForeignConvention (a, b)
instance Unison.Runtime.Foreign.Function.ForeignConvention a => Unison.Runtime.Foreign.Function.ForeignConvention (Unison.Runtime.Foreign.Failure a)
instance (Unison.Runtime.Foreign.Function.ForeignConvention a, Unison.Runtime.Foreign.Function.ForeignConvention b, Unison.Runtime.Foreign.Function.ForeignConvention c) => Unison.Runtime.Foreign.Function.ForeignConvention (a, b, c)
instance (Unison.Runtime.Foreign.Function.ForeignConvention a, Unison.Runtime.Foreign.Function.ForeignConvention b, Unison.Runtime.Foreign.Function.ForeignConvention c, Unison.Runtime.Foreign.Function.ForeignConvention d) => Unison.Runtime.Foreign.Function.ForeignConvention (a, b, c, d)
instance (Unison.Runtime.Foreign.Function.ForeignConvention a, Unison.Runtime.Foreign.Function.ForeignConvention b, Unison.Runtime.Foreign.Function.ForeignConvention c, Unison.Runtime.Foreign.Function.ForeignConvention d, Unison.Runtime.Foreign.Function.ForeignConvention e) => Unison.Runtime.Foreign.Function.ForeignConvention (a, b, c, d, e)
instance Unison.Runtime.Foreign.Function.ForeignConvention GHC.IO.Handle.Types.BufferMode
instance Unison.Runtime.Foreign.Function.ForeignConvention [Unison.Runtime.Stack.Closure]
instance Unison.Runtime.Foreign.Function.ForeignConvention [Unison.Runtime.Foreign.Foreign]
instance Unison.Runtime.Foreign.Function.ForeignConvention (GHC.MVar.MVar Unison.Runtime.Stack.Closure)
instance Unison.Runtime.Foreign.Function.ForeignConvention (GHC.Conc.Sync.TVar Unison.Runtime.Stack.Closure)
instance Unison.Runtime.Foreign.Function.ForeignConvention (GHC.IORef.IORef Unison.Runtime.Stack.Closure)
instance Unison.Runtime.Foreign.Function.ForeignConvention (Data.Atomics.Internal.Ticket Unison.Runtime.Stack.Closure)
instance Unison.Runtime.Foreign.Function.ForeignConvention (Unison.Util.RefPromise.Promise Unison.Runtime.Stack.Closure)
instance Unison.Runtime.Foreign.Function.ForeignConvention Unison.Runtime.ANF.Code
instance Unison.Runtime.Foreign.Function.ForeignConvention Unison.Runtime.ANF.Value
instance Unison.Runtime.Foreign.Function.ForeignConvention Unison.Runtime.Foreign.Foreign
instance Unison.Runtime.Foreign.Function.ForeignConvention (Data.Primitive.Array.MutableArray s Unison.Runtime.Stack.Closure)
instance Unison.Runtime.Foreign.Function.ForeignConvention (Data.Array.Byte.MutableByteArray s)
instance Unison.Runtime.Foreign.Function.ForeignConvention (Data.Primitive.Array.Array Unison.Runtime.Stack.Closure)
instance Unison.Runtime.Foreign.Function.ForeignConvention Data.Array.Byte.ByteArray
instance Unison.Runtime.Foreign.BuiltinForeign b => Unison.Runtime.Foreign.Function.ForeignConvention b
instance (Unison.Runtime.Foreign.BuiltinForeign a, Unison.Runtime.Foreign.BuiltinForeign b) => Unison.Runtime.Foreign.Function.ForeignConvention [(a, b)]
instance Unison.Runtime.Foreign.BuiltinForeign b => Unison.Runtime.Foreign.Function.ForeignConvention [b]
instance GHC.Show.Show Unison.Runtime.Foreign.Function.ForeignFunc
instance GHC.Classes.Eq Unison.Runtime.Foreign.Function.ForeignFunc
instance GHC.Classes.Ord Unison.Runtime.Foreign.Function.ForeignFunc

module Unison.Runtime.ANF.Serialize
data Version
Transfer :: Word32 -> Version
Hash :: Word32 -> Version
data TmTag
VarT :: TmTag
ForceT :: TmTag
AppT :: TmTag
HandleT :: TmTag
ShiftT :: TmTag
MatchT :: TmTag
LitT :: TmTag
NameRefT :: TmTag
NameVarT :: TmTag
LetDirT :: TmTag
LetIndT :: TmTag
BxLitT :: TmTag
data FnTag
FVarT :: FnTag
FCombT :: FnTag
FContT :: FnTag
FConT :: FnTag
FReqT :: FnTag
FPrimT :: FnTag
FForeignT :: FnTag
data MtTag
MIntT :: MtTag
MTextT :: MtTag
MReqT :: MtTag
MEmptyT :: MtTag
MDataT :: MtTag
MSumT :: MtTag
MNumT :: MtTag
data LtTag
IT :: LtTag
NT :: LtTag
FT :: LtTag
TT :: LtTag
CT :: LtTag
LMT :: LtTag
LYT :: LtTag
data BLTag
TextT :: BLTag
ListT :: BLTag
TmLinkT :: BLTag
TyLinkT :: BLTag
BytesT :: BLTag
QuoteT :: BLTag
CodeT :: BLTag
BArrT :: BLTag
PosT :: BLTag
NegT :: BLTag
CharT :: BLTag
FloatT :: BLTag
ArrT :: BLTag
CachedCodeT :: BLTag
data VaTag
PartialT :: VaTag
DataT :: VaTag
ContT :: VaTag
BLitT :: VaTag
data CoTag
KET :: CoTag
MarkT :: CoTag
PushT :: CoTag
index :: Eq v => [v] -> v -> Maybe Word64
deindex :: HasCallStack => [v] -> Word64 -> v
pushCtx :: [v] -> [v] -> [v]
putIndex :: MonadPut m => Word64 -> m ()
getIndex :: MonadGet m => m Word64
putVar :: MonadPut m => Eq v => [v] -> v -> m ()
getVar :: MonadGet m => [v] -> m v
putArgs :: MonadPut m => Eq v => [v] -> [v] -> m ()
getArgs :: MonadGet m => [v] -> m [v]
putCCs :: MonadPut m => [Mem] -> m ()
getCCs :: MonadGet m => m [Mem]
putGroup :: MonadPut m => Var v => Map Reference Word64 -> EnumMap FOp Text -> SuperGroup v -> m ()
getGroup :: MonadGet m => Var v => m (SuperGroup v)
putCode :: MonadPut m => EnumMap FOp Text -> Code -> m ()
getCode :: MonadGet m => Word32 -> m Code
putCacheability :: MonadPut m => Cacheability -> m ()
getCacheability :: MonadGet m => m Cacheability
putComb :: MonadPut m => Var v => Map Reference Word64 -> EnumMap FOp Text -> [v] -> SuperNormal v -> m ()
getFresh :: Var v => Word64 -> v
getComb :: MonadGet m => Var v => [v] -> Word64 -> m (SuperNormal v)
putNormal :: MonadPut m => Var v => Map Reference Word64 -> EnumMap FOp Text -> [v] -> ANormal v -> m ()
getNormal :: MonadGet m => Var v => [v] -> Word64 -> m (ANormal v)
putFunc :: MonadPut m => Var v => Map Reference Word64 -> EnumMap FOp Text -> [v] -> Func v -> m ()
getFunc :: MonadGet m => Var v => [v] -> m (Func v)
putPOp :: MonadPut m => POp -> m ()
getPOp :: MonadGet m => m POp
pOpCode :: POp -> Word16
pOpAssoc :: [(POp, Word16)]
pop2word :: Map POp Word16
word2pop :: Map Word16 POp
putLit :: MonadPut m => Lit -> m ()
getLit :: MonadGet m => m Lit
putBLit :: MonadPut m => Version -> BLit -> m ()
getBLit :: MonadGet m => Version -> m BLit
putRefs :: MonadPut m => [Reference] -> m ()
getRefs :: MonadGet m => m [Reference]
putBranches :: MonadPut m => Var v => Map Reference Word64 -> EnumMap FOp Text -> [v] -> Branched (ANormal v) -> m ()
getBranches :: MonadGet m => Var v => [v] -> Word64 -> m (Branched (ANormal v))
putCase :: MonadPut m => Var v => Map Reference Word64 -> EnumMap FOp Text -> [v] -> ([Mem], ANormal v) -> m ()
getCase :: MonadGet m => Var v => [v] -> Word64 -> m ([Mem], ANormal v)
putCTag :: MonadPut m => CTag -> m ()
getCTag :: MonadGet m => m CTag
putGroupRef :: MonadPut m => GroupRef -> m ()
getGroupRef :: MonadGet m => m GroupRef
putValue :: MonadPut m => Version -> Value -> m ()
putUBValue :: MonadPut m => Version -> UBValue -> m ()
getValue :: MonadGet m => Version -> m Value
putCont :: MonadPut m => Version -> Cont -> m ()
getCont :: MonadGet m => Version -> m Cont
deserializeCode :: ByteString -> Either String Code
serializeCode :: EnumMap FOp Text -> Code -> ByteString

-- | Serializes a <a>SuperGroup</a> for rehashing.
--   
--   Expected as arguments are some code, and the <a>Reference</a> that
--   refers to it. In particular, if the code refers to itself by
--   reference, or if the code is part of a mututally-recursive set of
--   definitions (which have a common hash), the reference used as part of
--   that (mutual) recursion must be supplied.
--   
--   Using that reference, we find all references in the code to that
--   connected component. In the resulting byte string, those references
--   are instead replaced by positions in a listing of the connected
--   component. This means that the byte string is independent of the hash
--   used for the self reference. Only the order matters (which is
--   determined by the <a>Reference</a>). Then the bytes can be re-hashed
--   to establish a new hash for the connected component. This operation
--   should be idempotent as long as the indexing is preserved.
--   
--   Supplying a <a>Builtin</a> reference is not supported. Such code
--   shouldn't be subject to rehashing.
serializeGroupForRehash :: Var v => EnumMap FOp Text -> Reference -> SuperGroup v -> ByteString
getVersionedValue :: MonadGet m => m Value
deserializeValue :: ByteString -> Either String Value
serializeValue :: Value -> ByteString
serializeValueForHash :: Value -> ByteString
valueVersion :: Word32
codeVersion :: Word32
instance Unison.Runtime.Serialize.Tag Unison.Runtime.ANF.Serialize.CoTag
instance Unison.Runtime.Serialize.Tag Unison.Runtime.ANF.Serialize.VaTag
instance Unison.Runtime.Serialize.Tag Unison.Runtime.ANF.Serialize.BLTag
instance Unison.Runtime.Serialize.Tag Unison.Runtime.ANF.Serialize.LtTag
instance Unison.Runtime.Serialize.Tag Unison.Runtime.ANF.Serialize.MtTag
instance Unison.Runtime.Serialize.Tag Unison.Runtime.ANF.Serialize.FnTag
instance Unison.Runtime.Serialize.Tag Unison.Runtime.ANF.Serialize.TmTag

module Unison.Runtime.ANF.Rehash
checkGroupHashes :: [(Referent, Code)] -> Either (Text, [Referent]) (Either [Referent] [Referent])
rehashGroups :: Map Reference (SuperGroup Symbol) -> Either (Text, [Referent]) (Map Reference Reference, Map Reference (SuperGroup Symbol))
checkMissing :: [(Referent, Code)] -> Either (Text, [Referent]) [Reference]
rehashSCC :: SCC (Reference, SuperGroup Symbol) -> (Map Reference Reference, Map Reference (SuperGroup Symbol))
checkSCC :: SCC (Reference, a) -> Bool

module Unison.Runtime.Decompile
decompile :: Var v => (Reference -> Maybe Reference) -> (Word64 -> Word64 -> Maybe (Term v ())) -> Closure -> DecompResult v
type DecompResult v = (Set DecompError, Term v ())
data DecompError
BadBool :: !Word64 -> DecompError
BadUnboxed :: !Reference -> DecompError
BadForeign :: !Reference -> DecompError
BadData :: !Reference -> DecompError
BadPAp :: !Reference -> DecompError
UnkComb :: !Reference -> DecompError
UnkLocal :: !Reference -> !Word64 -> DecompError
Cont :: DecompError
Exn :: DecompError
renderDecompError :: DecompError -> Error
instance GHC.Classes.Ord Unison.Runtime.Decompile.DecompError
instance GHC.Classes.Eq Unison.Runtime.Decompile.DecompError

module Unison.Runtime.Builtin
builtinLookup :: Map Reference (Sandbox, SuperNormal Symbol)
builtinTermNumbering :: Map Reference Word64
builtinTypeNumbering :: Map Reference Word64
builtinTermBackref :: EnumMap Word64 Reference
builtinTypeBackref :: EnumMap Word64 Reference
builtinForeigns :: EnumMap Word64 ForeignFunc
sandboxedForeigns :: EnumMap Word64 ForeignFunc
numberedTermLookup :: EnumMap Word64 (SuperNormal Symbol)
data Sandbox
Tracked :: Sandbox
Untracked :: Sandbox
baseSandboxInfo :: Map Reference (Set Reference)
instance GHC.Enum.Bounded Unison.Runtime.Builtin.Sandbox
instance GHC.Enum.Enum Unison.Runtime.Builtin.Sandbox
instance GHC.Read.Read Unison.Runtime.Builtin.Sandbox
instance GHC.Show.Show Unison.Runtime.Builtin.Sandbox
instance GHC.Classes.Ord Unison.Runtime.Builtin.Sandbox
instance GHC.Classes.Eq Unison.Runtime.Builtin.Sandbox
instance Unison.Var.Var v => Unison.Runtime.Builtin.Fresh (v, v)
instance Unison.Var.Var v => Unison.Runtime.Builtin.Fresh (v, v, v)
instance Unison.Var.Var v => Unison.Runtime.Builtin.Fresh (v, v, v, v)
instance Unison.Var.Var v => Unison.Runtime.Builtin.Fresh (v, v, v, v, v)
instance Unison.Var.Var v => Unison.Runtime.Builtin.Fresh (v, v, v, v, v, v)
instance Unison.Var.Var v => Unison.Runtime.Builtin.Fresh (v, v, v, v, v, v, v)
instance Unison.Var.Var v => Unison.Runtime.Builtin.Fresh (v, v, v, v, v, v, v, v)
instance Unison.Var.Var v => Unison.Runtime.Builtin.Fresh (v, v, v, v, v, v, v, v, v)
instance Unison.Var.Var v => Unison.Runtime.Builtin.Fresh (v, v, v, v, v, v, v, v, v, v)
instance Unison.Var.Var v => Unison.Runtime.Builtin.Fresh (v, v, v, v, v, v, v, v, v, v, v)
instance Unison.Var.Var v => Unison.Runtime.Builtin.Fresh (v, v, v, v, v, v, v, v, v, v, v, v, v)
instance Unison.Var.Var v => Unison.Runtime.Builtin.Fresh (v, v, v, v, v, v, v, v, v, v, v, v, v, v)

module Unison.Runtime.Machine

-- | A ref storing every currently active thread. This is helpful for
--   cleaning up orphaned threads when the main process completes.
--   
--   We track threads when running in a host process like UCM, otherwise,
--   in one-off environments <a>Nothing</a> is used and we don't bother
--   tracking forked threads since they'll be cleaned up automatically on
--   process termination.
type ActiveThreads = Maybe (IORef (Set ThreadId))
type Tag = Word64
type DEnv = EnumMap Word64 Closure
type MCombs = RCombs Closure
type Combs = GCombs Void CombIx
type MSection = RSection Closure
type MBranch = RBranch Closure
type MInstr = RInstr Closure
type MComb = RComb Closure
type MRef = RRef Closure
data Tracer
NoTrace :: Tracer
MsgTrace :: String -> String -> String -> Tracer
SimpleTrace :: String -> Tracer
data CCache
CCache :: EnumMap Word64 ForeignFunc -> Bool -> (Bool -> Closure -> Tracer) -> TVar (EnumMap Word64 Combs) -> TVar (EnumMap Word64 MCombs) -> TVar (EnumMap Word64 Reference) -> TVar (EnumSet Word64) -> TVar (EnumMap Word64 Reference) -> TVar Word64 -> TVar Word64 -> TVar (Map Reference (SuperGroup Symbol)) -> TVar (Map Reference Word64) -> TVar (Map Reference Word64) -> TVar (Map Reference (Set Reference)) -> CCache
[$sel:foreignFuncs:CCache] :: CCache -> EnumMap Word64 ForeignFunc
[$sel:sandboxed:CCache] :: CCache -> Bool
[$sel:tracer:CCache] :: CCache -> Bool -> Closure -> Tracer
[$sel:srcCombs:CCache] :: CCache -> TVar (EnumMap Word64 Combs)
[$sel:combs:CCache] :: CCache -> TVar (EnumMap Word64 MCombs)
[$sel:combRefs:CCache] :: CCache -> TVar (EnumMap Word64 Reference)
[$sel:cacheableCombs:CCache] :: CCache -> TVar (EnumSet Word64)
[$sel:tagRefs:CCache] :: CCache -> TVar (EnumMap Word64 Reference)
[$sel:freshTm:CCache] :: CCache -> TVar Word64
[$sel:freshTy:CCache] :: CCache -> TVar Word64
[$sel:intermed:CCache] :: CCache -> TVar (Map Reference (SuperGroup Symbol))
[$sel:refTm:CCache] :: CCache -> TVar (Map Reference Word64)
[$sel:refTy:CCache] :: CCache -> TVar (Map Reference Word64)
[$sel:sandbox:CCache] :: CCache -> TVar (Map Reference (Set Reference))
refNumsTm :: CCache -> IO (Map Reference Word64)
refNumsTy :: CCache -> IO (Map Reference Word64)
refNumTm :: CCache -> Reference -> IO Word64
refNumTy :: CCache -> Reference -> IO Word64
refNumTy' :: CCache -> Reference -> IO (Maybe Word64)
baseCCache :: Bool -> IO CCache
info :: Show a => String -> a -> IO ()
infos :: String -> String -> IO ()
stk'info :: Stack -> IO ()
eval0 :: CCache -> ActiveThreads -> MSection -> IO ()
mCombClosure :: CombIx -> MComb -> Closure
topDEnv :: EnumMap Word64 MCombs -> Map Reference Word64 -> Map Reference Word64 -> (DEnv, K -> K)
apply0 :: Maybe (Stack -> IO ()) -> CCache -> ActiveThreads -> Word64 -> IO ()
apply1 :: (Stack -> IO ()) -> CCache -> ActiveThreads -> Closure -> IO ()
jump0 :: (Stack -> IO ()) -> CCache -> ActiveThreads -> Closure -> IO ()
unitValue :: Closure
lookupDenv :: Word64 -> DEnv -> Closure
buildLit :: Reference -> Word64 -> MLit -> Closure

-- | Execute an instruction
exec :: CCache -> DEnv -> ActiveThreads -> Stack -> K -> Reference -> MInstr -> IO (DEnv, Stack, K)
encodeExn :: Stack -> Either SomeException () -> IO Stack
numValue :: Maybe Reference -> Closure -> IO Word64

-- | Evaluate a section
eval :: CCache -> DEnv -> ActiveThreads -> Stack -> K -> Reference -> MSection -> IO ()
forkEval :: CCache -> ActiveThreads -> Closure -> IO ThreadId
nestEval :: CCache -> ActiveThreads -> (Closure -> IO ()) -> Closure -> IO ()
atomicEval :: CCache -> ActiveThreads -> (Closure -> IO ()) -> Closure -> IO ()
enter :: CCache -> DEnv -> ActiveThreads -> Stack -> K -> Bool -> Args -> MComb -> IO ()
name :: Stack -> Args -> Closure -> IO Stack
apply :: CCache -> DEnv -> ActiveThreads -> Stack -> K -> Bool -> Args -> Closure -> IO ()
jump :: CCache -> DEnv -> ActiveThreads -> Stack -> K -> Args -> Closure -> IO ()
repush :: CCache -> ActiveThreads -> Stack -> DEnv -> K -> K -> IO ()
moveArgs :: Stack -> Args -> IO Stack
closureArgs :: Stack -> Args -> IO [Closure]

-- | TODO: Experiment: In cases where we need to check the boxed stack to
--   see where the argument lives we can either fetch from both unboxed and
--   boxed stacks, then check the boxed result; OR we can just fetch from
--   the boxed stack and check the result, then conditionally fetch from
--   the unboxed stack.
--   
--   The former puts more work before the branch, which _may_ be better for
--   cpu pipelining, but the latter avoids an unnecessary fetch from the
--   unboxed stack in cases where all args are boxed.
buildData :: Stack -> Reference -> Tag -> Args -> IO Closure
dumpDataNoTag :: Maybe Reference -> Stack -> Closure -> IO (Word64, Stack)
closeArgs :: Augment -> Stack -> Seg -> Args -> IO Seg
peekForeign :: Stack -> Int -> IO a
uprim1 :: Stack -> UPrim1 -> Int -> IO Stack
uprim2 :: Stack -> UPrim2 -> Int -> Int -> IO Stack
bprim1 :: Stack -> BPrim1 -> Int -> IO Stack
bprim2 :: Stack -> BPrim2 -> Int -> Int -> IO Stack
yield :: CCache -> DEnv -> ActiveThreads -> Stack -> K -> IO ()
selectTextBranch :: Text -> MSection -> Map Text MSection -> MSection
selectBranch :: Tag -> MBranch -> MSection
splitCont :: DEnv -> Stack -> K -> Word64 -> IO (Closure, DEnv, Stack, K)
discardCont :: DEnv -> Stack -> K -> Word64 -> IO (DEnv, Stack, K)
resolve :: CCache -> DEnv -> Stack -> MRef -> IO Closure
unhandledErr :: String -> CCache -> Word64 -> IO a
rCombSection :: EnumMap Word64 MCombs -> CombIx -> MComb
resolveSection :: CCache -> Section -> IO MSection
dummyRef :: Reference
reserveIds :: Word64 -> TVar Word64 -> IO Word64
updateMap :: Semigroup s => s -> TVar s -> STM s
refLookup :: String -> Map Reference Word64 -> Reference -> Word64
decodeCacheArgument :: Seq Closure -> IO [(Reference, Code)]
decodeSandboxArgument :: Seq Closure -> IO [Reference]
encodeSandboxListResult :: [Reference] -> Seq Closure
encodeSandboxResult :: Either [Reference] [Reference] -> Closure
encodeLeft :: Closure -> Closure
encodeRight :: Closure -> Closure
addRefs :: TVar Word64 -> TVar (Map Reference Word64) -> TVar (EnumMap Word64 Reference) -> Set Reference -> STM (Map Reference Word64)
codeValidate :: [(Reference, SuperGroup Symbol)] -> CCache -> IO (Maybe (Failure Closure))
sandboxList :: CCache -> Referent -> IO [Reference]
checkSandboxing :: CCache -> [Reference] -> Closure -> IO Bool
checkValueSandboxing :: CCache -> [Reference] -> Value -> IO (Either [Reference] [Reference])
evaluateSTM :: a -> STM a
cacheAdd0 :: Set Reference -> [(Reference, Code)] -> [(Reference, Set Reference)] -> CCache -> IO ()
preEvalTopLevelConstants :: EnumMap Word64 (GCombs Closure CombIx) -> EnumMap Word64 (GCombs Closure CombIx) -> CCache -> IO ()
expandSandbox :: Map Reference (Set Reference) -> [(Reference, SuperGroup Symbol)] -> [(Reference, Set Reference)]
cacheAdd :: [(Reference, Code)] -> CCache -> IO [Reference]
reflectValue :: EnumMap Word64 Reference -> Closure -> IO Value
reifyValue :: CCache -> Value -> IO (Either [Reference] Closure)
reifyValue0 :: (EnumMap Word64 MCombs, Map Reference Word64, Map Reference Word64) -> Value -> IO Closure
doubleToInt :: Double -> Int
intToDouble :: Int -> Double
closureNum :: Closure -> Int
universalEq :: (Foreign -> Foreign -> Bool) -> Closure -> Closure -> Bool
arrayEq :: (Closure -> Closure -> Bool) -> Array Closure -> Array Closure -> Bool
compareAsFloat :: Int -> Int -> Ordering
compareAsNat :: Int -> Int -> Ordering
floatTag :: Word64
natTag :: Word64
intTag :: Word64
charTag :: Word64
unitTag :: Word64
leftTag :: Word64
rightTag :: Word64
universalCompare :: (Foreign -> Foreign -> Ordering) -> Closure -> Closure -> Ordering
arrayCmp :: (Closure -> Closure -> Ordering) -> Array Closure -> Array Closure -> Ordering

module Unison.Runtime.Interface
startRuntime :: Bool -> RuntimeHost -> Text -> IO (Runtime Symbol)
withRuntime :: MonadUnliftIO m => Bool -> RuntimeHost -> Text -> (Runtime Symbol -> m a) -> m a
startNativeRuntime :: Text -> FilePath -> IO (Runtime Symbol)
standalone :: CCache -> Word64 -> IO StoredCache
runStandalone :: StoredCache -> CombIx -> IO (Either (Pretty ColorText) ())

-- | A version of the Code Cache designed to be serialized to disk as
--   standalone bytecode.
data StoredCache
decodeStandalone :: ByteString -> Either String (Text, Text, CombIx, StoredCache)

-- | Whether the runtime is hosted within a persistent session or as a
--   one-off process. This affects the amount of clean-up and book-keeping
--   the runtime does.
data RuntimeHost
OneOff :: RuntimeHost
Persistent :: RuntimeHost
data () => Runtime v
Runtime :: IO () -> (CodeLookup v IO () -> PrettyPrintEnv -> Term v -> IO (Either Error ([Error], Term v))) -> (CompileOpts -> CodeLookup v IO () -> PrettyPrintEnv -> Reference -> FilePath -> IO (Maybe Error)) -> Type v Ann -> NESet (Type v Ann) -> Runtime v
[$sel:terminate:Runtime] :: Runtime v -> IO ()
[$sel:evaluate:Runtime] :: Runtime v -> CodeLookup v IO () -> PrettyPrintEnv -> Term v -> IO (Either Error ([Error], Term v))
[$sel:compileTo:Runtime] :: Runtime v -> CompileOpts -> CodeLookup v IO () -> PrettyPrintEnv -> Reference -> FilePath -> IO (Maybe Error)
[$sel:mainType:Runtime] :: Runtime v -> Type v Ann
[$sel:ioTestTypes:Runtime] :: Runtime v -> NESet (Type v Ann)
instance GHC.Show.Show Unison.Runtime.Interface.StoredCache
instance (GHC.Classes.Ord from, GHC.Classes.Ord to) => GHC.Base.Semigroup (Unison.Runtime.Interface.Remapping from to)
instance (GHC.Classes.Ord from, GHC.Classes.Ord to) => GHC.Base.Monoid (Unison.Runtime.Interface.Remapping from to)

module Unison.Runtime.Vector
data Vec a
[Scalar] :: a -> Vec a
[Vec] :: Unbox a => Vector a -> Vec a
[Pair] :: Vec a -> Vec b -> Vec (a, b)
[Choose] :: Vec Bool -> Vec a -> Vec a -> Vec a
[Mux] :: Vec Nat -> Vec (Vec a) -> Vec a
type Nat = Word64
mu :: Vec a -> Nat -> Maybe a
bound :: Nat -> Vec a -> Nat
toList :: Vec a -> [a]
