-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Recover run-time type information from the GHC heap
--   
--   The main function in this package is <a>classify</a>, which looks at
--   the GHC heap to recover type information about arbitrary values. This
--   makes it possible for example to show any value (function
--   <a>anythingToString</a>) without having any <tt>Show</tt> instance in
--   scope, though there are other use cases as well. For example, you
--   could use it to define an <a>anythingToJSON</a> function.
@package recover-rtti
@version 0.4.3

module Debug.RecoverRTTI.ClosureTree

-- | Show closure tree up to the given depth
--   
--   Used only for internal debugging
showClosureTree :: Int -> a -> IO String

module Debug.RecoverRTTI.Classify

-- | Classify a value
--   
--   Given a value of some unknown type <tt>a</tt> and a classifier
--   <tt>Classifier a</tt>, it should be sound to coerce the value to the
--   type indicated by the classifier.
--   
--   This is also the reason not all values can be classified; in
--   particular, we cannot classify values of unlifted types, as for these
--   types coercion does not work (this would result in a ghc runtime
--   crash).
classify :: a -> Either Closure (Classifier a)

-- | Bundle a value with its classifier
data Classified a
Classified :: Classifier a -> a -> Classified a

-- | Classify the arguments to the constructor
--   
--   Additionally returns the constructor name itself.
fromUserDefined :: UserDefined -> (String, [Some Classified])

-- | Show any value
--   
--   This shows any value, as long as it's not unlifted. The result should
--   be equal to show instances, with the following caveats:
--   
--   <ul>
--   <li>User-defined types (types not explicitly known to this library)
--   with a <i>custom</i> Show instance will still be showable, but the
--   result will be what the <i>derived</i> show instance would have
--   done.</li>
--   <li>Record field names are not known at runtime, so they are not
--   shown.</li>
--   <li>UNPACKed data is not visible to this library (if you compile with
--   <tt>-O0</tt> <tt>ghc</tt> will not unpack data, so that might be a
--   workaround if necessary).</li>
--   </ul>
--   
--   If classification fails, we show the actual closure.
anythingToString :: forall a. a -> String
canShowPrim :: PrimClassifier a -> Dict Show a
canShowClassified :: Classifier a -> Dict Show a
canShowClassified_ :: forall o. (forall a. o a -> Dict Show a) -> forall a. Classifier_ o a -> Dict Show a
pattern ElemK :: Classifier_ o a -> Elems o '[a]
pattern ElemU :: Elems o '[Void]
pattern ElemKK :: Classifier_ o a -> Classifier_ o b -> Elems o '[a, b]
pattern ElemUU :: Elems o '[Void, Void]
pattern ElemKU :: Classifier_ o a -> Elems o '[a, Void]
pattern ElemUK :: Classifier_ o b -> Elems o '[Void, b]
instance GHC.Show.Show (Debug.RecoverRTTI.Util.Some Debug.RecoverRTTI.Classify.Classified)
instance GHC.Show.Show (Debug.RecoverRTTI.Classify.Classified a)
instance GHC.Show.Show Debug.RecoverRTTI.Wrappers.UserDefined


-- | Recover runtime type information
module Debug.RecoverRTTI

-- | Show any value
--   
--   This shows any value, as long as it's not unlifted. The result should
--   be equal to show instances, with the following caveats:
--   
--   <ul>
--   <li>User-defined types (types not explicitly known to this library)
--   with a <i>custom</i> Show instance will still be showable, but the
--   result will be what the <i>derived</i> show instance would have
--   done.</li>
--   <li>Record field names are not known at runtime, so they are not
--   shown.</li>
--   <li>UNPACKed data is not visible to this library (if you compile with
--   <tt>-O0</tt> <tt>ghc</tt> will not unpack data, so that might be a
--   workaround if necessary).</li>
--   </ul>
--   
--   If classification fails, we show the actual closure.
anythingToString :: forall a. a -> String

-- | Like <a>traceShow</a>, but using <a>anythingToString</a>
traceAnything :: a -> b -> b

-- | Like <a>traceShowId</a>, but using <a>anythingToString</a>
traceAnythingId :: a -> a

-- | Deriving-via support for <a>anythingToString</a>
--   
--   If for debugging purposes you want to temporarily add a <a>Show</a>
--   instance to an arbitrary datatype in terms of <a>anythingToString</a>,
--   you can do so using
--   
--   <pre>
--   data T = MkT ...
--     deriving Show via AnythingToString T
--   </pre>
--   
--   This is equivalent to saying
--   
--   <pre>
--   instance Show T where
--     show = anythingToString
--   </pre>
newtype AnythingToString a
AnythingToString :: a -> AnythingToString a

-- | Add level of indirection on the heap
--   
--   (Advanced users only, for most use cases this should not be
--   necessary.)
--   
--   Type recovery in <tt>recover-rtti</tt> (through <a>classify</a>) works
--   by looking at the values on the heap. For example, if we see a list,
--   we then look at the first element of that list (if any), and if that
--   element happens to be an <a>Int</a>, the inferred type is
--   <tt>[Int]</tt>. When we show such a list (<a>anythingToString</a>),
--   every element of the list is interpreted as an <a>Int</a>, without
--   doing further type recovery.
--   
--   This works for normal use cases, but fails in low-level code that uses
--   <tt>Any</tt> to squeeze values of different types into a data
--   structure not designed for that purpose. For example, consider
--   
--   <pre>
--   data T f = T [f Any]
--   </pre>
--   
--   If we call <a>anythingToString</a> on a <tt>T</tt> value with elements
--   of different types in the list, we get some unexpected results:
--   
--   <pre>
--      anythingToString (T [unsafeCoerce (1 :: Int), unsafeCoerce False])
--   == "T [1,14355032]"
--   </pre>
--   
--   The reason is that the type of the list was inferred as
--   <tt>[Int]</tt>, and hence the <a>Bool</a> was subsequently also
--   interpreted as an <a>Int</a>.
--   
--   <a>BoxAnything</a> helps to resolve the problem. There are ways in
--   which it can be used. First, we can derive the following entirely
--   reasonable <a>Show</a> instance for <tt>T</tt>:
--   
--   <pre>
--   deriving instance Show a =&gt; Show (T (K a))
--   </pre>
--   
--   We then get
--   
--   <pre>
--      show (T [K $ BoxAnything (1 :: Int), K $ BoxAnything False])
--   == "T [K 1,K False]"
--   </pre>
--   
--   Alternatively, we can omit the <a>Show</a> instance for <tt>T</tt>, to
--   get
--   
--   <pre>
--      anythingToString (T [K $ BoxAnything (1 :: Int), K $ BoxAnything False])
--   == "T [BoxAnything 1,BoxAnything False]"
--   </pre>
--   
--   For this second use case to work, it is critical that
--   <a>BoxAnything</a> is a datatype, not a newtype, so that it actually
--   appears on the heap.
data BoxAnything
BoxAnything :: a -> BoxAnything

-- | Classify a value
--   
--   Given a value of some unknown type <tt>a</tt> and a classifier
--   <tt>Classifier a</tt>, it should be sound to coerce the value to the
--   type indicated by the classifier.
--   
--   This is also the reason not all values can be classified; in
--   particular, we cannot classify values of unlifted types, as for these
--   types coercion does not work (this would result in a ghc runtime
--   crash).
classify :: a -> Either Closure (Classifier a)

-- | Classifier
--   
--   Given a value of some unknown type <tt>a</tt>, a <tt>Classifier a</tt>
--   will tell you what the type of <tt>a</tt> is. This is similar to a
--   <tt>TypeRep</tt>, but since we recover this information from the heap,
--   we have less accurate type information than <tt>TypeRep</tt> does.
type Classifier = Classifier_ IsUserDefined

-- | Classifier for primitive types
data PrimClassifier (a :: Type)
[C_Bool] :: PrimClassifier Bool
[C_Char] :: PrimClassifier Char
[C_Double] :: PrimClassifier Double
[C_Float] :: PrimClassifier Float
[C_Int] :: PrimClassifier Int
[C_Int16] :: PrimClassifier Int16
[C_Int8] :: PrimClassifier Int8
[C_Int32] :: PrimClassifier Int32
[C_Int64] :: PrimClassifier Int64
[C_Integer] :: PrimClassifier Integer
[C_Ordering] :: PrimClassifier Ordering
[C_Unit] :: PrimClassifier ()
[C_Word] :: PrimClassifier Word
[C_Word8] :: PrimClassifier Word8
[C_Word16] :: PrimClassifier Word16
[C_Word32] :: PrimClassifier Word32
[C_Word64] :: PrimClassifier Word64
[C_String] :: PrimClassifier String
[C_BS_Strict] :: PrimClassifier ByteString
[C_BS_Lazy] :: PrimClassifier ByteString
[C_BS_Short] :: PrimClassifier ShortByteString
[C_Text_Strict] :: PrimClassifier Text
[C_Text_Lazy] :: PrimClassifier Text
[C_Value] :: PrimClassifier Value
[C_STRef] :: PrimClassifier SomeSTRef
[C_TVar] :: PrimClassifier SomeTVar
[C_MVar] :: PrimClassifier SomeMVar
[C_Fun] :: PrimClassifier SomeFun
[C_IntSet] :: PrimClassifier IntSet
[C_Prim_ArrayM] :: PrimClassifier SomePrimArrayM
[C_Vector_Storable] :: PrimClassifier SomeStorableVector
[C_Vector_StorableM] :: PrimClassifier SomeStorableVectorM
[C_Vector_Primitive] :: PrimClassifier SomePrimitiveVector
[C_Vector_PrimitiveM] :: PrimClassifier SomePrimitiveVectorM

-- | User-defined types
--   
--   If we classify a type as user-defined, we pair the classifier with the
--   original value. This means that a <tt>Classifier</tt> is sufficient
--   information for staged inference by client code that may wish to
--   further classify these types given additional domain knowledge (see
--   also <tt>reclassify_</tt>).
data IsUserDefined a
[IsUserDefined] :: UserDefined -> IsUserDefined UserDefined

-- | Generalization of <a>Classifier</a>
--   
--   Type arguments:
--   
--   <ul>
--   <li><tt>o</tt>: Classification of " other " types (not explicitly
--   known to the lib)</li>
--   </ul>
--   
--   Normally we instantiate this to <a>IsUserDefined</a>, classifying all
--   unknown types as <a>UserDefined</a>.
--   
--   <ul>
--   <li><tt>a</tt>: The type we're actually classifying</li>
--   </ul>
data Classifier_ (o :: Type -> Type) (a :: Type) :: Type
[C_Prim] :: PrimClassifier a -> Classifier_ o a
[C_Other] :: o a -> Classifier_ o a
[C_Maybe] :: Elems o '[a] -> Classifier_ o (Maybe a)
[C_Either] :: Elems o '[a, b] -> Classifier_ o (Either a b)
[C_List] :: Elems o '[a] -> Classifier_ o [a]
[C_Ratio] :: Elems o '[a] -> Classifier_ o (Ratio a)
[C_Set] :: Elems o '[a] -> Classifier_ o (Set a)
[C_Map] :: Elems o '[a, b] -> Classifier_ o (Map a b)
[C_IntMap] :: Elems o '[a] -> Classifier_ o (IntMap a)
[C_Sequence] :: Elems o '[a] -> Classifier_ o (Seq a)
[C_Tree] :: Elems o '[a] -> Classifier_ o (Tree a)
[C_HashSet] :: Elems o '[a] -> Classifier_ o (HashSet a)
[C_HashMap] :: Elems o '[a, b] -> Classifier_ o (HashMap a b)
[C_HM_Array] :: Elems o '[a] -> Classifier_ o (Array a)
[C_Prim_Array] :: Elems o '[a] -> Classifier_ o (Array a)
[C_Vector_Boxed] :: Elems o '[a] -> Classifier_ o (Vector a)
[C_Tuple] :: (SListI xs, IsValidSize (Length xs)) => Elems o xs -> Classifier_ o (WrappedTuple xs)
data Elem o a
[Elem] :: Classifier_ o a -> Elem o a
[NoElem] :: Elem o Void
newtype Elems o xs
Elems :: NP (Elem o) xs -> Elems o xs
newtype SomeSTRef
SomeSTRef :: STRef Any Any -> SomeSTRef
newtype SomeTVar
SomeTVar :: TVar Any -> SomeTVar
newtype SomeMVar
SomeMVar :: MVar Any -> SomeMVar

-- | Functions
--   
--   We do not try to infer the domain or codomain of the function.
newtype SomeFun
SomeFun :: (Any -> Any) -> SomeFun
newtype SomePrimArrayM
SomePrimArrayM :: MutableArray RealWorld Any -> SomePrimArrayM

-- | Storable vector (<a>Data.Vector.Storable</a>)
--   
--   For storable arrays we have no hope of inferring the type of the
--   elements: the elements are not stored as pointers, but rather as "
--   serialized " data through the <tt>Storable</tt> type class. In order
--   to get at any element, we'd need to have the corresponding
--   <tt>Storable</tt> instance, but of course we don't have it if we don't
--   have the type.
newtype SomeStorableVector
SomeStorableVector :: Any -> SomeStorableVector

-- | Mutable storage vector (<a>Data.Vector.Storable</a>)
--   
--   See <a>SomeStorableVector</a> for some details on why we don't infer
--   anything here.
newtype SomeStorableVectorM
SomeStorableVectorM :: Any -> SomeStorableVectorM

-- | Primitive vector (<a>Data.Vector.Primitive</a>)
--   
--   See <a>SomeStorableVector</a> for why we can't classify elements of
--   these vectors.
newtype SomePrimitiveVector
SomePrimitiveVector :: Any -> SomePrimitiveVector

-- | Mutable primitive vector
newtype SomePrimitiveVectorM
SomePrimitiveVectorM :: Any -> SomePrimitiveVectorM
mapClassifier :: forall m o o'. Applicative m => (forall a. o a -> m (o' a)) -> forall a. Classifier_ o a -> m (Classifier_ o' a)
samePrim :: PrimClassifier a -> PrimClassifier b -> Maybe (a :~: b)

-- | Check that two classifiers are the same
--   
--   If they are the same, additionally return a proof that that means the
--   <i>types</i> they classify must be equal (note that equality on the
--   classifiers is strictly stronger than equality on the types: for
--   example, non-empty and empty lists have different classifiers, but
--   classify the same type).
--   
--   This is defined on the general type <a>Classifier_</a> rather than on
--   <a>Classifier</a> because different user-defined types may both be
--   classified as <tt>UserDefined</tt> yet not be equal to each other
sameClassifier_ :: forall o. (forall a b. o a -> o b -> Maybe (a :~: b)) -> forall a b. Classifier_ o a -> Classifier_ o b -> Maybe (a :~: b)
sameElem :: forall o. (forall a b. o a -> o b -> Maybe (a :~: b)) -> forall a b. Elem o a -> Elem o b -> Maybe (a :~: b)
sameElems :: forall o r. (forall a b. o a -> o b -> Maybe (a :~: b)) -> forall as bs. Elems o as -> Elems o bs -> (as ~ bs => r) -> Maybe r

-- | User-defined type
--   
--   We defer classification of the arguments to the constructor (the type
--   might be recursive, so if we tried to classify all arguments, we might
--   end up unrolling the recursion at the type level).
data UserDefined

-- | Bundle a value with its classifier
data Classified a
Classified :: Classifier a -> a -> Classified a

-- | Classify the arguments to the constructor
--   
--   Additionally returns the constructor name itself.
fromUserDefined :: UserDefined -> (String, [Some Classified])
canShowClassified :: Classifier a -> Dict Show a
canShowPrim :: PrimClassifier a -> Dict Show a
canShowClassified_ :: forall o. (forall a. o a -> Dict Show a) -> forall a. Classifier_ o a -> Dict Show a
type PrimSatisfies (c :: Type -> Constraint) = (c Bool, c Char, c Double, c Float, c Int, c Int16, c Int8, c Int32, c Int64, c Integer, c Ordering, c (), c Word, c Word8, c Word16, c Word32, c Word64, c String, c ByteString, c ByteString, c ShortByteString, c Text, c Text, c Value, c SomeSTRef, c SomeTVar, c SomeMVar, c SomeFun, c IntSet, c SomePrimArrayM, c SomeStorableVector, c SomeStorableVectorM, c SomePrimitiveVector, c SomePrimitiveVectorM)
primSatisfies :: forall c. PrimSatisfies c => forall a. PrimClassifier a -> Dict c a
class (PrimSatisfies c, forall a. (c a) => c (Maybe a), forall a b. (c a, c b) => c (Either a b), forall a. (c a) => c [a], forall a. (c a) => c (Ratio a), forall a. (c a) => c (Set a), forall a b. (c a, c b) => c (Map a b), forall a. (c a) => c (IntMap a), forall a. (c a) => c (Seq a), forall a. (c a) => c (Tree a), forall a. (c a) => c (HashSet a), forall a b. (c a, c b) => c (HashMap a b), forall a. (c a) => c (Array a), forall a. (c a) => c (Array a), forall a. (c a) => c (Vector a), forall xs. (All c xs, IsValidSize (Length xs)) => c (WrappedTuple xs)) => ClassifiedSatisfies (c :: Type -> Constraint)
classifiedSatisfies :: forall c o. (ClassifiedSatisfies c, c Void) => (forall a. o a -> Dict c a) -> forall a. Classifier_ o a -> Dict c a

-- | Reclassified values
--   
--   Reclassification can be done by user code which want to take advantage
--   of the classification infrastructure for <tt>recover-rtti</tt> but add
--   some additional classification for domain-specific types known only to
--   that client code.
--   
--   When we reclassify a value, a value that might previously be
--   classified as <tt>UserDefined</tt> may now be classified as some
--   concrete type; therefore we compute a classifier for a potentially
--   <i>different</i> type along with evidence that we can coerce between
--   the two.
data Reclassified o a
[Reclassified] :: o b -> FromUsr a b -> Reclassified o a
reclassify_ :: forall m o o'. Applicative m => (forall a. o a -> m (Reclassified o' a)) -> forall a. Classifier_ o a -> m (Classifier_ (Reclassified o') a)

-- | Lift <a>Reclassified</a> to the top-level
--   
--   Given a classifier with user-defined classifiers at the levels, along
--   with coercion functions, leave the user-defined classifiers in place
--   but lift the coercion function to the top-level.
distribReclassified :: forall o. forall a. Classifier_ (Reclassified o) a -> Reclassified (Classifier_ o) a

-- | Evidence that we can convert between two types
--   
--   The only actual conversion we ever do is from <a>UserDefined</a> (aka
--   <tt>Any</tt>) to whatever type the reclassification gives.
data FromUsr :: Type -> Type -> Type
[Id] :: FromUsr a a
[Absurd] :: FromUsr Void a
[FromUsr] :: FromUsr UserDefined a
[F1] :: FromUsr a1 b1 -> FromUsr (f a1) (f b1)
[F2] :: FromUsr a1 b1 -> FromUsr a2 b2 -> FromUsr (f a1 a2) (f b1 b2)
[FN] :: PairWise FromUsr as bs -> FromUsr (f as) (f bs)
[Compose] :: FromUsr b c -> FromUsr a b -> FromUsr a c

-- | Coerce, given some evidence that the coercion is sound.
coerceFromUsr :: FromUsr a b -> a -> b

-- | Inductive tuple
--   
--   Inductive view on tuples that can be constructed with or pattern
--   matched on using <a>TNil</a> and <a>TCons</a>. The underlying
--   representation is a <i>true</i> tuple however; for example, <tt>Tuple
--   '[Int, Bool, Char] ~ (Int, Bool, Char)</tt>.
newtype WrappedTuple xs
WrappedTuple :: Tuple xs -> WrappedTuple xs
pattern TNil :: forall xs. (SListI xs, IsValidSize (Length xs)) => xs ~ '[] => WrappedTuple xs
pattern TCons :: forall xs'. (SListI xs', IsValidSize (Length xs')) => forall x xs. (xs' ~ (x ': xs), SListI xs, IsValidSize (Length xs)) => x -> WrappedTuple xs -> WrappedTuple xs'
unwrapTuple :: WrappedTuple xs -> Tuple xs
type family Tuple xs
tupleFromNP :: forall xs. (SListI xs, IsValidSize (Length xs)) => NP I xs -> WrappedTuple xs
tupleToNP :: (SListI xs, IsValidSize (Length xs)) => WrappedTuple xs -> NP I xs

-- | Valid tuple sizes
--   
--   GHC does not support tuples larger than 62 fields. We do allow for
--   tuples of zero size (which we interpret as unit <tt>()</tt>) and
--   tuples of size one (where <tt>Tuple '[x] ~ x</tt>).
class KnownNat n => IsValidSize n
isValidSize :: IsValidSize n => ValidSize n
data ValidSize (n :: Nat)
[ValidSize] :: SNat n -> (forall r. TooBig n -> r) -> ValidSize n

-- | Tuples with too many fields (more than 62)
data TooBig (n :: Nat)
[TooBig] :: TooBig ('S ('S ('S ('S ('S ('S ('S ('S ('S ('S ('S ('S ('S ('S ('S ('S ('S ('S ('S ('S ('S ('S ('S ('S ('S ('S ('S ('S ('S ('S ('S ('S ('S ('S ('S ('S ('S ('S ('S ('S ('S ('S ('S ('S ('S ('S ('S ('S ('S ('S ('S ('S ('S ('S ('S ('S ('S ('S ('S ('S ('S ('S ('S n)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))

-- | Smaller tuple sizes are always valid
--   
--   This function is primarily useful when doing recursion on tuples: we
--   may have in scope evidence that <tt>('S n)</tt> is a valid tuple size,
--   and need to know that <tt>n</tt> is a valid tuple size in order to be
--   able to make the recursive call.
smallerIsValid :: forall n r. IsValidSize ('S n) => Proxy ('S n) -> (IsValidSize n => r) -> r

-- | Check the given size is a valid tuple size
toValidSize :: Int -> Maybe (Some ValidSize)

-- | Lift term-level evidence to type-level
liftValidSize :: forall n. ValidSize n -> Dict IsValidSize n

-- | Natural numbers
--   
--   Intended to be used lifted to the type level; unlike <tt>ghc</tt>'s
--   type level natural numbers, these are inductive.
data Nat
Z :: Nat
S :: Nat -> Nat

-- | Singleton for <a>Nat</a>
data SNat (n :: Nat)
[SZ] :: SNat 'Z
[SS] :: SNat n -> SNat ('S n)
class KnownNat (n :: Nat)
singNat :: KnownNat n => SNat n
type family Length (xs :: [k]) :: Nat
data Some (f :: k -> Type)
[Some] :: forall f a. f a -> Some f
mapSome :: (forall x. f x -> g x) -> Some f -> Some g
