-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Existential type: Some
--   
--   This library defines an existential type <a>Some</a>.
--   
--   <pre>
--   data Some f where
--       Some :: f a -&gt; Some f
--   </pre>
--   
--   in few variants, and utilities to work with it.
--   
--   If you are unsure which variant to use, use the one in
--   <a>Data.Some</a> module.
@package some
@version 1.0.6

module Data.EqP

-- | Heterogenous lifted equality.
--   
--   This class is stronger version of <tt>Eq1</tt> from <tt>base</tt>
--   
--   <pre>
--   class (forall a. Eq a =&gt; Eq (f a)) =&gt; Eq1 f where
--       liftEq :: (a -&gt; b -&gt; Bool) -&gt; f a -&gt; f b -&gt; Bool
--   </pre>
--   
--   as we don't require a <tt>a -&gt; b -&gt; Bool</tt> function.
--   
--   Morally <tt>Eq1</tt> should be a superclass of <a>EqP</a>, but it
--   cannot be, as GHC wouldn't allow <a>EqP</a> to be polykinded.
--   <a>https://gitlab.haskell.org/ghc/ghc/-/issues/22682</a>
--   
--   <h2>Laws</h2>
--   
--   <ul>
--   <li><i>reflexivity</i> <tt><a>eqp</a> x x ≡ True</tt></li>
--   <li><i>symmetry</i> <tt><a>eqp</a> x y ≡ <a>eqp</a> y x</tt></li>
--   <li><i>transitivity</i> <tt><a>eqp</a> x y ≡ <a>eqp</a> y z ≡ True ⇒
--   <a>eqp</a> x z ≡ True</tt></li>
--   <li><i>compatibility</i> <tt><a>eqp</a> x y ≡ x <a>==</a> y</tt></li>
--   <li><i>extensionality</i> <tt><a>eqp</a> x y ≡ True ⇒ f x == f y ≡
--   True</tt> for polymorphic <tt>f :: forall x. f x -&gt; a</tt> and
--   <tt><a>Eq</a> a</tt>.</li>
--   </ul>
--   
--   <i>Note:</i> P stands for phantom.
class (forall a. Eq (f a)) => EqP (f :: k -> Type)
eqp :: EqP f => f a -> f b -> Bool
instance forall k (a :: k). Data.EqP.EqP ((Data.Type.Equality.:~:) a)
instance forall k1 k (a :: k1). Data.EqP.EqP ((Data.Type.Equality.:~~:) a)
instance forall k (a :: k -> *) (b :: k -> *). (Data.EqP.EqP a, Data.EqP.EqP b) => Data.EqP.EqP (Data.Functor.Sum.Sum a b)
instance forall k (a :: k -> *) (b :: k -> *). (Data.EqP.EqP a, Data.EqP.EqP b) => Data.EqP.EqP (Data.Functor.Product.Product a b)
instance forall k (f :: k -> *) (g :: k -> *). (Data.EqP.EqP f, Data.EqP.EqP g) => Data.EqP.EqP (f GHC.Generics.:+: g)
instance forall k (a :: k -> *) (b :: k -> *). (Data.EqP.EqP a, Data.EqP.EqP b) => Data.EqP.EqP (a GHC.Generics.:*: b)
instance Data.EqP.EqP Data.Typeable.Internal.TypeRep
instance Data.EqP.EqP GHC.TypeLits.SChar
instance Data.EqP.EqP GHC.TypeLits.SSymbol
instance Data.EqP.EqP GHC.TypeNats.SNat
instance Data.EqP.EqP Data.Proxy.Proxy
instance GHC.Classes.Eq a => Data.EqP.EqP (Data.Functor.Const.Const a)
instance Data.EqP.EqP GHC.StableName.StableName

module Data.GADT.DeepSeq
class GNFData f
grnf :: GNFData f => f a -> ()
instance forall k (a :: k -> *) (b :: k -> *). (Data.GADT.DeepSeq.GNFData a, Data.GADT.DeepSeq.GNFData b) => Data.GADT.DeepSeq.GNFData (Data.Functor.Product.Product a b)
instance forall k (a :: k -> *) (b :: k -> *). (Data.GADT.DeepSeq.GNFData a, Data.GADT.DeepSeq.GNFData b) => Data.GADT.DeepSeq.GNFData (Data.Functor.Sum.Sum a b)
instance forall k (a :: k -> *) (b :: k -> *). (Data.GADT.DeepSeq.GNFData a, Data.GADT.DeepSeq.GNFData b) => Data.GADT.DeepSeq.GNFData (a GHC.Generics.:*: b)
instance forall k (a :: k -> *) (b :: k -> *). (Data.GADT.DeepSeq.GNFData a, Data.GADT.DeepSeq.GNFData b) => Data.GADT.DeepSeq.GNFData (a GHC.Generics.:+: b)
instance forall k (a :: k). Data.GADT.DeepSeq.GNFData ((Data.Type.Equality.:~:) a)
instance forall k1 k (a :: k1). Data.GADT.DeepSeq.GNFData ((Data.Type.Equality.:~~:) a)
instance Data.GADT.DeepSeq.GNFData Data.Typeable.Internal.TypeRep

module Data.GADT.Compare

-- | A class for type-contexts which contain enough information to (at
--   least in some cases) decide the equality of types occurring within
--   them.
--   
--   This class is sometimes confused with <a>TestEquality</a> from base.
--   <a>TestEquality</a> only checks <i>type equality</i>.
--   
--   Consider
--   
--   <pre>
--   &gt;&gt;&gt; data Tag a where TagInt1 :: Tag Int; TagInt2 :: Tag Int
--   </pre>
--   
--   The correct <tt><a>TestEquality</a> Tag</tt> instance is
--   
--   <pre>
--   &gt;&gt;&gt; :{
--   instance TestEquality Tag where
--       testEquality TagInt1 TagInt1 = Just Refl
--       testEquality TagInt1 TagInt2 = Just Refl
--       testEquality TagInt2 TagInt1 = Just Refl
--       testEquality TagInt2 TagInt2 = Just Refl
--   :}
--   </pre>
--   
--   While we can define
--   
--   <pre>
--   instance <a>GEq</a> Tag where
--      <a>geq</a> = <a>testEquality</a>
--   </pre>
--   
--   this will mean we probably want to have
--   
--   <pre>
--   instance <a>Eq</a> Tag where
--      _ <a>==</a> _ = True
--   </pre>
--   
--   <i>Note:</i> In the future version of <tt>some</tt> package (to be
--   released around GHC-9.6 / 9.8) the <tt>forall a. Eq (f a)</tt>
--   constraint will be added as a constraint to <a>GEq</a>, with a law
--   relating <a>GEq</a> and <a>Eq</a>:
--   
--   <pre>
--   <a>geq</a> x y = Just Refl   ⇒  x == y = True        ∀ (x :: f a) (y :: f b)
--   x == y                ≡  isJust (<a>geq</a> x y)     ∀ (x, y :: f a)
--   </pre>
--   
--   So, the more useful <tt><a>GEq</a> Tag</tt> instance would
--   differentiate between different constructors:
--   
--   <pre>
--   &gt;&gt;&gt; :{
--   instance GEq Tag where
--       geq TagInt1 TagInt1 = Just Refl
--       geq TagInt1 TagInt2 = Nothing
--       geq TagInt2 TagInt1 = Nothing
--       geq TagInt2 TagInt2 = Just Refl
--   :}
--   </pre>
--   
--   which is consistent with a derived <a>Eq</a> instance for <tt>Tag</tt>
--   
--   <pre>
--   &gt;&gt;&gt; deriving instance Eq (Tag a)
--   </pre>
--   
--   Note that even if <tt>a ~ b</tt>, the <tt><a>geq</a> (x :: f a) (y ::
--   f b)</tt> may be <a>Nothing</a> (when value terms are inequal).
--   
--   The consistency of <a>GEq</a> and <a>Eq</a> is easy to check by
--   exhaustion:
--   
--   <pre>
--   &gt;&gt;&gt; let checkFwdGEq :: (forall a. Eq (f a), GEq f) =&gt; f a -&gt; f b -&gt; Bool; checkFwdGEq x y = case geq x y of Just Refl -&gt; x == y; Nothing -&gt; True
--   
--   &gt;&gt;&gt; (checkFwdGEq TagInt1 TagInt1, checkFwdGEq TagInt1 TagInt2, checkFwdGEq TagInt2 TagInt1, checkFwdGEq TagInt2 TagInt2)
--   (True,True,True,True)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; let checkBwdGEq :: (Eq (f a), GEq f) =&gt; f a -&gt; f a -&gt; Bool; checkBwdGEq x y = if x == y then isJust (geq x y) else isNothing (geq x y)
--   
--   &gt;&gt;&gt; (checkBwdGEq TagInt1 TagInt1, checkBwdGEq TagInt1 TagInt2, checkBwdGEq TagInt2 TagInt1, checkBwdGEq TagInt2 TagInt2)
--   (True,True,True,True)
--   </pre>
class GEq f

-- | Produce a witness of type-equality, if one exists.
--   
--   A handy idiom for using this would be to pattern-bind in the Maybe
--   monad, eg.:
--   
--   <pre>
--   extract :: GEq tag =&gt; tag a -&gt; DSum tag -&gt; Maybe a
--   extract t1 (t2 :=&gt; x) = do
--       Refl &lt;- geq t1 t2
--       return x
--   </pre>
--   
--   Or in a list comprehension:
--   
--   <pre>
--   extractMany :: GEq tag =&gt; tag a -&gt; [DSum tag] -&gt; [a]
--   extractMany t1 things = [ x | (t2 :=&gt; x) &lt;- things, Refl &lt;- maybeToList (geq t1 t2)]
--   </pre>
--   
--   (Making use of the <tt>DSum</tt> type from <a>Data.Dependent.Sum</a>
--   in both examples)
geq :: GEq f => f a -> f b -> Maybe (a :~: b)

-- | If <tt>f</tt> has a <a>GCompare</a> instance, this function makes a
--   suitable default implementation of <a>geq</a>.
defaultGeq :: GCompare f => f a -> f b -> Maybe (a :~: b)

-- | If <tt>f</tt> has a <a>GEq</a> instance, this function makes a
--   suitable default implementation of <a>(==)</a>.
defaultEq :: GEq f => f a -> f b -> Bool

-- | If <tt>f</tt> has a <a>GEq</a> instance, this function makes a
--   suitable default implementation of <a>(/=)</a>.
defaultNeq :: GEq f => f a -> f b -> Bool

-- | Type class for comparable GADT-like structures. When 2 things are
--   equal, must return a witness that their parameter types are equal as
--   well (<a>GEQ</a>).
class GEq f => GCompare f
gcompare :: GCompare f => f a -> f b -> GOrdering a b
defaultCompare :: GCompare f => f a -> f b -> Ordering

-- | A type for the result of comparing GADT constructors; the type
--   parameters of the GADT values being compared are included so that in
--   the case where they are equal their parameter types can be unified.
data GOrdering a b
[GLT] :: GOrdering a b
[GEQ] :: GOrdering t t
[GGT] :: GOrdering a b

module Data.GADT.Show

-- | <a>Show</a>-like class for 1-type-parameter GADTs. <tt>GShow t =&gt;
--   ...</tt> is equivalent to something like <tt>(forall a. Show (t a))
--   =&gt; ...</tt>. The easiest way to create instances would probably be
--   to write (or derive) an <tt>instance Show (T a)</tt>, and then simply
--   say:
--   
--   <pre>
--   instance GShow t where gshowsPrec = defaultGshowsPrec
--   </pre>
class GShow t
gshowsPrec :: GShow t => Int -> t a -> ShowS

-- | If <tt>f</tt> has a 'Show (f a)' instance, this function makes a
--   suitable default implementation of <a>gshowsPrec</a>.
defaultGshowsPrec :: Show (t a) => Int -> t a -> ShowS
gshows :: GShow t => t a -> ShowS
gshow :: GShow t => t a -> String

-- | <a>Read</a>-like class for 1-type-parameter GADTs. Unlike
--   <a>GShow</a>, this one cannot be mechanically derived from a
--   <a>Read</a> instance because <a>greadsPrec</a> must choose the phantom
--   type based on the <a>String</a> being parsed.
class GRead t
greadsPrec :: GRead t => Int -> GReadS t

-- | <tt>GReadS t</tt> is equivalent to <tt>ReadS (forall b. (forall a. t a
--   -&gt; b) -&gt; b)</tt>, which is in turn equivalent to <tt>ReadS
--   (Exists t)</tt> (with <tt>data Exists t where Exists :: t a -&gt;
--   Exists t</tt>)
type GReadS t = String -> [(Some t, String)]
greads :: GRead t => GReadS t
gread :: GRead t => String -> (forall a. t a -> b) -> b

-- | <pre>
--   &gt;&gt;&gt; greadMaybe "InL Refl" mkSome :: Maybe (Some (Sum ((:~:) Int) ((:~:) Bool)))
--   Just (mkSome (InL Refl))
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; greadMaybe "L1 Refl" mkSome :: Maybe (Some ((:~:) Int :+: (:~:) Bool))
--   Just (mkSome (L1 Refl))
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; greadMaybe "garbage" mkSome :: Maybe (Some ((:~:) Int))
--   Nothing
--   </pre>
greadMaybe :: GRead t => String -> (forall a. t a -> b) -> Maybe b
getGReadResult :: Some tag -> (forall a. tag a -> b) -> b
mkGReadResult :: tag a -> Some tag

module Data.OrdP

-- | Heterogenous lifted total order.
--   
--   This class is stronger version of <tt>Ord1</tt> from <tt>base</tt>
--   
--   <pre>
--   class (forall a. Ord a =&gt; Ord (f a)) =&gt; Ord1 f where
--       liftCompare :: (a -&gt; b -&gt; Ordering) -&gt; f a -&gt; f b -&gt; Ordering
--   </pre>
class (EqP f, forall a. Ord (f a)) => OrdP (f :: k -> Type)
comparep :: OrdP f => f a -> f b -> Ordering
instance forall k (a :: k). Data.OrdP.OrdP ((Data.Type.Equality.:~:) a)
instance forall k1 k (a :: k1). Data.OrdP.OrdP ((Data.Type.Equality.:~~:) a)
instance forall k (a :: k -> *) (b :: k -> *). (Data.OrdP.OrdP a, Data.OrdP.OrdP b) => Data.OrdP.OrdP (Data.Functor.Sum.Sum a b)
instance forall k (a :: k -> *) (b :: k -> *). (Data.OrdP.OrdP a, Data.OrdP.OrdP b) => Data.OrdP.OrdP (Data.Functor.Product.Product a b)
instance forall k (f :: k -> *) (g :: k -> *). (Data.OrdP.OrdP f, Data.OrdP.OrdP g) => Data.OrdP.OrdP (f GHC.Generics.:+: g)
instance forall k (a :: k -> *) (b :: k -> *). (Data.OrdP.OrdP a, Data.OrdP.OrdP b) => Data.OrdP.OrdP (a GHC.Generics.:*: b)
instance Data.OrdP.OrdP Data.Typeable.Internal.TypeRep
instance Data.OrdP.OrdP GHC.TypeLits.SChar
instance Data.OrdP.OrdP GHC.TypeLits.SSymbol
instance Data.OrdP.OrdP GHC.TypeNats.SNat
instance Data.OrdP.OrdP Data.Proxy.Proxy
instance GHC.Classes.Ord a => Data.OrdP.OrdP (Data.Functor.Const.Const a)

module Data.Some.Church

-- | Existential. This is type is useful to hide GADTs' parameters.
--   
--   <pre>
--   &gt;&gt;&gt; data Tag :: * -&gt; * where TagInt :: Tag Int; TagBool :: Tag Bool
--   
--   &gt;&gt;&gt; instance GShow Tag where gshowsPrec _ TagInt = showString "TagInt"; gshowsPrec _ TagBool = showString "TagBool"
--   
--   &gt;&gt;&gt; classify s = case s of "TagInt" -&gt; [mkGReadResult TagInt]; "TagBool" -&gt; [mkGReadResult TagBool]; _ -&gt; []
--   
--   &gt;&gt;&gt; instance GRead Tag where greadsPrec _ s = [ (r, rest) | (con, rest) &lt;-  lex s, r &lt;- classify con ]
--   </pre>
--   
--   With Church-encoding youcan only use a functions:
--   
--   <pre>
--   &gt;&gt;&gt; let y = mkSome TagBool
--   
--   &gt;&gt;&gt; y
--   mkSome TagBool
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; withSome y $ \y' -&gt; case y' of { TagInt -&gt; "I"; TagBool -&gt; "B" } :: String
--   "B"
--   </pre>
--   
--   or explicitly work with <a>S</a>
--   
--   <pre>
--   &gt;&gt;&gt; let x = S $ \f -&gt; f TagInt
--   
--   &gt;&gt;&gt; x
--   mkSome TagInt
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; case x of S f -&gt; f $ \x' -&gt; case x' of { TagInt -&gt; "I"; TagBool -&gt; "B" } :: String
--   "I"
--   </pre>
--   
--   The implementation of <a>mapSome</a> is <i>safe</i>.
--   
--   <pre>
--   &gt;&gt;&gt; let f :: Tag a -&gt; Tag a; f TagInt = TagInt; f TagBool = TagBool
--   
--   &gt;&gt;&gt; mapSome f y
--   mkSome TagBool
--   </pre>
--   
--   but you can also use:
--   
--   <pre>
--   &gt;&gt;&gt; withSome y (mkSome . f)
--   mkSome TagBool
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; read "Some TagBool" :: Some Tag
--   mkSome TagBool
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; read "mkSome TagInt" :: Some Tag
--   mkSome TagInt
--   </pre>
newtype Some tag
S :: (forall r. (forall a. tag a -> r) -> r) -> Some tag

-- | Eliminator.
[withSome] :: Some tag -> forall r. (forall a. tag a -> r) -> r

-- | Constructor.
mkSome :: tag a -> Some tag

-- | Map over argument.
mapSome :: (forall x. f x -> g x) -> Some f -> Some g

-- | Monadic <a>withSome</a>.
withSomeM :: Monad m => m (Some tag) -> (forall a. tag a -> m r) -> m r

-- | <pre>
--   <a>flip</a> <a>withSome</a>
--   </pre>
foldSome :: (forall a. tag a -> b) -> Some tag -> b

-- | Traverse over argument.
traverseSome :: Functor m => (forall a. f a -> m (g a)) -> Some f -> m (Some g)

module Data.Some.GADT

-- | Existential. This is type is useful to hide GADTs' parameters.
--   
--   <pre>
--   &gt;&gt;&gt; data Tag :: Type -&gt; Type where TagInt :: Tag Int; TagBool :: Tag Bool
--   
--   &gt;&gt;&gt; instance GShow Tag where gshowsPrec _ TagInt = showString "TagInt"; gshowsPrec _ TagBool = showString "TagBool"
--   
--   &gt;&gt;&gt; classify s = case s of "TagInt" -&gt; [mkGReadResult TagInt]; "TagBool" -&gt; [mkGReadResult TagBool]; _ -&gt; []
--   
--   &gt;&gt;&gt; instance GRead Tag where greadsPrec _ s = [ (r, rest) | (con, rest) &lt;-  lex s, r &lt;- classify con ]
--   </pre>
--   
--   You can either use constructor:
--   
--   <pre>
--   &gt;&gt;&gt; let x = Some TagInt
--   
--   &gt;&gt;&gt; x
--   Some TagInt
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; case x of { Some TagInt -&gt; "I"; Some TagBool -&gt; "B" } :: String
--   "I"
--   </pre>
--   
--   or you can use functions
--   
--   <pre>
--   &gt;&gt;&gt; let y = mkSome TagBool
--   
--   &gt;&gt;&gt; y
--   Some TagBool
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; withSome y $ \y' -&gt; case y' of { TagInt -&gt; "I"; TagBool -&gt; "B" } :: String
--   "B"
--   </pre>
--   
--   The implementation of <a>mapSome</a> is <i>safe</i>.
--   
--   <pre>
--   &gt;&gt;&gt; let f :: Tag a -&gt; Tag a; f TagInt = TagInt; f TagBool = TagBool
--   
--   &gt;&gt;&gt; mapSome f y
--   Some TagBool
--   </pre>
--   
--   but you can also use:
--   
--   <pre>
--   &gt;&gt;&gt; withSome y (mkSome . f)
--   Some TagBool
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; read "Some TagBool" :: Some Tag
--   Some TagBool
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; read "mkSome TagInt" :: Some Tag
--   Some TagInt
--   </pre>
data Some tag
[Some] :: tag a -> Some tag

-- | Constructor.
mkSome :: tag a -> Some tag

-- | Eliminator.
withSome :: Some tag -> (forall a. tag a -> b) -> b

-- | Monadic <a>withSome</a>.
withSomeM :: Monad m => m (Some tag) -> (forall a. tag a -> m r) -> m r

-- | Map over argument.
mapSome :: (forall x. f x -> g x) -> Some f -> Some g

-- | <pre>
--   <a>flip</a> <a>withSome</a>
--   </pre>
foldSome :: (forall a. tag a -> b) -> Some tag -> b

-- | Traverse over argument.
traverseSome :: Functor m => (forall a. f a -> m (g a)) -> Some f -> m (Some g)
instance forall k (tag :: k -> *). Data.GADT.Internal.GShow tag => GHC.Show.Show (Data.Some.GADT.Some tag)
instance forall k (f :: k -> *). Data.GADT.Internal.GRead f => GHC.Read.Read (Data.Some.GADT.Some f)
instance forall k (tag :: k -> *). Data.GADT.Internal.GEq tag => GHC.Classes.Eq (Data.Some.GADT.Some tag)
instance forall k (tag :: k -> *). Data.GADT.Internal.GCompare tag => GHC.Classes.Ord (Data.Some.GADT.Some tag)
instance forall k (tag :: k -> *). Data.GADT.DeepSeq.GNFData tag => Control.DeepSeq.NFData (Data.Some.GADT.Some tag)
instance GHC.Base.Applicative m => GHC.Base.Semigroup (Data.Some.GADT.Some m)
instance GHC.Base.Applicative m => GHC.Base.Monoid (Data.Some.GADT.Some m)

module Data.Some.Newtype

-- | Existential. This is type is useful to hide GADTs' parameters.
--   
--   <pre>
--   &gt;&gt;&gt; data Tag :: Type -&gt; Type where TagInt :: Tag Int; TagBool :: Tag Bool
--   
--   &gt;&gt;&gt; instance GShow Tag where gshowsPrec _ TagInt = showString "TagInt"; gshowsPrec _ TagBool = showString "TagBool"
--   
--   &gt;&gt;&gt; classify s = case s of "TagInt" -&gt; [mkGReadResult TagInt]; "TagBool" -&gt; [mkGReadResult TagBool]; _ -&gt; []
--   
--   &gt;&gt;&gt; instance GRead Tag where greadsPrec _ s = [ (r, rest) | (con, rest) &lt;-  lex s, r &lt;- classify con ]
--   </pre>
--   
--   You can either use <tt>PatternSynonyms</tt> (available with GHC &gt;=
--   8.0)
--   
--   <pre>
--   &gt;&gt;&gt; let x = Some TagInt
--   
--   &gt;&gt;&gt; x
--   Some TagInt
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; case x of { Some TagInt -&gt; "I"; Some TagBool -&gt; "B" } :: String
--   "I"
--   </pre>
--   
--   or you can use functions
--   
--   <pre>
--   &gt;&gt;&gt; let y = mkSome TagBool
--   
--   &gt;&gt;&gt; y
--   Some TagBool
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; withSome y $ \y' -&gt; case y' of { TagInt -&gt; "I"; TagBool -&gt; "B" } :: String
--   "B"
--   </pre>
--   
--   The implementation of <a>mapSome</a> is <i>safe</i>.
--   
--   <pre>
--   &gt;&gt;&gt; let f :: Tag a -&gt; Tag a; f TagInt = TagInt; f TagBool = TagBool
--   
--   &gt;&gt;&gt; mapSome f y
--   Some TagBool
--   </pre>
--   
--   but you can also use:
--   
--   <pre>
--   &gt;&gt;&gt; withSome y (mkSome . f)
--   Some TagBool
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; read "Some TagBool" :: Some Tag
--   Some TagBool
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; read "mkSome TagInt" :: Some Tag
--   Some TagInt
--   </pre>
data Some tag
pattern Some :: tag a -> Some tag

-- | Constructor.
mkSome :: tag a -> Some tag

-- | Eliminator.
withSome :: Some tag -> (forall a. tag a -> b) -> b

-- | Monadic <a>withSome</a>.
withSomeM :: Monad m => m (Some tag) -> (forall a. tag a -> m r) -> m r

-- | Map over argument.
mapSome :: (forall t. f t -> g t) -> Some f -> Some g

-- | <pre>
--   <a>flip</a> <a>withSome</a>
--   </pre>
foldSome :: (forall a. tag a -> b) -> Some tag -> b

-- | Traverse over argument.
traverseSome :: Functor m => (forall a. f a -> m (g a)) -> Some f -> m (Some g)
instance forall k (tag :: k -> *). Data.GADT.Internal.GShow tag => GHC.Show.Show (Data.Some.Newtype.Some tag)
instance forall k (f :: k -> *). Data.GADT.Internal.GRead f => GHC.Read.Read (Data.Some.Newtype.Some f)
instance forall k (tag :: k -> *). Data.GADT.Internal.GEq tag => GHC.Classes.Eq (Data.Some.Newtype.Some tag)
instance forall k (tag :: k -> *). Data.GADT.Internal.GCompare tag => GHC.Classes.Ord (Data.Some.Newtype.Some tag)
instance forall k (tag :: k -> *). Data.GADT.DeepSeq.GNFData tag => Control.DeepSeq.NFData (Data.Some.Newtype.Some tag)
instance GHC.Base.Applicative m => GHC.Base.Semigroup (Data.Some.Newtype.Some m)
instance GHC.Base.Applicative m => GHC.Base.Monoid (Data.Some.Newtype.Some m)


-- | An existential type.
--   
--   The constructor is exported only on GHC-8 and later.
module Data.Some

-- | Existential. This is type is useful to hide GADTs' parameters.
--   
--   <pre>
--   &gt;&gt;&gt; data Tag :: Type -&gt; Type where TagInt :: Tag Int; TagBool :: Tag Bool
--   
--   &gt;&gt;&gt; instance GShow Tag where gshowsPrec _ TagInt = showString "TagInt"; gshowsPrec _ TagBool = showString "TagBool"
--   
--   &gt;&gt;&gt; classify s = case s of "TagInt" -&gt; [mkGReadResult TagInt]; "TagBool" -&gt; [mkGReadResult TagBool]; _ -&gt; []
--   
--   &gt;&gt;&gt; instance GRead Tag where greadsPrec _ s = [ (r, rest) | (con, rest) &lt;-  lex s, r &lt;- classify con ]
--   </pre>
--   
--   You can either use <tt>PatternSynonyms</tt> (available with GHC &gt;=
--   8.0)
--   
--   <pre>
--   &gt;&gt;&gt; let x = Some TagInt
--   
--   &gt;&gt;&gt; x
--   Some TagInt
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; case x of { Some TagInt -&gt; "I"; Some TagBool -&gt; "B" } :: String
--   "I"
--   </pre>
--   
--   or you can use functions
--   
--   <pre>
--   &gt;&gt;&gt; let y = mkSome TagBool
--   
--   &gt;&gt;&gt; y
--   Some TagBool
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; withSome y $ \y' -&gt; case y' of { TagInt -&gt; "I"; TagBool -&gt; "B" } :: String
--   "B"
--   </pre>
--   
--   The implementation of <a>mapSome</a> is <i>safe</i>.
--   
--   <pre>
--   &gt;&gt;&gt; let f :: Tag a -&gt; Tag a; f TagInt = TagInt; f TagBool = TagBool
--   
--   &gt;&gt;&gt; mapSome f y
--   Some TagBool
--   </pre>
--   
--   but you can also use:
--   
--   <pre>
--   &gt;&gt;&gt; withSome y (mkSome . f)
--   Some TagBool
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; read "Some TagBool" :: Some Tag
--   Some TagBool
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; read "mkSome TagInt" :: Some Tag
--   Some TagInt
--   </pre>
data Some tag
pattern Some :: tag a -> Some tag

-- | Constructor.
mkSome :: tag a -> Some tag

-- | Eliminator.
withSome :: Some tag -> (forall a. tag a -> b) -> b

-- | Monadic <a>withSome</a>.
withSomeM :: Monad m => m (Some tag) -> (forall a. tag a -> m r) -> m r

-- | Map over argument.
mapSome :: (forall t. f t -> g t) -> Some f -> Some g

-- | <pre>
--   <a>flip</a> <a>withSome</a>
--   </pre>
foldSome :: (forall a. tag a -> b) -> Some tag -> b

-- | Traverse over argument.
traverseSome :: Functor m => (forall a. f a -> m (g a)) -> Some f -> m (Some g)
