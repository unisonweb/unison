<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><link rel="stylesheet" type="text/css" href="style.css" /><script type="text/javascript" src="highlight.js"></script></head><body><pre><span class="hs-comment">-- | The &quot;decl coherency check&quot;: a type declaration in a namespace is &quot;coherent&quot; if it satisfies both of the following</span><span>
</span><span id="line-2"></span><span class="hs-comment">-- criteria.</span><span>
</span><span id="line-3"></span><span class="hs-comment">--</span><span>
</span><span id="line-4"></span><span class="hs-comment">--   1. For each naming of the type decl (say &quot;Foo&quot;#foohash), there exists exactly one name for each of its constructors</span><span>
</span><span id="line-5"></span><span class="hs-comment">--      arbitrarily deep in the corresponding namespace (&quot;Foo&quot; in this example).</span><span>
</span><span id="line-6"></span><span class="hs-comment">--</span><span>
</span><span id="line-7"></span><span class="hs-comment">--      This allows us to render the decl naturally, as in</span><span>
</span><span id="line-8"></span><span class="hs-comment">--</span><span>
</span><span id="line-9"></span><span class="hs-comment">--        structural type Foo</span><span>
</span><span id="line-10"></span><span class="hs-comment">--          = Bar Nat Int</span><span>
</span><span id="line-11"></span><span class="hs-comment">--          | internal.hello.Bonk Nat</span><span>
</span><span id="line-12"></span><span class="hs-comment">--</span><span>
</span><span id="line-13"></span><span class="hs-comment">--      which corresponds to the three names</span><span>
</span><span id="line-14"></span><span class="hs-comment">--</span><span>
</span><span id="line-15"></span><span class="hs-comment">--        &quot;Foo&quot;                     =&gt; #foohash</span><span>
</span><span id="line-16"></span><span class="hs-comment">--        &quot;Foo.Bar&quot;                 =&gt; #foohash#0</span><span>
</span><span id="line-17"></span><span class="hs-comment">--        &quot;Foo.internal.hello.Bonk&quot; =&gt; #foohash#1</span><span>
</span><span id="line-18"></span><span class="hs-comment">--</span><span>
</span><span id="line-19"></span><span class="hs-comment">--      We could not do if there was at least one constructor whose full name does not contain the full name of the type</span><span>
</span><span id="line-20"></span><span class="hs-comment">--      decl itself as a prefix.</span><span>
</span><span id="line-21"></span><span class="hs-comment">--</span><span>
</span><span id="line-22"></span><span class="hs-comment">--      A notable consequence of this requirement is that a second naming of a decl (i.e. an alias) cannot be embedded</span><span>
</span><span id="line-23"></span><span class="hs-comment">--      within the first naming, as in:</span><span>
</span><span id="line-24"></span><span class="hs-comment">--</span><span>
</span><span id="line-25"></span><span class="hs-comment">--        type Foo = ...</span><span>
</span><span id="line-26"></span><span class="hs-comment">--        type Foo.some.inner.namespace = ... -- an alias of Foo</span><span>
</span><span id="line-27"></span><span class="hs-comment">--</span><span>
</span><span id="line-28"></span><span class="hs-comment">--   2. No constructor has a &quot;stray&quot; name that does not have a prefix that equals the type declaration's name. For</span><span>
</span><span id="line-29"></span><span class="hs-comment">--      example, in the namespace</span><span>
</span><span id="line-30"></span><span class="hs-comment">--</span><span>
</span><span id="line-31"></span><span class="hs-comment">--        &quot;Foo&quot;                 =&gt; #foohash</span><span>
</span><span id="line-32"></span><span class="hs-comment">--        &quot;Foo.Bar&quot;             =&gt; #foohash#0</span><span>
</span><span id="line-33"></span><span class="hs-comment">--        &quot;Deep.What.SomeAlias&quot; =&gt; #foohash#0</span><span>
</span><span id="line-34"></span><span class="hs-comment">--</span><span>
</span><span id="line-35"></span><span class="hs-comment">--      the constructor &quot;What.SomeAlias&quot; is &quot;stray&quot;, as the type decl #foohash has no name that matches any prefix</span><span>
</span><span id="line-36"></span><span class="hs-comment">--      (i.e. &quot;Deep.What&quot; nor &quot;Deep&quot;).</span><span>
</span><span id="line-37"></span><span class="hs-comment">--</span><span>
</span><span id="line-38"></span><span class="hs-comment">-- On to the implementation. We are going to traverse the namespace depth-first. As we go, we have a stateful mapping</span><span>
</span><span id="line-39"></span><span class="hs-comment">-- between decl reference that we *have* seen a name for in one of our parent namespace, and its corresponding set of</span><span>
</span><span id="line-40"></span><span class="hs-comment">-- constructors that we *haven't* yet seen names for, but expect to, before fully searching the corresponding</span><span>
</span><span id="line-41"></span><span class="hs-comment">-- sub-namespace (e.g. the child namespace named &quot;Foo&quot; of the namepace that declares a decl &quot;Foo&quot;).</span><span>
</span><span id="line-42"></span><span class="hs-comment">--</span><span>
</span><span id="line-43"></span><span class="hs-comment">-- When processing a namespace, we first process all terms. Each constructor will fall into one of three cases:</span><span>
</span><span id="line-44"></span><span class="hs-comment">--</span><span>
</span><span id="line-45"></span><span class="hs-comment">-- &gt; +----------------------------------------------------------------------------------------------------------------+</span><span>
</span><span id="line-46"></span><span class="hs-comment">-- &gt; | Case         | Mapping before       | Encountered constructor | Mapping after                                  |</span><span>
</span><span id="line-47"></span><span class="hs-comment">-- &gt; +----------------------------------------------------------------------------------------------------------------+</span><span>
</span><span id="line-48"></span><span class="hs-comment">-- &gt; | Happy path   | { #foo : {0, 1, 2} } | #foo#1                  | { #foo : {0, 2} }                              |</span><span>
</span><span id="line-49"></span><span class="hs-comment">-- &gt; | Already seen | { #foo : {0, 1, 2} } | #foo#5                  | Error: duplicate naming for constructor #foo#5 |</span><span>
</span><span id="line-50"></span><span class="hs-comment">-- &gt; | Never seen   | { #foo : {0, 1, 2} } | #bar#2                  | Error: stray constructor #bar#2                |</span><span>
</span><span id="line-51"></span><span class="hs-comment">-- &gt; +----------------------------------------------------------------------------------------------------------------+</span><span>
</span><span id="line-52"></span><span class="hs-comment">--</span><span>
</span><span id="line-53"></span><span class="hs-comment">-- In &quot;happy path&quot;, we see a naming of a constructor that we're expecting, and check it off.</span><span>
</span><span id="line-54"></span><span class="hs-comment">-- In &quot;already seen&quot;, we see a second naming of a constructor that we're no longer expecting, and fail.</span><span>
</span><span id="line-55"></span><span class="hs-comment">-- In &quot;never seen&quot;, we see a naming of a constructor before any naming of its decl, so we fail.</span><span>
</span><span id="line-56"></span><span class="hs-comment">--</span><span>
</span><span id="line-57"></span><span class="hs-comment">-- Next, we process all type decls. Each will again fall into one of three cases:</span><span>
</span><span id="line-58"></span><span class="hs-comment">--</span><span>
</span><span id="line-59"></span><span class="hs-comment">-- &gt; +-----------------------------------------------------------------------------------------------------+</span><span>
</span><span id="line-60"></span><span class="hs-comment">-- &gt; | Case             | Mapping before       | Declaration | Num constructors | New mapping              |</span><span>
</span><span id="line-61"></span><span class="hs-comment">-- &gt; +-----------------------------------------------------------------------------------------------------+</span><span>
</span><span id="line-62"></span><span class="hs-comment">-- &gt; | Uninhabited decl |                      | #foo        | 0                |                          |</span><span>
</span><span id="line-63"></span><span class="hs-comment">-- &gt; | Inhabited decl   |                      | #foo        | 1 or more        | { #foo : {0, ..., n-1} } |</span><span>
</span><span id="line-64"></span><span class="hs-comment">-- &gt; | Already seen     | { foo : {0, 1, 2}  } | #foo        | Irrelevant       | Error: nested decl alias |</span><span>
</span><span id="line-65"></span><span class="hs-comment">-- &gt; +-----------------------------------------------------------------------------------------------------+</span><span>
</span><span id="line-66"></span><span class="hs-comment">--</span><span>
</span><span id="line-67"></span><span class="hs-comment">-- In &quot;uninhabited decl&quot;, we find a decl with no constructors, so we don't expect anything new.</span><span>
</span><span id="line-68"></span><span class="hs-comment">-- In &quot;already seen&quot;, we find a second naming of a decl, whose constructors will necessarily violate coherency condition</span><span>
</span><span id="line-69"></span><span class="hs-comment">--   (1) above.</span><span>
</span><span id="line-70"></span><span class="hs-comment">--</span><span>
</span><span id="line-71"></span><span class="hs-comment">-- In &quot;inhabited decl&quot;, we find a decl with N constructors, and handle it by:</span><span>
</span><span id="line-72"></span><span class="hs-comment">--   1. Adding to our state that we expect a name for each.</span><span>
</span><span id="line-73"></span><span class="hs-comment">--   2. Recursing into the child namespace whose name matches the decl.</span><span>
</span><span id="line-74"></span><span class="hs-comment">--   3. (If we return from the recursion without short-circuiting) remove the mapping added in step (1) and assert that</span><span>
</span><span id="line-75"></span><span class="hs-comment">--      its value is the empty set (meaning we encountered a name for every constructor).</span><span>
</span><span id="line-76"></span><span class="hs-comment">--</span><span>
</span><span id="line-77"></span><span class="hs-comment">-- Note: This check could be moved into SQLite (with sufficient schema support) some day, but for now, we just do this</span><span>
</span><span id="line-78"></span><span class="hs-comment">-- in memory.</span><span>
</span><span id="line-79"></span><span class="hs-comment">--</span><span>
</span><span id="line-80"></span><span class="hs-comment">-- Note: once upon a time, decls could be &quot;incoherent&quot;. Then, we decided we want decls to be &quot;coherent&quot;. Thus, this</span><span>
</span><span id="line-81"></span><span class="hs-comment">-- machinery was invented.</span><span>
</span><span id="line-82"></span><span class="hs-keyword">module</span><span> </span><span class="hs-identifier">Unison.Merge.DeclCoherencyCheck</span><span>
</span><span id="line-83"></span><span>  </span><span class="hs-special">(</span><span> </span><span class="annot"><a href="Unison.Merge.DeclCoherencyCheck.html#IncoherentDeclReason"><span class="hs-identifier">IncoherentDeclReason</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span>
</span><span id="line-84"></span><span>    </span><span class="annot"><a href="Unison.Merge.DeclCoherencyCheck.html#checkDeclCoherency"><span class="hs-identifier">checkDeclCoherency</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-85"></span><span>    </span><span class="annot"><a href="Unison.Merge.DeclCoherencyCheck.html#lenientCheckDeclCoherency"><span class="hs-identifier">lenientCheckDeclCoherency</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-86"></span><span>
</span><span id="line-87"></span><span>    </span><span class="annot"><span class="hs-comment">-- * Getting all failures rather than just the first</span></span><span>
</span><span id="line-88"></span><span>    </span><span class="annot"><a href="Unison.Merge.DeclCoherencyCheck.html#IncoherentDeclReasons"><span class="hs-identifier">IncoherentDeclReasons</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span>
</span><span id="line-89"></span><span>    </span><span class="annot"><a href="Unison.Merge.DeclCoherencyCheck.html#checkAllDeclCoherency"><span class="hs-identifier">checkAllDeclCoherency</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-90"></span><span>  </span><span class="hs-special">)</span><span>
</span><span id="line-91"></span><span class="hs-keyword">where</span><span>
</span><span id="line-92"></span><span>
</span><span id="line-93"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Control.Lens</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-operator">(%=)</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-operator">(.=)</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">_2</span></span><span class="hs-special">)</span><span>
</span><span id="line-94"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Control.Monad.State.Strict</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">StateT</span></span><span class="hs-special">)</span><span>
</span><span id="line-95"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Control.Monad.State.Strict</span></span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">State</span></span><span>
</span><span id="line-96"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Control.Monad.Trans.State.Strict</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">State</span></span><span class="hs-special">)</span><span>
</span><span id="line-97"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Data.Functor.Compose</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">Compose</span></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-98"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Data.IntMap.Strict</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">IntMap</span></span><span class="hs-special">)</span><span>
</span><span id="line-99"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Data.IntMap.Strict</span></span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">IntMap</span></span><span>
</span><span id="line-100"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Data.List</span></span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">List</span></span><span>
</span><span id="line-101"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Data.List.NonEmpty</span></span><span> </span><span class="hs-special">(</span><span class="hs-keyword">pattern</span><span> </span><span class="annot"><span class="hs-operator">(:|)</span></span><span class="hs-special">)</span><span>
</span><span id="line-102"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Data.Map.Strict</span></span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">Map</span></span><span>
</span><span id="line-103"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Data.Maybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">fromJust</span></span><span class="hs-special">)</span><span>
</span><span id="line-104"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Data.Set</span></span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">Set</span></span><span>
</span><span id="line-105"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">U.Codebase.Reference</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">Reference'</span></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">TypeReference</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">TypeReferenceId</span></span><span class="hs-special">)</span><span>
</span><span id="line-106"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Unison.ConstructorReference</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">GConstructorReference</span></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-107"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Unison.DataDeclaration.ConstructorId</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">ConstructorId</span></span><span class="hs-special">)</span><span>
</span><span id="line-108"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Unison.DeclNameLookup</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">DeclNameLookup</span></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-109"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Unison.Merge.PartialDeclNameLookup.html"><span class="hs-identifier">Unison.Merge.PartialDeclNameLookup</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Unison.Merge.PartialDeclNameLookup.html#PartialDeclNameLookup"><span class="hs-identifier">PartialDeclNameLookup</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-110"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Unison.Name</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">Name</span></span><span class="hs-special">)</span><span>
</span><span id="line-111"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Unison.Name</span></span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">Name</span></span><span>
</span><span id="line-112"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Unison.NameSegment</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">NameSegment</span></span><span class="hs-special">)</span><span>
</span><span id="line-113"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Unison.Prelude</span></span><span>
</span><span id="line-114"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Unison.Reference</span></span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">Reference</span></span><span>
</span><span id="line-115"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Unison.Referent</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">Referent</span></span><span class="hs-special">)</span><span>
</span><span id="line-116"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Unison.Referent</span></span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">Referent</span></span><span>
</span><span id="line-117"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Unison.Util.Defns</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">Defns</span></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">DefnsF</span></span><span class="hs-special">)</span><span>
</span><span id="line-118"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Unison.Util.Map</span></span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">Map</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">deleteLookup</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">deleteLookupJust</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">upsertF</span></span><span class="hs-special">)</span><span>
</span><span id="line-119"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Unison.Util.Nametree</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">Nametree</span></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-120"></span><span>
</span><span id="line-121"></span><span class="hs-keyword">data</span><span> </span><span id="IncoherentDeclReason"><span class="annot"><a href="Unison.Merge.DeclCoherencyCheck.html#IncoherentDeclReason"><span class="hs-identifier hs-var">IncoherentDeclReason</span></a></span></span><span>
</span><span id="line-122"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="hs-comment">-- | A second naming of a constructor was discovered underneath a decl's name, e.g.</span><span>
</span><span id="line-123"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-124"></span><span>    </span><span class="hs-comment">--   Foo#Foo</span><span>
</span><span id="line-125"></span><span>    </span><span class="hs-comment">--   Foo.Bar#Foo#0</span><span>
</span><span id="line-126"></span><span>    </span><span class="hs-comment">--   Foo.Some.Other.Name.For.Bar#Foo#0</span><span>
</span><span id="line-127"></span><span>    </span><span id="IncoherentDeclReason%27ConstructorAlias"><span class="annot"><a href="Unison.Merge.DeclCoherencyCheck.html#IncoherentDeclReason%27ConstructorAlias"><span class="hs-identifier hs-var">IncoherentDeclReason'ConstructorAlias</span></a></span></span><span> </span><span class="hs-glyph">!</span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="hs-glyph">!</span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="hs-glyph">!</span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="hs-comment">-- type, first constructor, second constructor</span><span>
</span><span id="line-128"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="IncoherentDeclReason%27MissingConstructorName"><span class="annot"><a href="Unison.Merge.DeclCoherencyCheck.html#IncoherentDeclReason%27MissingConstructorName"><span class="hs-identifier hs-var">IncoherentDeclReason'MissingConstructorName</span></a></span></span><span> </span><span class="hs-glyph">!</span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span>
</span><span id="line-129"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="hs-comment">-- | A second naming of a decl was discovered underneath its name, e.g.</span><span>
</span><span id="line-130"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-131"></span><span>    </span><span class="hs-comment">--   Foo#Foo</span><span>
</span><span id="line-132"></span><span>    </span><span class="hs-comment">--   Foo.Bar#Foo</span><span>
</span><span id="line-133"></span><span>    </span><span id="IncoherentDeclReason%27NestedDeclAlias"><span class="annot"><a href="Unison.Merge.DeclCoherencyCheck.html#IncoherentDeclReason%27NestedDeclAlias"><span class="hs-identifier hs-var">IncoherentDeclReason'NestedDeclAlias</span></a></span></span><span> </span><span class="hs-glyph">!</span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="hs-glyph">!</span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="hs-comment">-- shorter name, longer name</span><span>
</span><span id="line-134"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="IncoherentDeclReason%27StrayConstructor"><span class="annot"><a href="Unison.Merge.DeclCoherencyCheck.html#IncoherentDeclReason%27StrayConstructor"><span class="hs-identifier hs-var">IncoherentDeclReason'StrayConstructor</span></a></span></span><span> </span><span class="hs-glyph">!</span><span class="annot"><span class="hs-identifier hs-type">TypeReferenceId</span></span><span> </span><span class="hs-glyph">!</span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span>
</span><span id="line-135"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="annot"><span class="hs-keyword">stock</span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621679184885"><span id="local-6989586621679184903"><span id="local-6989586621679184907"><span class="annot"><span class="annottext">Int -&gt; IncoherentDeclReason -&gt; ShowS
[IncoherentDeclReason] -&gt; ShowS
IncoherentDeclReason -&gt; String
(Int -&gt; IncoherentDeclReason -&gt; ShowS)
-&gt; (IncoherentDeclReason -&gt; String)
-&gt; ([IncoherentDeclReason] -&gt; ShowS)
-&gt; Show IncoherentDeclReason
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
$cshowsPrec :: Int -&gt; IncoherentDeclReason -&gt; ShowS
showsPrec :: Int -&gt; IncoherentDeclReason -&gt; ShowS
$cshow :: IncoherentDeclReason -&gt; String
show :: IncoherentDeclReason -&gt; String
$cshowList :: [IncoherentDeclReason] -&gt; ShowS
showList :: [IncoherentDeclReason] -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">)</span><span>
</span><span id="line-136"></span><span>
</span><span id="line-137"></span><span class="annot"><a href="Unison.Merge.DeclCoherencyCheck.html#checkDeclCoherency"><span class="hs-identifier hs-type">checkDeclCoherency</span></a></span><span> </span><span class="hs-glyph">::</span><span>
</span><span id="line-138"></span><span>  </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">HasCallStack</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span>
</span><span id="line-139"></span><span>  </span><span class="annot"><span class="hs-identifier hs-type">Nametree</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">DefnsF</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Map</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">NameSegment</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Referent</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">TypeReference</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-140"></span><span>  </span><span class="annot"><span class="hs-identifier hs-type">Map</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">TypeReferenceId</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-141"></span><span>  </span><span class="annot"><span class="hs-identifier hs-type">Either</span></span><span> </span><span class="annot"><a href="Unison.Merge.DeclCoherencyCheck.html#IncoherentDeclReason"><span class="hs-identifier hs-type">IncoherentDeclReason</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">DeclNameLookup</span></span><span>
</span><span id="line-142"></span><span id="checkDeclCoherency"><span class="annot"><span class="annottext">checkDeclCoherency :: HasCallStack =&gt;
Nametree (DefnsF (Map NameSegment) Referent TypeReference)
-&gt; Map (Id' Hash) Int -&gt; Either IncoherentDeclReason DeclNameLookup
</span><a href="Unison.Merge.DeclCoherencyCheck.html#checkDeclCoherency"><span class="hs-identifier hs-var hs-var">checkDeclCoherency</span></a></span></span><span> </span><span id="local-6989586621679184916"><span class="annot"><span class="annottext">Nametree (DefnsF (Map NameSegment) Referent TypeReference)
</span><a href="#local-6989586621679184916"><span class="hs-identifier hs-var">nametree</span></a></span></span><span> </span><span id="local-6989586621679184917"><span class="annot"><span class="annottext">Map (Id' Hash) Int
</span><a href="#local-6989586621679184917"><span class="hs-identifier hs-var">numConstructorsById</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-143"></span><span>  </span><span class="annot"><span class="annottext">(Id' Hash -&gt; Either IncoherentDeclReason Int)
-&gt; OnIncoherentDeclReasons (Either IncoherentDeclReason)
-&gt; Nametree (DefnsF (Map NameSegment) Referent TypeReference)
-&gt; Either IncoherentDeclReason DeclNameLookup
forall (m :: * -&gt; *).
Monad m =&gt;
(Id' Hash -&gt; m Int)
-&gt; OnIncoherentDeclReasons m
-&gt; Nametree (DefnsF (Map NameSegment) Referent TypeReference)
-&gt; m DeclNameLookup
</span><a href="Unison.Merge.DeclCoherencyCheck.html#checkDeclCoherencyWith"><span class="hs-identifier hs-var">checkDeclCoherencyWith</span></a></span><span>
</span><span id="line-144"></span><span>    </span><span class="hs-special">(</span><span class="hs-glyph">\</span><span id="local-6989586621679184919"><span class="annot"><span class="annottext">Id' Hash
</span><a href="#local-6989586621679184919"><span class="hs-identifier hs-var">refId</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Int -&gt; Either IncoherentDeclReason Int
forall a b. b -&gt; Either a b
</span><span class="hs-identifier hs-var">Right</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">HasCallStack =&gt; Id' Hash -&gt; Map (Id' Hash) Int -&gt; Int
Id' Hash -&gt; Map (Id' Hash) Int -&gt; Int
</span><a href="Unison.Merge.DeclCoherencyCheck.html#expectNumConstructors"><span class="hs-identifier hs-var">expectNumConstructors</span></a></span><span> </span><span class="annot"><span class="annottext">Id' Hash
</span><a href="#local-6989586621679184919"><span class="hs-identifier hs-var">refId</span></a></span><span> </span><span class="annot"><span class="annottext">Map (Id' Hash) Int
</span><a href="#local-6989586621679184917"><span class="hs-identifier hs-var">numConstructorsById</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-145"></span><span>    </span><span class="annot"><a href="Unison.Merge.DeclCoherencyCheck.html#OnIncoherentDeclReasons"><span class="hs-identifier hs-type">OnIncoherentDeclReasons</span></a></span><span>
</span><span id="line-146"></span><span>      </span><span class="hs-special">{</span><span> </span><span class="annot"><span class="annottext">$sel:onConstructorAlias:OnIncoherentDeclReasons :: Name -&gt; Name -&gt; Name -&gt; Either IncoherentDeclReason ()
</span><a href="Unison.Merge.DeclCoherencyCheck.html#%24sel%3AonConstructorAlias%3AOnIncoherentDeclReasons"><span class="hs-identifier hs-var">onConstructorAlias</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-glyph">\</span><span id="local-6989586621679184923"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679184923"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span id="local-6989586621679184924"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679184924"><span class="hs-identifier hs-var">y</span></a></span></span><span> </span><span id="local-6989586621679184925"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679184925"><span class="hs-identifier hs-var">z</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">IncoherentDeclReason -&gt; Either IncoherentDeclReason ()
forall a b. a -&gt; Either a b
</span><span class="hs-identifier hs-var">Left</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Name -&gt; Name -&gt; Name -&gt; IncoherentDeclReason
</span><a href="Unison.Merge.DeclCoherencyCheck.html#IncoherentDeclReason%27ConstructorAlias"><span class="hs-identifier hs-var">IncoherentDeclReason'ConstructorAlias</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679184923"><span class="hs-identifier hs-var">x</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679184924"><span class="hs-identifier hs-var">y</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679184925"><span class="hs-identifier hs-var">z</span></a></span><span class="hs-special">)</span><span class="hs-special">,</span><span>
</span><span id="line-147"></span><span>        </span><span class="annot"><span class="annottext">$sel:onMissingConstructorName:OnIncoherentDeclReasons :: Name -&gt; Either IncoherentDeclReason ()
</span><a href="Unison.Merge.DeclCoherencyCheck.html#%24sel%3AonMissingConstructorName%3AOnIncoherentDeclReasons"><span class="hs-identifier hs-var">onMissingConstructorName</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-glyph">\</span><span id="local-6989586621679184927"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679184927"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">IncoherentDeclReason -&gt; Either IncoherentDeclReason ()
forall a b. a -&gt; Either a b
</span><span class="hs-identifier hs-var">Left</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Name -&gt; IncoherentDeclReason
</span><a href="Unison.Merge.DeclCoherencyCheck.html#IncoherentDeclReason%27MissingConstructorName"><span class="hs-identifier hs-var">IncoherentDeclReason'MissingConstructorName</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679184927"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">)</span><span class="hs-special">,</span><span>
</span><span id="line-148"></span><span>        </span><span class="annot"><span class="annottext">$sel:onNestedDeclAlias:OnIncoherentDeclReasons :: Name -&gt; Name -&gt; Either IncoherentDeclReason ()
</span><a href="Unison.Merge.DeclCoherencyCheck.html#%24sel%3AonNestedDeclAlias%3AOnIncoherentDeclReasons"><span class="hs-identifier hs-var">onNestedDeclAlias</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-glyph">\</span><span id="local-6989586621679184929"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679184929"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span id="local-6989586621679184930"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679184930"><span class="hs-identifier hs-var">y</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">IncoherentDeclReason -&gt; Either IncoherentDeclReason ()
forall a b. a -&gt; Either a b
</span><span class="hs-identifier hs-var">Left</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Name -&gt; Name -&gt; IncoherentDeclReason
</span><a href="Unison.Merge.DeclCoherencyCheck.html#IncoherentDeclReason%27NestedDeclAlias"><span class="hs-identifier hs-var">IncoherentDeclReason'NestedDeclAlias</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679184929"><span class="hs-identifier hs-var">x</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679184930"><span class="hs-identifier hs-var">y</span></a></span><span class="hs-special">)</span><span class="hs-special">,</span><span>
</span><span id="line-149"></span><span>        </span><span class="annot"><span class="annottext">$sel:onStrayConstructor:OnIncoherentDeclReasons :: Id' Hash -&gt; Name -&gt; Either IncoherentDeclReason ()
</span><a href="Unison.Merge.DeclCoherencyCheck.html#%24sel%3AonStrayConstructor%3AOnIncoherentDeclReasons"><span class="hs-identifier hs-var">onStrayConstructor</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-glyph">\</span><span id="local-6989586621679184932"><span class="annot"><span class="annottext">Id' Hash
</span><a href="#local-6989586621679184932"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span id="local-6989586621679184933"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679184933"><span class="hs-identifier hs-var">y</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">IncoherentDeclReason -&gt; Either IncoherentDeclReason ()
forall a b. a -&gt; Either a b
</span><span class="hs-identifier hs-var">Left</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Id' Hash -&gt; Name -&gt; IncoherentDeclReason
</span><a href="Unison.Merge.DeclCoherencyCheck.html#IncoherentDeclReason%27StrayConstructor"><span class="hs-identifier hs-var">IncoherentDeclReason'StrayConstructor</span></a></span><span> </span><span class="annot"><span class="annottext">Id' Hash
</span><a href="#local-6989586621679184932"><span class="hs-identifier hs-var">x</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679184933"><span class="hs-identifier hs-var">y</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-150"></span><span>      </span><span class="hs-special">}</span><span>
</span><span id="line-151"></span><span>    </span><span class="annot"><span class="annottext">Nametree (DefnsF (Map NameSegment) Referent TypeReference)
</span><a href="#local-6989586621679184916"><span class="hs-identifier hs-var">nametree</span></a></span><span>
</span><span id="line-152"></span><span>
</span><span id="line-153"></span><span class="hs-keyword">data</span><span> </span><span id="IncoherentDeclReasons"><span class="annot"><a href="Unison.Merge.DeclCoherencyCheck.html#IncoherentDeclReasons"><span class="hs-identifier hs-var">IncoherentDeclReasons</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="IncoherentDeclReasons"><span class="annot"><a href="Unison.Merge.DeclCoherencyCheck.html#IncoherentDeclReasons"><span class="hs-identifier hs-var">IncoherentDeclReasons</span></a></span></span><span>
</span><span id="line-154"></span><span>  </span><span class="hs-special">{</span><span> </span><span id="%24sel%3AconstructorAliases%3AIncoherentDeclReasons"><span class="annot"><span class="annottext">IncoherentDeclReasons -&gt; [(Name, Name, Name)]
</span><a href="Unison.Merge.DeclCoherencyCheck.html#%24sel%3AconstructorAliases%3AIncoherentDeclReasons"><span class="hs-identifier hs-var hs-var">constructorAliases</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-glyph">!</span><span class="hs-special">[</span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span class="hs-special">)</span><span class="hs-special">]</span><span class="hs-special">,</span><span>
</span><span id="line-155"></span><span>    </span><span id="%24sel%3AmissingConstructorNames%3AIncoherentDeclReasons"><span class="annot"><span class="annottext">IncoherentDeclReasons -&gt; [Name]
</span><a href="Unison.Merge.DeclCoherencyCheck.html#%24sel%3AmissingConstructorNames%3AIncoherentDeclReasons"><span class="hs-identifier hs-var hs-var">missingConstructorNames</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-glyph">!</span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span class="hs-special">]</span><span class="hs-special">,</span><span>
</span><span id="line-156"></span><span>    </span><span id="%24sel%3AnestedDeclAliases%3AIncoherentDeclReasons"><span class="annot"><span class="annottext">IncoherentDeclReasons -&gt; [(Name, Name)]
</span><a href="Unison.Merge.DeclCoherencyCheck.html#%24sel%3AnestedDeclAliases%3AIncoherentDeclReasons"><span class="hs-identifier hs-var hs-var">nestedDeclAliases</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-glyph">!</span><span class="hs-special">[</span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span class="hs-special">)</span><span class="hs-special">]</span><span class="hs-special">,</span><span>
</span><span id="line-157"></span><span>    </span><span id="%24sel%3AstrayConstructors%3AIncoherentDeclReasons"><span class="annot"><span class="annottext">IncoherentDeclReasons -&gt; [(Id' Hash, Name)]
</span><a href="Unison.Merge.DeclCoherencyCheck.html#%24sel%3AstrayConstructors%3AIncoherentDeclReasons"><span class="hs-identifier hs-var hs-var">strayConstructors</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-glyph">!</span><span class="hs-special">[</span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">TypeReferenceId</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span class="hs-special">)</span><span class="hs-special">]</span><span>
</span><span id="line-158"></span><span>  </span><span class="hs-special">}</span><span>
</span><span id="line-159"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="annot"><span class="hs-keyword">stock</span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621679184940"><span id="local-6989586621679184951"><span class="annot"><span class="annottext">IncoherentDeclReasons -&gt; IncoherentDeclReasons -&gt; Bool
(IncoherentDeclReasons -&gt; IncoherentDeclReasons -&gt; Bool)
-&gt; (IncoherentDeclReasons -&gt; IncoherentDeclReasons -&gt; Bool)
-&gt; Eq IncoherentDeclReasons
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
$c== :: IncoherentDeclReasons -&gt; IncoherentDeclReasons -&gt; Bool
== :: IncoherentDeclReasons -&gt; IncoherentDeclReasons -&gt; Bool
$c/= :: IncoherentDeclReasons -&gt; IncoherentDeclReasons -&gt; Bool
/= :: IncoherentDeclReasons -&gt; IncoherentDeclReasons -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679184965"><span id="local-6989586621679184967"><span class="annot"><span class="annottext">(forall x. IncoherentDeclReasons -&gt; Rep IncoherentDeclReasons x)
-&gt; (forall x. Rep IncoherentDeclReasons x -&gt; IncoherentDeclReasons)
-&gt; Generic IncoherentDeclReasons
forall x. Rep IncoherentDeclReasons x -&gt; IncoherentDeclReasons
forall x. IncoherentDeclReasons -&gt; Rep IncoherentDeclReasons x
forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
$cfrom :: forall x. IncoherentDeclReasons -&gt; Rep IncoherentDeclReasons x
from :: forall x. IncoherentDeclReasons -&gt; Rep IncoherentDeclReasons x
$cto :: forall x. Rep IncoherentDeclReasons x -&gt; IncoherentDeclReasons
to :: forall x. Rep IncoherentDeclReasons x -&gt; IncoherentDeclReasons
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Generic</span></span></span></span><span class="hs-special">)</span><span>
</span><span id="line-160"></span><span>
</span><span id="line-161"></span><span class="annot"><span class="hs-comment">-- | Like 'checkDeclCoherency', but returns info about all of the incoherent decls found, not just the first.</span></span><span>
</span><span id="line-162"></span><span class="annot"><a href="Unison.Merge.DeclCoherencyCheck.html#checkAllDeclCoherency"><span class="hs-identifier hs-type">checkAllDeclCoherency</span></a></span><span> </span><span class="hs-glyph">::</span><span>
</span><span id="line-163"></span><span>  </span><span class="hs-keyword">forall</span><span> </span><span id="local-6989586621679184366"><span class="annot"><a href="#local-6989586621679184366"><span class="hs-identifier hs-type">m</span></a></span></span><span class="hs-operator">.</span><span>
</span><span id="line-164"></span><span>  </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679184366"><span class="hs-identifier hs-type">m</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span>
</span><span id="line-165"></span><span>  </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">TypeReferenceId</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679184366"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-166"></span><span>  </span><span class="annot"><span class="hs-identifier hs-type">Nametree</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">DefnsF</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Map</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">NameSegment</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Referent</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">TypeReference</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-167"></span><span>  </span><span class="annot"><a href="#local-6989586621679184366"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Either</span></span><span> </span><span class="annot"><a href="Unison.Merge.DeclCoherencyCheck.html#IncoherentDeclReasons"><span class="hs-identifier hs-type">IncoherentDeclReasons</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">DeclNameLookup</span></span><span class="hs-special">)</span><span>
</span><span id="line-168"></span><span id="checkAllDeclCoherency"><span class="annot"><span class="annottext">checkAllDeclCoherency :: forall (m :: * -&gt; *).
Monad m =&gt;
(Id' Hash -&gt; m Int)
-&gt; Nametree (DefnsF (Map NameSegment) Referent TypeReference)
-&gt; m (Either IncoherentDeclReasons DeclNameLookup)
</span><a href="Unison.Merge.DeclCoherencyCheck.html#checkAllDeclCoherency"><span class="hs-identifier hs-var hs-var">checkAllDeclCoherency</span></a></span></span><span> </span><span id="local-6989586621679185070"><span class="annot"><span class="annottext">Id' Hash -&gt; m Int
</span><a href="#local-6989586621679185070"><span class="hs-identifier hs-var">loadDeclNumConstructors</span></a></span></span><span> </span><span id="local-6989586621679185071"><span class="annot"><span class="annottext">Nametree (DefnsF (Map NameSegment) Referent TypeReference)
</span><a href="#local-6989586621679185071"><span class="hs-identifier hs-var">nametree</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-169"></span><span>  </span><span class="annot"><span class="annottext">StateT IncoherentDeclReasons m DeclNameLookup
-&gt; IncoherentDeclReasons
-&gt; m (DeclNameLookup, IncoherentDeclReasons)
forall s (m :: * -&gt; *) a. StateT s m a -&gt; s -&gt; m (a, s)
</span><span class="hs-identifier hs-var">State.runStateT</span></span><span> </span><span class="annot"><span class="annottext">StateT IncoherentDeclReasons m DeclNameLookup
</span><a href="#local-6989586621679185073"><span class="hs-identifier hs-var">doCheck</span></a></span><span> </span><span class="annot"><span class="annottext">IncoherentDeclReasons
</span><a href="#local-6989586621679185074"><span class="hs-identifier hs-var">emptyReasons</span></a></span><span> </span><span class="annot"><span class="annottext">m (DeclNameLookup, IncoherentDeclReasons)
-&gt; ((DeclNameLookup, IncoherentDeclReasons)
    -&gt; Either IncoherentDeclReasons DeclNameLookup)
-&gt; m (Either IncoherentDeclReasons DeclNameLookup)
forall (f :: * -&gt; *) a b. Functor f =&gt; f a -&gt; (a -&gt; b) -&gt; f b
</span><span class="hs-operator hs-var">&lt;&amp;&gt;</span></span><span> </span><span class="hs-glyph">\</span><span class="hs-special">(</span><span id="local-6989586621679185076"><span class="annot"><span class="annottext">DeclNameLookup
</span><a href="#local-6989586621679185076"><span class="hs-identifier hs-var">declNameLookup</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679185077"><span class="annot"><span class="annottext">IncoherentDeclReasons
</span><a href="#local-6989586621679185077"><span class="hs-identifier hs-var">reasons</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-170"></span><span>    </span><span class="hs-keyword">if</span><span> </span><span class="annot"><span class="annottext">IncoherentDeclReasons
</span><a href="#local-6989586621679185077"><span class="hs-identifier hs-var">reasons</span></a></span><span> </span><span class="annot"><span class="annottext">IncoherentDeclReasons -&gt; IncoherentDeclReasons -&gt; Bool
forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="annot"><span class="annottext">IncoherentDeclReasons
</span><a href="#local-6989586621679185074"><span class="hs-identifier hs-var">emptyReasons</span></a></span><span>
</span><span id="line-171"></span><span>      </span><span class="hs-keyword">then</span><span> </span><span class="annot"><span class="annottext">DeclNameLookup -&gt; Either IncoherentDeclReasons DeclNameLookup
forall a b. b -&gt; Either a b
</span><span class="hs-identifier hs-var">Right</span></span><span> </span><span class="annot"><span class="annottext">DeclNameLookup
</span><a href="#local-6989586621679185076"><span class="hs-identifier hs-var">declNameLookup</span></a></span><span>
</span><span id="line-172"></span><span>      </span><span class="hs-keyword">else</span><span> </span><span class="annot"><span class="annottext">IncoherentDeclReasons
-&gt; Either IncoherentDeclReasons DeclNameLookup
forall a b. a -&gt; Either a b
</span><span class="hs-identifier hs-var">Left</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">IncoherentDeclReasons -&gt; IncoherentDeclReasons
</span><a href="#local-6989586621679185078"><span class="hs-identifier hs-var">reverseReasons</span></a></span><span> </span><span class="annot"><span class="annottext">IncoherentDeclReasons
</span><a href="#local-6989586621679185077"><span class="hs-identifier hs-var">reasons</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-173"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-174"></span><span>    </span><span class="annot"><a href="#local-6989586621679185073"><span class="hs-identifier hs-type">doCheck</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">StateT</span></span><span> </span><span class="annot"><a href="Unison.Merge.DeclCoherencyCheck.html#IncoherentDeclReasons"><span class="hs-identifier hs-type">IncoherentDeclReasons</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679184366"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">DeclNameLookup</span></span><span>
</span><span id="line-175"></span><span>    </span><span id="local-6989586621679185073"><span class="annot"><span class="annottext">doCheck :: StateT IncoherentDeclReasons m DeclNameLookup
</span><a href="#local-6989586621679185073"><span class="hs-identifier hs-var hs-var">doCheck</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-176"></span><span>      </span><span class="annot"><span class="annottext">(Id' Hash -&gt; StateT IncoherentDeclReasons m Int)
-&gt; OnIncoherentDeclReasons (StateT IncoherentDeclReasons m)
-&gt; Nametree (DefnsF (Map NameSegment) Referent TypeReference)
-&gt; StateT IncoherentDeclReasons m DeclNameLookup
forall (m :: * -&gt; *).
Monad m =&gt;
(Id' Hash -&gt; m Int)
-&gt; OnIncoherentDeclReasons m
-&gt; Nametree (DefnsF (Map NameSegment) Referent TypeReference)
-&gt; m DeclNameLookup
</span><a href="Unison.Merge.DeclCoherencyCheck.html#checkDeclCoherencyWith"><span class="hs-identifier hs-var">checkDeclCoherencyWith</span></a></span><span>
</span><span id="line-177"></span><span>        </span><span class="hs-special">(</span><span class="annot"><span class="annottext">m Int -&gt; StateT IncoherentDeclReasons m Int
forall (m :: * -&gt; *) a.
Monad m =&gt;
m a -&gt; StateT IncoherentDeclReasons m a
forall (t :: (* -&gt; *) -&gt; * -&gt; *) (m :: * -&gt; *) a.
(MonadTrans t, Monad m) =&gt;
m a -&gt; t m a
</span><span class="hs-identifier hs-var">lift</span></span><span> </span><span class="annot"><span class="annottext">(m Int -&gt; StateT IncoherentDeclReasons m Int)
-&gt; (Id' Hash -&gt; m Int)
-&gt; Id' Hash
-&gt; StateT IncoherentDeclReasons m Int
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">Id' Hash -&gt; m Int
</span><a href="#local-6989586621679185070"><span class="hs-identifier hs-var">loadDeclNumConstructors</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-178"></span><span>        </span><span class="hs-special">(</span><span> </span><span class="annot"><a href="Unison.Merge.DeclCoherencyCheck.html#OnIncoherentDeclReasons"><span class="hs-identifier hs-type">OnIncoherentDeclReasons</span></a></span><span>
</span><span id="line-179"></span><span>            </span><span class="hs-special">{</span><span> </span><span class="annot"><span class="annottext">$sel:onConstructorAlias:OnIncoherentDeclReasons :: Name -&gt; Name -&gt; Name -&gt; StateT IncoherentDeclReasons m ()
</span><a href="Unison.Merge.DeclCoherencyCheck.html#%24sel%3AonConstructorAlias%3AOnIncoherentDeclReasons"><span class="hs-identifier hs-var">onConstructorAlias</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-glyph">\</span><span id="local-6989586621679185081"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679185081"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span id="local-6989586621679185082"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679185082"><span class="hs-identifier hs-var">y</span></a></span></span><span> </span><span id="local-6989586621679185083"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679185083"><span class="hs-identifier hs-var">z</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">ASetter
  IncoherentDeclReasons
  IncoherentDeclReasons
  [(Name, Name, Name)]
  [(Name, Name, Name)]
</span><span class="">#constructorAliases</span></span><span> </span><span class="annot"><span class="annottext">ASetter
  IncoherentDeclReasons
  IncoherentDeclReasons
  [(Name, Name, Name)]
  [(Name, Name, Name)]
-&gt; ([(Name, Name, Name)] -&gt; [(Name, Name, Name)])
-&gt; StateT IncoherentDeclReasons m ()
forall s (m :: * -&gt; *) a b.
MonadState s m =&gt;
ASetter s s a b -&gt; (a -&gt; b) -&gt; m ()
</span><span class="hs-operator hs-var">%=</span></span><span> </span><span class="hs-special">(</span><span class="hs-special">(</span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679185081"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679185082"><span class="hs-identifier hs-var">y</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679185083"><span class="hs-identifier hs-var">z</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">(Name, Name, Name) -&gt; [(Name, Name, Name)] -&gt; [(Name, Name, Name)]
forall a. a -&gt; [a] -&gt; [a]
</span><span class="hs-glyph hs-var">:</span></span><span class="hs-special">)</span><span class="hs-special">,</span><span>
</span><span id="line-180"></span><span>              </span><span class="annot"><span class="annottext">$sel:onMissingConstructorName:OnIncoherentDeclReasons :: Name -&gt; StateT IncoherentDeclReasons m ()
</span><a href="Unison.Merge.DeclCoherencyCheck.html#%24sel%3AonMissingConstructorName%3AOnIncoherentDeclReasons"><span class="hs-identifier hs-var">onMissingConstructorName</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-glyph">\</span><span id="local-6989586621679185084"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679185084"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">ASetter IncoherentDeclReasons IncoherentDeclReasons [Name] [Name]
</span><span class="">#missingConstructorNames</span></span><span> </span><span class="annot"><span class="annottext">ASetter IncoherentDeclReasons IncoherentDeclReasons [Name] [Name]
-&gt; ([Name] -&gt; [Name]) -&gt; StateT IncoherentDeclReasons m ()
forall s (m :: * -&gt; *) a b.
MonadState s m =&gt;
ASetter s s a b -&gt; (a -&gt; b) -&gt; m ()
</span><span class="hs-operator hs-var">%=</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679185084"><span class="hs-identifier hs-var">x</span></a></span><span> </span><span class="annot"><span class="annottext">Name -&gt; [Name] -&gt; [Name]
forall a. a -&gt; [a] -&gt; [a]
</span><span class="hs-glyph hs-var">:</span></span><span class="hs-special">)</span><span class="hs-special">,</span><span>
</span><span id="line-181"></span><span>              </span><span class="annot"><span class="annottext">$sel:onNestedDeclAlias:OnIncoherentDeclReasons :: Name -&gt; Name -&gt; StateT IncoherentDeclReasons m ()
</span><a href="Unison.Merge.DeclCoherencyCheck.html#%24sel%3AonNestedDeclAlias%3AOnIncoherentDeclReasons"><span class="hs-identifier hs-var">onNestedDeclAlias</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-glyph">\</span><span id="local-6989586621679185085"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679185085"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span id="local-6989586621679185086"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679185086"><span class="hs-identifier hs-var">y</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">ASetter
  IncoherentDeclReasons
  IncoherentDeclReasons
  [(Name, Name)]
  [(Name, Name)]
</span><span class="">#nestedDeclAliases</span></span><span> </span><span class="annot"><span class="annottext">ASetter
  IncoherentDeclReasons
  IncoherentDeclReasons
  [(Name, Name)]
  [(Name, Name)]
-&gt; ([(Name, Name)] -&gt; [(Name, Name)])
-&gt; StateT IncoherentDeclReasons m ()
forall s (m :: * -&gt; *) a b.
MonadState s m =&gt;
ASetter s s a b -&gt; (a -&gt; b) -&gt; m ()
</span><span class="hs-operator hs-var">%=</span></span><span> </span><span class="hs-special">(</span><span class="hs-special">(</span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679185085"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679185086"><span class="hs-identifier hs-var">y</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">(Name, Name) -&gt; [(Name, Name)] -&gt; [(Name, Name)]
forall a. a -&gt; [a] -&gt; [a]
</span><span class="hs-glyph hs-var">:</span></span><span class="hs-special">)</span><span class="hs-special">,</span><span>
</span><span id="line-182"></span><span>              </span><span class="annot"><span class="annottext">$sel:onStrayConstructor:OnIncoherentDeclReasons :: Id' Hash -&gt; Name -&gt; StateT IncoherentDeclReasons m ()
</span><a href="Unison.Merge.DeclCoherencyCheck.html#%24sel%3AonStrayConstructor%3AOnIncoherentDeclReasons"><span class="hs-identifier hs-var">onStrayConstructor</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-glyph">\</span><span id="local-6989586621679185087"><span class="annot"><span class="annottext">Id' Hash
</span><a href="#local-6989586621679185087"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span id="local-6989586621679185088"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679185088"><span class="hs-identifier hs-var">y</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">ASetter
  IncoherentDeclReasons
  IncoherentDeclReasons
  [(Id' Hash, Name)]
  [(Id' Hash, Name)]
</span><span class="">#strayConstructors</span></span><span> </span><span class="annot"><span class="annottext">ASetter
  IncoherentDeclReasons
  IncoherentDeclReasons
  [(Id' Hash, Name)]
  [(Id' Hash, Name)]
-&gt; ([(Id' Hash, Name)] -&gt; [(Id' Hash, Name)])
-&gt; StateT IncoherentDeclReasons m ()
forall s (m :: * -&gt; *) a b.
MonadState s m =&gt;
ASetter s s a b -&gt; (a -&gt; b) -&gt; m ()
</span><span class="hs-operator hs-var">%=</span></span><span> </span><span class="hs-special">(</span><span class="hs-special">(</span><span class="annot"><span class="annottext">Id' Hash
</span><a href="#local-6989586621679185087"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679185088"><span class="hs-identifier hs-var">y</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">(Id' Hash, Name) -&gt; [(Id' Hash, Name)] -&gt; [(Id' Hash, Name)]
forall a. a -&gt; [a] -&gt; [a]
</span><span class="hs-glyph hs-var">:</span></span><span class="hs-special">)</span><span>
</span><span id="line-183"></span><span>            </span><span class="hs-special">}</span><span>
</span><span id="line-184"></span><span>        </span><span class="hs-special">)</span><span>
</span><span id="line-185"></span><span>        </span><span class="annot"><span class="annottext">Nametree (DefnsF (Map NameSegment) Referent TypeReference)
</span><a href="#local-6989586621679185071"><span class="hs-identifier hs-var">nametree</span></a></span><span>
</span><span id="line-186"></span><span>
</span><span id="line-187"></span><span>    </span><span class="annot"><a href="#local-6989586621679185074"><span class="hs-identifier hs-type">emptyReasons</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Unison.Merge.DeclCoherencyCheck.html#IncoherentDeclReasons"><span class="hs-identifier hs-type">IncoherentDeclReasons</span></a></span><span>
</span><span id="line-188"></span><span>    </span><span id="local-6989586621679185074"><span class="annot"><span class="annottext">emptyReasons :: IncoherentDeclReasons
</span><a href="#local-6989586621679185074"><span class="hs-identifier hs-var hs-var">emptyReasons</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-189"></span><span>      </span><span class="annot"><span class="annottext">[(Name, Name, Name)]
-&gt; [Name]
-&gt; [(Name, Name)]
-&gt; [(Id' Hash, Name)]
-&gt; IncoherentDeclReasons
</span><a href="Unison.Merge.DeclCoherencyCheck.html#IncoherentDeclReasons"><span class="hs-identifier hs-var">IncoherentDeclReasons</span></a></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span>
</span><span id="line-190"></span><span>
</span><span id="line-191"></span><span>    </span><span class="annot"><a href="#local-6989586621679185078"><span class="hs-identifier hs-type">reverseReasons</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Unison.Merge.DeclCoherencyCheck.html#IncoherentDeclReasons"><span class="hs-identifier hs-type">IncoherentDeclReasons</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Unison.Merge.DeclCoherencyCheck.html#IncoherentDeclReasons"><span class="hs-identifier hs-type">IncoherentDeclReasons</span></a></span><span>
</span><span id="line-192"></span><span>    </span><span id="local-6989586621679185078"><span class="annot"><span class="annottext">reverseReasons :: IncoherentDeclReasons -&gt; IncoherentDeclReasons
</span><a href="#local-6989586621679185078"><span class="hs-identifier hs-var hs-var">reverseReasons</span></a></span></span><span> </span><span id="local-6989586621679185089"><span class="annot"><span class="annottext">IncoherentDeclReasons
</span><a href="#local-6989586621679185089"><span class="hs-identifier hs-var">reasons</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-193"></span><span>      </span><span class="annot"><a href="Unison.Merge.DeclCoherencyCheck.html#IncoherentDeclReasons"><span class="hs-identifier hs-type">IncoherentDeclReasons</span></a></span><span>
</span><span id="line-194"></span><span>        </span><span class="hs-special">{</span><span> </span><span class="annot"><span class="annottext">$sel:constructorAliases:IncoherentDeclReasons :: [(Name, Name, Name)]
</span><a href="Unison.Merge.DeclCoherencyCheck.html#%24sel%3AconstructorAliases%3AIncoherentDeclReasons"><span class="hs-identifier hs-var">constructorAliases</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[(Name, Name, Name)] -&gt; [(Name, Name, Name)]
forall a. [a] -&gt; [a]
</span><span class="hs-identifier hs-var">reverse</span></span><span> </span><span class="annot"><span class="annottext">IncoherentDeclReasons
</span><a href="#local-6989586621679185089"><span class="hs-identifier hs-var">reasons</span></a></span><span class="hs-operator">.</span><span class="hs-identifier">constructorAliases</span><span class="hs-special">,</span><span>
</span><span id="line-195"></span><span>          </span><span class="annot"><span class="annottext">$sel:missingConstructorNames:IncoherentDeclReasons :: [Name]
</span><a href="Unison.Merge.DeclCoherencyCheck.html#%24sel%3AmissingConstructorNames%3AIncoherentDeclReasons"><span class="hs-identifier hs-var">missingConstructorNames</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[Name] -&gt; [Name]
forall a. [a] -&gt; [a]
</span><span class="hs-identifier hs-var">reverse</span></span><span> </span><span class="annot"><span class="annottext">IncoherentDeclReasons
</span><a href="#local-6989586621679185089"><span class="hs-identifier hs-var">reasons</span></a></span><span class="hs-operator">.</span><span class="hs-identifier">missingConstructorNames</span><span class="hs-special">,</span><span>
</span><span id="line-196"></span><span>          </span><span class="annot"><span class="annottext">$sel:nestedDeclAliases:IncoherentDeclReasons :: [(Name, Name)]
</span><a href="Unison.Merge.DeclCoherencyCheck.html#%24sel%3AnestedDeclAliases%3AIncoherentDeclReasons"><span class="hs-identifier hs-var">nestedDeclAliases</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[(Name, Name)] -&gt; [(Name, Name)]
forall a. [a] -&gt; [a]
</span><span class="hs-identifier hs-var">reverse</span></span><span> </span><span class="annot"><span class="annottext">IncoherentDeclReasons
</span><a href="#local-6989586621679185089"><span class="hs-identifier hs-var">reasons</span></a></span><span class="hs-operator">.</span><span class="hs-identifier">nestedDeclAliases</span><span class="hs-special">,</span><span>
</span><span id="line-197"></span><span>          </span><span class="annot"><span class="annottext">$sel:strayConstructors:IncoherentDeclReasons :: [(Id' Hash, Name)]
</span><a href="Unison.Merge.DeclCoherencyCheck.html#%24sel%3AstrayConstructors%3AIncoherentDeclReasons"><span class="hs-identifier hs-var">strayConstructors</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[(Id' Hash, Name)] -&gt; [(Id' Hash, Name)]
forall a. [a] -&gt; [a]
</span><span class="hs-identifier hs-var">reverse</span></span><span> </span><span class="annot"><span class="annottext">IncoherentDeclReasons
</span><a href="#local-6989586621679185089"><span class="hs-identifier hs-var">reasons</span></a></span><span class="hs-operator">.</span><span class="hs-identifier">strayConstructors</span><span>
</span><span id="line-198"></span><span>        </span><span class="hs-special">}</span><span>
</span><span id="line-199"></span><span>
</span><span id="line-200"></span><span class="hs-keyword">data</span><span> </span><span id="OnIncoherentDeclReasons"><span class="annot"><a href="Unison.Merge.DeclCoherencyCheck.html#OnIncoherentDeclReasons"><span class="hs-identifier hs-var">OnIncoherentDeclReasons</span></a></span></span><span> </span><span id="local-6989586621679184389"><span class="annot"><a href="#local-6989586621679184389"><span class="hs-identifier hs-type">m</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="OnIncoherentDeclReasons"><span class="annot"><a href="Unison.Merge.DeclCoherencyCheck.html#OnIncoherentDeclReasons"><span class="hs-identifier hs-var">OnIncoherentDeclReasons</span></a></span></span><span>
</span><span id="line-201"></span><span>  </span><span class="hs-special">{</span><span> </span><span id="%24sel%3AonConstructorAlias%3AOnIncoherentDeclReasons"><span class="annot"><span class="annottext">forall (m :: * -&gt; *).
OnIncoherentDeclReasons m -&gt; Name -&gt; Name -&gt; Name -&gt; m ()
</span><a href="Unison.Merge.DeclCoherencyCheck.html#%24sel%3AonConstructorAlias%3AOnIncoherentDeclReasons"><span class="hs-identifier hs-var hs-var">onConstructorAlias</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679184389"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span class="hs-special">,</span><span>
</span><span id="line-202"></span><span>    </span><span id="%24sel%3AonMissingConstructorName%3AOnIncoherentDeclReasons"><span class="annot"><span class="annottext">forall (m :: * -&gt; *). OnIncoherentDeclReasons m -&gt; Name -&gt; m ()
</span><a href="Unison.Merge.DeclCoherencyCheck.html#%24sel%3AonMissingConstructorName%3AOnIncoherentDeclReasons"><span class="hs-identifier hs-var hs-var">onMissingConstructorName</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679184389"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span class="hs-special">,</span><span>
</span><span id="line-203"></span><span>    </span><span id="%24sel%3AonNestedDeclAlias%3AOnIncoherentDeclReasons"><span class="annot"><span class="annottext">forall (m :: * -&gt; *).
OnIncoherentDeclReasons m -&gt; Name -&gt; Name -&gt; m ()
</span><a href="Unison.Merge.DeclCoherencyCheck.html#%24sel%3AonNestedDeclAlias%3AOnIncoherentDeclReasons"><span class="hs-identifier hs-var hs-var">onNestedDeclAlias</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679184389"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span class="hs-special">,</span><span>
</span><span id="line-204"></span><span>    </span><span id="%24sel%3AonStrayConstructor%3AOnIncoherentDeclReasons"><span class="annot"><span class="annottext">forall (m :: * -&gt; *).
OnIncoherentDeclReasons m -&gt; Id' Hash -&gt; Name -&gt; m ()
</span><a href="Unison.Merge.DeclCoherencyCheck.html#%24sel%3AonStrayConstructor%3AOnIncoherentDeclReasons"><span class="hs-identifier hs-var hs-var">onStrayConstructor</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">TypeReferenceId</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679184389"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><span id="line-205"></span><span>  </span><span class="hs-special">}</span><span>
</span><span id="line-206"></span><span>
</span><span id="line-207"></span><span class="annot"><a href="Unison.Merge.DeclCoherencyCheck.html#checkDeclCoherencyWith"><span class="hs-identifier hs-type">checkDeclCoherencyWith</span></a></span><span> </span><span class="hs-glyph">::</span><span>
</span><span id="line-208"></span><span>  </span><span class="hs-keyword">forall</span><span> </span><span id="local-6989586621679184351"><span class="annot"><a href="#local-6989586621679184351"><span class="hs-identifier hs-type">m</span></a></span></span><span class="hs-operator">.</span><span>
</span><span id="line-209"></span><span>  </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679184351"><span class="hs-identifier hs-type">m</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span>
</span><span id="line-210"></span><span>  </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">TypeReferenceId</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679184351"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-211"></span><span>  </span><span class="annot"><a href="Unison.Merge.DeclCoherencyCheck.html#OnIncoherentDeclReasons"><span class="hs-identifier hs-type">OnIncoherentDeclReasons</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679184351"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-212"></span><span>  </span><span class="annot"><span class="hs-identifier hs-type">Nametree</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">DefnsF</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Map</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">NameSegment</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Referent</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">TypeReference</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-213"></span><span>  </span><span class="annot"><a href="#local-6989586621679184351"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">DeclNameLookup</span></span><span>
</span><span id="line-214"></span><span id="checkDeclCoherencyWith"><span class="annot"><span class="annottext">checkDeclCoherencyWith :: forall (m :: * -&gt; *).
Monad m =&gt;
(Id' Hash -&gt; m Int)
-&gt; OnIncoherentDeclReasons m
-&gt; Nametree (DefnsF (Map NameSegment) Referent TypeReference)
-&gt; m DeclNameLookup
</span><a href="Unison.Merge.DeclCoherencyCheck.html#checkDeclCoherencyWith"><span class="hs-identifier hs-var hs-var">checkDeclCoherencyWith</span></a></span></span><span> </span><span id="local-6989586621679185134"><span class="annot"><span class="annottext">Id' Hash -&gt; m Int
</span><a href="#local-6989586621679185134"><span class="hs-identifier hs-var">loadDeclNumConstructors</span></a></span></span><span> </span><span id="local-6989586621679185135"><span class="annot"><span class="annottext">OnIncoherentDeclReasons m
</span><a href="#local-6989586621679185135"><span class="hs-identifier hs-var">callbacks</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-215"></span><span>  </span><span class="annot"><span class="annottext">(DeclCoherencyCheckState -&gt; DeclNameLookup)
-&gt; m DeclCoherencyCheckState -&gt; m DeclNameLookup
forall a b. (a -&gt; b) -&gt; m a -&gt; m b
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-identifier hs-var">fmap</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Getting DeclNameLookup DeclCoherencyCheckState DeclNameLookup
-&gt; DeclCoherencyCheckState -&gt; DeclNameLookup
forall s (m :: * -&gt; *) a. MonadReader s m =&gt; Getting a s a -&gt; m a
</span><span class="hs-identifier hs-var">view</span></span><span> </span><span class="annot"><span class="annottext">Getting DeclNameLookup DeclCoherencyCheckState DeclNameLookup
</span><span class="">#declNameLookup</span></span><span class="hs-special">)</span><span>
</span><span id="line-216"></span><span>    </span><span class="annot"><span class="annottext">(m DeclCoherencyCheckState -&gt; m DeclNameLookup)
-&gt; (Nametree (DefnsF (Map NameSegment) Referent TypeReference)
    -&gt; m DeclCoherencyCheckState)
-&gt; Nametree (DefnsF (Map NameSegment) Referent TypeReference)
-&gt; m DeclNameLookup
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">StateT DeclCoherencyCheckState m ()
-&gt; DeclCoherencyCheckState -&gt; m DeclCoherencyCheckState
forall (m :: * -&gt; *) s a. Monad m =&gt; StateT s m a -&gt; s -&gt; m s
</span><span class="hs-operator hs-var">`State.execStateT`</span></span><span> </span><span class="annot"><span class="annottext">Map (Id' Hash) (Name, ConstructorNames)
-&gt; DeclNameLookup -&gt; DeclCoherencyCheckState
</span><a href="Unison.Merge.DeclCoherencyCheck.html#DeclCoherencyCheckState"><span class="hs-identifier hs-var">DeclCoherencyCheckState</span></a></span><span> </span><span class="annot"><span class="annottext">Map (Id' Hash) (Name, ConstructorNames)
forall k a. Map k a
</span><span class="hs-identifier hs-var">Map.empty</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Map Name Name -&gt; Map Name [Name] -&gt; DeclNameLookup
</span><span class="hs-identifier hs-var">DeclNameLookup</span></span><span> </span><span class="annot"><span class="annottext">Map Name Name
forall k a. Map k a
</span><span class="hs-identifier hs-var">Map.empty</span></span><span> </span><span class="annot"><span class="annottext">Map Name [Name]
forall k a. Map k a
</span><span class="hs-identifier hs-var">Map.empty</span></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-217"></span><span>    </span><span class="annot"><span class="annottext">(StateT DeclCoherencyCheckState m () -&gt; m DeclCoherencyCheckState)
-&gt; (Nametree (DefnsF (Map NameSegment) Referent TypeReference)
    -&gt; StateT DeclCoherencyCheckState m ())
-&gt; Nametree (DefnsF (Map NameSegment) Referent TypeReference)
-&gt; m DeclCoherencyCheckState
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">[NameSegment]
-&gt; Nametree (DefnsF (Map NameSegment) Referent TypeReference)
-&gt; StateT DeclCoherencyCheckState m ()
</span><a href="#local-6989586621679185141"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span>
</span><span id="line-218"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-219"></span><span>    </span><span class="annot"><a href="#local-6989586621679185141"><span class="hs-identifier hs-type">go</span></a></span><span> </span><span class="hs-glyph">::</span><span>
</span><span id="line-220"></span><span>      </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">NameSegment</span></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-221"></span><span>      </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Nametree</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">DefnsF</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Map</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">NameSegment</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Referent</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">TypeReference</span></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-222"></span><span>      </span><span class="annot"><span class="hs-identifier hs-type">StateT</span></span><span> </span><span class="annot"><a href="Unison.Merge.DeclCoherencyCheck.html#DeclCoherencyCheckState"><span class="hs-identifier hs-type">DeclCoherencyCheckState</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679184351"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><span id="line-223"></span><span>    </span><span id="local-6989586621679185141"><span class="annot"><span class="annottext">go :: [NameSegment]
-&gt; Nametree (DefnsF (Map NameSegment) Referent TypeReference)
-&gt; StateT DeclCoherencyCheckState m ()
</span><a href="#local-6989586621679185141"><span class="hs-identifier hs-var hs-var">go</span></a></span></span><span> </span><span id="local-6989586621679185142"><span class="annot"><span class="annottext">[NameSegment]
</span><a href="#local-6989586621679185142"><span class="hs-identifier hs-var">prefix</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Nametree</span></span><span> </span><span id="local-6989586621679185144"><span class="annot"><span class="annottext">DefnsF (Map NameSegment) Referent TypeReference
</span><a href="#local-6989586621679185144"><span class="hs-identifier hs-var">defns</span></a></span></span><span> </span><span id="local-6989586621679185145"><span class="annot"><span class="annottext">Map
  NameSegment
  (Nametree (DefnsF (Map NameSegment) Referent TypeReference))
</span><a href="#local-6989586621679185145"><span class="hs-identifier hs-var">children</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-224"></span><span>      </span><span class="annot"><span class="annottext">[(NameSegment, Referent)]
-&gt; ((NameSegment, Referent) -&gt; StateT DeclCoherencyCheckState m ())
-&gt; StateT DeclCoherencyCheckState m ()
forall (t :: * -&gt; *) (f :: * -&gt; *) a b.
(Foldable t, Applicative f) =&gt;
t a -&gt; (a -&gt; f b) -&gt; f ()
</span><span class="hs-identifier hs-var">for_</span></span><span>
</span><span id="line-225"></span><span>        </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Map NameSegment Referent -&gt; [(NameSegment, Referent)]
forall k a. Map k a -&gt; [(k, a)]
</span><span class="hs-identifier hs-var">Map.toList</span></span><span> </span><span class="annot"><span class="annottext">DefnsF (Map NameSegment) Referent TypeReference
</span><a href="#local-6989586621679185144"><span class="hs-identifier hs-var">defns</span></a></span><span class="hs-operator">.</span><span class="hs-identifier">terms</span><span class="hs-special">)</span><span>
</span><span id="line-226"></span><span>        </span><span class="hs-special">(</span><span> </span><span class="annot"><span class="annottext">OnIncoherentDeclReasons m
-&gt; [NameSegment]
-&gt; (NameSegment, Referent)
-&gt; StateT DeclCoherencyCheckState m ()
forall (m :: * -&gt; *).
Monad m =&gt;
OnIncoherentDeclReasons m
-&gt; [NameSegment]
-&gt; (NameSegment, Referent)
-&gt; StateT DeclCoherencyCheckState m ()
</span><a href="Unison.Merge.DeclCoherencyCheck.html#checkDeclCoherencyWith_DoTerms"><span class="hs-identifier hs-var">checkDeclCoherencyWith_DoTerms</span></a></span><span>
</span><span id="line-227"></span><span>            </span><span class="annot"><span class="annottext">OnIncoherentDeclReasons m
</span><a href="#local-6989586621679185135"><span class="hs-identifier hs-var">callbacks</span></a></span><span>
</span><span id="line-228"></span><span>            </span><span class="annot"><span class="annottext">[NameSegment]
</span><a href="#local-6989586621679185142"><span class="hs-identifier hs-var">prefix</span></a></span><span>
</span><span id="line-229"></span><span>        </span><span class="hs-special">)</span><span>
</span><span id="line-230"></span><span>      </span><span id="local-6989586621679185149"><span class="annot"><span class="annottext">[NameSegment]
</span><a href="#local-6989586621679185149"><span class="hs-identifier hs-var">childrenWeWentInto</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span>
</span><span id="line-231"></span><span>        </span><span class="annot"><span class="annottext">[(NameSegment, TypeReference)]
-&gt; ((NameSegment, TypeReference)
    -&gt; StateT DeclCoherencyCheckState m (Maybe NameSegment))
-&gt; StateT DeclCoherencyCheckState m [NameSegment]
forall (t :: * -&gt; *) (f :: * -&gt; *) a b.
(Witherable t, Applicative f) =&gt;
t a -&gt; (a -&gt; f (Maybe b)) -&gt; f (t b)
</span><span class="hs-identifier hs-var">forMaybe</span></span><span>
</span><span id="line-232"></span><span>          </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Map NameSegment TypeReference -&gt; [(NameSegment, TypeReference)]
forall k a. Map k a -&gt; [(k, a)]
</span><span class="hs-identifier hs-var">Map.toList</span></span><span> </span><span class="annot"><span class="annottext">DefnsF (Map NameSegment) Referent TypeReference
</span><a href="#local-6989586621679185144"><span class="hs-identifier hs-var">defns</span></a></span><span class="hs-operator">.</span><span class="hs-identifier">types</span><span class="hs-special">)</span><span>
</span><span id="line-233"></span><span>          </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(Id' Hash -&gt; m Int)
-&gt; OnIncoherentDeclReasons m
-&gt; ([NameSegment]
    -&gt; Nametree (DefnsF (Map NameSegment) Referent TypeReference)
    -&gt; StateT DeclCoherencyCheckState m ())
-&gt; [NameSegment]
-&gt; Map
     NameSegment
     (Nametree (DefnsF (Map NameSegment) Referent TypeReference))
-&gt; (NameSegment, TypeReference)
-&gt; StateT DeclCoherencyCheckState m (Maybe NameSegment)
forall (m :: * -&gt; *).
Monad m =&gt;
(Id' Hash -&gt; m Int)
-&gt; OnIncoherentDeclReasons m
-&gt; ([NameSegment]
    -&gt; Nametree (DefnsF (Map NameSegment) Referent TypeReference)
    -&gt; StateT DeclCoherencyCheckState m ())
-&gt; [NameSegment]
-&gt; Map
     NameSegment
     (Nametree (DefnsF (Map NameSegment) Referent TypeReference))
-&gt; (NameSegment, TypeReference)
-&gt; StateT DeclCoherencyCheckState m (Maybe NameSegment)
</span><a href="Unison.Merge.DeclCoherencyCheck.html#checkDeclCoherencyWith_DoTypes"><span class="hs-identifier hs-var">checkDeclCoherencyWith_DoTypes</span></a></span><span> </span><span class="annot"><span class="annottext">Id' Hash -&gt; m Int
</span><a href="#local-6989586621679185134"><span class="hs-identifier hs-var">loadDeclNumConstructors</span></a></span><span> </span><span class="annot"><span class="annottext">OnIncoherentDeclReasons m
</span><a href="#local-6989586621679185135"><span class="hs-identifier hs-var">callbacks</span></a></span><span> </span><span class="annot"><span class="annottext">[NameSegment]
-&gt; Nametree (DefnsF (Map NameSegment) Referent TypeReference)
-&gt; StateT DeclCoherencyCheckState m ()
</span><a href="#local-6989586621679185141"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="annot"><span class="annottext">[NameSegment]
</span><a href="#local-6989586621679185142"><span class="hs-identifier hs-var">prefix</span></a></span><span> </span><span class="annot"><span class="annottext">Map
  NameSegment
  (Nametree (DefnsF (Map NameSegment) Referent TypeReference))
</span><a href="#local-6989586621679185145"><span class="hs-identifier hs-var">children</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-234"></span><span>      </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621679185152"><span class="annot"><span class="annottext">childrenWeHaventGoneInto :: Map
  NameSegment
  (Nametree (DefnsF (Map NameSegment) Referent TypeReference))
</span><a href="#local-6989586621679185152"><span class="hs-identifier hs-var hs-var">childrenWeHaventGoneInto</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Map
  NameSegment
  (Nametree (DefnsF (Map NameSegment) Referent TypeReference))
</span><a href="#local-6989586621679185145"><span class="hs-identifier hs-var">children</span></a></span><span> </span><span class="annot"><span class="annottext">Map
  NameSegment
  (Nametree (DefnsF (Map NameSegment) Referent TypeReference))
-&gt; Set NameSegment
-&gt; Map
     NameSegment
     (Nametree (DefnsF (Map NameSegment) Referent TypeReference))
forall k a. Ord k =&gt; Map k a -&gt; Set k -&gt; Map k a
</span><span class="hs-operator hs-var">`Map.withoutKeys`</span></span><span> </span><span class="annot"><span class="annottext">[NameSegment] -&gt; Set NameSegment
forall a. Ord a =&gt; [a] -&gt; Set a
</span><span class="hs-identifier hs-var">Set.fromList</span></span><span> </span><span class="annot"><span class="annottext">[NameSegment]
</span><a href="#local-6989586621679185149"><span class="hs-identifier hs-var">childrenWeWentInto</span></a></span><span>
</span><span id="line-235"></span><span>      </span><span class="annot"><span class="annottext">[(NameSegment,
  Nametree (DefnsF (Map NameSegment) Referent TypeReference))]
-&gt; ((NameSegment,
     Nametree (DefnsF (Map NameSegment) Referent TypeReference))
    -&gt; StateT DeclCoherencyCheckState m ())
-&gt; StateT DeclCoherencyCheckState m ()
forall (t :: * -&gt; *) (f :: * -&gt; *) a b.
(Foldable t, Applicative f) =&gt;
t a -&gt; (a -&gt; f b) -&gt; f ()
</span><span class="hs-identifier hs-var">for_</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Map
  NameSegment
  (Nametree (DefnsF (Map NameSegment) Referent TypeReference))
-&gt; [(NameSegment,
     Nametree (DefnsF (Map NameSegment) Referent TypeReference))]
forall k a. Map k a -&gt; [(k, a)]
</span><span class="hs-identifier hs-var">Map.toList</span></span><span> </span><span class="annot"><span class="annottext">Map
  NameSegment
  (Nametree (DefnsF (Map NameSegment) Referent TypeReference))
</span><a href="#local-6989586621679185152"><span class="hs-identifier hs-var">childrenWeHaventGoneInto</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">\</span><span class="hs-special">(</span><span id="local-6989586621679185155"><span class="annot"><span class="annottext">NameSegment
</span><a href="#local-6989586621679185155"><span class="hs-identifier hs-var">name</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679185156"><span class="annot"><span class="annottext">Nametree (DefnsF (Map NameSegment) Referent TypeReference)
</span><a href="#local-6989586621679185156"><span class="hs-identifier hs-var">child</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">[NameSegment]
-&gt; Nametree (DefnsF (Map NameSegment) Referent TypeReference)
-&gt; StateT DeclCoherencyCheckState m ()
</span><a href="#local-6989586621679185141"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">NameSegment
</span><a href="#local-6989586621679185155"><span class="hs-identifier hs-var">name</span></a></span><span> </span><span class="annot"><span class="annottext">NameSegment -&gt; [NameSegment] -&gt; [NameSegment]
forall a. a -&gt; [a] -&gt; [a]
</span><span class="hs-glyph hs-var">:</span></span><span> </span><span class="annot"><span class="annottext">[NameSegment]
</span><a href="#local-6989586621679185142"><span class="hs-identifier hs-var">prefix</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Nametree (DefnsF (Map NameSegment) Referent TypeReference)
</span><a href="#local-6989586621679185156"><span class="hs-identifier hs-var">child</span></a></span><span>
</span><span id="line-236"></span><span>
</span><span id="line-237"></span><span class="annot"><a href="Unison.Merge.DeclCoherencyCheck.html#checkDeclCoherencyWith_DoTerms"><span class="hs-identifier hs-type">checkDeclCoherencyWith_DoTerms</span></a></span><span> </span><span class="hs-glyph">::</span><span>
</span><span id="line-238"></span><span>  </span><span class="hs-keyword">forall</span><span> </span><span id="local-6989586621679184413"><span class="annot"><a href="#local-6989586621679184413"><span class="hs-identifier hs-type">m</span></a></span></span><span class="hs-operator">.</span><span>
</span><span id="line-239"></span><span>  </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679184413"><span class="hs-identifier hs-type">m</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span>
</span><span id="line-240"></span><span>  </span><span class="annot"><a href="Unison.Merge.DeclCoherencyCheck.html#OnIncoherentDeclReasons"><span class="hs-identifier hs-type">OnIncoherentDeclReasons</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679184413"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-241"></span><span>  </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">NameSegment</span></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-242"></span><span>  </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">NameSegment</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Referent</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-243"></span><span>  </span><span class="annot"><span class="hs-identifier hs-type">StateT</span></span><span> </span><span class="annot"><a href="Unison.Merge.DeclCoherencyCheck.html#DeclCoherencyCheckState"><span class="hs-identifier hs-type">DeclCoherencyCheckState</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679184413"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><span id="line-244"></span><span id="checkDeclCoherencyWith_DoTerms"><span class="annot"><span class="annottext">checkDeclCoherencyWith_DoTerms :: forall (m :: * -&gt; *).
Monad m =&gt;
OnIncoherentDeclReasons m
-&gt; [NameSegment]
-&gt; (NameSegment, Referent)
-&gt; StateT DeclCoherencyCheckState m ()
</span><a href="Unison.Merge.DeclCoherencyCheck.html#checkDeclCoherencyWith_DoTerms"><span class="hs-identifier hs-var hs-var">checkDeclCoherencyWith_DoTerms</span></a></span></span><span> </span><span id="local-6989586621679185220"><span class="annot"><span class="annottext">OnIncoherentDeclReasons m
</span><a href="#local-6989586621679185220"><span class="hs-identifier hs-var">callbacks</span></a></span></span><span> </span><span id="local-6989586621679185221"><span class="annot"><span class="annottext">[NameSegment]
</span><a href="#local-6989586621679185221"><span class="hs-identifier hs-var">prefix</span></a></span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621679185222"><span class="annot"><span class="annottext">NameSegment
</span><a href="#local-6989586621679185222"><span class="hs-identifier hs-var">segment</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679185223"><span class="annot"><span class="annottext">Referent
</span><a href="#local-6989586621679185223"><span class="hs-identifier hs-var">ref</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-245"></span><span>  </span><span class="annot"><span class="annottext">Maybe ConstructorReferenceId
-&gt; (ConstructorReferenceId -&gt; StateT DeclCoherencyCheckState m ())
-&gt; StateT DeclCoherencyCheckState m ()
forall (m :: * -&gt; *) a.
Applicative m =&gt;
Maybe a -&gt; (a -&gt; m ()) -&gt; m ()
</span><span class="hs-identifier hs-var">whenJust</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Referent -&gt; Maybe ConstructorReferenceId
</span><span class="hs-identifier hs-var">Referent.toConstructorReferenceId</span></span><span> </span><span class="annot"><span class="annottext">Referent
</span><a href="#local-6989586621679185223"><span class="hs-identifier hs-var">ref</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">\</span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">ConstructorReference</span></span><span> </span><span id="local-6989586621679185227"><span class="annot"><span class="annottext">Id' Hash
</span><a href="#local-6989586621679185227"><span class="hs-identifier hs-var">typeRef</span></a></span></span><span> </span><span id="local-6989586621679185228"><span class="annot"><span class="annottext">Word64
</span><a href="#local-6989586621679185228"><span class="hs-identifier hs-var">conId</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-246"></span><span>    </span><span class="hs-keyword">let</span><span> </span><span class="annot"><a href="#local-6989586621679185229"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Unison.Merge.DeclCoherencyCheck.html#ConstructorNames"><span class="hs-identifier hs-type">ConstructorNames</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">MaybeT</span></span><span> </span><span class="annot"><a href="#local-6989586621679184413"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Unison.Merge.DeclCoherencyCheck.html#ConstructorNames"><span class="hs-identifier hs-type">ConstructorNames</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-247"></span><span>        </span><span id="local-6989586621679185229"><span class="annot"><span class="annottext">f :: Maybe (Name, ConstructorNames) -&gt; MaybeT m (Name, ConstructorNames)
</span><a href="#local-6989586621679185229"><span class="hs-identifier hs-var hs-var">f</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-glyph">\</span><span class="hs-glyph">case</span><span>
</span><span id="line-248"></span><span>          </span><span class="annot"><span class="annottext">Maybe (Name, ConstructorNames)
</span><span class="hs-identifier hs-var">Nothing</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-249"></span><span>            </span><span class="annot"><span class="annottext">m () -&gt; MaybeT m ()
forall (m :: * -&gt; *) a. Monad m =&gt; m a -&gt; MaybeT m a
forall (t :: (* -&gt; *) -&gt; * -&gt; *) (m :: * -&gt; *) a.
(MonadTrans t, Monad m) =&gt;
m a -&gt; t m a
</span><span class="hs-identifier hs-var">lift</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">OnIncoherentDeclReasons m
</span><a href="#local-6989586621679185220"><span class="hs-identifier hs-var">callbacks</span></a></span><span class="hs-operator">.</span><span class="hs-identifier">onStrayConstructor</span><span> </span><span class="annot"><span class="annottext">Id' Hash
</span><a href="#local-6989586621679185227"><span class="hs-identifier hs-var">typeRef</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679185230"><span class="hs-identifier hs-var">conName</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-250"></span><span>            </span><span class="annot"><span class="annottext">m (Maybe (Name, ConstructorNames))
-&gt; MaybeT m (Name, ConstructorNames)
forall (m :: * -&gt; *) a. m (Maybe a) -&gt; MaybeT m a
</span><span class="hs-identifier hs-var">MaybeT</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Maybe (Name, ConstructorNames)
-&gt; m (Maybe (Name, ConstructorNames))
forall a. a -&gt; m a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">Maybe (Name, ConstructorNames)
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span class="hs-special">)</span><span>
</span><span id="line-251"></span><span>          </span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621679185232"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679185232"><span class="hs-identifier hs-var">typeName</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679185233"><span class="annot"><span class="annottext">ConstructorNames
</span><a href="#local-6989586621679185233"><span class="hs-identifier hs-var">expected</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-252"></span><span>            </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">HasCallStack =&gt;
Word64 -&gt; Name -&gt; ConstructorNames -&gt; Either Name ConstructorNames
Word64 -&gt; Name -&gt; ConstructorNames -&gt; Either Name ConstructorNames
</span><a href="Unison.Merge.DeclCoherencyCheck.html#recordConstructorName"><span class="hs-identifier hs-var">recordConstructorName</span></a></span><span> </span><span class="annot"><span class="annottext">Word64
</span><a href="#local-6989586621679185228"><span class="hs-identifier hs-var">conId</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679185230"><span class="hs-identifier hs-var">conName</span></a></span><span> </span><span class="annot"><span class="annottext">ConstructorNames
</span><a href="#local-6989586621679185233"><span class="hs-identifier hs-var">expected</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-253"></span><span>              </span><span class="annot"><span class="hs-identifier hs-type">Left</span></span><span> </span><span id="local-6989586621679185235"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679185235"><span class="hs-identifier hs-var">existingName</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-254"></span><span>                </span><span class="annot"><span class="annottext">m () -&gt; MaybeT m ()
forall (m :: * -&gt; *) a. Monad m =&gt; m a -&gt; MaybeT m a
forall (t :: (* -&gt; *) -&gt; * -&gt; *) (m :: * -&gt; *) a.
(MonadTrans t, Monad m) =&gt;
m a -&gt; t m a
</span><span class="hs-identifier hs-var">lift</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">OnIncoherentDeclReasons m
</span><a href="#local-6989586621679185220"><span class="hs-identifier hs-var">callbacks</span></a></span><span class="hs-operator">.</span><span class="hs-identifier">onConstructorAlias</span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679185232"><span class="hs-identifier hs-var">typeName</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679185235"><span class="hs-identifier hs-var">existingName</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679185230"><span class="hs-identifier hs-var">conName</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-255"></span><span>                </span><span class="annot"><span class="annottext">m (Maybe (Name, ConstructorNames))
-&gt; MaybeT m (Name, ConstructorNames)
forall (m :: * -&gt; *) a. m (Maybe a) -&gt; MaybeT m a
</span><span class="hs-identifier hs-var">MaybeT</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Maybe (Name, ConstructorNames)
-&gt; m (Maybe (Name, ConstructorNames))
forall a. a -&gt; m a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">Maybe (Name, ConstructorNames)
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span class="hs-special">)</span><span>
</span><span id="line-256"></span><span>              </span><span class="annot"><span class="hs-identifier hs-type">Right</span></span><span> </span><span id="local-6989586621679185236"><span class="annot"><span class="annottext">ConstructorNames
</span><a href="#local-6989586621679185236"><span class="hs-identifier hs-var">expected1</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">(Name, ConstructorNames) -&gt; MaybeT m (Name, ConstructorNames)
forall a. a -&gt; MaybeT m a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679185232"><span class="hs-identifier hs-var">typeName</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">ConstructorNames
</span><a href="#local-6989586621679185236"><span class="hs-identifier hs-var">expected1</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-257"></span><span>          </span><span class="hs-keyword">where</span><span>
</span><span id="line-258"></span><span>            </span><span id="local-6989586621679185230"><span class="annot"><span class="annottext">conName :: Name
</span><a href="#local-6989586621679185230"><span class="hs-identifier hs-var hs-var">conName</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-259"></span><span>              </span><span class="annot"><span class="annottext">NonEmpty NameSegment -&gt; Name
</span><span class="hs-identifier hs-var">Name.fromReverseSegments</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">NameSegment
</span><a href="#local-6989586621679185222"><span class="hs-identifier hs-var">segment</span></a></span><span> </span><span class="annot"><span class="annottext">NameSegment -&gt; [NameSegment] -&gt; NonEmpty NameSegment
forall a. a -&gt; [a] -&gt; NonEmpty a
</span><span class="hs-operator hs-var">:|</span></span><span> </span><span class="annot"><span class="annottext">[NameSegment]
</span><a href="#local-6989586621679185221"><span class="hs-identifier hs-var">prefix</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-260"></span><span>    </span><span id="local-6989586621679185238"><span class="annot"><span class="annottext">DeclCoherencyCheckState
</span><a href="#local-6989586621679185238"><span class="hs-identifier hs-var">state</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">StateT DeclCoherencyCheckState m DeclCoherencyCheckState
forall s (m :: * -&gt; *). MonadState s m =&gt; m s
</span><span class="hs-identifier hs-var">State.get</span></span><span>
</span><span id="line-261"></span><span>    </span><span class="annot"><span class="annottext">StateT
  DeclCoherencyCheckState
  m
  (Maybe (Map (Id' Hash) (Name, ConstructorNames)))
-&gt; (Map (Id' Hash) (Name, ConstructorNames)
    -&gt; StateT DeclCoherencyCheckState m ())
-&gt; StateT DeclCoherencyCheckState m ()
forall (m :: * -&gt; *) a.
Monad m =&gt;
m (Maybe a) -&gt; (a -&gt; m ()) -&gt; m ()
</span><span class="hs-identifier hs-var">whenJustM</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">m (Maybe (Map (Id' Hash) (Name, ConstructorNames)))
-&gt; StateT
     DeclCoherencyCheckState
     m
     (Maybe (Map (Id' Hash) (Name, ConstructorNames)))
forall (m :: * -&gt; *) a.
Monad m =&gt;
m a -&gt; StateT DeclCoherencyCheckState m a
forall (t :: (* -&gt; *) -&gt; * -&gt; *) (m :: * -&gt; *) a.
(MonadTrans t, Monad m) =&gt;
m a -&gt; t m a
</span><span class="hs-identifier hs-var">lift</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">MaybeT m (Map (Id' Hash) (Name, ConstructorNames))
-&gt; m (Maybe (Map (Id' Hash) (Name, ConstructorNames)))
forall (m :: * -&gt; *) a. MaybeT m a -&gt; m (Maybe a)
</span><span class="hs-identifier hs-var">runMaybeT</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(Maybe (Name, ConstructorNames)
 -&gt; MaybeT m (Name, ConstructorNames))
-&gt; Id' Hash
-&gt; Map (Id' Hash) (Name, ConstructorNames)
-&gt; MaybeT m (Map (Id' Hash) (Name, ConstructorNames))
forall (f :: * -&gt; *) k v.
(Functor f, Ord k) =&gt;
(Maybe v -&gt; f v) -&gt; k -&gt; Map k v -&gt; f (Map k v)
</span><span class="hs-identifier hs-var">Map.upsertF</span></span><span> </span><span class="annot"><span class="annottext">Maybe (Name, ConstructorNames) -&gt; MaybeT m (Name, ConstructorNames)
</span><a href="#local-6989586621679185229"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">Id' Hash
</span><a href="#local-6989586621679185227"><span class="hs-identifier hs-var">typeRef</span></a></span><span> </span><span class="annot"><span class="annottext">DeclCoherencyCheckState
</span><a href="#local-6989586621679185238"><span class="hs-identifier hs-var">state</span></a></span><span class="hs-operator">.</span><span class="hs-identifier">expectedConstructors</span><span class="hs-special">)</span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">\</span><span id="local-6989586621679185242"><span class="annot"><span class="annottext">Map (Id' Hash) (Name, ConstructorNames)
</span><a href="#local-6989586621679185242"><span class="hs-identifier hs-var">expectedConstructors1</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span class="hs-cpp">
      #expectedConstructors .= expectedConstructors1
</span><span>
</span><span id="line-264"></span><span class="annot"><a href="Unison.Merge.DeclCoherencyCheck.html#checkDeclCoherencyWith_DoTypes"><span class="hs-identifier hs-type">checkDeclCoherencyWith_DoTypes</span></a></span><span> </span><span class="hs-glyph">::</span><span>
</span><span id="line-265"></span><span>  </span><span class="hs-keyword">forall</span><span> </span><span id="local-6989586621679184418"><span class="annot"><a href="#local-6989586621679184418"><span class="hs-identifier hs-type">m</span></a></span></span><span class="hs-operator">.</span><span>
</span><span id="line-266"></span><span>  </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679184418"><span class="hs-identifier hs-type">m</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span>
</span><span id="line-267"></span><span>  </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">TypeReferenceId</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679184418"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-268"></span><span>  </span><span class="annot"><a href="Unison.Merge.DeclCoherencyCheck.html#OnIncoherentDeclReasons"><span class="hs-identifier hs-type">OnIncoherentDeclReasons</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679184418"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-269"></span><span>  </span><span class="hs-special">(</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">NameSegment</span></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-270"></span><span>    </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Nametree</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">DefnsF</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Map</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">NameSegment</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Referent</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">TypeReference</span></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-271"></span><span>    </span><span class="annot"><span class="hs-identifier hs-type">StateT</span></span><span> </span><span class="annot"><a href="Unison.Merge.DeclCoherencyCheck.html#DeclCoherencyCheckState"><span class="hs-identifier hs-type">DeclCoherencyCheckState</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679184418"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><span id="line-272"></span><span>  </span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-273"></span><span>  </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">NameSegment</span></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-274"></span><span>  </span><span class="annot"><span class="hs-identifier hs-type">Map</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">NameSegment</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Nametree</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">DefnsF</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Map</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">NameSegment</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Referent</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">TypeReference</span></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-275"></span><span>  </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">NameSegment</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">TypeReference</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-276"></span><span>  </span><span class="annot"><span class="hs-identifier hs-type">StateT</span></span><span> </span><span class="annot"><a href="Unison.Merge.DeclCoherencyCheck.html#DeclCoherencyCheckState"><span class="hs-identifier hs-type">DeclCoherencyCheckState</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679184418"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">NameSegment</span></span><span class="hs-special">)</span><span>
</span><span id="line-277"></span><span id="checkDeclCoherencyWith_DoTypes"><span class="annot"><span class="annottext">checkDeclCoherencyWith_DoTypes :: forall (m :: * -&gt; *).
Monad m =&gt;
(Id' Hash -&gt; m Int)
-&gt; OnIncoherentDeclReasons m
-&gt; ([NameSegment]
    -&gt; Nametree (DefnsF (Map NameSegment) Referent TypeReference)
    -&gt; StateT DeclCoherencyCheckState m ())
-&gt; [NameSegment]
-&gt; Map
     NameSegment
     (Nametree (DefnsF (Map NameSegment) Referent TypeReference))
-&gt; (NameSegment, TypeReference)
-&gt; StateT DeclCoherencyCheckState m (Maybe NameSegment)
</span><a href="Unison.Merge.DeclCoherencyCheck.html#checkDeclCoherencyWith_DoTypes"><span class="hs-identifier hs-var hs-var">checkDeclCoherencyWith_DoTypes</span></a></span></span><span> </span><span id="local-6989586621679185248"><span class="annot"><span class="annottext">Id' Hash -&gt; m Int
</span><a href="#local-6989586621679185248"><span class="hs-identifier hs-var">loadDeclNumConstructors</span></a></span></span><span> </span><span id="local-6989586621679185249"><span class="annot"><span class="annottext">OnIncoherentDeclReasons m
</span><a href="#local-6989586621679185249"><span class="hs-identifier hs-var">callbacks</span></a></span></span><span> </span><span id="local-6989586621679185250"><span class="annot"><span class="annottext">[NameSegment]
-&gt; Nametree (DefnsF (Map NameSegment) Referent TypeReference)
-&gt; StateT DeclCoherencyCheckState m ()
</span><a href="#local-6989586621679185250"><span class="hs-identifier hs-var">go</span></a></span></span><span> </span><span id="local-6989586621679185251"><span class="annot"><span class="annottext">[NameSegment]
</span><a href="#local-6989586621679185251"><span class="hs-identifier hs-var">prefix</span></a></span></span><span> </span><span id="local-6989586621679185252"><span class="annot"><span class="annottext">Map
  NameSegment
  (Nametree (DefnsF (Map NameSegment) Referent TypeReference))
</span><a href="#local-6989586621679185252"><span class="hs-identifier hs-var">children</span></a></span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621679185253"><span class="annot"><span class="annottext">NameSegment
</span><a href="#local-6989586621679185253"><span class="hs-identifier hs-var">name</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679185254"><span class="annot"><span class="annottext">TypeReference
</span><a href="#local-6989586621679185254"><span class="hs-identifier hs-var">ref</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-278"></span><span>  </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">TypeReference -&gt; Maybe (Id' Hash)
</span><span class="hs-identifier hs-var">Reference.toId</span></span><span> </span><span class="annot"><span class="annottext">TypeReference
</span><a href="#local-6989586621679185254"><span class="hs-identifier hs-var">ref</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-279"></span><span>    </span><span class="annot"><span class="annottext">Maybe (Id' Hash)
</span><span class="hs-identifier hs-var">Nothing</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Maybe NameSegment
-&gt; StateT DeclCoherencyCheckState m (Maybe NameSegment)
forall a. a -&gt; StateT DeclCoherencyCheckState m a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">Maybe NameSegment
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span>
</span><span id="line-280"></span><span>    </span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span id="local-6989586621679185256"><span class="annot"><span class="annottext">Id' Hash
</span><a href="#local-6989586621679185256"><span class="hs-identifier hs-var">refId</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-281"></span><span>      </span><span class="annot"><span class="annottext">(Id' Hash -&gt; m Int)
-&gt; OnIncoherentDeclReasons m
-&gt; ([NameSegment]
    -&gt; Nametree (DefnsF (Map NameSegment) Referent TypeReference)
    -&gt; StateT DeclCoherencyCheckState m ())
-&gt; [NameSegment]
-&gt; Map
     NameSegment
     (Nametree (DefnsF (Map NameSegment) Referent TypeReference))
-&gt; NameSegment
-&gt; Id' Hash
-&gt; StateT DeclCoherencyCheckState m (Maybe NameSegment)
forall (m :: * -&gt; *).
Monad m =&gt;
(Id' Hash -&gt; m Int)
-&gt; OnIncoherentDeclReasons m
-&gt; ([NameSegment]
    -&gt; Nametree (DefnsF (Map NameSegment) Referent TypeReference)
    -&gt; StateT DeclCoherencyCheckState m ())
-&gt; [NameSegment]
-&gt; Map
     NameSegment
     (Nametree (DefnsF (Map NameSegment) Referent TypeReference))
-&gt; NameSegment
-&gt; Id' Hash
-&gt; StateT DeclCoherencyCheckState m (Maybe NameSegment)
</span><a href="Unison.Merge.DeclCoherencyCheck.html#checkDeclCoherencyWith_DoTypes2"><span class="hs-identifier hs-var">checkDeclCoherencyWith_DoTypes2</span></a></span><span> </span><span class="annot"><span class="annottext">Id' Hash -&gt; m Int
</span><a href="#local-6989586621679185248"><span class="hs-identifier hs-var">loadDeclNumConstructors</span></a></span><span> </span><span class="annot"><span class="annottext">OnIncoherentDeclReasons m
</span><a href="#local-6989586621679185249"><span class="hs-identifier hs-var">callbacks</span></a></span><span> </span><span class="annot"><span class="annottext">[NameSegment]
-&gt; Nametree (DefnsF (Map NameSegment) Referent TypeReference)
-&gt; StateT DeclCoherencyCheckState m ()
</span><a href="#local-6989586621679185250"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="annot"><span class="annottext">[NameSegment]
</span><a href="#local-6989586621679185251"><span class="hs-identifier hs-var">prefix</span></a></span><span> </span><span class="annot"><span class="annottext">Map
  NameSegment
  (Nametree (DefnsF (Map NameSegment) Referent TypeReference))
</span><a href="#local-6989586621679185252"><span class="hs-identifier hs-var">children</span></a></span><span> </span><span class="annot"><span class="annottext">NameSegment
</span><a href="#local-6989586621679185253"><span class="hs-identifier hs-var">name</span></a></span><span> </span><span class="annot"><span class="annottext">Id' Hash
</span><a href="#local-6989586621679185256"><span class="hs-identifier hs-var">refId</span></a></span><span>
</span><span id="line-282"></span><span>
</span><span id="line-283"></span><span class="annot"><a href="Unison.Merge.DeclCoherencyCheck.html#checkDeclCoherencyWith_DoTypes2"><span class="hs-identifier hs-type">checkDeclCoherencyWith_DoTypes2</span></a></span><span> </span><span class="hs-glyph">::</span><span>
</span><span id="line-284"></span><span>  </span><span class="hs-keyword">forall</span><span> </span><span id="local-6989586621679184453"><span class="annot"><a href="#local-6989586621679184453"><span class="hs-identifier hs-type">m</span></a></span></span><span class="hs-operator">.</span><span>
</span><span id="line-285"></span><span>  </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679184453"><span class="hs-identifier hs-type">m</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span>
</span><span id="line-286"></span><span>  </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">TypeReferenceId</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679184453"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-287"></span><span>  </span><span class="annot"><a href="Unison.Merge.DeclCoherencyCheck.html#OnIncoherentDeclReasons"><span class="hs-identifier hs-type">OnIncoherentDeclReasons</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679184453"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-288"></span><span>  </span><span class="hs-special">(</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">NameSegment</span></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-289"></span><span>    </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Nametree</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">DefnsF</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Map</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">NameSegment</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Referent</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">TypeReference</span></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-290"></span><span>    </span><span class="annot"><span class="hs-identifier hs-type">StateT</span></span><span> </span><span class="annot"><a href="Unison.Merge.DeclCoherencyCheck.html#DeclCoherencyCheckState"><span class="hs-identifier hs-type">DeclCoherencyCheckState</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679184453"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><span id="line-291"></span><span>  </span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-292"></span><span>  </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">NameSegment</span></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-293"></span><span>  </span><span class="annot"><span class="hs-identifier hs-type">Map</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">NameSegment</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Nametree</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">DefnsF</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Map</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">NameSegment</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Referent</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">TypeReference</span></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-294"></span><span>  </span><span class="annot"><span class="hs-identifier hs-type">NameSegment</span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-295"></span><span>  </span><span class="annot"><span class="hs-identifier hs-type">TypeReferenceId</span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-296"></span><span>  </span><span class="annot"><span class="hs-identifier hs-type">StateT</span></span><span> </span><span class="annot"><a href="Unison.Merge.DeclCoherencyCheck.html#DeclCoherencyCheckState"><span class="hs-identifier hs-type">DeclCoherencyCheckState</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679184453"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">NameSegment</span></span><span class="hs-special">)</span><span>
</span><span id="line-297"></span><span id="checkDeclCoherencyWith_DoTypes2"><span class="annot"><span class="annottext">checkDeclCoherencyWith_DoTypes2 :: forall (m :: * -&gt; *).
Monad m =&gt;
(Id' Hash -&gt; m Int)
-&gt; OnIncoherentDeclReasons m
-&gt; ([NameSegment]
    -&gt; Nametree (DefnsF (Map NameSegment) Referent TypeReference)
    -&gt; StateT DeclCoherencyCheckState m ())
-&gt; [NameSegment]
-&gt; Map
     NameSegment
     (Nametree (DefnsF (Map NameSegment) Referent TypeReference))
-&gt; NameSegment
-&gt; Id' Hash
-&gt; StateT DeclCoherencyCheckState m (Maybe NameSegment)
</span><a href="Unison.Merge.DeclCoherencyCheck.html#checkDeclCoherencyWith_DoTypes2"><span class="hs-identifier hs-var hs-var">checkDeclCoherencyWith_DoTypes2</span></a></span></span><span> </span><span id="local-6989586621679185495"><span class="annot"><span class="annottext">Id' Hash -&gt; m Int
</span><a href="#local-6989586621679185495"><span class="hs-identifier hs-var">loadDeclNumConstructors</span></a></span></span><span> </span><span id="local-6989586621679185496"><span class="annot"><span class="annottext">OnIncoherentDeclReasons m
</span><a href="#local-6989586621679185496"><span class="hs-identifier hs-var">callbacks</span></a></span></span><span> </span><span id="local-6989586621679185497"><span class="annot"><span class="annottext">[NameSegment]
-&gt; Nametree (DefnsF (Map NameSegment) Referent TypeReference)
-&gt; StateT DeclCoherencyCheckState m ()
</span><a href="#local-6989586621679185497"><span class="hs-identifier hs-var">go</span></a></span></span><span> </span><span id="local-6989586621679185498"><span class="annot"><span class="annottext">[NameSegment]
</span><a href="#local-6989586621679185498"><span class="hs-identifier hs-var">prefix</span></a></span></span><span> </span><span id="local-6989586621679185499"><span class="annot"><span class="annottext">Map
  NameSegment
  (Nametree (DefnsF (Map NameSegment) Referent TypeReference))
</span><a href="#local-6989586621679185499"><span class="hs-identifier hs-var">children</span></a></span></span><span> </span><span id="local-6989586621679185500"><span class="annot"><span class="annottext">NameSegment
</span><a href="#local-6989586621679185500"><span class="hs-identifier hs-var">name</span></a></span></span><span> </span><span id="local-6989586621679185501"><span class="annot"><span class="annottext">Id' Hash
</span><a href="#local-6989586621679185501"><span class="hs-identifier hs-var">typeRef</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-298"></span><span>  </span><span id="local-6989586621679185502"><span class="annot"><span class="annottext">DeclCoherencyCheckState
</span><a href="#local-6989586621679185502"><span class="hs-identifier hs-var">state</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">StateT DeclCoherencyCheckState m DeclCoherencyCheckState
forall s (m :: * -&gt; *). MonadState s m =&gt; m s
</span><span class="hs-identifier hs-var">State.get</span></span><span>
</span><span id="line-299"></span><span>  </span><span class="annot"><span class="annottext">m (Maybe (WhatHappened (Map (Id' Hash) (Name, ConstructorNames))))
-&gt; StateT
     DeclCoherencyCheckState
     m
     (Maybe (WhatHappened (Map (Id' Hash) (Name, ConstructorNames))))
forall (m :: * -&gt; *) a.
Monad m =&gt;
m a -&gt; StateT DeclCoherencyCheckState m a
forall (t :: (* -&gt; *) -&gt; * -&gt; *) (m :: * -&gt; *) a.
(MonadTrans t, Monad m) =&gt;
m a -&gt; t m a
</span><span class="hs-identifier hs-var">lift</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">MaybeT m (WhatHappened (Map (Id' Hash) (Name, ConstructorNames)))
-&gt; m (Maybe
        (WhatHappened (Map (Id' Hash) (Name, ConstructorNames))))
forall (m :: * -&gt; *) a. MaybeT m a -&gt; m (Maybe a)
</span><span class="hs-identifier hs-var">runMaybeT</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Compose
  (MaybeT m) WhatHappened (Map (Id' Hash) (Name, ConstructorNames))
-&gt; MaybeT
     m (WhatHappened (Map (Id' Hash) (Name, ConstructorNames)))
forall {k1} {k2} (f :: k1 -&gt; *) (g :: k2 -&gt; k1) (a :: k2).
Compose f g a -&gt; f (g a)
</span><span class="hs-identifier hs-var">getCompose</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(Maybe (Name, ConstructorNames)
 -&gt; Compose (MaybeT m) WhatHappened (Name, ConstructorNames))
-&gt; Id' Hash
-&gt; Map (Id' Hash) (Name, ConstructorNames)
-&gt; Compose
     (MaybeT m) WhatHappened (Map (Id' Hash) (Name, ConstructorNames))
forall (f :: * -&gt; *) k v.
(Functor f, Ord k) =&gt;
(Maybe v -&gt; f v) -&gt; k -&gt; Map k v -&gt; f (Map k v)
</span><span class="hs-identifier hs-var">Map.upsertF</span></span><span> </span><span class="annot"><span class="annottext">Maybe (Name, ConstructorNames)
-&gt; Compose (MaybeT m) WhatHappened (Name, ConstructorNames)
</span><a href="#local-6989586621679185504"><span class="hs-identifier hs-var">recordNewDecl</span></a></span><span> </span><span class="annot"><span class="annottext">Id' Hash
</span><a href="#local-6989586621679185501"><span class="hs-identifier hs-var">typeRef</span></a></span><span> </span><span class="annot"><span class="annottext">DeclCoherencyCheckState
</span><a href="#local-6989586621679185502"><span class="hs-identifier hs-var">state</span></a></span><span class="hs-operator">.</span><span class="hs-identifier">expectedConstructors</span><span class="hs-special">)</span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">StateT
  DeclCoherencyCheckState
  m
  (Maybe (WhatHappened (Map (Id' Hash) (Name, ConstructorNames))))
-&gt; (Maybe (WhatHappened (Map (Id' Hash) (Name, ConstructorNames)))
    -&gt; StateT DeclCoherencyCheckState m (Maybe NameSegment))
-&gt; StateT DeclCoherencyCheckState m (Maybe NameSegment)
forall a b.
StateT DeclCoherencyCheckState m a
-&gt; (a -&gt; StateT DeclCoherencyCheckState m b)
-&gt; StateT DeclCoherencyCheckState m b
forall (m :: * -&gt; *) a b. Monad m =&gt; m a -&gt; (a -&gt; m b) -&gt; m b
</span><span class="hs-operator hs-var">&gt;&gt;=</span></span><span> </span><span class="hs-glyph">\</span><span class="hs-glyph">case</span><span>
</span><span id="line-300"></span><span>    </span><span class="annot"><span class="annottext">Maybe (WhatHappened (Map (Id' Hash) (Name, ConstructorNames)))
</span><span class="hs-identifier hs-var">Nothing</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Maybe NameSegment
-&gt; StateT DeclCoherencyCheckState m (Maybe NameSegment)
forall a. a -&gt; StateT DeclCoherencyCheckState m a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">Maybe NameSegment
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span>
</span><span id="line-301"></span><span>    </span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span class="annot"><span class="annottext">WhatHappened (Map (Id' Hash) (Name, ConstructorNames))
</span><a href="Unison.Merge.DeclCoherencyCheck.html#UninhabitedDecl"><span class="hs-identifier hs-var">UninhabitedDecl</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">do</span><span class="hs-cpp">
      #declNameLookup . #declToConstructors %= Map.insert typeName []
</span><span>      </span><span class="hs-identifier">pure</span><span> </span><span class="hs-identifier">Nothing</span><span>
</span><span id="line-304"></span><span>    </span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Unison.Merge.DeclCoherencyCheck.html#InhabitedDecl"><span class="hs-identifier hs-type">InhabitedDecl</span></a></span><span> </span><span id="local-6989586621679185509"><span class="annot"><span class="annottext">Map (Id' Hash) (Name, ConstructorNames)
</span><a href="#local-6989586621679185509"><span class="hs-identifier hs-var">expectedConstructors1</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-305"></span><span>      </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">NameSegment
-&gt; Map
     NameSegment
     (Nametree (DefnsF (Map NameSegment) Referent TypeReference))
-&gt; Maybe
     (Nametree (DefnsF (Map NameSegment) Referent TypeReference))
forall k a. Ord k =&gt; k -&gt; Map k a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Map.lookup</span></span><span> </span><span class="annot"><span class="annottext">NameSegment
</span><a href="#local-6989586621679185500"><span class="hs-identifier hs-var">name</span></a></span><span> </span><span class="annot"><span class="annottext">Map
  NameSegment
  (Nametree (DefnsF (Map NameSegment) Referent TypeReference))
</span><a href="#local-6989586621679185499"><span class="hs-identifier hs-var">children</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-306"></span><span>        </span><span class="annot"><span class="annottext">Maybe (Nametree (DefnsF (Map NameSegment) Referent TypeReference))
</span><span class="hs-identifier hs-var">Nothing</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-307"></span><span>          </span><span class="annot"><span class="annottext">m () -&gt; StateT DeclCoherencyCheckState m ()
forall (m :: * -&gt; *) a.
Monad m =&gt;
m a -&gt; StateT DeclCoherencyCheckState m a
forall (t :: (* -&gt; *) -&gt; * -&gt; *) (m :: * -&gt; *) a.
(MonadTrans t, Monad m) =&gt;
m a -&gt; t m a
</span><span class="hs-identifier hs-var">lift</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">OnIncoherentDeclReasons m
</span><a href="#local-6989586621679185496"><span class="hs-identifier hs-var">callbacks</span></a></span><span class="hs-operator">.</span><span class="hs-identifier">onMissingConstructorName</span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679185507"><span class="hs-identifier hs-var">typeName</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-308"></span><span>          </span><span class="hs-identifier">pure</span><span> </span><span class="annot"><span class="annottext">Maybe NameSegment
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span>
</span><span id="line-309"></span><span>        </span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span id="local-6989586621679185511"><span class="annot"><span class="annottext">Nametree (DefnsF (Map NameSegment) Referent TypeReference)
</span><a href="#local-6989586621679185511"><span class="hs-identifier hs-var">child</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">do</span><span class="hs-cpp">
          #expectedConstructors .= expectedConstructors1
</span><span>          </span><span class="hs-identifier">go</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">name</span><span> </span><span class="hs-glyph">:</span><span> </span><span class="hs-identifier">prefix</span><span class="hs-special">)</span><span> </span><span class="hs-identifier">child</span><span>
</span><span id="line-312"></span><span>          </span><span class="hs-identifier">state</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="hs-identifier">State.get</span><span>
</span><span id="line-313"></span><span>          </span><span class="hs-comment">-- fromJust is safe here because we upserted `typeRef` key above</span><span>
</span><span id="line-314"></span><span>          </span><span class="hs-keyword">let</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">fromJust</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">_typeName</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">maybeConstructorNames</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">expectedConstructors1</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-315"></span><span>                </span><span class="hs-identifier">Map.deleteLookup</span><span> </span><span class="hs-identifier">typeRef</span><span> </span><span class="hs-identifier">state</span><span class="hs-operator">.</span><span class="hs-identifier">expectedConstructors</span><span class="hs-cpp">
          #expectedConstructors .= expectedConstructors1
</span><span>          </span><span class="hs-keyword">case</span><span> </span><span class="hs-identifier">sequence</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">IntMap.elems</span><span> </span><span class="hs-identifier">maybeConstructorNames</span><span class="hs-special">)</span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-318"></span><span>            </span><span class="hs-identifier">Nothing</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier">lift</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">callbacks</span><span class="hs-operator">.</span><span class="hs-identifier">onMissingConstructorName</span><span> </span><span class="hs-identifier">typeName</span><span class="hs-special">)</span><span>
</span><span id="line-319"></span><span>            </span><span class="hs-identifier">Just</span><span> </span><span class="hs-identifier">constructorNames</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">do</span><span class="hs-cpp">
              #declNameLookup . #constructorToDecl %= \constructorToDecl -&gt;
</span><span>                </span><span class="hs-identifier">List.foldl'</span><span>
</span><span id="line-322"></span><span>                  </span><span class="hs-special">(</span><span class="hs-glyph">\</span><span class="hs-identifier">acc</span><span> </span><span class="hs-identifier">constructorName</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier">Map.insert</span><span> </span><span class="hs-identifier">constructorName</span><span> </span><span class="hs-identifier">typeName</span><span> </span><span class="hs-identifier">acc</span><span class="hs-special">)</span><span>
</span><span id="line-323"></span><span>                  </span><span class="hs-identifier">constructorToDecl</span><span>
</span><span id="line-324"></span><span>                  </span><span class="hs-identifier">constructorNames</span><span class="hs-cpp">
              #declNameLookup . #declToConstructors %= Map.insert typeName constructorNames
</span><span>          </span><span class="hs-identifier">pure</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">Just</span><span> </span><span class="hs-identifier">name</span><span class="hs-special">)</span><span>
</span><span id="line-327"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-328"></span><span>    </span><span class="annot"><a href="#local-6989586621679185507"><span class="hs-identifier hs-type">typeName</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span>
</span><span id="line-329"></span><span>    </span><span id="local-6989586621679185507"><span class="annot"><span class="annottext">typeName :: Name
</span><a href="#local-6989586621679185507"><span class="hs-identifier hs-var hs-var">typeName</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-330"></span><span>      </span><span class="annot"><span class="annottext">NonEmpty NameSegment -&gt; Name
</span><span class="hs-identifier hs-var">Name.fromReverseSegments</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">NameSegment
</span><a href="#local-6989586621679185500"><span class="hs-identifier hs-var">name</span></a></span><span> </span><span class="annot"><span class="annottext">NameSegment -&gt; [NameSegment] -&gt; NonEmpty NameSegment
forall a. a -&gt; [a] -&gt; NonEmpty a
</span><span class="hs-operator hs-var">:|</span></span><span> </span><span class="annot"><span class="annottext">[NameSegment]
</span><a href="#local-6989586621679185498"><span class="hs-identifier hs-var">prefix</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-331"></span><span>
</span><span id="line-332"></span><span>    </span><span class="annot"><a href="#local-6989586621679185504"><span class="hs-identifier hs-type">recordNewDecl</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Unison.Merge.DeclCoherencyCheck.html#ConstructorNames"><span class="hs-identifier hs-type">ConstructorNames</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Compose</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">MaybeT</span></span><span> </span><span class="annot"><a href="#local-6989586621679184453"><span class="hs-identifier hs-type">m</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><a href="Unison.Merge.DeclCoherencyCheck.html#WhatHappened"><span class="hs-identifier hs-type">WhatHappened</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Unison.Merge.DeclCoherencyCheck.html#ConstructorNames"><span class="hs-identifier hs-type">ConstructorNames</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-333"></span><span>    </span><span id="local-6989586621679185504"><span class="annot"><span class="annottext">recordNewDecl :: Maybe (Name, ConstructorNames)
-&gt; Compose (MaybeT m) WhatHappened (Name, ConstructorNames)
</span><a href="#local-6989586621679185504"><span class="hs-identifier hs-var hs-var">recordNewDecl</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-334"></span><span>      </span><span class="annot"><span class="annottext">MaybeT m (WhatHappened (Name, ConstructorNames))
-&gt; Compose (MaybeT m) WhatHappened (Name, ConstructorNames)
forall {k} {k1} (f :: k -&gt; *) (g :: k1 -&gt; k) (a :: k1).
f (g a) -&gt; Compose f g a
</span><span class="hs-identifier hs-var">Compose</span></span><span> </span><span class="annot"><span class="annottext">(MaybeT m (WhatHappened (Name, ConstructorNames))
 -&gt; Compose (MaybeT m) WhatHappened (Name, ConstructorNames))
-&gt; (Maybe (Name, ConstructorNames)
    -&gt; MaybeT m (WhatHappened (Name, ConstructorNames)))
-&gt; Maybe (Name, ConstructorNames)
-&gt; Compose (MaybeT m) WhatHappened (Name, ConstructorNames)
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="hs-glyph">\</span><span class="hs-glyph">case</span><span>
</span><span id="line-335"></span><span>        </span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621679185524"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679185524"><span class="hs-identifier hs-var">shorterTypeName</span></a></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">ConstructorNames
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-336"></span><span>          </span><span class="annot"><span class="annottext">m () -&gt; MaybeT m ()
forall (m :: * -&gt; *) a. Monad m =&gt; m a -&gt; MaybeT m a
forall (t :: (* -&gt; *) -&gt; * -&gt; *) (m :: * -&gt; *) a.
(MonadTrans t, Monad m) =&gt;
m a -&gt; t m a
</span><span class="hs-identifier hs-var">lift</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">OnIncoherentDeclReasons m
</span><a href="#local-6989586621679185496"><span class="hs-identifier hs-var">callbacks</span></a></span><span class="hs-operator">.</span><span class="hs-identifier">onNestedDeclAlias</span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679185524"><span class="hs-identifier hs-var">shorterTypeName</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679185507"><span class="hs-identifier hs-var">typeName</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-337"></span><span>          </span><span class="annot"><span class="annottext">m (Maybe (WhatHappened (Name, ConstructorNames)))
-&gt; MaybeT m (WhatHappened (Name, ConstructorNames))
forall (m :: * -&gt; *) a. m (Maybe a) -&gt; MaybeT m a
</span><span class="hs-identifier hs-var">MaybeT</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Maybe (WhatHappened (Name, ConstructorNames))
-&gt; m (Maybe (WhatHappened (Name, ConstructorNames)))
forall a. a -&gt; m a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">Maybe (WhatHappened (Name, ConstructorNames))
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span class="hs-special">)</span><span>
</span><span id="line-338"></span><span>        </span><span class="annot"><span class="annottext">Maybe (Name, ConstructorNames)
</span><span class="hs-identifier hs-var">Nothing</span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-339"></span><span>          </span><span class="annot"><span class="annottext">m Int -&gt; MaybeT m Int
forall (m :: * -&gt; *) a. Monad m =&gt; m a -&gt; MaybeT m a
forall (t :: (* -&gt; *) -&gt; * -&gt; *) (m :: * -&gt; *) a.
(MonadTrans t, Monad m) =&gt;
m a -&gt; t m a
</span><span class="hs-identifier hs-var">lift</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Id' Hash -&gt; m Int
</span><a href="#local-6989586621679185495"><span class="hs-identifier hs-var">loadDeclNumConstructors</span></a></span><span> </span><span class="annot"><span class="annottext">Id' Hash
</span><a href="#local-6989586621679185501"><span class="hs-identifier hs-var">typeRef</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">MaybeT m Int
-&gt; (Int -&gt; WhatHappened (Name, ConstructorNames))
-&gt; MaybeT m (WhatHappened (Name, ConstructorNames))
forall (f :: * -&gt; *) a b. Functor f =&gt; f a -&gt; (a -&gt; b) -&gt; f b
</span><span class="hs-operator hs-var">&lt;&amp;&gt;</span></span><span> </span><span class="hs-glyph">\</span><span class="hs-glyph">case</span><span>
</span><span id="line-340"></span><span>            </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">0</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">WhatHappened (Name, ConstructorNames)
forall a. WhatHappened a
</span><a href="Unison.Merge.DeclCoherencyCheck.html#UninhabitedDecl"><span class="hs-identifier hs-var">UninhabitedDecl</span></a></span><span>
</span><span id="line-341"></span><span>            </span><span id="local-6989586621679185525"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679185525"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">(Name, ConstructorNames) -&gt; WhatHappened (Name, ConstructorNames)
forall a. a -&gt; WhatHappened a
</span><a href="Unison.Merge.DeclCoherencyCheck.html#InhabitedDecl"><span class="hs-identifier hs-var">InhabitedDecl</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679185507"><span class="hs-identifier hs-var">typeName</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Int -&gt; ConstructorNames
</span><a href="Unison.Merge.DeclCoherencyCheck.html#emptyConstructorNames"><span class="hs-identifier hs-var">emptyConstructorNames</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679185525"><span class="hs-identifier hs-var">n</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-342"></span><span>
</span><span id="line-343"></span><span class="hs-comment">-- | A lenient variant of 'checkDeclCoherency' - so lenient it can't even fail! It returns partial decl name lookup,</span><span>
</span><span id="line-344"></span><span class="hs-comment">-- which doesn't require a name for every constructor, and allows a constructor with a nameless decl.</span><span>
</span><span id="line-345"></span><span class="hs-comment">--</span><span>
</span><span id="line-346"></span><span class="hs-comment">-- This function exists merely to extract a best-effort name mapping for the LCA of a merge. We require Alice and Bob to</span><span>
</span><span id="line-347"></span><span class="hs-comment">-- have coherent decls, but their LCA is out of the user's control and may have incoherent decls, and whether or not it</span><span>
</span><span id="line-348"></span><span class="hs-comment">-- does, we still need to compute *some* syntactic hash for its decls.</span><span>
</span><span id="line-349"></span><span class="annot"><a href="Unison.Merge.DeclCoherencyCheck.html#lenientCheckDeclCoherency"><span class="hs-identifier hs-type">lenientCheckDeclCoherency</span></a></span><span> </span><span class="hs-glyph">::</span><span>
</span><span id="line-350"></span><span>  </span><span class="annot"><span class="hs-identifier hs-type">Nametree</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">DefnsF</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Map</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">NameSegment</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Referent</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">TypeReference</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-351"></span><span>  </span><span class="annot"><span class="hs-identifier hs-type">Map</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">TypeReferenceId</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-352"></span><span>  </span><span class="annot"><a href="Unison.Merge.PartialDeclNameLookup.html#PartialDeclNameLookup"><span class="hs-identifier hs-type">PartialDeclNameLookup</span></a></span><span>
</span><span id="line-353"></span><span id="lenientCheckDeclCoherency"><span class="annot"><span class="annottext">lenientCheckDeclCoherency :: Nametree (DefnsF (Map NameSegment) Referent TypeReference)
-&gt; Map (Id' Hash) Int -&gt; PartialDeclNameLookup
</span><a href="Unison.Merge.DeclCoherencyCheck.html#lenientCheckDeclCoherency"><span class="hs-identifier hs-var hs-var">lenientCheckDeclCoherency</span></a></span></span><span> </span><span id="local-6989586621679185527"><span class="annot"><span class="annottext">Nametree (DefnsF (Map NameSegment) Referent TypeReference)
</span><a href="#local-6989586621679185527"><span class="hs-identifier hs-var">nametree</span></a></span></span><span> </span><span id="local-6989586621679185528"><span class="annot"><span class="annottext">Map (Id' Hash) Int
</span><a href="#local-6989586621679185528"><span class="hs-identifier hs-var">numConstructorsById</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-354"></span><span>  </span><span class="annot"><span class="annottext">Nametree (DefnsF (Map NameSegment) Referent TypeReference)
</span><a href="#local-6989586621679185527"><span class="hs-identifier hs-var">nametree</span></a></span><span>
</span><span id="line-355"></span><span>    </span><span class="annot"><span class="annottext">Nametree (DefnsF (Map NameSegment) Referent TypeReference)
-&gt; (Nametree (DefnsF (Map NameSegment) Referent TypeReference)
    -&gt; State LenientDeclCoherencyCheckState ())
-&gt; State LenientDeclCoherencyCheckState ()
forall a b. a -&gt; (a -&gt; b) -&gt; b
</span><span class="hs-operator hs-var">&amp;</span></span><span> </span><span class="annot"><span class="annottext">[NameSegment]
-&gt; Nametree (DefnsF (Map NameSegment) Referent TypeReference)
-&gt; State LenientDeclCoherencyCheckState ()
</span><a href="#local-6989586621679185530"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span>
</span><span id="line-356"></span><span>    </span><span class="annot"><span class="annottext">State LenientDeclCoherencyCheckState ()
-&gt; (State LenientDeclCoherencyCheckState ()
    -&gt; LenientDeclCoherencyCheckState)
-&gt; LenientDeclCoherencyCheckState
forall a b. a -&gt; (a -&gt; b) -&gt; b
</span><span class="hs-operator hs-var">&amp;</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">State LenientDeclCoherencyCheckState ()
-&gt; LenientDeclCoherencyCheckState -&gt; LenientDeclCoherencyCheckState
forall s a. State s a -&gt; s -&gt; s
</span><span class="hs-operator hs-var">`State.execState`</span></span><span> </span><span class="annot"><span class="annottext">Map (Id' Hash) (Map Name ConstructorNames)
-&gt; PartialDeclNameLookup -&gt; LenientDeclCoherencyCheckState
</span><a href="Unison.Merge.DeclCoherencyCheck.html#LenientDeclCoherencyCheckState"><span class="hs-identifier hs-var">LenientDeclCoherencyCheckState</span></a></span><span> </span><span class="annot"><span class="annottext">Map (Id' Hash) (Map Name ConstructorNames)
forall k a. Map k a
</span><span class="hs-identifier hs-var">Map.empty</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Map Name Name -&gt; Map Name [Maybe Name] -&gt; PartialDeclNameLookup
</span><a href="Unison.Merge.PartialDeclNameLookup.html#PartialDeclNameLookup"><span class="hs-identifier hs-var">PartialDeclNameLookup</span></a></span><span> </span><span class="annot"><span class="annottext">Map Name Name
forall k a. Map k a
</span><span class="hs-identifier hs-var">Map.empty</span></span><span> </span><span class="annot"><span class="annottext">Map Name [Maybe Name]
forall k a. Map k a
</span><span class="hs-identifier hs-var">Map.empty</span></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-357"></span><span>    </span><span class="annot"><span class="annottext">LenientDeclCoherencyCheckState
-&gt; (LenientDeclCoherencyCheckState -&gt; PartialDeclNameLookup)
-&gt; PartialDeclNameLookup
forall a b. a -&gt; (a -&gt; b) -&gt; b
</span><span class="hs-operator hs-var">&amp;</span></span><span> </span><span class="annot"><span class="annottext">Getting
  PartialDeclNameLookup
  LenientDeclCoherencyCheckState
  PartialDeclNameLookup
-&gt; LenientDeclCoherencyCheckState -&gt; PartialDeclNameLookup
forall s (m :: * -&gt; *) a. MonadReader s m =&gt; Getting a s a -&gt; m a
</span><span class="hs-identifier hs-var">view</span></span><span> </span><span class="annot"><span class="annottext">Getting
  PartialDeclNameLookup
  LenientDeclCoherencyCheckState
  PartialDeclNameLookup
</span><span class="">#declNameLookup</span></span><span>
</span><span id="line-358"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-359"></span><span>    </span><span class="annot"><a href="#local-6989586621679185530"><span class="hs-identifier hs-type">go</span></a></span><span> </span><span class="hs-glyph">::</span><span>
</span><span id="line-360"></span><span>      </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">NameSegment</span></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-361"></span><span>      </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Nametree</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">DefnsF</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Map</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">NameSegment</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Referent</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">TypeReference</span></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-362"></span><span>      </span><span class="annot"><span class="hs-identifier hs-type">State</span></span><span> </span><span class="annot"><a href="Unison.Merge.DeclCoherencyCheck.html#LenientDeclCoherencyCheckState"><span class="hs-identifier hs-type">LenientDeclCoherencyCheckState</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><span id="line-363"></span><span>    </span><span id="local-6989586621679185530"><span class="annot"><span class="annottext">go :: [NameSegment]
-&gt; Nametree (DefnsF (Map NameSegment) Referent TypeReference)
-&gt; State LenientDeclCoherencyCheckState ()
</span><a href="#local-6989586621679185530"><span class="hs-identifier hs-var hs-var">go</span></a></span></span><span> </span><span id="local-6989586621679185534"><span class="annot"><span class="annottext">[NameSegment]
</span><a href="#local-6989586621679185534"><span class="hs-identifier hs-var">prefix</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Nametree</span></span><span> </span><span id="local-6989586621679185535"><span class="annot"><span class="annottext">DefnsF (Map NameSegment) Referent TypeReference
</span><a href="#local-6989586621679185535"><span class="hs-identifier hs-var">defns</span></a></span></span><span> </span><span id="local-6989586621679185536"><span class="annot"><span class="annottext">Map
  NameSegment
  (Nametree (DefnsF (Map NameSegment) Referent TypeReference))
</span><a href="#local-6989586621679185536"><span class="hs-identifier hs-var">children</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-364"></span><span>      </span><span class="annot"><span class="annottext">[(NameSegment, Referent)]
-&gt; ((NameSegment, Referent)
    -&gt; State LenientDeclCoherencyCheckState ())
-&gt; State LenientDeclCoherencyCheckState ()
forall (t :: * -&gt; *) (f :: * -&gt; *) a b.
(Foldable t, Applicative f) =&gt;
t a -&gt; (a -&gt; f b) -&gt; f ()
</span><span class="hs-identifier hs-var">for_</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Map NameSegment Referent -&gt; [(NameSegment, Referent)]
forall k a. Map k a -&gt; [(k, a)]
</span><span class="hs-identifier hs-var">Map.toList</span></span><span> </span><span class="annot"><span class="annottext">DefnsF (Map NameSegment) Referent TypeReference
</span><a href="#local-6989586621679185535"><span class="hs-identifier hs-var">defns</span></a></span><span class="hs-operator">.</span><span class="hs-identifier">terms</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">\</span><span class="hs-glyph">case</span><span>
</span><span id="line-365"></span><span>        </span><span class="hs-special">(</span><span class="annot"><span class="annottext">NameSegment
</span><span class="hs-identifier">_</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Referent.Ref</span></span><span> </span><span class="annot"><span class="annottext">TypeReference
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">() -&gt; State LenientDeclCoherencyCheckState ()
forall a. a -&gt; StateT LenientDeclCoherencyCheckState Identity a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><span id="line-366"></span><span>        </span><span class="hs-special">(</span><span class="annot"><span class="annottext">NameSegment
</span><span class="hs-identifier">_</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Referent.Con</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">ConstructorReference</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">ReferenceBuiltin</span></span><span> </span><span class="annot"><span class="annottext">Text
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Word64
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">ConstructorType
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">() -&gt; State LenientDeclCoherencyCheckState ()
forall a. a -&gt; StateT LenientDeclCoherencyCheckState Identity a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><span id="line-367"></span><span>        </span><span class="hs-special">(</span><span id="local-6989586621679185540"><span class="annot"><span class="annottext">NameSegment
</span><a href="#local-6989586621679185540"><span class="hs-identifier hs-var">name</span></a></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Referent.Con</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">ConstructorReference</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">ReferenceDerived</span></span><span> </span><span id="local-6989586621679185542"><span class="annot"><span class="annottext">Id' Hash
</span><a href="#local-6989586621679185542"><span class="hs-identifier hs-var">typeRef</span></a></span></span><span class="hs-special">)</span><span> </span><span id="local-6989586621679185543"><span class="annot"><span class="annottext">Word64
</span><a href="#local-6989586621679185543"><span class="hs-identifier hs-var">conId</span></a></span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">ConstructorType
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">do</span><span class="hs-cpp">
          #expectedConstructors %= Map.adjust (Map.map (lenientRecordConstructorName conId (fullName name))) typeRef
</span><span>
</span><span id="line-370"></span><span>      </span><span id="local-6989586621679185548"><span class="annot"><span class="annottext">[NameSegment]
</span><a href="#local-6989586621679185548"><span class="hs-identifier hs-var">childrenWeWentInto</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span>
</span><span id="line-371"></span><span>        </span><span class="annot"><span class="annottext">[(NameSegment, TypeReference)]
-&gt; ((NameSegment, TypeReference)
    -&gt; StateT
         LenientDeclCoherencyCheckState Identity (Maybe NameSegment))
-&gt; StateT LenientDeclCoherencyCheckState Identity [NameSegment]
forall (t :: * -&gt; *) (f :: * -&gt; *) a b.
(Witherable t, Applicative f) =&gt;
t a -&gt; (a -&gt; f (Maybe b)) -&gt; f (t b)
</span><span class="hs-identifier hs-var">forMaybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Map NameSegment TypeReference -&gt; [(NameSegment, TypeReference)]
forall k a. Map k a -&gt; [(k, a)]
</span><span class="hs-identifier hs-var">Map.toList</span></span><span> </span><span class="annot"><span class="annottext">DefnsF (Map NameSegment) Referent TypeReference
</span><a href="#local-6989586621679185535"><span class="hs-identifier hs-var">defns</span></a></span><span class="hs-operator">.</span><span class="hs-identifier">types</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">\</span><span class="hs-glyph">case</span><span>
</span><span id="line-372"></span><span>          </span><span class="hs-special">(</span><span class="annot"><span class="annottext">NameSegment
</span><span class="hs-identifier">_</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">ReferenceBuiltin</span></span><span> </span><span class="annot"><span class="annottext">Text
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Maybe NameSegment
-&gt; StateT
     LenientDeclCoherencyCheckState Identity (Maybe NameSegment)
forall a. a -&gt; StateT LenientDeclCoherencyCheckState Identity a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">Maybe NameSegment
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span>
</span><span id="line-373"></span><span>          </span><span class="hs-special">(</span><span id="local-6989586621679185549"><span class="annot"><span class="annottext">NameSegment
</span><a href="#local-6989586621679185549"><span class="hs-identifier hs-var">name</span></a></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">ReferenceDerived</span></span><span> </span><span id="local-6989586621679185550"><span class="annot"><span class="annottext">Id' Hash
</span><a href="#local-6989586621679185550"><span class="hs-identifier hs-var">typeRef</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-374"></span><span>            </span><span id="local-6989586621679185551"><span class="annot"><span class="annottext">LenientDeclCoherencyCheckState
</span><a href="#local-6989586621679185551"><span class="hs-identifier hs-var">state</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">StateT
  LenientDeclCoherencyCheckState
  Identity
  LenientDeclCoherencyCheckState
forall s (m :: * -&gt; *). MonadState s m =&gt; m s
</span><span class="hs-identifier hs-var">State.get</span></span><span>
</span><span id="line-375"></span><span>            </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621679185552"><span class="annot"><span class="annottext">whatHappened :: WhatHappened (Map (Id' Hash) (Map Name ConstructorNames))
</span><a href="#local-6989586621679185552"><span class="hs-identifier hs-var hs-var">whatHappened</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-376"></span><span>                  </span><span class="hs-keyword">let</span><span> </span><span class="annot"><a href="#local-6989586621679185553"><span class="hs-identifier hs-type">recordNewDecl</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Unison.Merge.DeclCoherencyCheck.html#WhatHappened"><span class="hs-identifier hs-type">WhatHappened</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Map</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="annot"><a href="Unison.Merge.DeclCoherencyCheck.html#ConstructorNames"><span class="hs-identifier hs-type">ConstructorNames</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-377"></span><span>                      </span><span id="local-6989586621679185553"><span class="annot"><span class="annottext">recordNewDecl :: WhatHappened (Map Name ConstructorNames)
</span><a href="#local-6989586621679185553"><span class="hs-identifier hs-var hs-var">recordNewDecl</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-378"></span><span>                        </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">HasCallStack =&gt; Id' Hash -&gt; Map (Id' Hash) Int -&gt; Int
Id' Hash -&gt; Map (Id' Hash) Int -&gt; Int
</span><a href="Unison.Merge.DeclCoherencyCheck.html#expectNumConstructors"><span class="hs-identifier hs-var">expectNumConstructors</span></a></span><span> </span><span class="annot"><span class="annottext">Id' Hash
</span><a href="#local-6989586621679185550"><span class="hs-identifier hs-var">typeRef</span></a></span><span> </span><span class="annot"><span class="annottext">Map (Id' Hash) Int
</span><a href="#local-6989586621679185528"><span class="hs-identifier hs-var">numConstructorsById</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-379"></span><span>                          </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">0</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">WhatHappened (Map Name ConstructorNames)
forall a. WhatHappened a
</span><a href="Unison.Merge.DeclCoherencyCheck.html#UninhabitedDecl"><span class="hs-identifier hs-var">UninhabitedDecl</span></a></span><span>
</span><span id="line-380"></span><span>                          </span><span id="local-6989586621679185554"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679185554"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Map Name ConstructorNames
-&gt; WhatHappened (Map Name ConstructorNames)
forall a. a -&gt; WhatHappened a
</span><a href="Unison.Merge.DeclCoherencyCheck.html#InhabitedDecl"><span class="hs-identifier hs-var">InhabitedDecl</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Name -&gt; ConstructorNames -&gt; Map Name ConstructorNames
forall k a. k -&gt; a -&gt; Map k a
</span><span class="hs-identifier hs-var">Map.singleton</span></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679185556"><span class="hs-identifier hs-var">typeName</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Int -&gt; ConstructorNames
</span><a href="Unison.Merge.DeclCoherencyCheck.html#emptyConstructorNames"><span class="hs-identifier hs-var">emptyConstructorNames</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679185554"><span class="hs-identifier hs-var">n</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-381"></span><span>                   </span><span class="hs-keyword">in</span><span> </span><span class="annot"><span class="annottext">(Maybe (Map Name ConstructorNames)
 -&gt; WhatHappened (Map Name ConstructorNames))
-&gt; Id' Hash
-&gt; Map (Id' Hash) (Map Name ConstructorNames)
-&gt; WhatHappened (Map (Id' Hash) (Map Name ConstructorNames))
forall (f :: * -&gt; *) k v.
(Functor f, Ord k) =&gt;
(Maybe v -&gt; f v) -&gt; k -&gt; Map k v -&gt; f (Map k v)
</span><span class="hs-identifier hs-var">Map.upsertF</span></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">\</span><span class="annot"><span class="annottext">Maybe (Map Name ConstructorNames)
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">WhatHappened (Map Name ConstructorNames)
</span><a href="#local-6989586621679185553"><span class="hs-identifier hs-var">recordNewDecl</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Id' Hash
</span><a href="#local-6989586621679185550"><span class="hs-identifier hs-var">typeRef</span></a></span><span> </span><span class="annot"><span class="annottext">LenientDeclCoherencyCheckState
</span><a href="#local-6989586621679185551"><span class="hs-identifier hs-var">state</span></a></span><span class="hs-operator">.</span><span class="hs-identifier">expectedConstructors</span><span>
</span><span id="line-382"></span><span>            </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">WhatHappened (Map (Id' Hash) (Map Name ConstructorNames))
</span><a href="#local-6989586621679185552"><span class="hs-identifier hs-var">whatHappened</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-383"></span><span>              </span><span class="annot"><span class="annottext">WhatHappened (Map (Id' Hash) (Map Name ConstructorNames))
</span><a href="Unison.Merge.DeclCoherencyCheck.html#UninhabitedDecl"><span class="hs-identifier hs-var">UninhabitedDecl</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">do</span><span class="hs-cpp">
                #declNameLookup . #declToConstructors %= Map.insert typeName []
</span><span>                </span><span class="hs-identifier">pure</span><span> </span><span class="hs-identifier">Nothing</span><span>
</span><span id="line-386"></span><span>              </span><span class="annot"><a href="Unison.Merge.DeclCoherencyCheck.html#InhabitedDecl"><span class="hs-identifier hs-type">InhabitedDecl</span></a></span><span> </span><span id="local-6989586621679185557"><span class="annot"><span class="annottext">Map (Id' Hash) (Map Name ConstructorNames)
</span><a href="#local-6989586621679185557"><span class="hs-identifier hs-var">expectedConstructors1</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-387"></span><span>                </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621679185558"><span class="annot"><span class="annottext">child :: Nametree (DefnsF (Map NameSegment) Referent TypeReference)
</span><a href="#local-6989586621679185558"><span class="hs-identifier hs-var hs-var">child</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Nametree (DefnsF (Map NameSegment) Referent TypeReference)
-&gt; NameSegment
-&gt; Map
     NameSegment
     (Nametree (DefnsF (Map NameSegment) Referent TypeReference))
-&gt; Nametree (DefnsF (Map NameSegment) Referent TypeReference)
forall k a. Ord k =&gt; a -&gt; k -&gt; Map k a -&gt; a
</span><span class="hs-identifier hs-var">Map.findWithDefault</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">DefnsF (Map NameSegment) Referent TypeReference
-&gt; Map
     NameSegment
     (Nametree (DefnsF (Map NameSegment) Referent TypeReference))
-&gt; Nametree (DefnsF (Map NameSegment) Referent TypeReference)
forall a. a -&gt; Map NameSegment (Nametree a) -&gt; Nametree a
</span><span class="hs-identifier hs-var">Nametree</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Map NameSegment Referent
-&gt; Map NameSegment TypeReference
-&gt; DefnsF (Map NameSegment) Referent TypeReference
forall terms types. terms -&gt; types -&gt; Defns terms types
</span><span class="hs-identifier hs-var">Defns</span></span><span> </span><span class="annot"><span class="annottext">Map NameSegment Referent
forall k a. Map k a
</span><span class="hs-identifier hs-var">Map.empty</span></span><span> </span><span class="annot"><span class="annottext">Map NameSegment TypeReference
forall k a. Map k a
</span><span class="hs-identifier hs-var">Map.empty</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Map
  NameSegment
  (Nametree (DefnsF (Map NameSegment) Referent TypeReference))
forall k a. Map k a
</span><span class="hs-identifier hs-var">Map.empty</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">NameSegment
</span><a href="#local-6989586621679185549"><span class="hs-identifier hs-var">name</span></a></span><span> </span><span class="annot"><span class="annottext">Map
  NameSegment
  (Nametree (DefnsF (Map NameSegment) Referent TypeReference))
</span><a href="#local-6989586621679185536"><span class="hs-identifier hs-var">children</span></a></span><span class="hs-cpp">
                #expectedConstructors .= expectedConstructors1
</span><span>                </span><span class="annot"><span class="annottext">[NameSegment]
-&gt; Nametree (DefnsF (Map NameSegment) Referent TypeReference)
-&gt; State LenientDeclCoherencyCheckState ()
</span><a href="#local-6989586621679185530"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">NameSegment
</span><a href="#local-6989586621679185549"><span class="hs-identifier hs-var">name</span></a></span><span> </span><span class="annot"><span class="annottext">NameSegment -&gt; [NameSegment] -&gt; [NameSegment]
forall a. a -&gt; [a] -&gt; [a]
</span><span class="hs-glyph hs-var">:</span></span><span> </span><span class="annot"><span class="annottext">[NameSegment]
</span><a href="#local-6989586621679185534"><span class="hs-identifier hs-var">prefix</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Nametree (DefnsF (Map NameSegment) Referent TypeReference)
</span><a href="#local-6989586621679185558"><span class="hs-identifier hs-var">child</span></a></span><span>
</span><span id="line-390"></span><span>                </span><span id="local-6989586621679185561"><span class="annot"><span class="annottext">LenientDeclCoherencyCheckState
</span><a href="#local-6989586621679185561"><span class="hs-identifier hs-var">state</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">StateT
  LenientDeclCoherencyCheckState
  Identity
  LenientDeclCoherencyCheckState
forall s (m :: * -&gt; *). MonadState s m =&gt; m s
</span><span class="hs-identifier hs-var">State.get</span></span><span>
</span><span id="line-391"></span><span>                </span><span class="hs-keyword">let</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679185562"><span class="annot"><span class="annottext">ConstructorNames
</span><a href="#local-6989586621679185562"><span class="hs-identifier hs-var">constructorNames0</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679185563"><span class="annot"><span class="annottext">Map (Id' Hash) (Map Name ConstructorNames)
</span><a href="#local-6989586621679185563"><span class="hs-identifier hs-var">expectedConstructors</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-392"></span><span>                      </span><span class="annot"><span class="annottext">(Maybe (Map Name ConstructorNames)
 -&gt; (ConstructorNames, Maybe (Map Name ConstructorNames)))
-&gt; Id' Hash
-&gt; Map (Id' Hash) (Map Name ConstructorNames)
-&gt; (ConstructorNames, Map (Id' Hash) (Map Name ConstructorNames))
forall (f :: * -&gt; *) k a.
(Functor f, Ord k) =&gt;
(Maybe a -&gt; f (Maybe a)) -&gt; k -&gt; Map k a -&gt; f (Map k a)
</span><span class="hs-identifier hs-var">Map.alterF</span></span><span> </span><span class="annot"><span class="annottext">Maybe (Map Name ConstructorNames)
-&gt; (ConstructorNames, Maybe (Map Name ConstructorNames))
</span><a href="#local-6989586621679185565"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">Id' Hash
</span><a href="#local-6989586621679185550"><span class="hs-identifier hs-var">typeRef</span></a></span><span> </span><span class="annot"><span class="annottext">LenientDeclCoherencyCheckState
</span><a href="#local-6989586621679185561"><span class="hs-identifier hs-var">state</span></a></span><span class="hs-operator">.</span><span class="hs-identifier">expectedConstructors</span><span>
</span><span id="line-393"></span><span>                      </span><span class="hs-keyword">where</span><span>
</span><span id="line-394"></span><span>                        </span><span class="annot"><a href="#local-6989586621679185565"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="hs-glyph">::</span><span>
</span><span id="line-395"></span><span>                          </span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Map</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="annot"><a href="Unison.Merge.DeclCoherencyCheck.html#ConstructorNames"><span class="hs-identifier hs-type">ConstructorNames</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-396"></span><span>                          </span><span class="hs-special">(</span><span class="annot"><a href="Unison.Merge.DeclCoherencyCheck.html#ConstructorNames"><span class="hs-identifier hs-type">ConstructorNames</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Map</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="annot"><a href="Unison.Merge.DeclCoherencyCheck.html#ConstructorNames"><span class="hs-identifier hs-type">ConstructorNames</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-397"></span><span>                        </span><span id="local-6989586621679185565"><span class="annot"><span class="annottext">f :: Maybe (Map Name ConstructorNames)
-&gt; (ConstructorNames, Maybe (Map Name ConstructorNames))
</span><a href="#local-6989586621679185565"><span class="hs-identifier hs-var hs-var">f</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-398"></span><span>                          </span><span class="hs-comment">-- fromJust is safe here because we upserted `typeRef` key above</span><span>
</span><span id="line-399"></span><span>                          </span><span class="hs-comment">-- deleteLookupJust is safe here because we upserted `typeName` key above</span><span>
</span><span id="line-400"></span><span>                          </span><span class="annot"><span class="annottext">Maybe (Map Name ConstructorNames) -&gt; Map Name ConstructorNames
forall a. HasCallStack =&gt; Maybe a -&gt; a
</span><span class="hs-identifier hs-var">fromJust</span></span><span>
</span><span id="line-401"></span><span>                            </span><span class="annot"><span class="annottext">(Maybe (Map Name ConstructorNames) -&gt; Map Name ConstructorNames)
-&gt; (Map Name ConstructorNames
    -&gt; (ConstructorNames, Maybe (Map Name ConstructorNames)))
-&gt; Maybe (Map Name ConstructorNames)
-&gt; (ConstructorNames, Maybe (Map Name ConstructorNames))
forall {k} (cat :: k -&gt; k -&gt; *) (a :: k) (b :: k) (c :: k).
Category cat =&gt;
cat a b -&gt; cat b c -&gt; cat a c
</span><span class="hs-operator hs-var">&gt;&gt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">Name
-&gt; Map Name ConstructorNames
-&gt; (ConstructorNames, Map Name ConstructorNames)
forall k v. (HasCallStack, Ord k) =&gt; k -&gt; Map k v -&gt; (v, Map k v)
</span><span class="hs-identifier hs-var">Map.deleteLookupJust</span></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679185556"><span class="hs-identifier hs-var">typeName</span></a></span><span>
</span><span id="line-402"></span><span>                            </span><span class="annot"><span class="annottext">(Map Name ConstructorNames
 -&gt; (ConstructorNames, Map Name ConstructorNames))
-&gt; ((ConstructorNames, Map Name ConstructorNames)
    -&gt; (ConstructorNames, Maybe (Map Name ConstructorNames)))
-&gt; Map Name ConstructorNames
-&gt; (ConstructorNames, Maybe (Map Name ConstructorNames))
forall {k} (cat :: k -&gt; k -&gt; *) (a :: k) (b :: k) (c :: k).
Category cat =&gt;
cat a b -&gt; cat b c -&gt; cat a c
</span><span class="hs-operator hs-var">&gt;&gt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">ASetter
  (ConstructorNames, Map Name ConstructorNames)
  (ConstructorNames, Maybe (Map Name ConstructorNames))
  (Map Name ConstructorNames)
  (Maybe (Map Name ConstructorNames))
-&gt; (Map Name ConstructorNames -&gt; Maybe (Map Name ConstructorNames))
-&gt; (ConstructorNames, Map Name ConstructorNames)
-&gt; (ConstructorNames, Maybe (Map Name ConstructorNames))
forall s t a b. ASetter s t a b -&gt; (a -&gt; b) -&gt; s -&gt; t
</span><span class="hs-identifier hs-var">over</span></span><span> </span><span class="annot"><span class="annottext">ASetter
  (ConstructorNames, Map Name ConstructorNames)
  (ConstructorNames, Maybe (Map Name ConstructorNames))
  (Map Name ConstructorNames)
  (Maybe (Map Name ConstructorNames))
forall s t a b. Field2 s t a b =&gt; Lens s t a b
Lens
  (ConstructorNames, Map Name ConstructorNames)
  (ConstructorNames, Maybe (Map Name ConstructorNames))
  (Map Name ConstructorNames)
  (Maybe (Map Name ConstructorNames))
</span><span class="hs-identifier hs-var">_2</span></span><span> </span><span class="hs-glyph">\</span><span id="local-6989586621679185568"><span class="annot"><span class="annottext">Map Name ConstructorNames
</span><a href="#local-6989586621679185568"><span class="hs-identifier hs-var">m</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">if</span><span> </span><span class="annot"><span class="annottext">Map Name ConstructorNames -&gt; Bool
forall k a. Map k a -&gt; Bool
</span><span class="hs-identifier hs-var">Map.null</span></span><span> </span><span class="annot"><span class="annottext">Map Name ConstructorNames
</span><a href="#local-6989586621679185568"><span class="hs-identifier hs-var">m</span></a></span><span> </span><span class="hs-keyword">then</span><span> </span><span class="annot"><span class="annottext">Maybe (Map Name ConstructorNames)
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span> </span><span class="hs-keyword">else</span><span> </span><span class="annot"><span class="annottext">Map Name ConstructorNames -&gt; Maybe (Map Name ConstructorNames)
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="annot"><span class="annottext">Map Name ConstructorNames
</span><a href="#local-6989586621679185568"><span class="hs-identifier hs-var">m</span></a></span><span>
</span><span id="line-403"></span><span>
</span><span id="line-404"></span><span>                    </span><span class="annot"><a href="#local-6989586621679185570"><span class="hs-identifier hs-type">constructorNames</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span class="hs-special">]</span><span>
</span><span id="line-405"></span><span>                    </span><span id="local-6989586621679185570"><span class="annot"><span class="annottext">constructorNames :: [Maybe Name]
</span><a href="#local-6989586621679185570"><span class="hs-identifier hs-var hs-var">constructorNames</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-406"></span><span>                      </span><span class="annot"><span class="annottext">ConstructorNames -&gt; [Maybe Name]
forall a. IntMap a -&gt; [a]
</span><span class="hs-identifier hs-var">IntMap.elems</span></span><span> </span><span class="annot"><span class="annottext">ConstructorNames
</span><a href="#local-6989586621679185562"><span class="hs-identifier hs-var">constructorNames0</span></a></span><span class="hs-cpp">

                #expectedConstructors .= expectedConstructors
</span><span class="hs-cpp">                #declNameLookup . #constructorToDecl %= \constructorToDecl -&gt;
</span><span>                  </span><span class="hs-identifier">List.foldl'</span><span>
</span><span id="line-411"></span><span>                    </span><span class="hs-special">(</span><span> </span><span class="hs-glyph">\</span><span class="hs-identifier">acc</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-glyph">\</span><span class="hs-glyph">case</span><span>
</span><span id="line-412"></span><span>                        </span><span class="hs-identifier">Nothing</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier">acc</span><span>
</span><span id="line-413"></span><span>                        </span><span class="hs-identifier">Just</span><span> </span><span class="hs-identifier">constructorName</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier">Map.insert</span><span> </span><span class="hs-identifier">constructorName</span><span> </span><span class="hs-identifier">typeName</span><span> </span><span class="hs-identifier">acc</span><span>
</span><span id="line-414"></span><span>                    </span><span class="hs-special">)</span><span>
</span><span id="line-415"></span><span>                    </span><span class="hs-identifier">constructorToDecl</span><span>
</span><span id="line-416"></span><span>                    </span><span class="hs-identifier">constructorNames</span><span class="hs-cpp">
                #declNameLookup . #declToConstructors %= Map.insert typeName constructorNames
</span><span>                </span><span class="hs-identifier">pure</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">NameSegment -&gt; Maybe NameSegment
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="annot"><span class="annottext">NameSegment
</span><a href="#local-6989586621679185549"><span class="hs-identifier hs-var">name</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-419"></span><span>            </span><span class="hs-keyword">where</span><span>
</span><span id="line-420"></span><span>              </span><span id="local-6989586621679185556"><span class="annot"><span class="annottext">typeName :: Name
</span><a href="#local-6989586621679185556"><span class="hs-identifier hs-var hs-var">typeName</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">NameSegment -&gt; Name
</span><a href="#local-6989586621679185547"><span class="hs-identifier hs-var">fullName</span></a></span><span> </span><span class="annot"><span class="annottext">NameSegment
</span><a href="#local-6989586621679185549"><span class="hs-identifier hs-var">name</span></a></span><span>
</span><span id="line-421"></span><span>
</span><span id="line-422"></span><span>      </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621679185574"><span class="annot"><span class="annottext">childrenWeHaventGoneInto :: Map
  NameSegment
  (Nametree (DefnsF (Map NameSegment) Referent TypeReference))
</span><a href="#local-6989586621679185574"><span class="hs-identifier hs-var hs-var">childrenWeHaventGoneInto</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Map
  NameSegment
  (Nametree (DefnsF (Map NameSegment) Referent TypeReference))
</span><a href="#local-6989586621679185536"><span class="hs-identifier hs-var">children</span></a></span><span> </span><span class="annot"><span class="annottext">Map
  NameSegment
  (Nametree (DefnsF (Map NameSegment) Referent TypeReference))
-&gt; Set NameSegment
-&gt; Map
     NameSegment
     (Nametree (DefnsF (Map NameSegment) Referent TypeReference))
forall k a. Ord k =&gt; Map k a -&gt; Set k -&gt; Map k a
</span><span class="hs-operator hs-var">`Map.withoutKeys`</span></span><span> </span><span class="annot"><span class="annottext">[NameSegment] -&gt; Set NameSegment
forall a. Ord a =&gt; [a] -&gt; Set a
</span><span class="hs-identifier hs-var">Set.fromList</span></span><span> </span><span class="annot"><span class="annottext">[NameSegment]
</span><a href="#local-6989586621679185548"><span class="hs-identifier hs-var">childrenWeWentInto</span></a></span><span>
</span><span id="line-423"></span><span>      </span><span class="annot"><span class="annottext">[(NameSegment,
  Nametree (DefnsF (Map NameSegment) Referent TypeReference))]
-&gt; ((NameSegment,
     Nametree (DefnsF (Map NameSegment) Referent TypeReference))
    -&gt; State LenientDeclCoherencyCheckState ())
-&gt; State LenientDeclCoherencyCheckState ()
forall (t :: * -&gt; *) (f :: * -&gt; *) a b.
(Foldable t, Applicative f) =&gt;
t a -&gt; (a -&gt; f b) -&gt; f ()
</span><span class="hs-identifier hs-var">for_</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Map
  NameSegment
  (Nametree (DefnsF (Map NameSegment) Referent TypeReference))
-&gt; [(NameSegment,
     Nametree (DefnsF (Map NameSegment) Referent TypeReference))]
forall k a. Map k a -&gt; [(k, a)]
</span><span class="hs-identifier hs-var">Map.toList</span></span><span> </span><span class="annot"><span class="annottext">Map
  NameSegment
  (Nametree (DefnsF (Map NameSegment) Referent TypeReference))
</span><a href="#local-6989586621679185574"><span class="hs-identifier hs-var">childrenWeHaventGoneInto</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">\</span><span class="hs-special">(</span><span id="local-6989586621679185575"><span class="annot"><span class="annottext">NameSegment
</span><a href="#local-6989586621679185575"><span class="hs-identifier hs-var">name</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679185576"><span class="annot"><span class="annottext">Nametree (DefnsF (Map NameSegment) Referent TypeReference)
</span><a href="#local-6989586621679185576"><span class="hs-identifier hs-var">child</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">[NameSegment]
-&gt; Nametree (DefnsF (Map NameSegment) Referent TypeReference)
-&gt; State LenientDeclCoherencyCheckState ()
</span><a href="#local-6989586621679185530"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">NameSegment
</span><a href="#local-6989586621679185575"><span class="hs-identifier hs-var">name</span></a></span><span> </span><span class="annot"><span class="annottext">NameSegment -&gt; [NameSegment] -&gt; [NameSegment]
forall a. a -&gt; [a] -&gt; [a]
</span><span class="hs-glyph hs-var">:</span></span><span> </span><span class="annot"><span class="annottext">[NameSegment]
</span><a href="#local-6989586621679185534"><span class="hs-identifier hs-var">prefix</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Nametree (DefnsF (Map NameSegment) Referent TypeReference)
</span><a href="#local-6989586621679185576"><span class="hs-identifier hs-var">child</span></a></span><span>
</span><span id="line-424"></span><span>      </span><span class="hs-keyword">where</span><span>
</span><span id="line-425"></span><span>        </span><span id="local-6989586621679185547"><span class="annot"><span class="annottext">fullName :: NameSegment -&gt; Name
</span><a href="#local-6989586621679185547"><span class="hs-identifier hs-var hs-var">fullName</span></a></span></span><span> </span><span id="local-6989586621679185577"><span class="annot"><span class="annottext">NameSegment
</span><a href="#local-6989586621679185577"><span class="hs-identifier hs-var">name</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-426"></span><span>          </span><span class="annot"><span class="annottext">NonEmpty NameSegment -&gt; Name
</span><span class="hs-identifier hs-var">Name.fromReverseSegments</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">NameSegment
</span><a href="#local-6989586621679185577"><span class="hs-identifier hs-var">name</span></a></span><span> </span><span class="annot"><span class="annottext">NameSegment -&gt; [NameSegment] -&gt; NonEmpty NameSegment
forall a. a -&gt; [a] -&gt; NonEmpty a
</span><span class="hs-operator hs-var">:|</span></span><span> </span><span class="annot"><span class="annottext">[NameSegment]
</span><a href="#local-6989586621679185534"><span class="hs-identifier hs-var">prefix</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-427"></span><span>
</span><span id="line-428"></span><span class="hs-keyword">data</span><span> </span><span id="DeclCoherencyCheckState"><span class="annot"><a href="Unison.Merge.DeclCoherencyCheck.html#DeclCoherencyCheckState"><span class="hs-identifier hs-var">DeclCoherencyCheckState</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="DeclCoherencyCheckState"><span class="annot"><a href="Unison.Merge.DeclCoherencyCheck.html#DeclCoherencyCheckState"><span class="hs-identifier hs-var">DeclCoherencyCheckState</span></a></span></span><span>
</span><span id="line-429"></span><span>  </span><span class="hs-special">{</span><span> </span><span id="%24sel%3AexpectedConstructors%3ADeclCoherencyCheckState"><span class="annot"><span class="annottext">DeclCoherencyCheckState -&gt; Map (Id' Hash) (Name, ConstructorNames)
</span><a href="Unison.Merge.DeclCoherencyCheck.html#%24sel%3AexpectedConstructors%3ADeclCoherencyCheckState"><span class="hs-identifier hs-var hs-var">expectedConstructors</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-glyph">!</span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Map</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">TypeReferenceId</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Unison.Merge.DeclCoherencyCheck.html#ConstructorNames"><span class="hs-identifier hs-type">ConstructorNames</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span class="hs-special">,</span><span>
</span><span id="line-430"></span><span>    </span><span id="%24sel%3AdeclNameLookup%3ADeclCoherencyCheckState"><span class="annot"><span class="annottext">DeclCoherencyCheckState -&gt; DeclNameLookup
</span><a href="Unison.Merge.DeclCoherencyCheck.html#%24sel%3AdeclNameLookup%3ADeclCoherencyCheckState"><span class="hs-identifier hs-var hs-var">declNameLookup</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-glyph">!</span><span class="annot"><span class="hs-identifier hs-type">DeclNameLookup</span></span><span>
</span><span id="line-431"></span><span>  </span><span class="hs-special">}</span><span>
</span><span id="line-432"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="annot"><span class="hs-keyword">stock</span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621679185581"><span id="local-6989586621679185583"><span class="annot"><span class="annottext">(forall x.
 DeclCoherencyCheckState -&gt; Rep DeclCoherencyCheckState x)
-&gt; (forall x.
    Rep DeclCoherencyCheckState x -&gt; DeclCoherencyCheckState)
-&gt; Generic DeclCoherencyCheckState
forall x. Rep DeclCoherencyCheckState x -&gt; DeclCoherencyCheckState
forall x. DeclCoherencyCheckState -&gt; Rep DeclCoherencyCheckState x
forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
$cfrom :: forall x. DeclCoherencyCheckState -&gt; Rep DeclCoherencyCheckState x
from :: forall x. DeclCoherencyCheckState -&gt; Rep DeclCoherencyCheckState x
$cto :: forall x. Rep DeclCoherencyCheckState x -&gt; DeclCoherencyCheckState
to :: forall x. Rep DeclCoherencyCheckState x -&gt; DeclCoherencyCheckState
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Generic</span></span></span></span><span class="hs-special">)</span><span>
</span><span id="line-433"></span><span>
</span><span id="line-434"></span><span class="hs-keyword">data</span><span> </span><span id="LenientDeclCoherencyCheckState"><span class="annot"><a href="Unison.Merge.DeclCoherencyCheck.html#LenientDeclCoherencyCheckState"><span class="hs-identifier hs-var">LenientDeclCoherencyCheckState</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="LenientDeclCoherencyCheckState"><span class="annot"><a href="Unison.Merge.DeclCoherencyCheck.html#LenientDeclCoherencyCheckState"><span class="hs-identifier hs-var">LenientDeclCoherencyCheckState</span></a></span></span><span>
</span><span id="line-435"></span><span>  </span><span class="hs-special">{</span><span> </span><span id="%24sel%3AexpectedConstructors%3ALenientDeclCoherencyCheckState"><span class="annot"><span class="annottext">LenientDeclCoherencyCheckState
-&gt; Map (Id' Hash) (Map Name ConstructorNames)
</span><a href="Unison.Merge.DeclCoherencyCheck.html#%24sel%3AexpectedConstructors%3ALenientDeclCoherencyCheckState"><span class="hs-identifier hs-var hs-var">expectedConstructors</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-glyph">!</span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Map</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">TypeReferenceId</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Map</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="annot"><a href="Unison.Merge.DeclCoherencyCheck.html#ConstructorNames"><span class="hs-identifier hs-type">ConstructorNames</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span class="hs-special">,</span><span>
</span><span id="line-436"></span><span>    </span><span id="%24sel%3AdeclNameLookup%3ALenientDeclCoherencyCheckState"><span class="annot"><span class="annottext">LenientDeclCoherencyCheckState -&gt; PartialDeclNameLookup
</span><a href="Unison.Merge.DeclCoherencyCheck.html#%24sel%3AdeclNameLookup%3ALenientDeclCoherencyCheckState"><span class="hs-identifier hs-var hs-var">declNameLookup</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-glyph">!</span><span class="annot"><a href="Unison.Merge.PartialDeclNameLookup.html#PartialDeclNameLookup"><span class="hs-identifier hs-type">PartialDeclNameLookup</span></a></span><span>
</span><span id="line-437"></span><span>  </span><span class="hs-special">}</span><span>
</span><span id="line-438"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="annot"><span class="hs-keyword">stock</span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621679185587"><span id="local-6989586621679185589"><span class="annot"><span class="annottext">(forall x.
 LenientDeclCoherencyCheckState
 -&gt; Rep LenientDeclCoherencyCheckState x)
-&gt; (forall x.
    Rep LenientDeclCoherencyCheckState x
    -&gt; LenientDeclCoherencyCheckState)
-&gt; Generic LenientDeclCoherencyCheckState
forall x.
Rep LenientDeclCoherencyCheckState x
-&gt; LenientDeclCoherencyCheckState
forall x.
LenientDeclCoherencyCheckState
-&gt; Rep LenientDeclCoherencyCheckState x
forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
$cfrom :: forall x.
LenientDeclCoherencyCheckState
-&gt; Rep LenientDeclCoherencyCheckState x
from :: forall x.
LenientDeclCoherencyCheckState
-&gt; Rep LenientDeclCoherencyCheckState x
$cto :: forall x.
Rep LenientDeclCoherencyCheckState x
-&gt; LenientDeclCoherencyCheckState
to :: forall x.
Rep LenientDeclCoherencyCheckState x
-&gt; LenientDeclCoherencyCheckState
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Generic</span></span></span></span><span class="hs-special">)</span><span>
</span><span id="line-439"></span><span>
</span><span id="line-440"></span><span class="hs-comment">-- A partial mapping from constructor id to name; a collection of constructor names starts out with the correct number</span><span>
</span><span id="line-441"></span><span class="hs-comment">-- of keys (per the number of data constructors) all mapped to Nothing. Then, as names are discovered by walking a</span><span>
</span><span id="line-442"></span><span class="hs-comment">-- name tree, Nothings become Justs.</span><span>
</span><span id="line-443"></span><span class="hs-keyword">type</span><span> </span><span id="ConstructorNames"><span class="annot"><a href="Unison.Merge.DeclCoherencyCheck.html#ConstructorNames"><span class="hs-identifier hs-var">ConstructorNames</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-444"></span><span>  </span><span class="annot"><span class="hs-identifier hs-type">IntMap</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span class="hs-special">)</span><span>
</span><span id="line-445"></span><span>
</span><span id="line-446"></span><span class="hs-comment">-- Make an empty set of constructor names given the number of constructors.</span><span>
</span><span id="line-447"></span><span class="annot"><a href="Unison.Merge.DeclCoherencyCheck.html#emptyConstructorNames"><span class="hs-identifier hs-type">emptyConstructorNames</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Unison.Merge.DeclCoherencyCheck.html#ConstructorNames"><span class="hs-identifier hs-type">ConstructorNames</span></a></span><span>
</span><span id="line-448"></span><span id="emptyConstructorNames"><span class="annot"><span class="annottext">emptyConstructorNames :: Int -&gt; ConstructorNames
</span><a href="Unison.Merge.DeclCoherencyCheck.html#emptyConstructorNames"><span class="hs-identifier hs-var hs-var">emptyConstructorNames</span></a></span></span><span> </span><span id="local-6989586621679185590"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679185590"><span class="hs-identifier hs-var">numConstructors</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-449"></span><span>  </span><span class="annot"><span class="annottext">[(Int, Maybe Name)] -&gt; ConstructorNames
forall a. [(Int, a)] -&gt; IntMap a
</span><span class="hs-identifier hs-var">IntMap.fromAscList</span></span><span> </span><span class="hs-special">[</span><span class="hs-special">(</span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679185592"><span class="hs-identifier hs-var">i</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Maybe Name
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">|</span><span> </span><span id="local-6989586621679185592"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679185592"><span class="hs-identifier hs-var">i</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">0</span></span><span> </span><span class="hs-glyph">..</span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679185590"><span class="hs-identifier hs-var">numConstructors</span></a></span><span> </span><span class="annot"><span class="annottext">Int -&gt; Int -&gt; Int
forall a. Num a =&gt; a -&gt; a -&gt; a
</span><span class="hs-glyph hs-var">-</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">1</span></span><span class="hs-special">]</span><span class="hs-special">]</span><span>
</span><span id="line-450"></span><span>
</span><span id="line-451"></span><span class="annot"><a href="Unison.Merge.DeclCoherencyCheck.html#recordConstructorName"><span class="hs-identifier hs-type">recordConstructorName</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">HasCallStack</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">ConstructorId</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Unison.Merge.DeclCoherencyCheck.html#ConstructorNames"><span class="hs-identifier hs-type">ConstructorNames</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Either</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="annot"><a href="Unison.Merge.DeclCoherencyCheck.html#ConstructorNames"><span class="hs-identifier hs-type">ConstructorNames</span></a></span><span>
</span><span id="line-452"></span><span id="recordConstructorName"><span class="annot"><span class="annottext">recordConstructorName :: HasCallStack =&gt;
Word64 -&gt; Name -&gt; ConstructorNames -&gt; Either Name ConstructorNames
</span><a href="Unison.Merge.DeclCoherencyCheck.html#recordConstructorName"><span class="hs-identifier hs-var hs-var">recordConstructorName</span></a></span></span><span> </span><span id="local-6989586621679185605"><span class="annot"><span class="annottext">Word64
</span><a href="#local-6989586621679185605"><span class="hs-identifier hs-var">conId</span></a></span></span><span> </span><span id="local-6989586621679185606"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679185606"><span class="hs-identifier hs-var">conName</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-453"></span><span>  </span><span class="annot"><span class="annottext">(Maybe (Maybe Name) -&gt; Either Name (Maybe (Maybe Name)))
-&gt; Int -&gt; ConstructorNames -&gt; Either Name ConstructorNames
forall (f :: * -&gt; *) a.
Functor f =&gt;
(Maybe a -&gt; f (Maybe a)) -&gt; Int -&gt; IntMap a -&gt; f (IntMap a)
</span><span class="hs-identifier hs-var">IntMap.alterF</span></span><span> </span><span class="annot"><span class="annottext">Maybe (Maybe Name) -&gt; Either Name (Maybe (Maybe Name))
</span><a href="#local-6989586621679185608"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall a b. (Integral a, Num b) =&gt; a -&gt; b
</span><span class="hs-identifier hs-var">fromIntegral</span></span><span> </span><span class="hs-glyph">@</span><span class="annot"><span class="hs-identifier hs-type">Word64</span></span><span> </span><span class="hs-glyph">@</span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span> </span><span class="annot"><span class="annottext">Word64
</span><a href="#local-6989586621679185605"><span class="hs-identifier hs-var">conId</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-454"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-455"></span><span>    </span><span class="annot"><a href="#local-6989586621679185608"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Either</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-456"></span><span>    </span><span id="local-6989586621679185608"><span class="annot"><span class="annottext">f :: Maybe (Maybe Name) -&gt; Either Name (Maybe (Maybe Name))
</span><a href="#local-6989586621679185608"><span class="hs-identifier hs-var hs-var">f</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-glyph">\</span><span class="hs-glyph">case</span><span>
</span><span id="line-457"></span><span>      </span><span class="annot"><span class="annottext">Maybe (Maybe Name)
</span><span class="hs-identifier hs-var">Nothing</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">String -&gt; Either Name (Maybe (Maybe Name))
forall a. HasCallStack =&gt; String -&gt; a
</span><span class="hs-identifier hs-var">error</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">String -&gt; ShowS
</span><span class="hs-identifier hs-var">reportBug</span></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;E397219&quot;</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;recordConstructorName: didn't expect constructor id &quot;</span></span><span> </span><span class="annot"><span class="annottext">String -&gt; ShowS
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="annottext">Word64 -&gt; String
forall a. Show a =&gt; a -&gt; String
</span><span class="hs-identifier hs-var">show</span></span><span> </span><span class="annot"><span class="annottext">Word64
</span><a href="#local-6989586621679185605"><span class="hs-identifier hs-var">conId</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-458"></span><span>      </span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span class="annot"><span class="annottext">Maybe Name
</span><span class="hs-identifier hs-var">Nothing</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Maybe (Maybe Name) -&gt; Either Name (Maybe (Maybe Name))
forall a b. b -&gt; Either a b
</span><span class="hs-identifier hs-var">Right</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Maybe Name -&gt; Maybe (Maybe Name)
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Name -&gt; Maybe Name
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679185606"><span class="hs-identifier hs-var">conName</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-459"></span><span>      </span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span id="local-6989586621679185612"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679185612"><span class="hs-identifier hs-var">existingName</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Name -&gt; Either Name (Maybe (Maybe Name))
forall a b. a -&gt; Either a b
</span><span class="hs-identifier hs-var">Left</span></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679185612"><span class="hs-identifier hs-var">existingName</span></a></span><span>
</span><span id="line-460"></span><span>
</span><span id="line-461"></span><span class="annot"><a href="Unison.Merge.DeclCoherencyCheck.html#lenientRecordConstructorName"><span class="hs-identifier hs-type">lenientRecordConstructorName</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">ConstructorId</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Unison.Merge.DeclCoherencyCheck.html#ConstructorNames"><span class="hs-identifier hs-type">ConstructorNames</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Unison.Merge.DeclCoherencyCheck.html#ConstructorNames"><span class="hs-identifier hs-type">ConstructorNames</span></a></span><span>
</span><span id="line-462"></span><span id="lenientRecordConstructorName"><span class="annot"><span class="annottext">lenientRecordConstructorName :: Word64 -&gt; Name -&gt; ConstructorNames -&gt; ConstructorNames
</span><a href="Unison.Merge.DeclCoherencyCheck.html#lenientRecordConstructorName"><span class="hs-identifier hs-var hs-var">lenientRecordConstructorName</span></a></span></span><span> </span><span id="local-6989586621679185613"><span class="annot"><span class="annottext">Word64
</span><a href="#local-6989586621679185613"><span class="hs-identifier hs-var">conId</span></a></span></span><span> </span><span id="local-6989586621679185614"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679185614"><span class="hs-identifier hs-var">conName</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-463"></span><span>  </span><span class="annot"><span class="annottext">(Maybe Name -&gt; Maybe Name)
-&gt; Int -&gt; ConstructorNames -&gt; ConstructorNames
forall a. (a -&gt; a) -&gt; Int -&gt; IntMap a -&gt; IntMap a
</span><span class="hs-identifier hs-var">IntMap.adjust</span></span><span> </span><span class="annot"><span class="annottext">Maybe Name -&gt; Maybe Name
</span><a href="#local-6989586621679185616"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall a b. (Integral a, Num b) =&gt; a -&gt; b
</span><span class="hs-identifier hs-var">fromIntegral</span></span><span> </span><span class="hs-glyph">@</span><span class="annot"><span class="hs-identifier hs-type">Word64</span></span><span> </span><span class="hs-glyph">@</span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span> </span><span class="annot"><span class="annottext">Word64
</span><a href="#local-6989586621679185613"><span class="hs-identifier hs-var">conId</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-464"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-465"></span><span>    </span><span class="annot"><a href="#local-6989586621679185616"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span>
</span><span id="line-466"></span><span>    </span><span id="local-6989586621679185616"><span class="annot"><span class="annottext">f :: Maybe Name -&gt; Maybe Name
</span><a href="#local-6989586621679185616"><span class="hs-identifier hs-var hs-var">f</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-glyph">\</span><span class="hs-glyph">case</span><span>
</span><span id="line-467"></span><span>      </span><span class="annot"><span class="annottext">Maybe Name
</span><span class="hs-identifier hs-var">Nothing</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Name -&gt; Maybe Name
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679185614"><span class="hs-identifier hs-var">conName</span></a></span><span>
</span><span id="line-468"></span><span>      </span><span class="hs-comment">-- Ignore constructor alias, just keep first name we found</span><span>
</span><span id="line-469"></span><span>      </span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span id="local-6989586621679185617"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679185617"><span class="hs-identifier hs-var">existingName</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Name -&gt; Maybe Name
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679185617"><span class="hs-identifier hs-var">existingName</span></a></span><span>
</span><span id="line-470"></span><span>
</span><span id="line-471"></span><span class="hs-keyword">data</span><span> </span><span id="WhatHappened"><span class="annot"><a href="Unison.Merge.DeclCoherencyCheck.html#WhatHappened"><span class="hs-identifier hs-var">WhatHappened</span></a></span></span><span> </span><span id="local-6989586621679184485"><span class="annot"><a href="#local-6989586621679184485"><span class="hs-identifier hs-type">a</span></a></span></span><span>
</span><span id="line-472"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span id="UninhabitedDecl"><span class="annot"><a href="Unison.Merge.DeclCoherencyCheck.html#UninhabitedDecl"><span class="hs-identifier hs-var">UninhabitedDecl</span></a></span></span><span>
</span><span id="line-473"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="InhabitedDecl"><span class="annot"><a href="Unison.Merge.DeclCoherencyCheck.html#InhabitedDecl"><span class="hs-identifier hs-var">InhabitedDecl</span></a></span></span><span> </span><span class="hs-glyph">!</span><span class="annot"><a href="#local-6989586621679184485"><span class="hs-identifier hs-type">a</span></a></span><span>
</span><span id="line-474"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="annot"><span class="hs-keyword">stock</span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621679185619"><span id="local-6989586621679185621"><span class="annot"><span class="annottext">(forall a b. (a -&gt; b) -&gt; WhatHappened a -&gt; WhatHappened b)
-&gt; (forall a b. a -&gt; WhatHappened b -&gt; WhatHappened a)
-&gt; Functor WhatHappened
forall a b. a -&gt; WhatHappened b -&gt; WhatHappened a
forall a b. (a -&gt; b) -&gt; WhatHappened a -&gt; WhatHappened b
forall (f :: * -&gt; *).
(forall a b. (a -&gt; b) -&gt; f a -&gt; f b)
-&gt; (forall a b. a -&gt; f b -&gt; f a) -&gt; Functor f
$cfmap :: forall a b. (a -&gt; b) -&gt; WhatHappened a -&gt; WhatHappened b
fmap :: forall a b. (a -&gt; b) -&gt; WhatHappened a -&gt; WhatHappened b
$c&lt;$ :: forall a b. a -&gt; WhatHappened b -&gt; WhatHappened a
&lt;$ :: forall a b. a -&gt; WhatHappened b -&gt; WhatHappened a
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Functor</span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679185625"><span id="local-6989586621679185629"><span id="local-6989586621679185633"><span class="annot"><span class="annottext">Int -&gt; WhatHappened a -&gt; ShowS
[WhatHappened a] -&gt; ShowS
WhatHappened a -&gt; String
(Int -&gt; WhatHappened a -&gt; ShowS)
-&gt; (WhatHappened a -&gt; String)
-&gt; ([WhatHappened a] -&gt; ShowS)
-&gt; Show (WhatHappened a)
forall a. Show a =&gt; Int -&gt; WhatHappened a -&gt; ShowS
forall a. Show a =&gt; [WhatHappened a] -&gt; ShowS
forall a. Show a =&gt; WhatHappened a -&gt; String
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
$cshowsPrec :: forall a. Show a =&gt; Int -&gt; WhatHappened a -&gt; ShowS
showsPrec :: Int -&gt; WhatHappened a -&gt; ShowS
$cshow :: forall a. Show a =&gt; WhatHappened a -&gt; String
show :: WhatHappened a -&gt; String
$cshowList :: forall a. Show a =&gt; [WhatHappened a] -&gt; ShowS
showList :: [WhatHappened a] -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">)</span><span>
</span><span id="line-475"></span><span>
</span><span id="line-476"></span><span class="annot"><a href="Unison.Merge.DeclCoherencyCheck.html#expectNumConstructors"><span class="hs-identifier hs-type">expectNumConstructors</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">HasCallStack</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">TypeReferenceId</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Map</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">TypeReferenceId</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span>
</span><span id="line-477"></span><span id="expectNumConstructors"><span class="annot"><span class="annottext">expectNumConstructors :: HasCallStack =&gt; Id' Hash -&gt; Map (Id' Hash) Int -&gt; Int
</span><a href="Unison.Merge.DeclCoherencyCheck.html#expectNumConstructors"><span class="hs-identifier hs-var hs-var">expectNumConstructors</span></a></span></span><span> </span><span id="local-6989586621679185648"><span class="annot"><span class="annottext">Id' Hash
</span><a href="#local-6989586621679185648"><span class="hs-identifier hs-var">refId</span></a></span></span><span> </span><span id="local-6989586621679185649"><span class="annot"><span class="annottext">Map (Id' Hash) Int
</span><a href="#local-6989586621679185649"><span class="hs-identifier hs-var">numConstructorsById</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-478"></span><span>  </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">Id' Hash -&gt; Map (Id' Hash) Int -&gt; Maybe Int
forall k a. Ord k =&gt; k -&gt; Map k a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Map.lookup</span></span><span> </span><span class="annot"><span class="annottext">Id' Hash
</span><a href="#local-6989586621679185648"><span class="hs-identifier hs-var">refId</span></a></span><span> </span><span class="annot"><span class="annottext">Map (Id' Hash) Int
</span><a href="#local-6989586621679185649"><span class="hs-identifier hs-var">numConstructorsById</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-479"></span><span>    </span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span id="local-6989586621679185650"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679185650"><span class="hs-identifier hs-var">numConstructors</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679185650"><span class="hs-identifier hs-var">numConstructors</span></a></span><span>
</span><span id="line-480"></span><span>    </span><span class="annot"><span class="annottext">Maybe Int
</span><span class="hs-identifier hs-var">Nothing</span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-481"></span><span>      </span><span class="annot"><span class="annottext">String -&gt; Int
forall a. HasCallStack =&gt; String -&gt; a
</span><span class="hs-identifier hs-var">error</span></span><span> </span><span class="annot"><span class="annottext">(String -&gt; Int) -&gt; String -&gt; Int
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span>
</span><span id="line-482"></span><span>        </span><span class="annot"><span class="annottext">String -&gt; ShowS
</span><span class="hs-identifier hs-var">reportBug</span></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;E061715&quot;</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;type ref &quot;</span></span><span> </span><span class="annot"><span class="annottext">String -&gt; ShowS
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="annottext">Id' Hash -&gt; String
forall a. Show a =&gt; a -&gt; String
</span><span class="hs-identifier hs-var">show</span></span><span> </span><span class="annot"><span class="annottext">Id' Hash
</span><a href="#local-6989586621679185648"><span class="hs-identifier hs-var">refId</span></a></span><span> </span><span class="annot"><span class="annottext">String -&gt; ShowS
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot; not found in map &quot;</span></span><span> </span><span class="annot"><span class="annottext">String -&gt; ShowS
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="annottext">Map (Id' Hash) Int -&gt; String
forall a. Show a =&gt; a -&gt; String
</span><span class="hs-identifier hs-var">show</span></span><span> </span><span class="annot"><span class="annottext">Map (Id' Hash) Int
</span><a href="#local-6989586621679185649"><span class="hs-identifier hs-var">numConstructorsById</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-483"></span></pre></body></html>