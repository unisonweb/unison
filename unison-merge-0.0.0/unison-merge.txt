-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


@package unison-merge
@version 0.0.0

module Unison.Merge.EitherWay

-- | Alice exclusive-or Bob?
data EitherWay a
Alice :: a -> EitherWay a
Bob :: a -> EitherWay a
swap :: EitherWay a -> EitherWay a
value :: EitherWay a -> a
instance GHC.Show.Show a => GHC.Show.Show (Unison.Merge.EitherWay.EitherWay a)
instance GHC.Base.Functor Unison.Merge.EitherWay.EitherWay
instance GHC.Classes.Eq a => GHC.Classes.Eq (Unison.Merge.EitherWay.EitherWay a)

module Unison.Merge.EitherWayI

-- | Alice inclusive-or Bob?
data EitherWayI a
OnlyAlice :: a -> EitherWayI a
OnlyBob :: a -> EitherWayI a
AliceAndBob :: a -> EitherWayI a
includingAlice :: EitherWayI a -> Maybe a
excludingAlice :: EitherWayI a -> Maybe a
value :: EitherWayI a -> a
instance GHC.Show.Show a => GHC.Show.Show (Unison.Merge.EitherWayI.EitherWayI a)
instance GHC.Base.Functor Unison.Merge.EitherWayI.EitherWayI

module Unison.Merge.PartialDeclNameLookup

-- | Like a <tt>DeclNameLookup</tt>, but "partial" / more lenient - because
--   we don't require the LCA of a merge to have a full
--   <tt>DeclNameLookup</tt>.
data PartialDeclNameLookup
PartialDeclNameLookup :: !Map Name Name -> !Map Name [Maybe Name] -> PartialDeclNameLookup
[$sel:constructorToDecl:PartialDeclNameLookup] :: PartialDeclNameLookup -> !Map Name Name
[$sel:declToConstructors:PartialDeclNameLookup] :: PartialDeclNameLookup -> !Map Name [Maybe Name]
instance GHC.Generics.Generic Unison.Merge.PartialDeclNameLookup.PartialDeclNameLookup


-- | The "decl coherency check": a type declaration in a namespace is
--   "coherent" if it satisfies both of the following criteria.
--   
--   <ol>
--   <li>For each naming of the type decl (say <a>Foo</a>#foohash), there
--   exists exactly one name for each of its constructors arbitrarily deep
--   in the corresponding namespace (<a>Foo</a> in this example).</li>
--   </ol>
--   
--   This allows us to render the decl naturally, as in
--   
--   structural type Foo = Bar Nat Int | internal.hello.Bonk Nat
--   
--   which corresponds to the three names
--   
--   <a>Foo</a> =&gt; #foohash <a>Foo.Bar</a> =&gt; 0
--   "Foo.internal.hello.Bonk" =&gt; 1
--   
--   We could not do if there was at least one constructor whose full name
--   does not contain the full name of the type decl itself as a prefix.
--   
--   A notable consequence of this requirement is that a second naming of a
--   decl (i.e. an alias) cannot be embedded within the first naming, as
--   in:
--   
--   type Foo = ... type Foo.some.inner.namespace = ... -- an alias of Foo
--   
--   <ol>
--   <li>No constructor has a "stray" name that does not have a prefix that
--   equals the type declaration's name. For example, in the
--   namespace<a>Foo</a> =&gt; #foohash <a>Foo.Bar</a> =&gt; 0
--   <a>Deep.What.SomeAlias</a> =&gt; 0</li>
--   </ol>
--   
--   the constructor <a>What.SomeAlias</a> is "stray", as the type decl
--   #foohash has no name that matches any prefix (i.e. <a>Deep.What</a>
--   nor <a>Deep</a>).
--   
--   On to the implementation. We are going to traverse the namespace
--   depth-first. As we go, we have a stateful mapping between decl
--   reference that we *have* seen a name for in one of our parent
--   namespace, and its corresponding set of constructors that we *haven't*
--   yet seen names for, but expect to, before fully searching the
--   corresponding sub-namespace (e.g. the child namespace named <a>Foo</a>
--   of the namepace that declares a decl <a>Foo</a>).
--   
--   When processing a namespace, we first process all terms. Each
--   constructor will fall into one of three cases:
--   
--   <pre>
--   +----------------------------------------------------------------------------------------------------------------+
--   | Case         | Mapping before       | Encountered constructor | Mapping after                                  |
--   +----------------------------------------------------------------------------------------------------------------+
--   | Happy path   | { #foo : {0, 1, 2} } | #foo#1                  | { #foo : {0, 2} }                              |
--   | Already seen | { #foo : {0, 1, 2} } | #foo#5                  | Error: duplicate naming for constructor #foo#5 |
--   | Never seen   | { #foo : {0, 1, 2} } | #bar#2                  | Error: stray constructor #bar#2                |
--   +----------------------------------------------------------------------------------------------------------------+
--   </pre>
--   
--   In "happy path", we see a naming of a constructor that we're
--   expecting, and check it off. In "already seen", we see a second naming
--   of a constructor that we're no longer expecting, and fail. In "never
--   seen", we see a naming of a constructor before any naming of its decl,
--   so we fail.
--   
--   Next, we process all type decls. Each will again fall into one of
--   three cases:
--   
--   <pre>
--   +-----------------------------------------------------------------------------------------------------+
--   | Case             | Mapping before       | Declaration | Num constructors | New mapping              |
--   +-----------------------------------------------------------------------------------------------------+
--   | Uninhabited decl |                      | #foo        | 0                |                          |
--   | Inhabited decl   |                      | #foo        | 1 or more        | { #foo : {0, ..., n-1} } |
--   | Already seen     | { foo : {0, 1, 2}  } | #foo        | Irrelevant       | Error: nested decl alias |
--   +-----------------------------------------------------------------------------------------------------+
--   </pre>
--   
--   In "uninhabited decl", we find a decl with no constructors, so we
--   don't expect anything new. In "already seen", we find a second naming
--   of a decl, whose constructors will necessarily violate coherency
--   condition (1) above.
--   
--   In "inhabited decl", we find a decl with N constructors, and handle it
--   by: 1. Adding to our state that we expect a name for each. 2.
--   Recursing into the child namespace whose name matches the decl. 3. (If
--   we return from the recursion without short-circuiting) remove the
--   mapping added in step (1) and assert that its value is the empty set
--   (meaning we encountered a name for every constructor).
--   
--   Note: This check could be moved into SQLite (with sufficient schema
--   support) some day, but for now, we just do this in memory.
--   
--   Note: once upon a time, decls could be "incoherent". Then, we decided
--   we want decls to be "coherent". Thus, this machinery was invented.
module Unison.Merge.DeclCoherencyCheck
data IncoherentDeclReason

-- | A second naming of a constructor was discovered underneath a decl's
--   name, e.g.
--   
--   Foo#Foo Foo.Bar0 Foo.Some.Other.Name.For.Bar0
IncoherentDeclReason'ConstructorAlias :: !Name -> !Name -> !Name -> IncoherentDeclReason
IncoherentDeclReason'MissingConstructorName :: !Name -> IncoherentDeclReason

-- | A second naming of a decl was discovered underneath its name, e.g.
--   
--   Foo#Foo Foo.Bar#Foo
IncoherentDeclReason'NestedDeclAlias :: !Name -> !Name -> IncoherentDeclReason
IncoherentDeclReason'StrayConstructor :: !TypeReferenceId -> !Name -> IncoherentDeclReason
checkDeclCoherency :: HasCallStack => Nametree (DefnsF (Map NameSegment) Referent TypeReference) -> Map TypeReferenceId Int -> Either IncoherentDeclReason DeclNameLookup

-- | A lenient variant of <a>checkDeclCoherency</a> - so lenient it can't
--   even fail! It returns partial decl name lookup, which doesn't require
--   a name for every constructor, and allows a constructor with a nameless
--   decl.
--   
--   This function exists merely to extract a best-effort name mapping for
--   the LCA of a merge. We require Alice and Bob to have coherent decls,
--   but their LCA is out of the user's control and may have incoherent
--   decls, and whether or not it does, we still need to compute *some*
--   syntactic hash for its decls.
lenientCheckDeclCoherency :: Nametree (DefnsF (Map NameSegment) Referent TypeReference) -> Map TypeReferenceId Int -> PartialDeclNameLookup
data IncoherentDeclReasons
IncoherentDeclReasons :: ![(Name, Name, Name)] -> ![Name] -> ![(Name, Name)] -> ![(TypeReferenceId, Name)] -> IncoherentDeclReasons
[$sel:constructorAliases:IncoherentDeclReasons] :: IncoherentDeclReasons -> ![(Name, Name, Name)]
[$sel:missingConstructorNames:IncoherentDeclReasons] :: IncoherentDeclReasons -> ![Name]
[$sel:nestedDeclAliases:IncoherentDeclReasons] :: IncoherentDeclReasons -> ![(Name, Name)]
[$sel:strayConstructors:IncoherentDeclReasons] :: IncoherentDeclReasons -> ![(TypeReferenceId, Name)]

-- | Like <a>checkDeclCoherency</a>, but returns info about all of the
--   incoherent decls found, not just the first.
checkAllDeclCoherency :: forall m. Monad m => (TypeReferenceId -> m Int) -> Nametree (DefnsF (Map NameSegment) Referent TypeReference) -> m (Either IncoherentDeclReasons DeclNameLookup)
instance GHC.Show.Show Unison.Merge.DeclCoherencyCheck.IncoherentDeclReason
instance GHC.Generics.Generic Unison.Merge.DeclCoherencyCheck.IncoherentDeclReasons
instance GHC.Classes.Eq Unison.Merge.DeclCoherencyCheck.IncoherentDeclReasons
instance GHC.Generics.Generic Unison.Merge.DeclCoherencyCheck.LenientDeclCoherencyCheckState
instance GHC.Generics.Generic Unison.Merge.DeclCoherencyCheck.DeclCoherencyCheckState
instance GHC.Show.Show a => GHC.Show.Show (Unison.Merge.DeclCoherencyCheck.WhatHappened a)
instance GHC.Base.Functor Unison.Merge.DeclCoherencyCheck.WhatHappened


-- | Utilities for computing the "syntactic hash" of a decl or term, which
--   is a hash that is computed after substituting references to other
--   terms and decls with names from a pretty-print environment.
--   
--   Thus, syntactic hashes can be compared for equality to answer
--   questions like "would these definitions look the same when rendered
--   for a human (even if their underlying references are different)?".
--   
--   The merge algorithm currently uses syntactic hashes for determining
--   whether an update was performed by a human, or was the result of
--   auto-propagation. (Critically, this cannot handle renames very well).
--   For example, consider comparing two definitions on Alice's branch; one
--   old one from somewhere in its history, and one new:
--   
--   old namespace new namespace ---------------- --------------- foo =
--   #bar + 3 foo = #bar2 + 3
--   
--   Either Alice manually updated #bar to #bar2, or else a dependency of
--   #bar was updated, inducing an update to #bar2. Computing the syntactic
--   hash can help answer that question. Let's combine a pretty-print
--   environment for the old and new namespaces together, substitute
--   references with it, and look again at the terms:
--   
--   old namespace new namespace ---------------- ---------------- foo =
--   helper + 3 foo = helper + 3
--   
--   We see now that our pretty-print environment has mapped both #bar and
--   #bar2 to the name "helper", so each version of "foo" would have the
--   same syntactic hash. This indicates (to our merge algorithm) that this
--   was an auto-propagated update.
module Unison.Merge.Synhash

-- | Syntactically hash a type, using reference names rather than hashes.
--   Two types will have the same syntactic hash if they would print the
--   the same way under the given pretty-print env.
synhashType :: Var v => PrettyPrintEnv -> Type v a -> Hash
synhashTerm :: forall m v a. (Monad m, Var v) => (TermReferenceId -> m (Term v a)) -> PrettyPrintEnv -> TermReference -> m Hash
synhashBuiltinTerm :: Text -> Hash
synhashDerivedTerm :: Var v => PrettyPrintEnv -> Term v a -> Hash
synhashBuiltinDecl :: Text -> Hash

-- | Syntactically hash a decl, using reference names rather than hashes.
--   Two decls will have the same syntactic hash if they they are the same
--   sort of decl (both are data decls or both are effect decls), the
--   unique type guid is the same, the constructors appear in the same
--   order and have the same names, and the constructors' types have the
--   same syntactic hashes.
synhashDerivedDecl :: Var v => PrettyPrintEnv -> Name -> Decl v a -> Hash
hashBuiltinTermTokens :: Text -> [Token]
hashDerivedTermTokens :: forall a v. Var v => PrettyPrintEnv -> Term v a -> [Token]

module Unison.Merge.Synhashed

-- | A small utility type that represents a syntactic-hashed thing.
--   
--   The <a>Eq</a> and <a>Ord</a> instances only compares syntactic hashes.
data Synhashed a
Synhashed :: !Hash -> !a -> Synhashed a
[$sel:hash:Synhashed] :: Synhashed a -> !Hash
[$sel:value:Synhashed] :: Synhashed a -> !a
instance GHC.Show.Show a => GHC.Show.Show (Unison.Merge.Synhashed.Synhashed a)
instance GHC.Generics.Generic (Unison.Merge.Synhashed.Synhashed a)
instance GHC.Base.Functor Unison.Merge.Synhashed.Synhashed
instance GHC.Classes.Eq (Unison.Merge.Synhashed.Synhashed a)
instance GHC.Classes.Ord (Unison.Merge.Synhashed.Synhashed a)

module Unison.Merge.TwoOrThreeWay
data TwoOrThreeWay a
TwoOrThreeWay :: Maybe a -> a -> a -> TwoOrThreeWay a
[$sel:lca:TwoOrThreeWay] :: TwoOrThreeWay a -> Maybe a
[$sel:alice:TwoOrThreeWay] :: TwoOrThreeWay a -> a
[$sel:bob:TwoOrThreeWay] :: TwoOrThreeWay a -> a
instance Data.Traversable.Traversable Unison.Merge.TwoOrThreeWay.TwoOrThreeWay
instance GHC.Generics.Generic (Unison.Merge.TwoOrThreeWay.TwoOrThreeWay a)
instance GHC.Base.Functor Unison.Merge.TwoOrThreeWay.TwoOrThreeWay
instance Data.Foldable.Foldable Unison.Merge.TwoOrThreeWay.TwoOrThreeWay

module Unison.Merge.TwoWay
data TwoWay a
TwoWay :: a -> a -> TwoWay a
[$sel:alice:TwoWay] :: TwoWay a -> a
[$sel:bob:TwoWay] :: TwoWay a -> a
bothWays :: a -> TwoWay a
justTheTerms :: TwoWay (Defns terms types) -> TwoWay terms
justTheTypes :: TwoWay (Defns terms types) -> TwoWay types
or :: TwoWay Bool -> Bool
sequenceDefns :: TwoWay (Defns terms types) -> DefnsF TwoWay terms types

-- | Swap who's considered Alice and who's considered Bob. Usually
--   nonsense, but sometimes what you need!
swap :: TwoWay a -> TwoWay a
twoWay :: (a -> a -> b) -> TwoWay a -> b

-- | Unzip a <tt>Map k (TwoWay v)</tt> into a <tt>TwoWay (Map k v)</tt>.
unzipMap :: Ord k => Map k (TwoWay v) -> TwoWay (Map k v)
who_ :: EitherWay x -> Lens' (TwoWay a) a
instance GHC.Base.Semigroup a => GHC.Base.Semigroup (Unison.Merge.TwoWay.TwoWay a)
instance GHC.Base.Monoid a => GHC.Base.Monoid (Unison.Merge.TwoWay.TwoWay a)
instance Data.Traversable.Traversable Unison.Merge.TwoWay.TwoWay
instance GHC.Show.Show a => GHC.Show.Show (Unison.Merge.TwoWay.TwoWay a)
instance GHC.Generics.Generic (Unison.Merge.TwoWay.TwoWay a)
instance GHC.Base.Functor Unison.Merge.TwoWay.TwoWay
instance Data.Foldable.Foldable Unison.Merge.TwoWay.TwoWay
instance GHC.Base.Applicative Unison.Merge.TwoWay.TwoWay
instance Data.Semialign.Internal.Semialign Unison.Merge.TwoWay.TwoWay
instance Data.Semialign.Internal.Unzip Unison.Merge.TwoWay.TwoWay
instance Data.Semialign.Internal.Zip Unison.Merge.TwoWay.TwoWay

module Unison.Merge.ThreeWay
data ThreeWay a
ThreeWay :: !a -> !a -> !a -> ThreeWay a
[$sel:lca:ThreeWay] :: ThreeWay a -> !a
[$sel:alice:ThreeWay] :: ThreeWay a -> !a
[$sel:bob:ThreeWay] :: ThreeWay a -> !a
forgetLca :: ThreeWay a -> TwoWay a
instance Data.Traversable.Traversable Unison.Merge.ThreeWay.ThreeWay
instance GHC.Generics.Generic (Unison.Merge.ThreeWay.ThreeWay a)
instance GHC.Base.Functor Unison.Merge.ThreeWay.ThreeWay
instance Data.Foldable.Foldable Unison.Merge.ThreeWay.ThreeWay
instance GHC.Base.Applicative Unison.Merge.ThreeWay.ThreeWay
instance Data.Semialign.Internal.Semialign Unison.Merge.ThreeWay.ThreeWay
instance Data.Semialign.Internal.Unzip Unison.Merge.ThreeWay.ThreeWay
instance Data.Semialign.Internal.Zip Unison.Merge.ThreeWay.ThreeWay

module Unison.Merge.Mergeblob0
data Mergeblob0 libdep
Mergeblob0 :: ThreeWay (Defns (BiMultimap Referent Name) (BiMultimap TypeReference Name)) -> ThreeWay (Map NameSegment libdep) -> ThreeWay (Nametree (DefnsF (Map NameSegment) Referent TypeReference)) -> Mergeblob0 libdep
[$sel:defns:Mergeblob0] :: Mergeblob0 libdep -> ThreeWay (Defns (BiMultimap Referent Name) (BiMultimap TypeReference Name))
[$sel:libdeps:Mergeblob0] :: Mergeblob0 libdep -> ThreeWay (Map NameSegment libdep)
[$sel:nametrees:Mergeblob0] :: Mergeblob0 libdep -> ThreeWay (Nametree (DefnsF (Map NameSegment) Referent TypeReference))
makeMergeblob0 :: ThreeWay (Nametree (DefnsF (Map NameSegment) Referent TypeReference)) -> ThreeWay (Map NameSegment libdep) -> Mergeblob0 libdep

module Unison.Merge.PrettyPrintEnv
makePrettyPrintEnv :: TwoWay Names -> Names -> PrettyPrintEnvDecl

module Unison.Merge.TwoWayI

-- | "Two-way inclusive".
data TwoWayI a
TwoWayI :: a -> a -> a -> TwoWayI a
[$sel:alice:TwoWayI] :: TwoWayI a -> a
[$sel:bob:TwoWayI] :: TwoWayI a -> a
[$sel:both:TwoWayI] :: TwoWayI a -> a
forgetBoth :: TwoWayI a -> TwoWay a
who_ :: EitherWayI x -> Lens' (TwoWayI a) a
instance GHC.Base.Semigroup a => GHC.Base.Semigroup (Unison.Merge.TwoWayI.TwoWayI a)
instance GHC.Base.Monoid a => GHC.Base.Monoid (Unison.Merge.TwoWayI.TwoWayI a)
instance GHC.Generics.Generic (Unison.Merge.TwoWayI.TwoWayI a)
instance GHC.Base.Functor Unison.Merge.TwoWayI.TwoWayI
instance Data.Foldable.Foldable Unison.Merge.TwoWayI.TwoWayI
instance GHC.Base.Applicative Unison.Merge.TwoWayI.TwoWayI
instance Data.Semialign.Internal.Semialign Unison.Merge.TwoWayI.TwoWayI
instance Data.Semialign.Internal.Zip Unison.Merge.TwoWayI.TwoWayI

module Unison.Merge.Unconflicts
data Unconflicts v
Unconflicts :: !TwoWayI (Map Name v) -> !TwoWayI (Map Name v) -> !TwoWayI (Map Name v) -> Unconflicts v
[$sel:adds:Unconflicts] :: Unconflicts v -> !TwoWayI (Map Name v)
[$sel:deletes:Unconflicts] :: Unconflicts v -> !TwoWayI (Map Name v)
[$sel:updates:Unconflicts] :: Unconflicts v -> !TwoWayI (Map Name v)
empty :: Unconflicts v

-- | Apply unconflicts to a namespace.
apply :: forall v. Unconflicts v -> Map Name v -> Map Name v
soloUpdatesAndDeletes :: DefnsF Unconflicts term typ -> TwoWay (DefnsF Set Name Name)
instance GHC.Generics.Generic (Unison.Merge.Unconflicts.Unconflicts v)
instance GHC.Base.Functor Unison.Merge.Unconflicts.Unconflicts
instance Data.Foldable.Foldable Unison.Merge.Unconflicts.Unconflicts

module Unison.Merge.Updated

-- | An updated thing.
data Updated a
Updated :: a -> a -> Updated a
[$sel:old:Updated] :: Updated a -> a
[$sel:new:Updated] :: Updated a -> a
instance GHC.Show.Show a => GHC.Show.Show (Unison.Merge.Updated.Updated a)
instance GHC.Generics.Generic (Unison.Merge.Updated.Updated a)
instance GHC.Base.Functor Unison.Merge.Updated.Updated

module Unison.Merge.DiffOp

-- | A diff operation is one of:
--   
--   <ul>
--   <li>An add (where nothing was)</li>
--   <li>A delete (of the thing that was)</li>
--   <li>An update (from old to new)</li>
--   </ul>
data DiffOp a
DiffOp'Add :: !a -> DiffOp a
DiffOp'Delete :: !a -> DiffOp a
DiffOp'Update :: !Updated a -> DiffOp a
instance GHC.Show.Show a => GHC.Show.Show (Unison.Merge.DiffOp.DiffOp a)
instance GHC.Base.Functor Unison.Merge.DiffOp.DiffOp

module Unison.Merge.TwoDiffOps
data TwoDiffOps a
TwoDiffOps'Add :: !EitherWay a -> TwoDiffOps a
TwoDiffOps'Delete :: !EitherWay a -> TwoDiffOps a
TwoDiffOps'Update :: !EitherWay (Updated a) -> TwoDiffOps a
TwoDiffOps'AddAdd :: !TwoWay a -> TwoDiffOps a
TwoDiffOps'DeleteDelete :: !a -> TwoDiffOps a
TwoDiffOps'DeleteUpdate :: !Updated a -> TwoDiffOps a
TwoDiffOps'UpdateDelete :: !Updated a -> TwoDiffOps a
TwoDiffOps'UpdateUpdate :: !a -> !TwoWay a -> TwoDiffOps a

-- | Combine two aligned <tt>DiffOp</tt> into one <tt>TwoDiffOps</tt>.
make :: These (DiffOp a) (DiffOp a) -> TwoDiffOps a


-- | An API for merging together two collections of library dependencies.
module Unison.Merge.Libdeps
data LibdepDiffOp a
AddLibdep :: !a -> LibdepDiffOp a
AddBothLibdeps :: !a -> !a -> LibdepDiffOp a
DeleteLibdep :: LibdepDiffOp a

-- | Perform a three-way diff on two collections of library dependencies.
diffLibdeps :: (Ord k, Eq v) => ThreeWay (Map k v) -> Map k (LibdepDiffOp v)
applyLibdepsDiff :: forall k v. Ord k => (Set k -> k -> (k, k)) -> ThreeWay (Map k v) -> Map k (LibdepDiffOp v) -> Map k v
getTwoFreshLibdepNames :: Set NameSegment -> NameSegment -> (NameSegment, NameSegment)

module Unison.Merge.FindConflictedAlias
findConflictedAlias :: forall name synhashed term typ. (Ord name, forall ref. Eq (synhashed ref), Ord term, Ord typ) => Defns (BiMultimap term name) (BiMultimap typ name) -> DefnsF3 (Map name) DiffOp synhashed term typ -> Maybe (Defn (name, name) (name, name))

module Unison.Merge.Diff

-- | <tt>nameBasedNamespaceDiff db declNameLookups defns</tt> returns
--   Alice's and Bob's name-based namespace diffs, each in the form:
--   
--   <pre>
--   terms :: Map Name (DiffOp (Synhashed Referent))
--   types :: Map Name (DiffOp (Synhashed TypeReference))
--   </pre>
--   
--   where each name is paired with its diff-op (added, deleted, or
--   updated), relative to the LCA between Alice and Bob's branches. If the
--   hash of a name did not change, it will not appear in the map.
nameBasedNamespaceDiff :: HasCallStack => TwoWay DeclNameLookup -> PartialDeclNameLookup -> ThreeWay (Defns (BiMultimap Referent Name) (BiMultimap TypeReference Name)) -> Defns (Map TermReferenceId (Term Symbol Ann)) (Map TypeReferenceId (Decl Symbol Ann)) -> TwoWay (DefnsF3 (Map Name) DiffOp Synhashed Referent TypeReference)


-- | Combine two diffs together.
module Unison.Merge.CombineDiffs

-- | The combined result of two diffs on the same thing.
data CombinedDiffOp a
CombinedDiffOp'Add :: !EitherWayI a -> CombinedDiffOp a
CombinedDiffOp'Delete :: !EitherWayI a -> CombinedDiffOp a
CombinedDiffOp'Update :: !EitherWayI (Updated a) -> CombinedDiffOp a
CombinedDiffOp'Conflict :: !TwoWay a -> CombinedDiffOp a

-- | Combine LCA-&gt;Alice diff and LCA-&gt;Bob diff.
combineDiffs :: TwoWay (DefnsF3 (Map Name) DiffOp Synhashed Referent TypeReference) -> DefnsF2 (Map Name) CombinedDiffOp Referent TypeReference
instance GHC.Show.Show a => GHC.Show.Show (Unison.Merge.CombineDiffs.CombinedDiffOp a)
instance GHC.Base.Functor Unison.Merge.CombineDiffs.CombinedDiffOp

module Unison.Merge.PartitionCombinedDiffs

-- | Combine LCA-&gt;Alice diff and LCA-&gt;Bob diff, then partition into
--   conflicted and unconflicted things.
partitionCombinedDiffs :: TwoWay (Defns (BiMultimap Referent Name) (BiMultimap TypeReference Name)) -> TwoWay DeclNameLookup -> DefnsF2 (Map Name) CombinedDiffOp Referent TypeReference -> (TwoWay (DefnsF (Map Name) TermReference TypeReference), DefnsF Unconflicts Referent TypeReference)
narrowConflictsToNonBuiltins :: TwoWay (DefnsF (Map Name) TermReference TypeReference) -> Either (Defn Name Name) (TwoWay (DefnsF (Map Name) TermReferenceId TypeReferenceId))
instance GHC.Generics.Generic Unison.Merge.PartitionCombinedDiffs.S

module Unison.Merge.Mergeblob1
data Mergeblob1 libdep
Mergeblob1 :: TwoWay (DefnsF (Map Name) TermReference TypeReference) -> TwoWay DeclNameLookup -> ThreeWay (Defns (BiMultimap Referent Name) (BiMultimap TypeReference Name)) -> DefnsF2 (Map Name) CombinedDiffOp Referent TypeReference -> TwoWay (DefnsF3 (Map Name) DiffOp Synhashed Referent TypeReference) -> ThreeWay (DefnsF (Map Name) (TermReferenceId, (Term Symbol Ann, Type Symbol Ann)) (TypeReferenceId, Decl Symbol Ann)) -> PartialDeclNameLookup -> Map NameSegment libdep -> Map NameSegment (LibdepDiffOp libdep) -> DefnsF Unconflicts Referent TypeReference -> Mergeblob1 libdep
[$sel:conflicts:Mergeblob1] :: Mergeblob1 libdep -> TwoWay (DefnsF (Map Name) TermReference TypeReference)
[$sel:declNameLookups:Mergeblob1] :: Mergeblob1 libdep -> TwoWay DeclNameLookup
[$sel:defns:Mergeblob1] :: Mergeblob1 libdep -> ThreeWay (Defns (BiMultimap Referent Name) (BiMultimap TypeReference Name))
[$sel:diff:Mergeblob1] :: Mergeblob1 libdep -> DefnsF2 (Map Name) CombinedDiffOp Referent TypeReference
[$sel:diffs:Mergeblob1] :: Mergeblob1 libdep -> TwoWay (DefnsF3 (Map Name) DiffOp Synhashed Referent TypeReference)
[$sel:hydratedDefns:Mergeblob1] :: Mergeblob1 libdep -> ThreeWay (DefnsF (Map Name) (TermReferenceId, (Term Symbol Ann, Type Symbol Ann)) (TypeReferenceId, Decl Symbol Ann))
[$sel:lcaDeclNameLookup:Mergeblob1] :: Mergeblob1 libdep -> PartialDeclNameLookup
[$sel:libdeps:Mergeblob1] :: Mergeblob1 libdep -> Map NameSegment libdep
[$sel:libdepsDiff:Mergeblob1] :: Mergeblob1 libdep -> Map NameSegment (LibdepDiffOp libdep)
[$sel:unconflicts:Mergeblob1] :: Mergeblob1 libdep -> DefnsF Unconflicts Referent TypeReference
makeMergeblob1 :: forall libdep. Eq libdep => Mergeblob0 libdep -> ThreeWay (DefnsF (Map Name) (TermReferenceId, (Term Symbol Ann, Type Symbol Ann)) (TypeReferenceId, Decl Symbol Ann)) -> Either (EitherWay IncoherentDeclReason) (Mergeblob1 libdep)

module Unison.Merge.Mergeblob2
data Mergeblob2 libdep
Mergeblob2 :: TwoWay (DefnsF (Map Name) TermReferenceId TypeReferenceId) -> TwoWay (DefnsF Set TermReference TypeReference) -> TwoWay DeclNameLookup -> ThreeWay (Defns (BiMultimap Referent Name) (BiMultimap TypeReference Name)) -> Bool -> TwoWay (DefnsF (Map Name) (TermReferenceId, (Term Symbol Ann, Type Symbol Ann)) (TypeReferenceId, Decl Symbol Ann)) -> Map NameSegment libdep -> TwoWay (DefnsF Set Name Name) -> DefnsF Unconflicts Referent TypeReference -> Mergeblob2 libdep
[$sel:conflicts:Mergeblob2] :: Mergeblob2 libdep -> TwoWay (DefnsF (Map Name) TermReferenceId TypeReferenceId)
[$sel:coreDependencies:Mergeblob2] :: Mergeblob2 libdep -> TwoWay (DefnsF Set TermReference TypeReference)
[$sel:declNameLookups:Mergeblob2] :: Mergeblob2 libdep -> TwoWay DeclNameLookup
[$sel:defns:Mergeblob2] :: Mergeblob2 libdep -> ThreeWay (Defns (BiMultimap Referent Name) (BiMultimap TypeReference Name))
[$sel:hasConflicts:Mergeblob2] :: Mergeblob2 libdep -> Bool
[$sel:hydratedDefns:Mergeblob2] :: Mergeblob2 libdep -> TwoWay (DefnsF (Map Name) (TermReferenceId, (Term Symbol Ann, Type Symbol Ann)) (TypeReferenceId, Decl Symbol Ann))
[$sel:libdeps:Mergeblob2] :: Mergeblob2 libdep -> Map NameSegment libdep
[$sel:soloUpdatesAndDeletes:Mergeblob2] :: Mergeblob2 libdep -> TwoWay (DefnsF Set Name Name)
[$sel:unconflicts:Mergeblob2] :: Mergeblob2 libdep -> DefnsF Unconflicts Referent TypeReference
data Mergeblob2Error
Mergeblob2Error'ConflictedAlias :: EitherWay (Defn (Name, Name) (Name, Name)) -> Mergeblob2Error
Mergeblob2Error'ConflictedBuiltin :: Defn Name Name -> Mergeblob2Error
makeMergeblob2 :: Mergeblob1 libdep -> Either Mergeblob2Error (Mergeblob2 libdep)

module Unison.Merge.Mergeblob3
data Mergeblob3
Mergeblob3 :: Names -> DefnsF (Map Name) Referent TypeReference -> DefnsF (Map Name) Referent TypeReference -> Map Name Text -> Pretty ColorText -> Mergeblob3
[$sel:libdeps:Mergeblob3] :: Mergeblob3 -> Names
[$sel:stageOne:Mergeblob3] :: Mergeblob3 -> DefnsF (Map Name) Referent TypeReference
[$sel:stageTwo:Mergeblob3] :: Mergeblob3 -> DefnsF (Map Name) Referent TypeReference
[$sel:uniqueTypeGuids:Mergeblob3] :: Mergeblob3 -> Map Name Text
[$sel:unparsedFile:Mergeblob3] :: Mergeblob3 -> Pretty ColorText
makeMergeblob3 :: Mergeblob2 libdep -> TwoWay (DefnsF Set TermReferenceId TypeReferenceId) -> Names -> TwoWay Text -> Mergeblob3

module Unison.Merge.Mergeblob4
data Mergeblob4
Mergeblob4 :: DefnsF Set TermReference TypeReference -> UnisonFile Symbol Ann -> Mergeblob4
[$sel:dependencies:Mergeblob4] :: Mergeblob4 -> DefnsF Set TermReference TypeReference
[$sel:file:Mergeblob4] :: Mergeblob4 -> UnisonFile Symbol Ann
makeMergeblob4 :: Mergeblob3 -> Either (Err Symbol) Mergeblob4

module Unison.Merge.Mergeblob5
data Mergeblob5
Mergeblob5 :: TypecheckedUnisonFile Symbol Ann -> Mergeblob5
[$sel:file:Mergeblob5] :: Mergeblob5 -> TypecheckedUnisonFile Symbol Ann
makeMergeblob5 :: Mergeblob4 -> TypeLookup Symbol Ann -> Either (Seq (Note Symbol Ann)) Mergeblob5

module Unison.Merge
data Mergeblob0 libdep
Mergeblob0 :: ThreeWay (Defns (BiMultimap Referent Name) (BiMultimap TypeReference Name)) -> ThreeWay (Map NameSegment libdep) -> ThreeWay (Nametree (DefnsF (Map NameSegment) Referent TypeReference)) -> Mergeblob0 libdep
[$sel:defns:Mergeblob0] :: Mergeblob0 libdep -> ThreeWay (Defns (BiMultimap Referent Name) (BiMultimap TypeReference Name))
[$sel:libdeps:Mergeblob0] :: Mergeblob0 libdep -> ThreeWay (Map NameSegment libdep)
[$sel:nametrees:Mergeblob0] :: Mergeblob0 libdep -> ThreeWay (Nametree (DefnsF (Map NameSegment) Referent TypeReference))
makeMergeblob0 :: ThreeWay (Nametree (DefnsF (Map NameSegment) Referent TypeReference)) -> ThreeWay (Map NameSegment libdep) -> Mergeblob0 libdep
data Mergeblob1 libdep
Mergeblob1 :: TwoWay (DefnsF (Map Name) TermReference TypeReference) -> TwoWay DeclNameLookup -> ThreeWay (Defns (BiMultimap Referent Name) (BiMultimap TypeReference Name)) -> DefnsF2 (Map Name) CombinedDiffOp Referent TypeReference -> TwoWay (DefnsF3 (Map Name) DiffOp Synhashed Referent TypeReference) -> ThreeWay (DefnsF (Map Name) (TermReferenceId, (Term Symbol Ann, Type Symbol Ann)) (TypeReferenceId, Decl Symbol Ann)) -> PartialDeclNameLookup -> Map NameSegment libdep -> Map NameSegment (LibdepDiffOp libdep) -> DefnsF Unconflicts Referent TypeReference -> Mergeblob1 libdep
[$sel:conflicts:Mergeblob1] :: Mergeblob1 libdep -> TwoWay (DefnsF (Map Name) TermReference TypeReference)
[$sel:declNameLookups:Mergeblob1] :: Mergeblob1 libdep -> TwoWay DeclNameLookup
[$sel:defns:Mergeblob1] :: Mergeblob1 libdep -> ThreeWay (Defns (BiMultimap Referent Name) (BiMultimap TypeReference Name))
[$sel:diff:Mergeblob1] :: Mergeblob1 libdep -> DefnsF2 (Map Name) CombinedDiffOp Referent TypeReference
[$sel:diffs:Mergeblob1] :: Mergeblob1 libdep -> TwoWay (DefnsF3 (Map Name) DiffOp Synhashed Referent TypeReference)
[$sel:hydratedDefns:Mergeblob1] :: Mergeblob1 libdep -> ThreeWay (DefnsF (Map Name) (TermReferenceId, (Term Symbol Ann, Type Symbol Ann)) (TypeReferenceId, Decl Symbol Ann))
[$sel:lcaDeclNameLookup:Mergeblob1] :: Mergeblob1 libdep -> PartialDeclNameLookup
[$sel:libdeps:Mergeblob1] :: Mergeblob1 libdep -> Map NameSegment libdep
[$sel:libdepsDiff:Mergeblob1] :: Mergeblob1 libdep -> Map NameSegment (LibdepDiffOp libdep)
[$sel:unconflicts:Mergeblob1] :: Mergeblob1 libdep -> DefnsF Unconflicts Referent TypeReference
makeMergeblob1 :: forall libdep. Eq libdep => Mergeblob0 libdep -> ThreeWay (DefnsF (Map Name) (TermReferenceId, (Term Symbol Ann, Type Symbol Ann)) (TypeReferenceId, Decl Symbol Ann)) -> Either (EitherWay IncoherentDeclReason) (Mergeblob1 libdep)
data Mergeblob2 libdep
Mergeblob2 :: TwoWay (DefnsF (Map Name) TermReferenceId TypeReferenceId) -> TwoWay (DefnsF Set TermReference TypeReference) -> TwoWay DeclNameLookup -> ThreeWay (Defns (BiMultimap Referent Name) (BiMultimap TypeReference Name)) -> Bool -> TwoWay (DefnsF (Map Name) (TermReferenceId, (Term Symbol Ann, Type Symbol Ann)) (TypeReferenceId, Decl Symbol Ann)) -> Map NameSegment libdep -> TwoWay (DefnsF Set Name Name) -> DefnsF Unconflicts Referent TypeReference -> Mergeblob2 libdep
[$sel:conflicts:Mergeblob2] :: Mergeblob2 libdep -> TwoWay (DefnsF (Map Name) TermReferenceId TypeReferenceId)
[$sel:coreDependencies:Mergeblob2] :: Mergeblob2 libdep -> TwoWay (DefnsF Set TermReference TypeReference)
[$sel:declNameLookups:Mergeblob2] :: Mergeblob2 libdep -> TwoWay DeclNameLookup
[$sel:defns:Mergeblob2] :: Mergeblob2 libdep -> ThreeWay (Defns (BiMultimap Referent Name) (BiMultimap TypeReference Name))
[$sel:hasConflicts:Mergeblob2] :: Mergeblob2 libdep -> Bool
[$sel:hydratedDefns:Mergeblob2] :: Mergeblob2 libdep -> TwoWay (DefnsF (Map Name) (TermReferenceId, (Term Symbol Ann, Type Symbol Ann)) (TypeReferenceId, Decl Symbol Ann))
[$sel:libdeps:Mergeblob2] :: Mergeblob2 libdep -> Map NameSegment libdep
[$sel:soloUpdatesAndDeletes:Mergeblob2] :: Mergeblob2 libdep -> TwoWay (DefnsF Set Name Name)
[$sel:unconflicts:Mergeblob2] :: Mergeblob2 libdep -> DefnsF Unconflicts Referent TypeReference
data Mergeblob2Error
Mergeblob2Error'ConflictedAlias :: EitherWay (Defn (Name, Name) (Name, Name)) -> Mergeblob2Error
Mergeblob2Error'ConflictedBuiltin :: Defn Name Name -> Mergeblob2Error
makeMergeblob2 :: Mergeblob1 libdep -> Either Mergeblob2Error (Mergeblob2 libdep)
data Mergeblob3
Mergeblob3 :: Names -> DefnsF (Map Name) Referent TypeReference -> DefnsF (Map Name) Referent TypeReference -> Map Name Text -> Pretty ColorText -> Mergeblob3
[$sel:libdeps:Mergeblob3] :: Mergeblob3 -> Names
[$sel:stageOne:Mergeblob3] :: Mergeblob3 -> DefnsF (Map Name) Referent TypeReference
[$sel:stageTwo:Mergeblob3] :: Mergeblob3 -> DefnsF (Map Name) Referent TypeReference
[$sel:uniqueTypeGuids:Mergeblob3] :: Mergeblob3 -> Map Name Text
[$sel:unparsedFile:Mergeblob3] :: Mergeblob3 -> Pretty ColorText
makeMergeblob3 :: Mergeblob2 libdep -> TwoWay (DefnsF Set TermReferenceId TypeReferenceId) -> Names -> TwoWay Text -> Mergeblob3
data Mergeblob4
Mergeblob4 :: DefnsF Set TermReference TypeReference -> UnisonFile Symbol Ann -> Mergeblob4
[$sel:dependencies:Mergeblob4] :: Mergeblob4 -> DefnsF Set TermReference TypeReference
[$sel:file:Mergeblob4] :: Mergeblob4 -> UnisonFile Symbol Ann
makeMergeblob4 :: Mergeblob3 -> Either (Err Symbol) Mergeblob4
data Mergeblob5
Mergeblob5 :: TypecheckedUnisonFile Symbol Ann -> Mergeblob5
[$sel:file:Mergeblob5] :: Mergeblob5 -> TypecheckedUnisonFile Symbol Ann
makeMergeblob5 :: Mergeblob4 -> TypeLookup Symbol Ann -> Either (Seq (Note Symbol Ann)) Mergeblob5

-- | Like a <tt>DeclNameLookup</tt>, but "partial" / more lenient - because
--   we don't require the LCA of a merge to have a full
--   <tt>DeclNameLookup</tt>.
data PartialDeclNameLookup
PartialDeclNameLookup :: !Map Name Name -> !Map Name [Maybe Name] -> PartialDeclNameLookup
[$sel:constructorToDecl:PartialDeclNameLookup] :: PartialDeclNameLookup -> !Map Name Name
[$sel:declToConstructors:PartialDeclNameLookup] :: PartialDeclNameLookup -> !Map Name [Maybe Name]
data IncoherentDeclReason

-- | A second naming of a constructor was discovered underneath a decl's
--   name, e.g.
--   
--   Foo#Foo Foo.Bar0 Foo.Some.Other.Name.For.Bar0
IncoherentDeclReason'ConstructorAlias :: !Name -> !Name -> !Name -> IncoherentDeclReason
IncoherentDeclReason'MissingConstructorName :: !Name -> IncoherentDeclReason

-- | A second naming of a decl was discovered underneath its name, e.g.
--   
--   Foo#Foo Foo.Bar#Foo
IncoherentDeclReason'NestedDeclAlias :: !Name -> !Name -> IncoherentDeclReason
IncoherentDeclReason'StrayConstructor :: !TypeReferenceId -> !Name -> IncoherentDeclReason
checkDeclCoherency :: HasCallStack => Nametree (DefnsF (Map NameSegment) Referent TypeReference) -> Map TypeReferenceId Int -> Either IncoherentDeclReason DeclNameLookup

-- | A lenient variant of <a>checkDeclCoherency</a> - so lenient it can't
--   even fail! It returns partial decl name lookup, which doesn't require
--   a name for every constructor, and allows a constructor with a nameless
--   decl.
--   
--   This function exists merely to extract a best-effort name mapping for
--   the LCA of a merge. We require Alice and Bob to have coherent decls,
--   but their LCA is out of the user's control and may have incoherent
--   decls, and whether or not it does, we still need to compute *some*
--   syntactic hash for its decls.
lenientCheckDeclCoherency :: Nametree (DefnsF (Map NameSegment) Referent TypeReference) -> Map TypeReferenceId Int -> PartialDeclNameLookup
data IncoherentDeclReasons
IncoherentDeclReasons :: ![(Name, Name, Name)] -> ![Name] -> ![(Name, Name)] -> ![(TypeReferenceId, Name)] -> IncoherentDeclReasons
[$sel:constructorAliases:IncoherentDeclReasons] :: IncoherentDeclReasons -> ![(Name, Name, Name)]
[$sel:missingConstructorNames:IncoherentDeclReasons] :: IncoherentDeclReasons -> ![Name]
[$sel:nestedDeclAliases:IncoherentDeclReasons] :: IncoherentDeclReasons -> ![(Name, Name)]
[$sel:strayConstructors:IncoherentDeclReasons] :: IncoherentDeclReasons -> ![(TypeReferenceId, Name)]

-- | Like <a>checkDeclCoherency</a>, but returns info about all of the
--   incoherent decls found, not just the first.
checkAllDeclCoherency :: forall m. Monad m => (TypeReferenceId -> m Int) -> Nametree (DefnsF (Map NameSegment) Referent TypeReference) -> m (Either IncoherentDeclReasons DeclNameLookup)

-- | The combined result of two diffs on the same thing.
data CombinedDiffOp a
CombinedDiffOp'Add :: !EitherWayI a -> CombinedDiffOp a
CombinedDiffOp'Delete :: !EitherWayI a -> CombinedDiffOp a
CombinedDiffOp'Update :: !EitherWayI (Updated a) -> CombinedDiffOp a
CombinedDiffOp'Conflict :: !TwoWay a -> CombinedDiffOp a

-- | A diff operation is one of:
--   
--   <ul>
--   <li>An add (where nothing was)</li>
--   <li>A delete (of the thing that was)</li>
--   <li>An update (from old to new)</li>
--   </ul>
data DiffOp a
DiffOp'Add :: !a -> DiffOp a
DiffOp'Delete :: !a -> DiffOp a
DiffOp'Update :: !Updated a -> DiffOp a

-- | Alice exclusive-or Bob?
data EitherWay a
Alice :: a -> EitherWay a
Bob :: a -> EitherWay a

-- | Alice inclusive-or Bob?
data EitherWayI a
OnlyAlice :: a -> EitherWayI a
OnlyBob :: a -> EitherWayI a
AliceAndBob :: a -> EitherWayI a
data LibdepDiffOp a
AddLibdep :: !a -> LibdepDiffOp a
AddBothLibdeps :: !a -> !a -> LibdepDiffOp a
DeleteLibdep :: LibdepDiffOp a

-- | A small utility type that represents a syntactic-hashed thing.
--   
--   The <a>Eq</a> and <a>Ord</a> instances only compares syntactic hashes.
data Synhashed a
Synhashed :: !Hash -> !a -> Synhashed a
[$sel:hash:Synhashed] :: Synhashed a -> !Hash
[$sel:value:Synhashed] :: Synhashed a -> !a
data ThreeWay a
ThreeWay :: !a -> !a -> !a -> ThreeWay a
[$sel:lca:ThreeWay] :: ThreeWay a -> !a
[$sel:alice:ThreeWay] :: ThreeWay a -> !a
[$sel:bob:ThreeWay] :: ThreeWay a -> !a
data TwoOrThreeWay a
TwoOrThreeWay :: Maybe a -> a -> a -> TwoOrThreeWay a
[$sel:lca:TwoOrThreeWay] :: TwoOrThreeWay a -> Maybe a
[$sel:alice:TwoOrThreeWay] :: TwoOrThreeWay a -> a
[$sel:bob:TwoOrThreeWay] :: TwoOrThreeWay a -> a
data TwoWay a
TwoWay :: a -> a -> TwoWay a
[$sel:alice:TwoWay] :: TwoWay a -> a
[$sel:bob:TwoWay] :: TwoWay a -> a

-- | "Two-way inclusive".
data TwoWayI a
TwoWayI :: a -> a -> a -> TwoWayI a
[$sel:alice:TwoWayI] :: TwoWayI a -> a
[$sel:bob:TwoWayI] :: TwoWayI a -> a
[$sel:both:TwoWayI] :: TwoWayI a -> a
data Unconflicts v
Unconflicts :: !TwoWayI (Map Name v) -> !TwoWayI (Map Name v) -> !TwoWayI (Map Name v) -> Unconflicts v
[$sel:adds:Unconflicts] :: Unconflicts v -> !TwoWayI (Map Name v)
[$sel:deletes:Unconflicts] :: Unconflicts v -> !TwoWayI (Map Name v)
[$sel:updates:Unconflicts] :: Unconflicts v -> !TwoWayI (Map Name v)

-- | An updated thing.
data Updated a
Updated :: a -> a -> Updated a
[$sel:old:Updated] :: Updated a -> a
[$sel:new:Updated] :: Updated a -> a
