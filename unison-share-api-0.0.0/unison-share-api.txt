-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


@package unison-share-api
@version 0.0.0

module Unison.Server.Doc.Markdown.Types

-- | Custom type for converting Docs into Markdown. I tried using the
--   existing cmark-gfm library for this, but we have too many edge-cases
--   for it to work well.
data Markdown

-- | E.g. '---'
ThematicBreak :: Markdown
Paragraph :: [Markdown] -> Markdown
BlockQuote :: [Markdown] -> Markdown
CodeBlock :: Text -> Text -> Markdown
Heading :: Int -> [Markdown] -> Markdown
OrderedList :: Int -> [[Markdown]] -> Markdown
UnorderedList :: [[Markdown]] -> Markdown
Txt :: Text -> Markdown
Linebreak :: Markdown
InlineCode :: Text -> Markdown
Italics :: [Markdown] -> Markdown
Strong :: [Markdown] -> Markdown
Strikethrough :: [Markdown] -> Markdown
Link :: [Markdown] -> Text -> Markdown
Image :: [Markdown] -> Text -> Markdown
Table :: Maybe [[Markdown]] -> [[[Markdown]]] -> Markdown

-- | Render the markdown datatype to markdown text
toText :: [Markdown] -> Text
instance GHC.Show.Show Unison.Server.Doc.Markdown.Types.Markdown

module Unison.Server.Orphans
instance Data.Aeson.Types.ToJSON.ToJSON U.Codebase.HashTags.CausalHash
instance Data.Aeson.Types.FromJSON.FromJSON U.Codebase.HashTags.CausalHash
instance Data.Binary.Class.Binary Unison.Hash.Hash
instance Data.Binary.Class.Binary U.Codebase.HashTags.CausalHash
instance Web.Internal.HttpApiData.ToHttpApiData Unison.Codebase.ShortCausalHash.ShortCausalHash
instance (Data.OpenApi.Internal.Schema.ToSchema b, Data.OpenApi.Internal.Schema.ToSchema a) => Data.OpenApi.Internal.Schema.ToSchema (Unison.Codebase.Editor.DisplayObject.DisplayObject b a)
instance Data.OpenApi.Internal.ParamSchema.ToParamSchema Unison.Codebase.ShortCausalHash.ShortCausalHash
instance Web.Internal.HttpApiData.FromHttpApiData Unison.Util.Pretty.Width
instance Web.Internal.HttpApiData.ToHttpApiData Unison.Util.Pretty.Width
instance Data.OpenApi.Internal.ParamSchema.ToParamSchema Unison.Util.Pretty.Width
instance Data.OpenApi.Internal.Schema.ToSchema Unison.NameSegment.Internal.NameSegment
instance Data.OpenApi.Internal.Schema.ToSchema n => Data.OpenApi.Internal.Schema.ToSchema (Unison.HashQualified.HashQualified n)
instance Data.OpenApi.Internal.Schema.ToSchema n => Data.OpenApi.Internal.Schema.ToSchema (Unison.HashQualifiedPrime.HashQualified n)
instance Data.Aeson.Types.ToJSON.ToJSON Unison.Core.Project.ProjectName
instance Data.Aeson.Types.ToJSON.ToJSON Unison.Core.Project.ProjectBranchName
instance Data.Aeson.Types.ToJSON.ToJSON Unison.Hash.Hash
instance Data.Aeson.Types.FromJSON.FromJSON Unison.Hash.Hash
instance Data.Aeson.Types.ToJSON.ToJSON Unison.ShortHash.ShortHash
instance Data.Aeson.Types.ToJSON.ToJSONKey Unison.ShortHash.ShortHash
instance Data.Aeson.Types.FromJSON.FromJSON Unison.ShortHash.ShortHash
instance Data.Aeson.Types.FromJSON.FromJSONKey Unison.ShortHash.ShortHash
instance Web.Internal.HttpApiData.FromHttpApiData Unison.Codebase.ShortCausalHash.ShortCausalHash
instance Web.Internal.HttpApiData.ToHttpApiData Unison.ShortHash.ShortHash
instance Web.Internal.HttpApiData.FromHttpApiData Unison.ShortHash.ShortHash
instance Data.OpenApi.Internal.Schema.ToSchema Unison.ShortHash.ShortHash
instance Web.Internal.HttpApiData.ToHttpApiData U.Codebase.Reference.Reference
instance Web.Internal.HttpApiData.ToHttpApiData Unison.Referent.Referent
instance Web.Internal.HttpApiData.FromHttpApiData U.Codebase.Reference.Reference
instance Web.Internal.HttpApiData.FromHttpApiData Unison.Referent.Referent
instance Data.OpenApi.Internal.Schema.ToSchema Data.OpenApi.Internal.Reference
instance (Data.Aeson.Types.ToJSON.ToJSON b, Data.Aeson.Types.ToJSON.ToJSON a) => Data.Aeson.Types.ToJSON.ToJSON (Unison.Codebase.Editor.DisplayObject.DisplayObject b a)
instance (Data.Aeson.Types.FromJSON.FromJSON a, Data.Aeson.Types.FromJSON.FromJSON b) => Data.Aeson.Types.FromJSON.FromJSON (Unison.Codebase.Editor.DisplayObject.DisplayObject b a)
instance Data.Aeson.Types.ToJSON.ToJSON Unison.Name.Internal.Name
instance Data.Aeson.Types.ToJSON.ToJSONKey Unison.Name.Internal.Name
instance Data.OpenApi.Internal.Schema.ToSchema Unison.Name.Internal.Name
instance Data.Aeson.Types.ToJSON.ToJSON Unison.NameSegment.Internal.NameSegment
instance Data.Aeson.Types.ToJSON.ToJSONKey Unison.NameSegment.Internal.NameSegment
instance Data.OpenApi.Internal.ParamSchema.ToParamSchema Unison.ShortHash.ShortHash
instance Data.OpenApi.Internal.ParamSchema.ToParamSchema U.Codebase.Reference.Reference
instance Data.OpenApi.Internal.ParamSchema.ToParamSchema Unison.Referent.Referent
instance Data.OpenApi.Internal.ParamSchema.ToParamSchema Unison.Name.Internal.Name
instance Data.OpenApi.Internal.ParamSchema.ToParamSchema Unison.Codebase.Path.Path
instance Data.OpenApi.Internal.ParamSchema.ToParamSchema Unison.Codebase.Path.Relative
instance Servant.Docs.Internal.ToParam (Servant.API.QueryParam.QueryParam "name" Unison.Name.Internal.Name)
instance Web.Internal.HttpApiData.FromHttpApiData Unison.Name.Internal.Name
instance Data.Aeson.Types.ToJSON.ToJSON Unison.ConstructorType.ConstructorType
instance Web.Internal.HttpApiData.FromHttpApiData Unison.Codebase.Path.Relative
instance Web.Internal.HttpApiData.ToHttpApiData Unison.Codebase.Path.Relative
instance Web.Internal.HttpApiData.FromHttpApiData Unison.Codebase.Path.Absolute
instance Web.Internal.HttpApiData.ToHttpApiData Unison.Codebase.Path.Absolute
instance Web.Internal.HttpApiData.FromHttpApiData Unison.Codebase.Path.Path'
instance Web.Internal.HttpApiData.ToHttpApiData Unison.Codebase.Path.Path'
instance Web.Internal.HttpApiData.FromHttpApiData Unison.Codebase.Path.Path
instance Servant.Docs.Internal.ToCapture (Servant.API.Capture.Capture "hash" Unison.ShortHash.ShortHash)
instance Servant.Docs.Internal.ToCapture (Servant.API.Capture.Capture "hash" U.Codebase.Reference.Reference)
instance Servant.Docs.Internal.ToCapture (Servant.API.Capture.Capture "hash" Unison.Referent.Referent)
instance Servant.Docs.Internal.ToCapture (Servant.API.Capture.Capture "fqn" Unison.Name.Internal.Name)
instance Servant.Docs.Internal.ToCapture (Servant.API.Capture.Capture "namespace" Unison.Codebase.Path.Path)
instance Data.Aeson.Types.ToJSON.ToJSON Unison.Codebase.Path.Path
instance Data.Aeson.Types.ToJSON.ToJSON Unison.Codebase.Path.Absolute
instance Data.OpenApi.Internal.Schema.ToSchema Unison.Codebase.Path.Path
instance Data.OpenApi.Internal.Schema.ToSchema Unison.Codebase.Path.Absolute
instance Data.Aeson.Types.ToJSON.ToJSON (Unison.HashQualified.HashQualified Unison.Name.Internal.Name)
instance Data.Aeson.Types.ToJSON.ToJSON (Unison.HashQualified.HashQualified Unison.NameSegment.Internal.NameSegment)
instance Data.Aeson.Types.ToJSON.ToJSON (Unison.HashQualifiedPrime.HashQualified Unison.Name.Internal.Name)
instance Data.Aeson.Types.ToJSON.ToJSON (Unison.HashQualifiedPrime.HashQualified Unison.NameSegment.Internal.NameSegment)
instance Data.Aeson.Types.FromJSON.FromJSON (Unison.HashQualifiedPrime.HashQualified Unison.Name.Internal.Name)
instance Data.Aeson.Types.FromJSON.FromJSON (Unison.HashQualified.HashQualified Unison.Name.Internal.Name)
instance Data.Aeson.Types.FromJSON.FromJSON (Unison.HashQualifiedPrime.HashQualified Unison.NameSegment.Internal.NameSegment)
instance Data.Aeson.Types.FromJSON.FromJSON (Unison.HashQualified.HashQualified Unison.NameSegment.Internal.NameSegment)
instance Web.Internal.HttpApiData.FromHttpApiData (Unison.HashQualified.HashQualified Unison.Name.Internal.Name)
instance Web.Internal.HttpApiData.FromHttpApiData (Unison.HashQualifiedPrime.HashQualified Unison.Name.Internal.Name)
instance Data.OpenApi.Internal.ParamSchema.ToParamSchema (Unison.HashQualified.HashQualified n)
instance Data.OpenApi.Internal.ParamSchema.ToParamSchema (Unison.HashQualifiedPrime.HashQualified n)
instance Web.Internal.HttpApiData.ToHttpApiData Unison.Name.Internal.Name
instance Web.Internal.HttpApiData.FromHttpApiData Unison.Core.Project.ProjectName
instance Data.OpenApi.Internal.ParamSchema.ToParamSchema Unison.Core.Project.ProjectName
instance Servant.Docs.Internal.ToCapture (Servant.API.Capture.Capture "project-name" Unison.Core.Project.ProjectName)
instance Data.OpenApi.Internal.Schema.ToSchema Unison.Core.Project.ProjectName
instance Web.Internal.HttpApiData.FromHttpApiData Unison.Core.Project.ProjectBranchName
instance Data.OpenApi.Internal.Schema.ToSchema Unison.Core.Project.ProjectBranchName
instance Data.OpenApi.Internal.ParamSchema.ToParamSchema Unison.Core.Project.ProjectBranchName
instance Servant.Docs.Internal.ToCapture (Servant.API.Capture.Capture "branch-name" Unison.Core.Project.ProjectBranchName)

module Unison.Server.SearchResult
data SearchResult
Tp :: TypeResult -> SearchResult
Tm :: TermResult -> SearchResult
data TermResult
TermResult :: HashQualified Name -> Referent -> Set (HashQualified Name) -> TermResult
[$sel:termName:TermResult] :: TermResult -> HashQualified Name
[$sel:referent:TermResult] :: TermResult -> Referent
[$sel:termAliases:TermResult] :: TermResult -> Set (HashQualified Name)
data TypeResult
TypeResult :: HashQualified Name -> Reference -> Set (HashQualified Name) -> TypeResult
[$sel:typeName:TypeResult] :: TypeResult -> HashQualified Name
[$sel:reference:TypeResult] :: TypeResult -> Reference
[$sel:typeAliases:TypeResult] :: TypeResult -> Set (HashQualified Name)
pattern Tm' :: HashQualified Name -> Referent -> Set (HashQualified Name) -> SearchResult
pattern Tp' :: HashQualified Name -> Reference -> Set (HashQualified Name) -> SearchResult

-- | Construct a term search result from a primary name, referent, and set
--   of aliases.
termResult :: HashQualified Name -> Referent -> Set (HashQualified Name) -> SearchResult
termSearchResult :: Names -> Name -> Referent -> SearchResult

-- | Construct a type search result from a primary name, reference, and set
--   of aliases.
typeResult :: HashQualified Name -> Reference -> Set (HashQualified Name) -> SearchResult
typeSearchResult :: Names -> Name -> Reference -> SearchResult
name :: SearchResult -> HashQualified Name
aliases :: SearchResult -> Set (HashQualified Name)

-- | TypeResults yield a <a>Ref</a>
toReferent :: SearchResult -> Referent
truncateAliases :: Int -> SearchResult -> SearchResult

-- | You may want to sort this list differently afterward.
fromNames :: Names -> [SearchResult]
_fromNames :: Names -> [SearchResult]

-- | Sort a list of search results by name. If names are equal, fall back
--   to comparing by reference (putting types before terms).
compareByName :: SearchResult -> SearchResult -> Ordering
instance GHC.Show.Show Unison.Server.SearchResult.TermResult
instance GHC.Classes.Ord Unison.Server.SearchResult.TermResult
instance GHC.Classes.Eq Unison.Server.SearchResult.TermResult
instance GHC.Show.Show Unison.Server.SearchResult.TypeResult
instance GHC.Classes.Ord Unison.Server.SearchResult.TypeResult
instance GHC.Classes.Eq Unison.Server.SearchResult.TypeResult
instance GHC.Show.Show Unison.Server.SearchResult.SearchResult
instance GHC.Classes.Ord Unison.Server.SearchResult.SearchResult
instance GHC.Classes.Eq Unison.Server.SearchResult.SearchResult

module Unison.Server.QueryResult
data QueryResult
QueryResult :: [HashQualified Name] -> [SearchResult] -> QueryResult
[$sel:misses:QueryResult] :: QueryResult -> [HashQualified Name]
[$sel:hits:QueryResult] :: QueryResult -> [SearchResult]

module Unison.Server.NameSearch

-- | A <tt>Search r</tt> is a small bag of functions that is used to power
--   a search for <tt>r</tt>s.
--   
--   There are currently two implementations of this interface:
--   
--   <ul>
--   <li><a>FromNames</a> which builds a name search from a <tt>Names</tt>
--   object</li>
--   <li>'NameSearch.Sqlite which builds a name search that uses a sqlite
--   name lookup index.</li>
--   </ul>
--   
--   You can use the individual methods of a name search or can use
--   <a>applySearch</a>.
data Search m r
Search :: (r -> m (Set (HashQualified Name))) -> (SearchType -> HashQualified Name -> m (Set r)) -> (HashQualified Name -> r -> Set (HashQualified Name) -> m SearchResult) -> (Name -> r -> HashQualified Name -> Bool) -> Search m r
[$sel:lookupNames:Search] :: Search m r -> r -> m (Set (HashQualified Name))
[$sel:lookupRelativeHQRefs':Search] :: Search m r -> SearchType -> HashQualified Name -> m (Set r)
[$sel:makeResult:Search] :: Search m r -> HashQualified Name -> r -> Set (HashQualified Name) -> m SearchResult
[$sel:matchesNamedRef:Search] :: Search m r -> Name -> r -> HashQualified Name -> Bool
data NameSearch m
NameSearch :: Search m Reference -> Search m Referent -> NameSearch m
[$sel:typeSearch:NameSearch] :: NameSearch m -> Search m Reference
[$sel:termSearch:NameSearch] :: NameSearch m -> Search m Referent
hoistSearch :: (forall x. m x -> n x) -> Search m r -> Search n r
hoistNameSearch :: (forall x. m x -> n x) -> NameSearch m -> NameSearch n

-- | Interpret a <a>Search</a> as a function from name to search results.
applySearch :: (Show r, Monad m) => Search m r -> SearchType -> HashQualified Name -> m [SearchResult]

-- | Whether to search for exact matches or to find definitions by a suffix
--   of their name.
data () => SearchType
IncludeSuffixes :: SearchType
ExactName :: SearchType

module Unison.Server.NameSearch.Sqlite

-- | Resolves a shorthash into any possible matches.
resolveShortHash :: Codebase m v a -> ShortHash -> Transaction (Set LabeledDependency)

-- | Look up types in the codebase by short hash, and include builtins.
typeReferencesByShortHash :: ShortHash -> Transaction (Set Reference)

-- | Look up terms in the codebase by short hash, and include builtins.
termReferentsByShortHash :: Codebase m v a -> ShortHash -> Transaction (Set Referent)
data NameSearch m
NameSearch :: Search m Reference -> Search m Referent -> NameSearch m
[$sel:typeSearch:NameSearch] :: NameSearch m -> Search m Reference
[$sel:termSearch:NameSearch] :: NameSearch m -> Search m Referent
nameSearchForPerspective :: Codebase m v a -> NamesPerspective -> NameSearch Transaction

module Unison.Server.NameSearch.FromNames

-- | Make a type search, given a short hash length and names to search in.
makeTypeSearch :: Applicative m => Int -> Names -> Search m Reference

-- | Make a term search, given a short hash length and names to search in.
makeTermSearch :: Applicative m => Int -> Names -> Search m Referent
makeNameSearch :: Applicative m => Int -> Names -> NameSearch m

module Unison.Server.SearchResultPrime
data SearchResult' v a
Tm' :: TermResult' v a -> SearchResult' v a
Tp' :: TypeResult' v a -> SearchResult' v a
data TermResult' v a
TermResult' :: HashQualified Name -> Maybe (Type v a) -> Referent -> Set (HashQualified Name) -> TermResult' v a
data TypeResult' v a
TypeResult' :: HashQualified Name -> DisplayObject () (Decl v a) -> Reference -> Set (HashQualified Name) -> TypeResult' v a
pattern Tm :: HashQualified Name -> Maybe (Type v a) -> Referent -> Set (HashQualified Name) -> SearchResult' v a
pattern Tp :: HashQualified Name -> DisplayObject () (Decl v a) -> Reference -> Set (HashQualified Name) -> SearchResult' v a
tmReferent :: SearchResult' v a -> Maybe Referent
tpReference :: SearchResult' v a -> Maybe Reference
foldResult' :: (TermResult' v a -> b) -> (TypeResult' v a -> b) -> SearchResult' v a -> b
labeledDependencies :: Ord v => SearchResult' v a -> Set LabeledDependency
instance GHC.Show.Show v => GHC.Show.Show (Unison.Server.SearchResultPrime.TermResult' v a)
instance U.Core.ABT.Var.Var v => GHC.Classes.Eq (Unison.Server.SearchResultPrime.TermResult' v a)
instance (GHC.Show.Show a, GHC.Show.Show v) => GHC.Show.Show (Unison.Server.SearchResultPrime.TypeResult' v a)
instance (U.Core.ABT.Var.Var v, GHC.Classes.Eq a) => GHC.Classes.Eq (Unison.Server.SearchResultPrime.TypeResult' v a)
instance (GHC.Show.Show v, GHC.Show.Show a) => GHC.Show.Show (Unison.Server.SearchResultPrime.SearchResult' v a)
instance (U.Core.ABT.Var.Var v, GHC.Classes.Eq a) => GHC.Classes.Eq (Unison.Server.SearchResultPrime.SearchResult' v a)


-- | Duplicate of the Unison.Util.SyntaxText module, but we expect these to
--   evolve separately. This is the version which is outward facing to the
--   server frontend.
module Unison.Server.Syntax
type SyntaxText = AnnotatedText Element
type SyntaxSegment = Segment Element
convertElement :: Element Reference -> Element
type UnisonHash = Text
type HashQualifiedName = Text

-- | The elements of the Unison grammar, for syntax highlighting purposes
data Element
NumericLiteral :: Element
TextLiteral :: Element
BytesLiteral :: Element
CharLiteral :: Element
BooleanLiteral :: Element
Blank :: Element
Var :: Element
TypeReference :: UnisonHash -> Element
DataConstructorReference :: UnisonHash -> Element
AbilityConstructorReference :: UnisonHash -> Element
TermReference :: UnisonHash -> Element
Op :: SeqOp -> Element

-- | Constructor Are these even used? | Request
AbilityBraces :: Element
ControlKeyword :: Element
TypeOperator :: Element
BindingEquals :: Element
TypeAscriptionColon :: Element
DataTypeKeyword :: Element
DataTypeParams :: Element
Unit :: Element
DataTypeModifier :: Element
UseKeyword :: Element
UsePrefix :: Element
UseSuffix :: Element
HashQualifier :: HashQualifiedName -> Element
DelayForceChar :: Element
DelimiterChar :: Element
Parenthesis :: Element
LinkKeyword :: Element
DocDelimiter :: Element
DocKeyword :: Element
syntax :: Element -> SyntaxText -> SyntaxText
firstReference :: SyntaxText -> Maybe UnisonHash
reference :: SyntaxSegment -> Maybe UnisonHash

-- | Convert a <a>SyntaxText</a> to a <a>Value</a>, ignoring syntax markup
toPlain :: SyntaxText -> String
toPlainText :: SyntaxText -> Text
toHtml :: SyntaxText -> Html ()
nameToHtml :: Name -> Html ()
segmentToHtml :: SyntaxSegment -> Html ()
elementToClassName :: Element -> Text
instance GHC.Generics.Generic Unison.Server.Syntax.Element
instance GHC.Show.Show Unison.Server.Syntax.Element
instance GHC.Classes.Ord Unison.Server.Syntax.Element
instance GHC.Classes.Eq Unison.Server.Syntax.Element
instance Data.OpenApi.Internal.Schema.ToSchema a => Data.OpenApi.Internal.Schema.ToSchema (Unison.Util.AnnotatedText.Segment a)
instance Data.OpenApi.Internal.Schema.ToSchema Unison.Pattern.SeqOp
instance Data.Aeson.Types.ToJSON.ToJSON (Unison.Util.AnnotatedText.AnnotatedText Unison.Server.Syntax.Element)
instance Data.Aeson.Types.FromJSON.FromJSON (Unison.Util.AnnotatedText.AnnotatedText Unison.Server.Syntax.Element)
instance Data.OpenApi.Internal.Schema.ToSchema Unison.Server.Syntax.SyntaxText
instance Data.OpenApi.Internal.Schema.ToSchema Unison.Server.Syntax.Element
instance Data.Aeson.Types.ToJSON.ToJSON Unison.Server.Syntax.Element
instance Data.Aeson.Types.FromJSON.FromJSON Unison.Server.Syntax.Element
instance Data.Aeson.Types.ToJSON.ToJSON a => Data.Aeson.Types.ToJSON.ToJSON (Unison.Util.AnnotatedText.Segment a)
instance Data.Aeson.Types.FromJSON.FromJSON a => Data.Aeson.Types.FromJSON.FromJSON (Unison.Util.AnnotatedText.Segment a)
instance Data.Aeson.Types.ToJSON.ToJSON Unison.Pattern.SeqOp
instance Data.Aeson.Types.FromJSON.FromJSON Unison.Pattern.SeqOp
instance Data.OpenApi.Internal.Schema.ToSchema r => Data.OpenApi.Internal.Schema.ToSchema (Data.Sequence.Internal.Seq r)

module Unison.Server.Doc
type Nat = Word64
type SSyntaxText = SyntaxText' Reference

-- | A doc rendered down to SyntaxText.
type Doc = DocG RenderedSpecialForm

-- | A doc which has been evaluated and includes all information necessary
--   to be rendered.
type EvaluatedDoc v = DocG (EvaluatedSpecialForm v)
type SrcRefs = Ref (UnisonHash, DisplayObject SyntaxText Src)

-- | A doc parameterized by its special forms.
data DocG specialForm
Word :: Text -> DocG specialForm
Code :: DocG specialForm -> DocG specialForm
CodeBlock :: Text -> DocG specialForm -> DocG specialForm
Bold :: DocG specialForm -> DocG specialForm
Italic :: DocG specialForm -> DocG specialForm
Strikethrough :: DocG specialForm -> DocG specialForm
Style :: Text -> DocG specialForm -> DocG specialForm
Anchor :: Text -> DocG specialForm -> DocG specialForm
Blockquote :: DocG specialForm -> DocG specialForm
Blankline :: DocG specialForm
Linebreak :: DocG specialForm
SectionBreak :: DocG specialForm
Tooltip :: DocG specialForm -> DocG specialForm -> DocG specialForm
Aside :: DocG specialForm -> DocG specialForm
Callout :: Maybe (DocG specialForm) -> DocG specialForm -> DocG specialForm
Table :: [[DocG specialForm]] -> DocG specialForm
Folded :: Bool -> DocG specialForm -> DocG specialForm -> DocG specialForm
Paragraph :: [DocG specialForm] -> DocG specialForm
BulletedList :: [DocG specialForm] -> DocG specialForm
NumberedList :: Nat -> [DocG specialForm] -> DocG specialForm
Section :: DocG specialForm -> [DocG specialForm] -> DocG specialForm
NamedLink :: DocG specialForm -> DocG specialForm -> DocG specialForm
Image :: DocG specialForm -> DocG specialForm -> Maybe (DocG specialForm) -> DocG specialForm
Special :: specialForm -> DocG specialForm
Join :: [DocG specialForm] -> DocG specialForm
UntitledSection :: [DocG specialForm] -> DocG specialForm
Column :: [DocG specialForm] -> DocG specialForm
Group :: DocG specialForm -> DocG specialForm
type UnisonHash = Text
data Ref a
Term :: a -> Ref a
Type :: a -> Ref a
data MediaSource
MediaSource :: Text -> Maybe Text -> MediaSource
[$sel:mediaSourceUrl:MediaSource] :: MediaSource -> Text
[$sel:mediaSourceMimeType:MediaSource] :: MediaSource -> Maybe Text
data RenderedSpecialForm
Source :: [SrcRefs] -> RenderedSpecialForm
FoldedSource :: [SrcRefs] -> RenderedSpecialForm
Example :: SyntaxText -> RenderedSpecialForm
ExampleBlock :: SyntaxText -> RenderedSpecialForm
Link :: SyntaxText -> RenderedSpecialForm
Signature :: [SyntaxText] -> RenderedSpecialForm
SignatureInline :: SyntaxText -> RenderedSpecialForm
Eval :: SyntaxText -> SyntaxText -> RenderedSpecialForm
EvalInline :: SyntaxText -> SyntaxText -> RenderedSpecialForm
Embed :: SyntaxText -> RenderedSpecialForm
EmbedInline :: SyntaxText -> RenderedSpecialForm
Video :: [MediaSource] -> Map Text Text -> RenderedSpecialForm
FrontMatter :: Map Text [Text] -> RenderedSpecialForm
LaTeXInline :: Text -> RenderedSpecialForm
Svg :: Text -> RenderedSpecialForm
RenderError :: RenderError SyntaxText -> RenderedSpecialForm
data EvaluatedSpecialForm v
ESource :: [EvaluatedSrc v] -> EvaluatedSpecialForm v
EFoldedSource :: [EvaluatedSrc v] -> EvaluatedSpecialForm v
EExample :: Term v () -> EvaluatedSpecialForm v
EExampleBlock :: Term v () -> EvaluatedSpecialForm v
ELink :: Either (Term v ()) LabeledDependency -> EvaluatedSpecialForm v
ESignature :: [(Referent, Type v ())] -> EvaluatedSpecialForm v
ESignatureInline :: (Referent, Type v ()) -> EvaluatedSpecialForm v
EEval :: Term v () -> Maybe (Term v ()) -> EvaluatedSpecialForm v
EEvalInline :: Term v () -> Maybe (Term v ()) -> EvaluatedSpecialForm v
EEmbed :: Term v () -> EvaluatedSpecialForm v
EEmbedInline :: Term v () -> EvaluatedSpecialForm v
EVideo :: [MediaSource] -> Map Text Text -> EvaluatedSpecialForm v
EFrontMatter :: Map Text [Text] -> EvaluatedSpecialForm v
ELaTeXInline :: Text -> EvaluatedSpecialForm v
ESvg :: Text -> EvaluatedSpecialForm v
ERenderError :: RenderError (Term v ()) -> EvaluatedSpecialForm v
data Src
Src :: SyntaxText -> SyntaxText -> Src

-- | Evaluate the doc, then render it.
evalAndRenderDoc :: forall v m. (Var v, Monad m) => PrettyPrintEnvDecl -> (Reference -> m (Maybe (Term v ()))) -> (Referent -> m (Maybe (Type v ()))) -> (Term v () -> m (Maybe (Term v ()))) -> (Reference -> m (Maybe (Decl v ()))) -> Term v () -> m Doc

-- | Renders the given doc, which must have been evaluated using
--   <a>evalDoc</a>
renderDoc :: forall v. Var v => PrettyPrintEnvDecl -> EvaluatedDoc v -> Doc

-- | Evaluates the given doc, expanding transclusions, expressions, etc.
evalDoc :: forall v m. (Var v, Monad m) => (Reference -> m (Maybe (Term v ()))) -> (Referent -> m (Maybe (Type v ()))) -> (Term v () -> m (Maybe (Term v ()))) -> (Reference -> m (Maybe (Decl v ()))) -> Term v () -> m (EvaluatedDoc v)
data RenderError trm
InvalidTerm :: trm -> RenderError trm
data EvaluatedSrc v
EvaluatedSrcDecl :: EvaluatedDecl v -> EvaluatedSrc v
EvaluatedSrcTerm :: EvaluatedTerm v -> EvaluatedSrc v
data EvaluatedDecl v
MissingDecl :: Reference -> EvaluatedDecl v
BuiltinDecl :: Reference -> EvaluatedDecl v
FoundDecl :: Reference -> Decl v () -> EvaluatedDecl v
data EvaluatedTerm v
MissingTerm :: Reference -> EvaluatedTerm v
BuiltinTypeSig :: Reference -> Type v () -> EvaluatedTerm v
MissingBuiltinTypeSig :: Reference -> EvaluatedTerm v
FoundTerm :: Reference -> Type v () -> Term v () -> EvaluatedTerm v
dependencies :: Ord v => EvaluatedDoc v -> Set LabeledDependency

-- | Determines all dependencies of a special form
dependenciesSpecial :: forall v. Ord v => EvaluatedSpecialForm v -> Set LabeledDependency
instance Data.Aeson.Types.ToJSON.ToJSON specialForm => Data.Aeson.Types.ToJSON.ToJSON (Unison.Server.Doc.DocG specialForm)
instance Data.Traversable.Traversable Unison.Server.Doc.DocG
instance Data.Foldable.Foldable Unison.Server.Doc.DocG
instance GHC.Base.Functor Unison.Server.Doc.DocG
instance GHC.Generics.Generic (Unison.Server.Doc.DocG specialForm)
instance GHC.Show.Show specialForm => GHC.Show.Show (Unison.Server.Doc.DocG specialForm)
instance GHC.Classes.Eq specialForm => GHC.Classes.Eq (Unison.Server.Doc.DocG specialForm)
instance Data.Aeson.Types.ToJSON.ToJSON a => Data.Aeson.Types.ToJSON.ToJSON (Unison.Server.Doc.Ref a)
instance Data.Traversable.Traversable Unison.Server.Doc.Ref
instance Data.Foldable.Foldable Unison.Server.Doc.Ref
instance GHC.Base.Functor Unison.Server.Doc.Ref
instance GHC.Generics.Generic (Unison.Server.Doc.Ref a)
instance GHC.Show.Show a => GHC.Show.Show (Unison.Server.Doc.Ref a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Unison.Server.Doc.Ref a)
instance Data.OpenApi.Internal.Schema.ToSchema Unison.Server.Doc.MediaSource
instance Data.Aeson.Types.ToJSON.ToJSON Unison.Server.Doc.MediaSource
instance GHC.Generics.Generic Unison.Server.Doc.MediaSource
instance GHC.Show.Show Unison.Server.Doc.MediaSource
instance GHC.Classes.Eq Unison.Server.Doc.MediaSource
instance Data.OpenApi.Internal.Schema.ToSchema Unison.Server.Doc.Src
instance Data.Aeson.Types.ToJSON.ToJSON Unison.Server.Doc.Src
instance GHC.Generics.Generic Unison.Server.Doc.Src
instance GHC.Show.Show Unison.Server.Doc.Src
instance GHC.Classes.Eq Unison.Server.Doc.Src
instance Data.Aeson.Types.ToJSON.ToJSON trm => Data.Aeson.Types.ToJSON.ToJSON (Unison.Server.Doc.RenderError trm)
instance GHC.Generics.Generic (Unison.Server.Doc.RenderError trm)
instance GHC.Show.Show trm => GHC.Show.Show (Unison.Server.Doc.RenderError trm)
instance GHC.Classes.Eq trm => GHC.Classes.Eq (Unison.Server.Doc.RenderError trm)
instance Data.OpenApi.Internal.Schema.ToSchema Unison.Server.Doc.RenderedSpecialForm
instance Data.Aeson.Types.ToJSON.ToJSON Unison.Server.Doc.RenderedSpecialForm
instance GHC.Generics.Generic Unison.Server.Doc.RenderedSpecialForm
instance GHC.Show.Show Unison.Server.Doc.RenderedSpecialForm
instance GHC.Classes.Eq Unison.Server.Doc.RenderedSpecialForm
instance GHC.Generics.Generic (Unison.Server.Doc.EvaluatedDecl v)
instance U.Core.ABT.Var.Var v => GHC.Classes.Eq (Unison.Server.Doc.EvaluatedDecl v)
instance GHC.Show.Show v => GHC.Show.Show (Unison.Server.Doc.EvaluatedDecl v)
instance GHC.Generics.Generic (Unison.Server.Doc.EvaluatedTerm v)
instance U.Core.ABT.Var.Var v => GHC.Classes.Eq (Unison.Server.Doc.EvaluatedTerm v)
instance GHC.Show.Show v => GHC.Show.Show (Unison.Server.Doc.EvaluatedTerm v)
instance GHC.Generics.Generic (Unison.Server.Doc.EvaluatedSrc v)
instance U.Core.ABT.Var.Var v => GHC.Classes.Eq (Unison.Server.Doc.EvaluatedSrc v)
instance GHC.Show.Show v => GHC.Show.Show (Unison.Server.Doc.EvaluatedSrc v)
instance GHC.Generics.Generic (Unison.Server.Doc.EvaluatedSpecialForm v)
instance GHC.Show.Show v => GHC.Show.Show (Unison.Server.Doc.EvaluatedSpecialForm v)
instance U.Core.ABT.Var.Var v => GHC.Classes.Eq (Unison.Server.Doc.EvaluatedSpecialForm v)
instance Data.OpenApi.Internal.Schema.ToSchema specialForm => Data.OpenApi.Internal.Schema.ToSchema (Unison.Server.Doc.DocG specialForm)
instance Data.OpenApi.Internal.Schema.ToSchema trm => Data.OpenApi.Internal.Schema.ToSchema (Unison.Server.Doc.RenderError trm)
instance Data.OpenApi.Internal.Schema.ToSchema a => Data.OpenApi.Internal.Schema.ToSchema (Unison.Server.Doc.Ref a)


-- | Render Unison.Server.Doc as plain markdown, used in the LSP
module Unison.Server.Doc.Markdown.Render

-- | Renders a Doc to a list of Markdown blocks
toMarkdown :: Doc -> [Markdown]


-- | Render Unison.Server.Doc and embedded source to Html
module Unison.Server.Doc.AsHtml
data NamedLinkHref
Href :: Text -> NamedLinkHref
DocLinkHref :: Name -> NamedLinkHref
ReferenceHref :: Text -> NamedLinkHref
InvalidHref :: NamedLinkHref
data EmbeddedSource
EmbeddedSource :: SyntaxText -> SyntaxText -> EmbeddedSource
Builtin :: SyntaxText -> EmbeddedSource
embeddedSource :: Ref (UnisonHash, DisplayObject SyntaxText Src) -> Maybe EmbeddedSource
inlineCode :: [Text] -> Html () -> Html ()
codeBlock :: [Attribute] -> Html () -> Html ()
normalizeHref :: Map Referent Name -> Doc -> NamedLinkHref
data IsFolded
IsFolded :: Bool -> [Html ()] -> [Html ()] -> IsFolded
Disabled :: Html () -> IsFolded
foldedToHtml :: [Attribute] -> IsFolded -> Html ()
foldedToHtmlSource :: Bool -> EmbeddedSource -> Html ()

-- | Merge adjacent Word elements in a list to 1 element with a string of
--   words separated by space— useful for rendering to the dom without
--   creating dom elements for each and every word in the doc, but instead
--   rely on textNodes
mergeWords :: Text -> [Doc] -> [Doc]

-- | Merge down Doc to Text by merging Paragraphs and Words. Used for
--   things like extract an src of an image. I.e something that has to be a
--   Text and not a Doc
toText :: Text -> Doc -> Text
data SideContent
FrontMatterContent :: Map Text [Text] -> SideContent
TooltipContent :: Html () -> SideContent
newtype FrontMatterData
FrontMatterData :: Map Text [Text] -> FrontMatterData
toHtml :: Map Referent Name -> Doc -> (FrontMatterData, Html ())

-- | Unison Doc allows endlessly deep section nesting with titles, but HTML
--   only supports to h1-h6, so we clamp the sectionLevel when converting
h :: Nat -> Text -> Html () -> Html ()
badge :: Html () -> Html ()
textToClass :: Text -> Text

module Unison.Server.Types
type APIHeaders x = Headers '[Header "Cache-Control" String] x
type APIGet c = Get '[JSON] (APIHeaders c)
type HashQualifiedName = Text
type NamespaceFQN = Text
type Size = Int
type UnisonName = Text
type UnisonHash = Text
data NamespaceDetails
NamespaceDetails :: Path -> UnisonHash -> Maybe Doc -> NamespaceDetails
[$sel:fqn:NamespaceDetails] :: NamespaceDetails -> Path
[$sel:hash:NamespaceDetails] :: NamespaceDetails -> UnisonHash
[$sel:readme:NamespaceDetails] :: NamespaceDetails -> Maybe Doc

-- | A hash qualified name, unlike HashQualified, the hash is required
data ExactName name ref
ExactName :: name -> ref -> ExactName name ref
[$sel:name:ExactName] :: ExactName name ref -> name
[$sel:ref:ExactName] :: ExactName name ref -> ref
exactToHQ :: ExactName name ShortHash -> HashQualified name
exactToHQ' :: ExactName name ShortHash -> HashQualified name
data TermDefinitionDiff
TermDefinitionDiff :: TermDefinition -> TermDefinition -> DisplayObjectDiff -> TermDefinitionDiff
[$sel:left:TermDefinitionDiff] :: TermDefinitionDiff -> TermDefinition
[$sel:right:TermDefinitionDiff] :: TermDefinitionDiff -> TermDefinition
[$sel:diff:TermDefinitionDiff] :: TermDefinitionDiff -> DisplayObjectDiff
data TypeDefinitionDiff
TypeDefinitionDiff :: TypeDefinition -> TypeDefinition -> DisplayObjectDiff -> TypeDefinitionDiff
[$sel:left:TypeDefinitionDiff] :: TypeDefinitionDiff -> TypeDefinition
[$sel:right:TypeDefinitionDiff] :: TypeDefinitionDiff -> TypeDefinition
[$sel:diff:TypeDefinitionDiff] :: TypeDefinitionDiff -> DisplayObjectDiff
newtype Suffixify
Suffixify :: Bool -> Suffixify
[$sel:suffixified:Suffixify] :: Suffixify -> Bool
data TermDefinition
TermDefinition :: [HashQualifiedName] -> HashQualifiedName -> TermTag -> DisplayObject SyntaxText SyntaxText -> SyntaxText -> [(HashQualifiedName, UnisonHash, Doc)] -> TermDefinition
[$sel:termNames:TermDefinition] :: TermDefinition -> [HashQualifiedName]
[$sel:bestTermName:TermDefinition] :: TermDefinition -> HashQualifiedName
[$sel:defnTermTag:TermDefinition] :: TermDefinition -> TermTag
[$sel:termDefinition:TermDefinition] :: TermDefinition -> DisplayObject SyntaxText SyntaxText
[$sel:signature:TermDefinition] :: TermDefinition -> SyntaxText
[$sel:termDocs:TermDefinition] :: TermDefinition -> [(HashQualifiedName, UnisonHash, Doc)]
data TypeDefinition
TypeDefinition :: [HashQualifiedName] -> HashQualifiedName -> TypeTag -> DisplayObject SyntaxText SyntaxText -> [(HashQualifiedName, UnisonHash, Doc)] -> TypeDefinition
[$sel:typeNames:TypeDefinition] :: TypeDefinition -> [HashQualifiedName]
[$sel:bestTypeName:TypeDefinition] :: TypeDefinition -> HashQualifiedName
[$sel:defnTypeTag:TypeDefinition] :: TypeDefinition -> TypeTag
[$sel:typeDefinition:TypeDefinition] :: TypeDefinition -> DisplayObject SyntaxText SyntaxText
[$sel:typeDocs:TypeDefinition] :: TypeDefinition -> [(HashQualifiedName, UnisonHash, Doc)]
data DefinitionDisplayResults
DefinitionDisplayResults :: Map UnisonHash TermDefinition -> Map UnisonHash TypeDefinition -> [HashQualifiedName] -> DefinitionDisplayResults
[$sel:termDefinitions:DefinitionDisplayResults] :: DefinitionDisplayResults -> Map UnisonHash TermDefinition
[$sel:typeDefinitions:DefinitionDisplayResults] :: DefinitionDisplayResults -> Map UnisonHash TypeDefinition
[$sel:missingDefinitions:DefinitionDisplayResults] :: DefinitionDisplayResults -> [HashQualifiedName]
data TermTag
Doc :: TermTag
Test :: TermTag
Plain :: TermTag
Constructor :: TypeTag -> TermTag
data TypeTag
Ability :: TypeTag
Data :: TypeTag

-- | A type for semantic diffing of definitions. Includes special-cases for
--   when the name in a definition has changed but the hash hasn't
--   (rename/alias), and when the hash has changed but the name hasn't
--   (update propagation).
data SemanticSyntaxDiff
Old :: [SyntaxSegment] -> SemanticSyntaxDiff
New :: [SyntaxSegment] -> SemanticSyntaxDiff
Both :: [SyntaxSegment] -> SemanticSyntaxDiff
SegmentChange :: (String, String) -> Maybe Element -> SemanticSyntaxDiff
AnnotationChange :: String -> (Maybe Element, Maybe Element) -> SemanticSyntaxDiff

-- | A diff of the syntax of a term or type
--   
--   It doesn't make sense to diff builtins with ABTs, so in that case we
--   just provide the undiffed syntax.
data DisplayObjectDiff
DisplayObjectDiff :: DisplayObject [SemanticSyntaxDiff] [SemanticSyntaxDiff] -> DisplayObjectDiff
MismatchedDisplayObjects :: DisplayObject SyntaxText SyntaxText -> DisplayObject SyntaxText SyntaxText -> DisplayObjectDiff
data UnisonRef
TypeRef :: UnisonHash -> UnisonRef
TermRef :: UnisonHash -> UnisonRef
unisonRefToText :: UnisonRef -> Text
data NamedTerm
NamedTerm :: HashQualified Name -> ShortHash -> Maybe SyntaxText -> TermTag -> NamedTerm
[$sel:termName:NamedTerm] :: NamedTerm -> HashQualified Name
[$sel:termHash:NamedTerm] :: NamedTerm -> ShortHash
[$sel:termType:NamedTerm] :: NamedTerm -> Maybe SyntaxText
[$sel:termTag:NamedTerm] :: NamedTerm -> TermTag
data NamedType
NamedType :: HashQualified Name -> ShortHash -> TypeTag -> NamedType
[$sel:typeName:NamedType] :: NamedType -> HashQualified Name
[$sel:typeHash:NamedType] :: NamedType -> ShortHash
[$sel:typeTag:NamedType] :: NamedType -> TypeTag
munge :: Text -> ByteString
mungeShow :: Show s => s -> ByteString
mungeString :: String -> ByteString
defaultWidth :: Width
discard :: Applicative m => a -> m ()
mayDefaultWidth :: Maybe Width -> Width
setCacheControl :: v -> APIHeaders v
branchToUnisonHash :: Branch m -> UnisonHash
v2CausalBranchToUnisonHash :: CausalBranch m -> UnisonHash
newtype ProjectBranchNameParam
ProjectBranchNameParam :: ProjectAndBranch ProjectName ProjectBranchName -> ProjectBranchNameParam
[$sel:unProjectBranchNameParam:ProjectBranchNameParam] :: ProjectBranchNameParam -> ProjectAndBranch ProjectName ProjectBranchName
data TermDiffResponse
TermDiffResponse :: ProjectName -> ProjectBranchName -> ProjectBranchName -> TermDefinition -> TermDefinition -> DisplayObjectDiff -> TermDiffResponse
[$sel:project:TermDiffResponse] :: TermDiffResponse -> ProjectName
[$sel:oldBranch:TermDiffResponse] :: TermDiffResponse -> ProjectBranchName
[$sel:newBranch:TermDiffResponse] :: TermDiffResponse -> ProjectBranchName
[$sel:oldTerm:TermDiffResponse] :: TermDiffResponse -> TermDefinition
[$sel:newTerm:TermDiffResponse] :: TermDiffResponse -> TermDefinition
[$sel:diff:TermDiffResponse] :: TermDiffResponse -> DisplayObjectDiff
data TypeDiffResponse
TypeDiffResponse :: ProjectName -> ProjectBranchName -> ProjectBranchName -> TypeDefinition -> TypeDefinition -> DisplayObjectDiff -> TypeDiffResponse
[$sel:project:TypeDiffResponse] :: TypeDiffResponse -> ProjectName
[$sel:oldBranch:TypeDiffResponse] :: TypeDiffResponse -> ProjectBranchName
[$sel:newBranch:TypeDiffResponse] :: TypeDiffResponse -> ProjectBranchName
[$sel:oldType:TypeDiffResponse] :: TypeDiffResponse -> TypeDefinition
[$sel:newType:TypeDiffResponse] :: TypeDiffResponse -> TypeDefinition
[$sel:diff:TypeDiffResponse] :: TypeDiffResponse -> DisplayObjectDiff

-- | Servant utility for a query param that's required, providing a useful
--   error message if it's missing.
type RequiredQueryParam = QueryParam' '[Required, Strict]
instance GHC.Show.Show Unison.Server.Types.NamespaceDetails
instance GHC.Generics.Generic Unison.Server.Types.NamespaceDetails
instance (GHC.Classes.Ord name, GHC.Classes.Ord ref) => GHC.Classes.Ord (Unison.Server.Types.ExactName name ref)
instance GHC.Base.Functor (Unison.Server.Types.ExactName name)
instance (GHC.Classes.Eq name, GHC.Classes.Eq ref) => GHC.Classes.Eq (Unison.Server.Types.ExactName name ref)
instance (GHC.Show.Show name, GHC.Show.Show ref) => GHC.Show.Show (Unison.Server.Types.ExactName name ref)
instance GHC.Generics.Generic Unison.Server.Types.Suffixify
instance GHC.Show.Show Unison.Server.Types.Suffixify
instance GHC.Classes.Ord Unison.Server.Types.Suffixify
instance GHC.Classes.Eq Unison.Server.Types.Suffixify
instance GHC.Generics.Generic Unison.Server.Types.TypeTag
instance GHC.Show.Show Unison.Server.Types.TypeTag
instance GHC.Classes.Ord Unison.Server.Types.TypeTag
instance GHC.Classes.Eq Unison.Server.Types.TypeTag
instance GHC.Generics.Generic Unison.Server.Types.TermTag
instance GHC.Show.Show Unison.Server.Types.TermTag
instance GHC.Classes.Ord Unison.Server.Types.TermTag
instance GHC.Classes.Eq Unison.Server.Types.TermTag
instance GHC.Generics.Generic Unison.Server.Types.TermDefinition
instance GHC.Show.Show Unison.Server.Types.TermDefinition
instance GHC.Classes.Eq Unison.Server.Types.TermDefinition
instance GHC.Generics.Generic Unison.Server.Types.TypeDefinition
instance GHC.Show.Show Unison.Server.Types.TypeDefinition
instance GHC.Classes.Eq Unison.Server.Types.TypeDefinition
instance GHC.Generics.Generic Unison.Server.Types.DefinitionDisplayResults
instance GHC.Show.Show Unison.Server.Types.DefinitionDisplayResults
instance GHC.Classes.Eq Unison.Server.Types.DefinitionDisplayResults
instance GHC.Generics.Generic Unison.Server.Types.SemanticSyntaxDiff
instance GHC.Show.Show Unison.Server.Types.SemanticSyntaxDiff
instance GHC.Classes.Eq Unison.Server.Types.SemanticSyntaxDiff
instance GHC.Generics.Generic Unison.Server.Types.DisplayObjectDiff
instance GHC.Classes.Eq Unison.Server.Types.DisplayObjectDiff
instance GHC.Show.Show Unison.Server.Types.DisplayObjectDiff
instance GHC.Generics.Generic Unison.Server.Types.TypeDefinitionDiff
instance GHC.Show.Show Unison.Server.Types.TypeDefinitionDiff
instance GHC.Classes.Eq Unison.Server.Types.TypeDefinitionDiff
instance GHC.Generics.Generic Unison.Server.Types.TermDefinitionDiff
instance GHC.Show.Show Unison.Server.Types.TermDefinitionDiff
instance GHC.Classes.Eq Unison.Server.Types.TermDefinitionDiff
instance GHC.Generics.Generic Unison.Server.Types.UnisonRef
instance GHC.Show.Show Unison.Server.Types.UnisonRef
instance GHC.Classes.Ord Unison.Server.Types.UnisonRef
instance GHC.Classes.Eq Unison.Server.Types.UnisonRef
instance GHC.Show.Show Unison.Server.Types.NamedTerm
instance GHC.Generics.Generic Unison.Server.Types.NamedTerm
instance GHC.Classes.Eq Unison.Server.Types.NamedTerm
instance GHC.Show.Show Unison.Server.Types.NamedType
instance GHC.Generics.Generic Unison.Server.Types.NamedType
instance GHC.Classes.Eq Unison.Server.Types.NamedType
instance GHC.Generics.Generic Unison.Server.Types.ProjectBranchNameParam
instance GHC.Show.Show Unison.Server.Types.ProjectBranchNameParam
instance GHC.Classes.Eq Unison.Server.Types.ProjectBranchNameParam
instance GHC.Generics.Generic Unison.Server.Types.TermDiffResponse
instance GHC.Show.Show Unison.Server.Types.TermDiffResponse
instance GHC.Classes.Eq Unison.Server.Types.TermDiffResponse
instance GHC.Generics.Generic Unison.Server.Types.TypeDiffResponse
instance GHC.Show.Show Unison.Server.Types.TypeDiffResponse
instance GHC.Classes.Eq Unison.Server.Types.TypeDiffResponse
instance Data.OpenApi.Internal.Schema.ToSchema Unison.Server.Types.NamespaceDetails
instance Web.Internal.HttpApiData.FromHttpApiData Unison.Server.Types.Suffixify
instance Data.OpenApi.Internal.ParamSchema.ToParamSchema Unison.Server.Types.Suffixify
instance Data.OpenApi.Internal.Schema.ToSchema Unison.Server.Types.TypeDefinition
instance Data.OpenApi.Internal.Schema.ToSchema Unison.Server.Types.TermDefinition
instance Data.OpenApi.Internal.Schema.ToSchema Unison.Server.Types.DefinitionDisplayResults
instance Data.OpenApi.Internal.Schema.ToSchema Unison.Server.Types.SemanticSyntaxDiff
instance Data.OpenApi.Internal.Schema.ToSchema Unison.Server.Types.DisplayObjectDiff
instance Data.OpenApi.Internal.Schema.ToSchema Unison.Server.Types.NamedTerm
instance Data.OpenApi.Internal.Schema.ToSchema Unison.Server.Types.NamedType
instance Data.OpenApi.Internal.Schema.ToSchema Unison.Server.Types.TermTag
instance Data.OpenApi.Internal.Schema.ToSchema Unison.Server.Types.TypeTag
instance Data.OpenApi.Internal.Schema.ToSchema Unison.Server.Types.TermDiffResponse
instance Data.OpenApi.Internal.Schema.ToSchema Unison.Server.Types.TypeDiffResponse
instance Servant.Docs.Internal.ToSample Unison.Server.Types.TypeDiffResponse
instance Data.Aeson.Types.ToJSON.ToJSON Unison.Server.Types.TypeDiffResponse
instance Servant.Docs.Internal.ToSample Unison.Server.Types.TermDiffResponse
instance Data.Aeson.Types.ToJSON.ToJSON Unison.Server.Types.TermDiffResponse
instance Data.OpenApi.Internal.ParamSchema.ToParamSchema Unison.Server.Types.ProjectBranchNameParam
instance Web.Internal.HttpApiData.FromHttpApiData Unison.Server.Types.ProjectBranchNameParam
instance Servant.Docs.Internal.ToParam (Servant.API.QueryParam.QueryParam "project-and-branch" Unison.Server.Types.ProjectBranchNameParam)
instance Servant.Docs.Internal.ToCapture (Servant.API.Capture.Capture "project-and-branch" Unison.Server.Types.ProjectBranchNameParam)
instance Data.Aeson.Types.ToJSON.ToJSON Unison.Server.Types.NamedType
instance Data.Aeson.Types.FromJSON.FromJSON Unison.Server.Types.NamedType
instance Data.Aeson.Types.ToJSON.ToJSON Unison.Server.Types.NamedTerm
instance Data.Aeson.Types.FromJSON.FromJSON Unison.Server.Types.NamedTerm
instance Data.Aeson.Types.ToJSON.ToJSON Unison.Server.Types.SemanticSyntaxDiff
instance Data.Aeson.Types.ToJSON.ToJSON Unison.Server.Types.DefinitionDisplayResults
instance GHC.Base.Semigroup Unison.Server.Types.DefinitionDisplayResults
instance GHC.Base.Monoid Unison.Server.Types.DefinitionDisplayResults
instance Data.Aeson.Types.ToJSON.ToJSON Unison.Server.Types.TypeDefinition
instance Data.Aeson.Types.ToJSON.ToJSON Unison.Server.Types.TermDefinition
instance Data.Aeson.Types.ToJSON.ToJSON Unison.Server.Types.TermTag
instance Data.Aeson.Types.FromJSON.FromJSON Unison.Server.Types.TermTag
instance Data.Aeson.Types.ToJSON.ToJSON Unison.Server.Types.TypeTag
instance Data.Aeson.Types.FromJSON.FromJSON Unison.Server.Types.TypeTag
instance Data.OpenApi.Internal.ParamSchema.ToParamSchema (Unison.Server.Types.ExactName Unison.Name.Internal.Name Unison.ShortHash.ShortHash)
instance Servant.Docs.Internal.ToParam (Servant.API.QueryParam.QueryParam "exact-name" (Unison.Server.Types.ExactName Unison.Name.Internal.Name Unison.ShortHash.ShortHash))
instance Servant.Docs.Internal.ToCapture (Servant.API.Capture.Capture "fqn" (Unison.Server.Types.ExactName Unison.Name.Internal.Name Unison.ShortHash.ShortHash))
instance Data.Bifunctor.Bifunctor Unison.Server.Types.ExactName
instance Data.Bifoldable.Bifoldable Unison.Server.Types.ExactName
instance Data.Bitraversable.Bitraversable Unison.Server.Types.ExactName
instance Web.Internal.HttpApiData.FromHttpApiData (Unison.Server.Types.ExactName Unison.Name.Internal.Name Unison.ShortHash.ShortHash)
instance Servant.Docs.Internal.ToSample Unison.Server.Types.NamespaceDetails
instance Data.Aeson.Types.ToJSON.ToJSON Unison.Server.Types.NamespaceDetails


-- | Utilities for displaying diffs between definitions.
module Unison.Server.Backend.DefinitionDiff
diffDisplayObjects :: HasCallStack => DisplayObject SyntaxText SyntaxText -> DisplayObject SyntaxText SyntaxText -> DisplayObjectDiff

module Unison.Server.Backend
data BackendError
NoSuchNamespace :: Absolute -> BackendError
BadNamespace :: String -> String -> BackendError
CouldntExpandBranchHash :: ShortCausalHash -> BackendError
AmbiguousBranchHash :: ShortCausalHash -> Set ShortCausalHash -> BackendError
AmbiguousHashForDefinition :: ShortHash -> BackendError
NoBranchForHash :: CausalHash -> BackendError
CouldntLoadBranch :: CausalHash -> BackendError
MissingSignatureForTerm :: Reference -> BackendError
NoSuchDefinition :: HashQualified Name -> BackendError
ExpectedNameLookup :: BranchHash -> BackendError
DisjointProjectAndPerspective :: Path -> Path -> BackendError
ProjectBranchNameNotFound :: ProjectName -> ProjectBranchName -> BackendError
newtype Backend m a
Backend :: ReaderT BackendEnv (ExceptT BackendError m) a -> Backend m a
[$sel:runBackend:Backend] :: Backend m a -> ReaderT BackendEnv (ExceptT BackendError m) a
data ShallowListEntry v a
ShallowTermEntry :: TermEntry v a -> ShallowListEntry v a
ShallowTypeEntry :: TypeEntry -> ShallowListEntry v a
ShallowBranchEntry :: NameSegment -> CausalHash -> NamespaceStats -> ShallowListEntry v a
ShallowPatchEntry :: NameSegment -> ShallowListEntry v a
listEntryName :: ShallowListEntry v a -> Text
newtype BackendEnv
BackendEnv :: Bool -> BackendEnv

-- | Whether to use the sqlite name-lookup table to generate Names objects
--   rather than building Names from the root branch.
[$sel:useNamesIndex:BackendEnv] :: BackendEnv -> Bool
data TermEntry v a
TermEntry :: Referent -> ShortHash -> Name -> Bool -> Maybe (Type v a) -> TermTag -> TermEntry v a
[$sel:termEntryReferent:TermEntry] :: TermEntry v a -> Referent
[$sel:termEntryHash:TermEntry] :: TermEntry v a -> ShortHash
[$sel:termEntryName:TermEntry] :: TermEntry v a -> Name
[$sel:termEntryConflicted:TermEntry] :: TermEntry v a -> Bool
[$sel:termEntryType:TermEntry] :: TermEntry v a -> Maybe (Type v a)
[$sel:termEntryTag:TermEntry] :: TermEntry v a -> TermTag
data TypeEntry
TypeEntry :: Reference -> ShortHash -> Name -> Bool -> TypeTag -> TypeEntry
[$sel:typeEntryReference:TypeEntry] :: TypeEntry -> Reference
[$sel:typeEntryHash:TypeEntry] :: TypeEntry -> ShortHash
[$sel:typeEntryName:TypeEntry] :: TypeEntry -> Name
[$sel:typeEntryConflicted:TypeEntry] :: TypeEntry -> Bool
[$sel:typeEntryTag:TypeEntry] :: TypeEntry -> TypeTag
data FoundRef
FoundTermRef :: Referent -> FoundRef
FoundTypeRef :: Reference -> FoundRef

-- | Determines whether we include full cycles in the results, (e.g. if I
--   search for <tt>isEven</tt>, will I find <tt>isOdd</tt> too?)
--   
--   This was once used for both term and decl components, but now is only
--   used for decl components, because <tt>update</tt> does The Right Thing
--   for terms (i.e. propagates changes to all dependents, including
--   component-mates, which are de facto dependents).
--   
--   Ticket of interest:
--   <a>https://github.com/unisonweb/unison/issues/3445</a>
data IncludeCycles
IncludeCycles :: IncludeCycles
DontIncludeCycles :: IncludeCycles
data DefinitionResults
DefinitionResults :: Map Reference (DisplayObject (Type Symbol Ann) (Term Symbol Ann)) -> Map Reference (DisplayObject () (Decl Symbol Ann)) -> [HashQualified Name] -> DefinitionResults
[$sel:termResults:DefinitionResults] :: DefinitionResults -> Map Reference (DisplayObject (Type Symbol Ann) (Term Symbol Ann))
[$sel:typeResults:DefinitionResults] :: DefinitionResults -> Map Reference (DisplayObject () (Decl Symbol Ann))
[$sel:noResults:DefinitionResults] :: DefinitionResults -> [HashQualified Name]
type SyntaxText = SyntaxText' Reference
fuzzyFind :: Names -> String -> [(Alignment, UnisonName, [FoundRef])]
bestNameForTerm :: forall v. Var v => PrettyPrintEnv -> Width -> Referent -> Text
bestNameForType :: forall v. Var v => PrettyPrintEnv -> Width -> Reference -> Text
definitionsByName :: Codebase m Symbol Ann -> NameSearch Transaction -> IncludeCycles -> SearchType -> [HashQualified Name] -> Transaction DefinitionResults
displayType :: Codebase m Symbol Ann -> Reference -> Transaction (DisplayObject () (Decl Symbol Ann))
docsInBranchToHtmlFiles :: Runtime Symbol -> Codebase IO Symbol Ann -> Branch IO -> FilePath -> IO [Error]
expandShortCausalHash :: ShortCausalHash -> Backend Transaction CausalHash
findDocInBranch :: Set NameSegment -> Branch m -> Maybe TermReference
formatSuffixedType :: Var v => PrettyPrintEnvDecl -> Width -> Type v Ann -> SyntaxText

-- | Efficiently resolve a root hash and path to a shallow branch's causal.
getShallowCausalAtPathFromRootHash :: CausalHash -> Path -> Transaction (CausalBranch Transaction)
getTermTag :: (Var v, MonadIO m) => Codebase m v a -> Referent -> Maybe (Type v Ann) -> m TermTag
getTypeTag :: Var v => Codebase m v Ann -> Reference -> Transaction TypeTag
hoistBackend :: (forall x. m x -> n x) -> Backend m a -> Backend n a
hqNameQuery :: Codebase m v Ann -> NameSearch Transaction -> SearchType -> [HashQualified Name] -> Transaction QueryResult
loadReferentType :: Codebase m Symbol Ann -> Referent -> Transaction (Maybe (Type Symbol Ann))
loadSearchResults :: Codebase m Symbol Ann -> [SearchResult] -> Transaction [SearchResult' Symbol Ann]
lsAtPath :: MonadIO m => Codebase m Symbol Ann -> Branch Transaction -> Absolute -> m [ShallowListEntry Symbol Ann]

-- | Find all definitions and children reachable from the given
--   <a>Branch</a>,
lsBranch :: MonadIO m => Codebase m Symbol Ann -> Branch n -> m [ShallowListEntry Symbol Ann]
mungeSyntaxText :: Functor g => g (Element Reference) -> g Element
expectCausalBranchByCausalHash :: CausalHash -> Transaction (CausalBranch Transaction)
resolveRootBranchHashV2 :: ShortCausalHash -> Backend Transaction (CausalBranch Transaction)

-- | Gets the names and PPED for the branch at the provided path from the
--   root branch for the provided branch hash.
namesAtPathFromRootBranchHash :: forall m n v a. MonadIO m => Codebase m v a -> CausalBranch n -> Path -> Backend m (Names, PrettyPrintEnvDecl)
termEntryDisplayName :: TermEntry v a -> Text
termEntryHQName :: TermEntry v a -> HashQualified Name
termEntryToNamedTerm :: Var v => PrettyPrintEnv -> Maybe Width -> TermEntry v a -> NamedTerm
termEntryLabeledDependencies :: Ord v => TermEntry v a -> Set LabeledDependency
termListEntry :: MonadIO m => Codebase m Symbol Ann -> ExactName Name Referent -> m (TermEntry Symbol Ann)

-- | Look up terms in the codebase by short hash, and include builtins.
termReferentsByShortHash :: Codebase m v a -> ShortHash -> Transaction (Set Referent)
typeDeclHeader :: forall v m. Var v => Codebase m v Ann -> PrettyPrintEnv -> Reference -> Transaction (DisplayObject SyntaxText SyntaxText)
typeEntryDisplayName :: TypeEntry -> Text
typeEntryHQName :: TypeEntry -> HashQualified Name
typeEntryToNamedType :: TypeEntry -> NamedType
typeEntryLabeledDependencies :: TypeEntry -> Set LabeledDependency
typeListEntry :: Var v => Codebase m v Ann -> ExactName Name Reference -> Transaction TypeEntry

-- | Look up types in the codebase by short hash, and include builtins.
typeReferencesByShortHash :: ShortHash -> Transaction (Set Reference)

-- | Renders a type to its decl header, e.g.
--   
--   Effect:
--   
--   unique ability Stream s
--   
--   Data:
--   
--   structural type Maybe a
typeToSyntaxHeader :: Width -> HashQualified Name -> DisplayObject () (Decl Symbol Ann) -> DisplayObject SyntaxText SyntaxText

-- | Evaluate and render the given docs
renderDocRefs :: Traversable t => PrettyPrintEnvDecl -> Width -> Codebase IO Symbol Ann -> Runtime Symbol -> t TermReference -> IO (t (HashQualifiedName, UnisonHash, Doc, [Error]))

-- | Fetch the docs associated with the given name. Returns all references
--   with a Doc type which are at the name provided, or at
--   '<a>name</a>.doc'.
docsForDefinitionName :: Codebase IO Symbol Ann -> NameSearch Transaction -> SearchType -> Name -> Transaction [TermReference]
normaliseRootCausalHash :: Either ShortCausalHash CausalHash -> Backend Transaction (CausalBranch Transaction)
resolveRootBranchHash :: MonadIO m => ShortCausalHash -> Codebase m v a -> Backend m (Branch m)
isTestResultList :: forall v a. (Var v, Monoid a) => Maybe (Type v a) -> Bool
fixupNamesRelative :: Absolute -> Names -> Names

-- | Converts Type Display Objects into Syntax Text.
termsToSyntax :: Var v => Ord a => Suffixify -> Width -> PrettyPrintEnvDecl -> [(TermReference, DisplayObject (Type v a) (Term v a))] -> [(TermReference, DisplayObject SyntaxText SyntaxText)]

-- | Version of <a>termsToSyntax</a> which works over arbitrary traversals.
--   
--   E.g. @@ termsToSyntaxOf suff width pped traversed [(ref, dispObj)]
--   
--   or
--   
--   termsToSyntaxOf suff width pped id (ref, dispObj)
--   
--   or
--   
--   termsToSyntaxOf suff width pped Map.asList_ (Map.singleton ref
--   dispObj) @@ e.g. <a>traversed</a>
termsToSyntaxOf :: Var v => Ord a => Suffixify -> Width -> PrettyPrintEnvDecl -> Traversal s t (TermReference, DisplayObject (Type v a) (Term v a)) (TermReference, DisplayObject SyntaxText SyntaxText) -> s -> t

-- | Converts Type Display Objects into Syntax Text.
typesToSyntax :: Var v => Ord a => Suffixify -> Width -> PrettyPrintEnvDecl -> [(TypeReference, DisplayObject () (Decl v a))] -> [(TypeReference, DisplayObject SyntaxText SyntaxText)]

-- | Version of <a>typesToSyntax</a> which works over arbitrary traversals.
--   
--   E.g. @@ typesToSyntaxOf suff width pped traversed [(ref, dispObj)]
--   
--   or
--   
--   typesToSyntaxOf suff width pped id (ref, dispObj)
--   
--   or
--   
--   typesToSyntaxOf suff width pped Map.asList_ (Map.singleton ref
--   dispObj) @@
typesToSyntaxOf :: Var v => Ord a => Suffixify -> Width -> PrettyPrintEnvDecl -> Traversal s t (TypeReference, DisplayObject () (Decl v a)) (TypeReference, DisplayObject SyntaxText SyntaxText) -> s -> t

-- | Finds ALL direct references contained within a
--   <a>DefinitionResults</a> so we can build a pretty printer for them.
definitionResultsDependencies :: DefinitionResults -> Set LabeledDependency

-- | Evaluate the doc at the given reference and return its
--   evaluated-but-not-rendered form.
evalDocRef :: Runtime Symbol -> Codebase IO Symbol Ann -> TermReference -> IO (EvaluatedDoc Symbol, [Error])
mkTermDefinition :: Codebase IO Symbol Ann -> PrettyPrintEnvDecl -> Width -> Reference -> [(HashQualifiedName, UnisonHash, Doc)] -> DisplayObject (AnnotatedText (Element Reference)) (AnnotatedText (Element Reference)) -> Backend IO TermDefinition
mkTypeDefinition :: MonadIO m => Codebase IO Symbol Ann -> PrettyPrintEnvDecl -> Width -> Reference -> [(HashQualifiedName, UnisonHash, Doc)] -> DisplayObject (AnnotatedText (Element Reference)) (AnnotatedText (Element Reference)) -> m TypeDefinition
displayTerm :: Codebase m Symbol Ann -> Reference -> Transaction (DisplayObject (Type Symbol Ann) (Term Symbol Ann))
formatTypeName :: PrettyPrintEnv -> Reference -> SyntaxText
instance GHC.Show.Show Unison.Server.Backend.BackendError
instance GHC.Base.Monad m => Control.Monad.Error.Class.MonadError Unison.Server.Backend.BackendError (Unison.Server.Backend.Backend m)
instance GHC.Base.Monad m => Control.Monad.Reader.Class.MonadReader Unison.Server.Backend.BackendEnv (Unison.Server.Backend.Backend m)
instance Control.Monad.IO.Class.MonadIO m => Control.Monad.IO.Class.MonadIO (Unison.Server.Backend.Backend m)
instance GHC.Base.Monad m => GHC.Base.Monad (Unison.Server.Backend.Backend m)
instance GHC.Base.Monad m => GHC.Base.Applicative (Unison.Server.Backend.Backend m)
instance GHC.Base.Functor m => GHC.Base.Functor (Unison.Server.Backend.Backend m)
instance GHC.Generics.Generic (Unison.Server.Backend.TermEntry v a)
instance GHC.Show.Show v => GHC.Show.Show (Unison.Server.Backend.TermEntry v a)
instance U.Core.ABT.Var.Var v => GHC.Classes.Ord (Unison.Server.Backend.TermEntry v a)
instance U.Core.ABT.Var.Var v => GHC.Classes.Eq (Unison.Server.Backend.TermEntry v a)
instance GHC.Generics.Generic Unison.Server.Backend.TypeEntry
instance GHC.Show.Show Unison.Server.Backend.TypeEntry
instance GHC.Classes.Ord Unison.Server.Backend.TypeEntry
instance GHC.Classes.Eq Unison.Server.Backend.TypeEntry
instance GHC.Generics.Generic (Unison.Server.Backend.ShallowListEntry v a)
instance GHC.Show.Show v => GHC.Show.Show (Unison.Server.Backend.ShallowListEntry v a)
instance U.Core.ABT.Var.Var v => GHC.Classes.Ord (Unison.Server.Backend.ShallowListEntry v a)
instance U.Core.ABT.Var.Var v => GHC.Classes.Eq (Unison.Server.Backend.ShallowListEntry v a)
instance GHC.Generics.Generic Unison.Server.Backend.FoundRef
instance GHC.Show.Show Unison.Server.Backend.FoundRef
instance GHC.Classes.Ord Unison.Server.Backend.FoundRef
instance GHC.Classes.Eq Unison.Server.Backend.FoundRef
instance GHC.Show.Show Unison.Server.Backend.DefinitionResults
instance Control.Monad.Trans.Class.MonadTrans Unison.Server.Backend.Backend

module Unison.Server.Local.Endpoints.Projects
projectListingEndpoint :: Codebase IO Symbol Ann -> Maybe PrefixFilter -> Backend IO [ProjectListing]
projectBranchListingEndpoint :: Codebase IO Symbol Ann -> ProjectName -> Maybe PrefixFilter -> Backend IO [ProjectBranchListing]
type ListProjectsEndpoint = QueryParam "prefix" PrefixFilter :> Get '[JSON] [ProjectListing]
type ListProjectBranchesEndpoint = QueryParam "prefix" PrefixFilter :> Get '[JSON] [ProjectBranchListing]
instance GHC.Generics.Generic Unison.Server.Local.Endpoints.Projects.ProjectListing
instance GHC.Show.Show Unison.Server.Local.Endpoints.Projects.ProjectListing
instance GHC.Generics.Generic Unison.Server.Local.Endpoints.Projects.ProjectBranchListing
instance GHC.Show.Show Unison.Server.Local.Endpoints.Projects.ProjectBranchListing
instance Web.Internal.HttpApiData.FromHttpApiData Unison.Server.Local.Endpoints.Projects.PrefixFilter
instance GHC.Generics.Generic Unison.Server.Local.Endpoints.Projects.PrefixFilter
instance GHC.Show.Show Unison.Server.Local.Endpoints.Projects.PrefixFilter
instance Data.OpenApi.Internal.ParamSchema.ToParamSchema Unison.Server.Local.Endpoints.Projects.PrefixFilter
instance Servant.Docs.Internal.ToParam (Servant.API.QueryParam.QueryParam "prefix" Unison.Server.Local.Endpoints.Projects.PrefixFilter)
instance Servant.Docs.Internal.ToSample Unison.Server.Local.Endpoints.Projects.PrefixFilter
instance Data.OpenApi.Internal.Schema.ToSchema Unison.Server.Local.Endpoints.Projects.ProjectBranchListing
instance Data.Aeson.Types.ToJSON.ToJSON Unison.Server.Local.Endpoints.Projects.ProjectBranchListing
instance Servant.Docs.Internal.ToSample Unison.Server.Local.Endpoints.Projects.ProjectBranchListing
instance Data.OpenApi.Internal.Schema.ToSchema Unison.Server.Local.Endpoints.Projects.ProjectListing
instance Data.Aeson.Types.ToJSON.ToJSON Unison.Server.Local.Endpoints.Projects.ProjectListing
instance Servant.Docs.Internal.ToSample Unison.Server.Local.Endpoints.Projects.ProjectListing

module Unison.Server.Local.Endpoints.NamespaceListing
serve :: Codebase IO Symbol Ann -> Either ShortCausalHash CausalHash -> Maybe Path -> Maybe Path -> Backend IO NamespaceListing
type NamespaceListingAPI = "list" :> QueryParam "relativeTo" Path :> QueryParam "namespace" Path :> APIGet NamespaceListing
data NamespaceListing
NamespaceListing :: UnisonName -> UnisonHash -> [NamespaceObject] -> NamespaceListing
[$sel:namespaceListingFQN:NamespaceListing] :: NamespaceListing -> UnisonName
[$sel:namespaceListingHash:NamespaceListing] :: NamespaceListing -> UnisonHash
[$sel:namespaceListingChildren:NamespaceListing] :: NamespaceListing -> [NamespaceObject]
data NamespaceObject
Subnamespace :: NamedNamespace -> NamespaceObject
TermObject :: NamedTerm -> NamespaceObject
TypeObject :: NamedType -> NamespaceObject
PatchObject :: NamedPatch -> NamespaceObject
data NamedNamespace
NamedNamespace :: UnisonName -> UnisonHash -> Int -> NamedNamespace
[$sel:namespaceName:NamedNamespace] :: NamedNamespace -> UnisonName
[$sel:namespaceHash:NamedNamespace] :: NamedNamespace -> UnisonHash
[$sel:namespaceSize:NamedNamespace] :: NamedNamespace -> Int
newtype NamedPatch
NamedPatch :: HashQualifiedName -> NamedPatch
[$sel:patchName:NamedPatch] :: NamedPatch -> HashQualifiedName
newtype KindExpression
KindExpression :: Text -> KindExpression
[$sel:kindExpressionText:KindExpression] :: KindExpression -> Text
instance GHC.Show.Show Unison.Server.Local.Endpoints.NamespaceListing.NamedNamespace
instance GHC.Generics.Generic Unison.Server.Local.Endpoints.NamespaceListing.NamedNamespace
instance Data.OpenApi.Internal.Schema.ToSchema Unison.Server.Local.Endpoints.NamespaceListing.NamedPatch
instance GHC.Show.Show Unison.Server.Local.Endpoints.NamespaceListing.NamedPatch
instance GHC.Generics.Generic Unison.Server.Local.Endpoints.NamespaceListing.NamedPatch
instance GHC.Show.Show Unison.Server.Local.Endpoints.NamespaceListing.NamespaceObject
instance GHC.Generics.Generic Unison.Server.Local.Endpoints.NamespaceListing.NamespaceObject
instance GHC.Show.Show Unison.Server.Local.Endpoints.NamespaceListing.NamespaceListing
instance GHC.Generics.Generic Unison.Server.Local.Endpoints.NamespaceListing.NamespaceListing
instance Data.OpenApi.Internal.Schema.ToSchema Unison.Server.Local.Endpoints.NamespaceListing.KindExpression
instance GHC.Show.Show Unison.Server.Local.Endpoints.NamespaceListing.KindExpression
instance GHC.Generics.Generic Unison.Server.Local.Endpoints.NamespaceListing.KindExpression
instance Data.OpenApi.Internal.Schema.ToSchema Unison.Server.Local.Endpoints.NamespaceListing.NamespaceListing
instance Data.OpenApi.Internal.Schema.ToSchema Unison.Server.Local.Endpoints.NamespaceListing.NamespaceObject
instance Data.OpenApi.Internal.Schema.ToSchema Unison.Server.Local.Endpoints.NamespaceListing.NamedNamespace
instance Data.Aeson.Types.ToJSON.ToJSON Unison.Server.Local.Endpoints.NamespaceListing.KindExpression
instance Servant.Docs.Internal.ToSample Unison.Server.Local.Endpoints.NamespaceListing.NamespaceListing
instance Data.Aeson.Types.ToJSON.ToJSON Unison.Server.Local.Endpoints.NamespaceListing.NamespaceListing
instance Data.Aeson.Types.FromJSON.FromJSON Unison.Server.Local.Endpoints.NamespaceListing.NamespaceListing
instance Data.Aeson.Types.ToJSON.ToJSON Unison.Server.Local.Endpoints.NamespaceListing.NamespaceObject
instance Data.Aeson.Types.FromJSON.FromJSON Unison.Server.Local.Endpoints.NamespaceListing.NamespaceObject
instance Data.Aeson.Types.ToJSON.ToJSON Unison.Server.Local.Endpoints.NamespaceListing.NamedPatch
instance Data.Aeson.Types.FromJSON.FromJSON Unison.Server.Local.Endpoints.NamespaceListing.NamedPatch
instance Data.Aeson.Types.ToJSON.ToJSON Unison.Server.Local.Endpoints.NamespaceListing.NamedNamespace
instance Data.Aeson.Types.FromJSON.FromJSON Unison.Server.Local.Endpoints.NamespaceListing.NamedNamespace
instance Servant.Docs.Internal.ToParam (Servant.API.QueryParam.QueryParam "namespace" Data.Text.Internal.Text)

module Unison.Server.Local.Endpoints.NamespaceDetails
type NamespaceDetailsAPI = "namespaces" :> Capture "namespace" Path :> QueryParam "renderWidth" Width :> APIGet NamespaceDetails
namespaceDetails :: Runtime Symbol -> Codebase IO Symbol Ann -> Path -> Either ShortCausalHash CausalHash -> Maybe Width -> Backend IO NamespaceDetails
instance Servant.Docs.Internal.ToCapture (Servant.API.Capture.Capture "namespace" Data.Text.Internal.Text)

module Unison.Server.Local.Endpoints.FuzzyFind
type FuzzyFindAPI = "find" :> QueryParam "relativeTo" Path :> QueryParam "limit" Int :> QueryParam "renderWidth" Width :> QueryParam "query" String :> APIGet [(Alignment, FoundResult)]
data FoundTerm
FoundTerm :: HashQualifiedName -> NamedTerm -> FoundTerm
[$sel:bestFoundTermName:FoundTerm] :: FoundTerm -> HashQualifiedName
[$sel:namedTerm:FoundTerm] :: FoundTerm -> NamedTerm
data FoundType
FoundType :: HashQualifiedName -> DisplayObject SyntaxText SyntaxText -> NamedType -> FoundType
[$sel:bestFoundTypeName:FoundType] :: FoundType -> HashQualifiedName
[$sel:typeDef:FoundType] :: FoundType -> DisplayObject SyntaxText SyntaxText
[$sel:namedType:FoundType] :: FoundType -> NamedType
data FoundResult
FoundTermResult :: FoundTerm -> FoundResult
FoundTypeResult :: FoundType -> FoundResult
serveFuzzyFind :: forall m. MonadIO m => Codebase m Symbol Ann -> Either ShortCausalHash CausalHash -> Maybe Path -> Maybe Int -> Maybe Width -> Maybe String -> Backend m [(Alignment, FoundResult)]
instance GHC.Show.Show Unison.Server.Local.Endpoints.FuzzyFind.FoundTerm
instance GHC.Generics.Generic Unison.Server.Local.Endpoints.FuzzyFind.FoundTerm
instance GHC.Show.Show Unison.Server.Local.Endpoints.FuzzyFind.FoundType
instance GHC.Generics.Generic Unison.Server.Local.Endpoints.FuzzyFind.FoundType
instance GHC.Show.Show Unison.Server.Local.Endpoints.FuzzyFind.FoundResult
instance GHC.Generics.Generic Unison.Server.Local.Endpoints.FuzzyFind.FoundResult
instance Data.OpenApi.Internal.Schema.ToSchema Text.FuzzyFind.Alignment
instance Data.OpenApi.Internal.Schema.ToSchema Text.FuzzyFind.Result
instance Data.OpenApi.Internal.Schema.ToSchema Text.FuzzyFind.ResultSegment
instance Data.OpenApi.Internal.Schema.ToSchema Unison.Server.Local.Endpoints.FuzzyFind.FoundType
instance Data.OpenApi.Internal.Schema.ToSchema Unison.Server.Local.Endpoints.FuzzyFind.FoundTerm
instance Data.OpenApi.Internal.Schema.ToSchema Unison.Server.Local.Endpoints.FuzzyFind.FoundResult
instance Data.Aeson.Types.ToJSON.ToJSON Unison.Server.Local.Endpoints.FuzzyFind.FoundResult
instance Servant.Docs.Internal.ToSample Unison.Server.Local.Endpoints.FuzzyFind.FoundResult
instance Data.Aeson.Types.ToJSON.ToJSON Unison.Server.Local.Endpoints.FuzzyFind.FoundType
instance Data.Aeson.Types.ToJSON.ToJSON Unison.Server.Local.Endpoints.FuzzyFind.FoundTerm
instance Servant.Docs.Internal.ToSample Text.FuzzyFind.Alignment
instance Servant.Docs.Internal.ToParam (Servant.API.QueryParam.QueryParam "limit" GHC.Types.Int)
instance Servant.Docs.Internal.ToParam (Servant.API.QueryParam.QueryParam "query" GHC.Base.String)
instance Data.Aeson.Types.ToJSON.ToJSON Text.FuzzyFind.Alignment
instance Data.Aeson.Types.ToJSON.ToJSON Text.FuzzyFind.Result
instance Data.Aeson.Types.ToJSON.ToJSON Text.FuzzyFind.ResultSegment

module Unison.Server.Local.Endpoints.DefinitionSummary
type TermSummaryAPI = "definitions" :> "terms" :> "by-hash" :> Capture "hash" Referent :> "summary" :> QueryParam "name" Name :> QueryParam "relativeTo" Path :> QueryParam "renderWidth" Width :> APIGet TermSummary
serveTermSummary :: Codebase IO Symbol Ann -> Referent -> Maybe Name -> Either ShortCausalHash CausalHash -> Maybe Path -> Maybe Width -> Backend IO TermSummary
data TermSummary
TermSummary :: HashQualified Name -> ShortHash -> DisplayObject SyntaxText SyntaxText -> TermTag -> TermSummary
[$sel:displayName:TermSummary] :: TermSummary -> HashQualified Name
[$sel:hash:TermSummary] :: TermSummary -> ShortHash
[$sel:summary:TermSummary] :: TermSummary -> DisplayObject SyntaxText SyntaxText
[$sel:tag:TermSummary] :: TermSummary -> TermTag
type TypeSummaryAPI = "definitions" :> "types" :> "by-hash" :> Capture "hash" Reference :> "summary" :> QueryParam "name" Name :> QueryParam "relativeTo" Path :> QueryParam "renderWidth" Width :> APIGet TypeSummary
serveTypeSummary :: Codebase IO Symbol Ann -> Reference -> Maybe Name -> Either ShortCausalHash CausalHash -> Maybe Path -> Maybe Width -> Backend IO TypeSummary
data TypeSummary
TypeSummary :: HashQualified Name -> ShortHash -> DisplayObject SyntaxText SyntaxText -> TypeTag -> TypeSummary
[$sel:displayName:TypeSummary] :: TypeSummary -> HashQualified Name
[$sel:hash:TypeSummary] :: TypeSummary -> ShortHash
[$sel:summary:TypeSummary] :: TypeSummary -> DisplayObject SyntaxText SyntaxText
[$sel:tag:TypeSummary] :: TypeSummary -> TypeTag
instance GHC.Show.Show Unison.Server.Local.Endpoints.DefinitionSummary.TermSummary
instance GHC.Generics.Generic Unison.Server.Local.Endpoints.DefinitionSummary.TermSummary
instance GHC.Show.Show Unison.Server.Local.Endpoints.DefinitionSummary.TypeSummary
instance GHC.Generics.Generic Unison.Server.Local.Endpoints.DefinitionSummary.TypeSummary
instance Data.OpenApi.Internal.Schema.ToSchema Unison.Server.Local.Endpoints.DefinitionSummary.TermSummary
instance Data.OpenApi.Internal.Schema.ToSchema Unison.Server.Local.Endpoints.DefinitionSummary.TypeSummary
instance Servant.Docs.Internal.ToSample Unison.Server.Local.Endpoints.DefinitionSummary.TypeSummary
instance Data.Aeson.Types.ToJSON.ToJSON Unison.Server.Local.Endpoints.DefinitionSummary.TypeSummary
instance Servant.Docs.Internal.ToSample Unison.Server.Local.Endpoints.DefinitionSummary.TermSummary
instance Data.Aeson.Types.ToJSON.ToJSON Unison.Server.Local.Endpoints.DefinitionSummary.TermSummary

module Unison.Server.Local.Endpoints.Current
type CurrentEndpoint = "current" :> APIGet Current
data Current
Current :: Maybe ProjectName -> Maybe ProjectBranchName -> Absolute -> Current
[$sel:project:Current] :: Current -> Maybe ProjectName
[$sel:branch:Current] :: Current -> Maybe ProjectBranchName
[$sel:path:Current] :: Current -> Absolute
serveCurrent :: MonadIO m => Codebase m v a -> Backend m Current
getCurrentProjectBranch :: MonadIO m => Codebase m v a -> m Current
instance Data.OpenApi.Internal.Schema.ToSchema Unison.Server.Local.Endpoints.Current.Current
instance GHC.Show.Show Unison.Server.Local.Endpoints.Current.Current
instance GHC.Generics.Generic Unison.Server.Local.Endpoints.Current.Current
instance Servant.Docs.Internal.ToSample Unison.Server.Local.Endpoints.Current.Current
instance Data.Aeson.Types.ToJSON.ToJSON Unison.Server.Local.Endpoints.Current.Current

module Unison.Server.Local.Endpoints.UCM
type UCMAPI = CurrentEndpoint
ucmServer :: MonadIO m => Codebase m v a -> Backend m Current


-- | Helpers which are specific to the local share server.
module Unison.Server.Local

-- | Given an arbitrary query and perspective, find the name root the query
--   belongs in, then return that root and the query relocated to that
--   root.
--   
--   A name root is either a project root or a dependency root. E.g.
--   <tt>.myproject.some.namespace -&gt; .myproject</tt> or
--   <tt>.myproject.lib.base.List -&gt; .myproject.lib.base</tt>
relocateToNameRoot :: Path -> HashQualified Name -> Branch Transaction -> Transaction (Either BackendError (Path, HashQualified Name))

module Unison.Server.Local.Definitions

-- | Renders a definition for the given name or hash alongside its
--   documentation.
prettyDefinitionsForHQName :: Path -> CausalBranch Transaction -> Maybe Width -> Suffixify -> Runtime Symbol -> Codebase IO Symbol Ann -> HashQualified Name -> Backend IO DefinitionDisplayResults
termDefinitionByName :: Codebase IO Symbol Ann -> PrettyPrintEnvDecl -> NameSearch Transaction -> Width -> Runtime Symbol -> Name -> Backend IO (Maybe TermDefinition)
typeDefinitionByName :: Codebase IO Symbol Ann -> PrettyPrintEnvDecl -> NameSearch Transaction -> Width -> Runtime Symbol -> Name -> Backend IO (Maybe TypeDefinition)

module Unison.Server.Local.Endpoints.GetDefinitions
type DefinitionsAPI = "getDefinition" :> QueryParam "relativeTo" Path :> QueryParams "names" (HashQualified Name) :> QueryParam "renderWidth" Width :> QueryParam "suffixifyBindings" Suffixify :> APIGet DefinitionDisplayResults
serveDefinitions :: Runtime Symbol -> Codebase IO Symbol Ann -> Either ShortCausalHash CausalHash -> Maybe Path -> [HashQualified Name] -> Maybe Width -> Maybe Suffixify -> Backend IO DefinitionDisplayResults
instance Servant.Docs.Internal.ToParam (Servant.API.QueryParam.QueryParam "renderWidth" Unison.Util.Pretty.Width)
instance Servant.Docs.Internal.ToParam (Servant.API.QueryParam.QueryParam "suffixifyBindings" Unison.Server.Types.Suffixify)
instance Servant.Docs.Internal.ToParam (Servant.API.QueryParam.QueryParam "relativeTo" Unison.Codebase.Path.Path)
instance Servant.Docs.Internal.ToParam (Servant.API.QueryParam.QueryParam "namespace" Unison.Codebase.Path.Path)
instance Servant.Docs.Internal.ToParam (Servant.API.QueryParam.QueryParams "names" (Unison.HashQualified.HashQualified Unison.Name.Internal.Name))
instance Servant.Docs.Internal.ToSample Unison.Server.Types.DefinitionDisplayResults

module Unison.Server.Errors
badHQN :: HashQualifiedName -> ServerError
backendError :: BackendError -> ServerError
badNamespace :: String -> String -> ServerError
noSuchNamespace :: HashQualifiedName -> ServerError
couldntLoadBranch :: CausalHash -> ServerError
ambiguousNamespace :: HashQualifiedName -> Set HashQualifiedName -> ServerError
missingSigForTerm :: HashQualifiedName -> ServerError
noSuchDefinition :: HashQualified Name -> ServerError
ambiguousHashForDefinition :: ShortHash -> ServerError
expectedNameLookup :: BranchHash -> ServerError
disjointProjectAndPerspective :: Path -> Path -> ServerError
projectBranchNameNotFound :: ProjectName -> ProjectBranchName -> ServerError

module Unison.Server.CodebaseServer
data HTML
HTML :: HTML
newtype RawHtml
RawHtml :: ByteString -> RawHtml
[$sel:unRaw:RawHtml] :: RawHtml -> ByteString
type OpenApiJSON = "openapi.json" :> Get '[JSON] OpenApi
type UnisonAndDocsAPI = UnisonLocalAPI :<|> OpenApiJSON :<|> Raw
type UnisonLocalAPI = ("projects" :> ProjectsAPI) :<|> ("ucm" :> UCMAPI)
type CodebaseServerAPI = NamespaceListingAPI :<|> NamespaceDetailsAPI :<|> DefinitionsAPI :<|> FuzzyFindAPI :<|> TermSummaryAPI :<|> TypeSummaryAPI
type ProjectsAPI = ListProjectsEndpoint :<|> (Capture "project-name" ProjectName :> (("branches" :> (ListProjectBranchesEndpoint :<|> (Capture "branch-name" ProjectBranchName :> CodebaseServerAPI))) :<|> ("diff" :> ("terms" :> ProjectDiffTermsEndpoint :<|> "types" :> ProjectDiffTypesEndpoint))))
type ProjectDiffTermsEndpoint = RequiredQueryParam "oldBranchRef" ProjectBranchName :> RequiredQueryParam "newBranchRef" ProjectBranchName :> RequiredQueryParam "oldTerm" Name :> RequiredQueryParam "newTerm" Name :> Get '[JSON] TermDiffResponse
type ProjectDiffTypesEndpoint = RequiredQueryParam "oldBranchRef" ProjectBranchName :> RequiredQueryParam "newBranchRef" ProjectBranchName :> RequiredQueryParam "oldType" Name :> RequiredQueryParam "newType" Name :> Get '[JSON] TypeDiffResponse
type WebUI = CaptureAll "route" Text :> Get '[HTML] RawHtml
type ServerAPI = ("ui" :> WebUI) :<|> ("api" :> UnisonAndDocsAPI)
type StaticAPI = "static" :> Raw
type Authed api = (Capture "token" Text :> api)
type AppAPI = StaticAPI :<|> Authed ServerAPI
data BaseUrl
BaseUrl :: String -> ByteString -> Port -> BaseUrl
[$sel:urlHost:BaseUrl] :: BaseUrl -> String
[$sel:urlToken:BaseUrl] :: BaseUrl -> ByteString
[$sel:urlPort:BaseUrl] :: BaseUrl -> Port
data DefinitionReference
TermReference :: HashQualified Name -> DefinitionReference
TypeReference :: HashQualified Name -> DefinitionReference
AbilityConstructorReference :: HashQualified Name -> DefinitionReference
DataConstructorReference :: HashQualified Name -> DefinitionReference
data Service
ProjectBranchUI :: ProjectAndBranch ProjectName ProjectBranchName -> Absolute -> Maybe DefinitionReference -> Service
Api :: Service
data URISegment
EscapeMe :: Text -> URISegment
DontEscape :: Text -> URISegment

-- | Create a Service URL, either for the UI or the API
--   
--   Examples:
--   
--   <pre>
--   &gt;&gt;&gt; urlFor Api (BaseUrl{ urlHost = "http://localhost", urlToken = "asdf", urlPort = 1234 })
--   "http://localhost:1234/asdf/api"
--   </pre>
--   
--   Loose code with definition but no perspective &gt;&gt;&gt; import
--   qualified Unison.Syntax.Name as Name &gt;&gt;&gt; let service =
--   LooseCodeUI (Path.absoluteEmpty) (Just (TermReference (NameOnly
--   (Name.unsafeFromText "base.data.List.map")))) &gt;&gt;&gt; let baseUrl
--   = (BaseUrl{ urlHost = "<a>http://localhost"</a>, urlToken = "asdf",
--   urlPort = 1234 }) &gt;&gt;&gt; urlFor service baseUrl
--   "<a>http://localhost:1234/asdf/ui/non-project-code/latest/terms/base/data/List/map"</a>
--   
--   Loose code with definition and perspective &gt;&gt;&gt; import
--   qualified Unison.Syntax.Name as Name &gt;&gt;&gt; let service =
--   LooseCodeUI (Path.Absolute (Path.fromText "base.data")) (Just
--   (TermReference (NameOnly (Name.unsafeFromText "List.map"))))
--   &gt;&gt;&gt; let baseUrl = (BaseUrl{ urlHost =
--   "<a>http://localhost"</a>, urlToken = "asdf", urlPort = 1234 })
--   &gt;&gt;&gt; urlFor service baseUrl
--   "<a>http://localhost:1234/asdf/ui/non-project-code/latest/namespaces/base/data/;/terms/List/map"</a>
--   
--   Project with definition but no perspective &gt;&gt;&gt; import
--   qualified Unison.Syntax.Name as Name &gt;&gt;&gt; import
--   Unison.Core.Project (ProjectName (..), ProjectBranchName (..),
--   ProjectAndBranch (..)) &gt;&gt;&gt; let service = ProjectBranchUI
--   (ProjectAndBranch (UnsafeProjectName "base") (UnsafeProjectBranchName
--   "main")) (Path.empty) (Just (TermReference (NameOnly
--   (Name.unsafeFromText "List.map")))) &gt;&gt;&gt; let baseUrl =
--   (BaseUrl{ urlHost = "<a>http://localhost"</a>, urlToken = "asdf",
--   urlPort = 1234 }) &gt;&gt;&gt; urlFor service baseUrl
--   "<a>http://localhost:1234/asdf/ui/projects/base/main/latest/terms/List/map"</a>
--   
--   Project with definition but no perspective, contributor branch
--   &gt;&gt;&gt; import qualified Unison.Syntax.Name as Name &gt;&gt;&gt;
--   import Unison.Core.Project (ProjectName (..), ProjectBranchName (..),
--   ProjectAndBranch (..)) &gt;&gt;&gt; let service = ProjectBranchUI
--   (ProjectAndBranch (UnsafeProjectName "<tt>unison/base")
--   (UnsafeProjectBranchName "</tt>runarorama/contribution")) (Path.empty)
--   (Just (TermReference (NameOnly (Name.unsafeFromText "List.map"))))
--   &gt;&gt;&gt; let baseUrl = (BaseUrl{ urlHost =
--   "<a>http://localhost"</a>, urlToken = "asdf", urlPort = 1234 })
--   &gt;&gt;&gt; urlFor service baseUrl
--   "<a>http://localhost:1234/asdf/ui/projects/@unison/base/@runarorama/contribution/latest/terms/List/map"</a>
--   
--   Project with definition and perspective &gt;&gt;&gt; import qualified
--   Unison.Syntax.Name as Name &gt;&gt;&gt; import Unison.Core.Project
--   (ProjectName (..), ProjectBranchName (..), ProjectAndBranch (..))
--   &gt;&gt;&gt; let service = ProjectBranchUI (ProjectAndBranch
--   (UnsafeProjectName "<tt>unison/base") (UnsafeProjectBranchName
--   "</tt>runarorama/contribution")) (Path.fromList ["data"]) (Just
--   (TermReference (NameOnly (Name.unsafeFromText "List.map"))))
--   &gt;&gt;&gt; let baseUrl = (BaseUrl{ urlHost =
--   "<a>http://localhost"</a>, urlToken = "asdf", urlPort = 1234 })
--   &gt;&gt;&gt; urlFor service baseUrl
--   "<a>http://localhost:1234/asdf/ui/projects/@unison/base/@runarorama/contribution/latest/namespaces/data/;/terms/List/map"</a>
urlFor :: Service -> BaseUrl -> Text
handleAuth :: ByteString -> Text -> Handler ()
openAPI :: OpenApi
infoObject :: Info
docsBS :: ByteString
unisonAndDocsAPI :: Proxy UnisonAndDocsAPI
api :: Proxy UnisonLocalAPI
serverAPI :: Proxy ServerAPI
appAPI :: Proxy AppAPI
app :: BackendEnv -> Runtime Symbol -> Codebase IO Symbol Ann -> FilePath -> ByteString -> Maybe String -> Application

-- | The Token is used to help prevent multiple users on a machine gain
--   access to each others codebases.
--   
--   Generate a cryptographically secure random token.
--   <a>https://neilmadden.blog/2018/08/30/moving-away-from-uuids/</a>
--   
--   E.g. &gt;&gt;&gt; genToken "uxf85C7Y0B6om47"
genToken :: IO ByteString
data Waiter a
Waiter :: (a -> IO ()) -> IO a -> Waiter a
[$sel:notify:Waiter] :: Waiter a -> a -> IO ()
[$sel:waitFor:Waiter] :: Waiter a -> IO a
mkWaiter :: IO (Waiter a)
ucmUIVar :: String
ucmPortVar :: String
ucmHostVar :: String
ucmAllowCorsHost :: String
ucmTokenVar :: String
data CodebaseServerOpts
CodebaseServerOpts :: Maybe String -> Maybe String -> Maybe Int -> Maybe String -> Maybe FilePath -> CodebaseServerOpts
[$sel:token:CodebaseServerOpts] :: CodebaseServerOpts -> Maybe String
[$sel:host:CodebaseServerOpts] :: CodebaseServerOpts -> Maybe String
[$sel:port:CodebaseServerOpts] :: CodebaseServerOpts -> Maybe Int
[$sel:allowCorsHost:CodebaseServerOpts] :: CodebaseServerOpts -> Maybe String
[$sel:codebaseUIPath:CodebaseServerOpts] :: CodebaseServerOpts -> Maybe FilePath
defaultCodebaseServerOpts :: CodebaseServerOpts
startServer :: BackendEnv -> CodebaseServerOpts -> Runtime Symbol -> Codebase IO Symbol Ann -> (BaseUrl -> IO a) -> IO a
serveIndex :: FilePath -> Handler RawHtml
serveUI :: FilePath -> Server WebUI
corsPolicy :: Maybe String -> Middleware
server :: BackendEnv -> Runtime Symbol -> Codebase IO Symbol Ann -> FilePath -> ByteString -> Server AppAPI
serveUnisonAndDocs :: BackendEnv -> Runtime Symbol -> Codebase IO Symbol Ann -> Server UnisonAndDocsAPI
serveDocs :: Application
serveOpenAPI :: Handler OpenApi
hoistWithAuth :: forall api. HasServer api '[] => Proxy api -> ByteString -> ServerT api Handler -> ServerT (Authed api) Handler
serveProjectsCodebaseServerAPI :: Codebase IO Symbol Ann -> Runtime Symbol -> ProjectName -> ProjectBranchName -> ServerT CodebaseServerAPI (Backend IO)
resolveProjectRoot :: Codebase IO v a -> ProjectAndBranch ProjectName ProjectBranchName -> Backend IO (CausalBranch Transaction)
resolveProjectRootHash :: Codebase IO v a -> ProjectAndBranch ProjectName ProjectBranchName -> Backend IO CausalHash
serveProjectDiffTermsEndpoint :: Codebase IO Symbol Ann -> Runtime Symbol -> ProjectName -> ProjectBranchName -> ProjectBranchName -> Name -> Name -> Backend IO TermDiffResponse
contextForProjectBranch :: Codebase IO v a -> ProjectName -> ProjectBranchName -> Backend IO (PrettyPrintEnvDecl, NameSearch Transaction)
serveProjectDiffTypesEndpoint :: Codebase IO Symbol Ann -> Runtime Symbol -> ProjectName -> ProjectBranchName -> ProjectBranchName -> Name -> Name -> Backend IO TypeDiffResponse
serveProjectsAPI :: Codebase IO Symbol Ann -> Runtime Symbol -> ServerT ProjectsAPI (Backend IO)
serveUnisonLocal :: BackendEnv -> Codebase IO Symbol Ann -> Runtime Symbol -> Server UnisonLocalAPI
backendHandler :: BackendEnv -> Backend IO a -> Handler a
instance GHC.Show.Show Unison.Server.CodebaseServer.DefinitionReference
instance GHC.Show.Show Unison.Server.CodebaseServer.Service
instance GHC.Show.Show Unison.Server.CodebaseServer.URISegment
instance GHC.Classes.Eq Unison.Server.CodebaseServer.CodebaseServerOpts
instance GHC.Show.Show Unison.Server.CodebaseServer.CodebaseServerOpts
instance GHC.Show.Show Unison.Server.CodebaseServer.BaseUrl
instance Servant.API.ContentTypes.MimeRender Unison.Server.CodebaseServer.HTML Unison.Server.CodebaseServer.RawHtml
instance Servant.API.ContentTypes.Accept Unison.Server.CodebaseServer.HTML
instance Servant.Docs.Internal.ToParam (Servant.API.QueryParam.QueryParam' mods "oldBranchRef" a)
instance Servant.Docs.Internal.ToParam (Servant.API.QueryParam.QueryParam' mods "newBranchRef" a)
instance Servant.Docs.Internal.ToParam (Servant.API.QueryParam.QueryParam' mods "oldTerm" a)
instance Servant.Docs.Internal.ToParam (Servant.API.QueryParam.QueryParam' mods "newTerm" a)
instance Servant.Docs.Internal.ToParam (Servant.API.QueryParam.QueryParam' mods "oldType" a)
instance Servant.Docs.Internal.ToParam (Servant.API.QueryParam.QueryParam' mods "newType" a)
instance Servant.Docs.Internal.ToSample GHC.Types.Char

module Unison.Sync.Types

-- | A newtype for JSON encoding binary data.
newtype Base64Bytes
Base64Bytes :: ByteString -> Base64Bytes
newtype RepoInfo
RepoInfo :: Text -> RepoInfo
[$sel:unRepoInfo:RepoInfo] :: RepoInfo -> Text
data Path
Path :: NonEmpty Text -> Path
[$sel:pathSegments:Path] :: Path -> NonEmpty Text

-- | Convert a path like arya.public.mystuff to a "repo info" by treating
--   the first segment as a user handle.
pathRepoInfo :: Path -> RepoInfo
pathCodebasePath :: Path -> [Text]
data Entity text noSyncHash hash
TC :: TermComponent text hash -> Entity text noSyncHash hash
DC :: DeclComponent text hash -> Entity text noSyncHash hash
P :: Patch text noSyncHash hash -> Entity text noSyncHash hash
PD :: PatchDiff text noSyncHash hash -> Entity text noSyncHash hash
N :: Namespace text hash -> Entity text noSyncHash hash
ND :: NamespaceDiff text hash -> Entity text noSyncHash hash
C :: Causal hash -> Entity text noSyncHash hash
data TermComponent text hash
TermComponent :: [(LocalIds text hash, ByteString)] -> TermComponent text hash
data DeclComponent text hash
DeclComponent :: [(LocalIds text hash, ByteString)] -> DeclComponent text hash
data Patch text oldHash newHash
Patch :: [text] -> [oldHash] -> [newHash] -> ByteString -> Patch text oldHash newHash
[$sel:textLookup:Patch] :: Patch text oldHash newHash -> [text]
[$sel:oldHashLookup:Patch] :: Patch text oldHash newHash -> [oldHash]
[$sel:newHashLookup:Patch] :: Patch text oldHash newHash -> [newHash]
[$sel:bytes:Patch] :: Patch text oldHash newHash -> ByteString
data PatchDiff text oldHash hash
PatchDiff :: hash -> [text] -> [oldHash] -> [hash] -> ByteString -> PatchDiff text oldHash hash
[$sel:parent:PatchDiff] :: PatchDiff text oldHash hash -> hash
[$sel:textLookup:PatchDiff] :: PatchDiff text oldHash hash -> [text]
[$sel:oldHashLookup:PatchDiff] :: PatchDiff text oldHash hash -> [oldHash]
[$sel:newHashLookup:PatchDiff] :: PatchDiff text oldHash hash -> [hash]
[$sel:bytes:PatchDiff] :: PatchDiff text oldHash hash -> ByteString
data Namespace text hash
Namespace :: [text] -> [hash] -> [hash] -> [(hash, hash)] -> LocalBranchBytes -> Namespace text hash
[$sel:textLookup:Namespace] :: Namespace text hash -> [text]
[$sel:defnLookup:Namespace] :: Namespace text hash -> [hash]
[$sel:patchLookup:Namespace] :: Namespace text hash -> [hash]
[$sel:childLookup:Namespace] :: Namespace text hash -> [(hash, hash)]
[$sel:bytes:Namespace] :: Namespace text hash -> LocalBranchBytes
data NamespaceDiff text hash
NamespaceDiff :: hash -> [text] -> [hash] -> [hash] -> [(hash, hash)] -> LocalBranchBytes -> NamespaceDiff text hash
[$sel:parent:NamespaceDiff] :: NamespaceDiff text hash -> hash
[$sel:textLookup:NamespaceDiff] :: NamespaceDiff text hash -> [text]
[$sel:defnLookup:NamespaceDiff] :: NamespaceDiff text hash -> [hash]
[$sel:patchLookup:NamespaceDiff] :: NamespaceDiff text hash -> [hash]
[$sel:childLookup:NamespaceDiff] :: NamespaceDiff text hash -> [(hash, hash)]
[$sel:bytes:NamespaceDiff] :: NamespaceDiff text hash -> LocalBranchBytes
data Causal hash
Causal :: hash -> Set hash -> Causal hash
[$sel:namespaceHash:Causal] :: Causal hash -> hash
[$sel:parents:Causal] :: Causal hash -> Set hash
data LocalIds text hash
LocalIds :: [text] -> [hash] -> LocalIds text hash
[$sel:texts:LocalIds] :: LocalIds text hash -> [text]
[$sel:hashes:LocalIds] :: LocalIds text hash -> [hash]

-- | Get the direct dependencies of an entity (which are actually sync'd).
--   
--   FIXME use generic-lens here? (typed @hash)
entityDependencies :: Ord hash => Entity text noSyncHash hash -> Set hash
data EntityType
TermComponentType :: EntityType
DeclComponentType :: EntityType
PatchType :: EntityType
PatchDiffType :: EntityType
NamespaceType :: EntityType
NamespaceDiffType :: EntityType
CausalType :: EntityType
entityHashes_ :: (Applicative m, Ord hash') => (hash -> m hash') -> Entity text noSyncHash hash -> m (Entity text noSyncHash hash')
patchOldHashes_ :: Applicative m => (oldHash -> m oldHash') -> Patch text oldHash newHash -> m (Patch text oldHash' newHash)
patchNewHashes_ :: Applicative m => (newHash -> m newHash') -> Patch text oldHash newHash -> m (Patch text oldHash newHash')
patchDiffHashes_ :: Applicative m => (hash -> m hash') -> PatchDiff text noSyncHash hash -> m (PatchDiff text noSyncHash hash')
namespaceDiffHashes_ :: Applicative m => (hash -> m hash') -> NamespaceDiff text hash -> m (NamespaceDiff text hash')
causalHashes_ :: (Applicative m, Ord hash') => (hash -> m hash') -> Causal hash -> m (Causal hash')
newtype GetCausalHashByPathRequest
GetCausalHashByPathRequest :: Path -> GetCausalHashByPathRequest
[$sel:path:GetCausalHashByPathRequest] :: GetCausalHashByPathRequest -> Path
data GetCausalHashByPathResponse
GetCausalHashByPathSuccess :: Maybe HashJWT -> GetCausalHashByPathResponse
GetCausalHashByPathNoReadPermission :: Path -> GetCausalHashByPathResponse
GetCausalHashByPathUserNotFound :: GetCausalHashByPathResponse
GetCausalHashByPathInvalidRepoInfo :: Text -> RepoInfo -> GetCausalHashByPathResponse
data DownloadEntitiesRequest
DownloadEntitiesRequest :: RepoInfo -> NESet HashJWT -> DownloadEntitiesRequest
[$sel:repoInfo:DownloadEntitiesRequest] :: DownloadEntitiesRequest -> RepoInfo
[$sel:hashes:DownloadEntitiesRequest] :: DownloadEntitiesRequest -> NESet HashJWT
data DownloadEntitiesResponse
DownloadEntitiesSuccess :: NEMap Hash32 (Entity Text Hash32 HashJWT) -> DownloadEntitiesResponse
DownloadEntitiesFailure :: DownloadEntitiesError -> DownloadEntitiesResponse
data DownloadEntitiesError
DownloadEntitiesNoReadPermission :: RepoInfo -> DownloadEntitiesError

-- | msg, repoInfo
DownloadEntitiesInvalidRepoInfo :: Text -> RepoInfo -> DownloadEntitiesError

-- | userHandle
DownloadEntitiesUserNotFound :: Text -> DownloadEntitiesError

-- | project shorthand
DownloadEntitiesProjectNotFound :: Text -> DownloadEntitiesError
DownloadEntitiesEntityValidationFailure :: EntityValidationError -> DownloadEntitiesError
data UploadEntitiesRequest
UploadEntitiesRequest :: RepoInfo -> NEMap Hash32 (Entity Text Hash32 Hash32) -> UploadEntitiesRequest
[$sel:repoInfo:UploadEntitiesRequest] :: UploadEntitiesRequest -> RepoInfo
[$sel:entities:UploadEntitiesRequest] :: UploadEntitiesRequest -> NEMap Hash32 (Entity Text Hash32 Hash32)
data UploadEntitiesResponse
UploadEntitiesSuccess :: UploadEntitiesResponse
UploadEntitiesFailure :: UploadEntitiesError -> UploadEntitiesResponse
data UploadEntitiesError
UploadEntitiesError'EntityValidationFailure :: EntityValidationError -> UploadEntitiesError
UploadEntitiesError'HashMismatchForEntity :: HashMismatchForEntity -> UploadEntitiesError

-- | msg, repoInfo
UploadEntitiesError'InvalidRepoInfo :: Text -> RepoInfo -> UploadEntitiesError
UploadEntitiesError'NeedDependencies :: NeedDependencies Hash32 -> UploadEntitiesError
UploadEntitiesError'NoWritePermission :: RepoInfo -> UploadEntitiesError

-- | project shorthand
UploadEntitiesError'ProjectNotFound :: Text -> UploadEntitiesError

-- | userHandle
UploadEntitiesError'UserNotFound :: Text -> UploadEntitiesError
data HashMismatchForEntity
HashMismatchForEntity :: Hash32 -> Hash32 -> HashMismatchForEntity
[$sel:supplied:HashMismatchForEntity] :: HashMismatchForEntity -> Hash32
[$sel:computed:HashMismatchForEntity] :: HashMismatchForEntity -> Hash32
data InvalidParentage
InvalidParentage :: Hash32 -> Hash32 -> InvalidParentage
[$sel:parent:InvalidParentage] :: InvalidParentage -> Hash32
[$sel:child:InvalidParentage] :: InvalidParentage -> Hash32
data NeedDependencies hash
NeedDependencies :: NESet hash -> NeedDependencies hash
[$sel:missingDependencies:NeedDependencies] :: NeedDependencies hash -> NESet hash

-- | The ways in which validating an entity may fail.
data EntityValidationError
EntityHashMismatch :: EntityType -> HashMismatchForEntity -> EntityValidationError
UnsupportedEntityType :: Hash32 -> EntityType -> EntityValidationError
InvalidByteEncoding :: Hash32 -> EntityType -> Text -> EntityValidationError
HashResolutionFailure :: Hash32 -> EntityValidationError
instance Data.Aeson.Types.FromJSON.FromJSON Unison.Sync.Types.RepoInfo
instance Data.Aeson.Types.ToJSON.ToJSON Unison.Sync.Types.RepoInfo
instance GHC.Classes.Ord Unison.Sync.Types.RepoInfo
instance GHC.Classes.Eq Unison.Sync.Types.RepoInfo
instance GHC.Show.Show Unison.Sync.Types.RepoInfo
instance GHC.Classes.Ord Unison.Sync.Types.Path
instance GHC.Classes.Eq Unison.Sync.Types.Path
instance GHC.Show.Show Unison.Sync.Types.Path
instance (GHC.Classes.Ord text, GHC.Classes.Ord hash) => GHC.Classes.Ord (Unison.Sync.Types.LocalIds text hash)
instance GHC.Base.Functor (Unison.Sync.Types.LocalIds text)
instance (GHC.Classes.Eq text, GHC.Classes.Eq hash) => GHC.Classes.Eq (Unison.Sync.Types.LocalIds text hash)
instance (GHC.Show.Show text, GHC.Show.Show hash) => GHC.Show.Show (Unison.Sync.Types.LocalIds text hash)
instance (GHC.Classes.Ord text, GHC.Classes.Ord hash) => GHC.Classes.Ord (Unison.Sync.Types.DeclComponent text hash)
instance GHC.Base.Functor (Unison.Sync.Types.DeclComponent text)
instance (GHC.Classes.Eq text, GHC.Classes.Eq hash) => GHC.Classes.Eq (Unison.Sync.Types.DeclComponent text hash)
instance (GHC.Show.Show text, GHC.Show.Show hash) => GHC.Show.Show (Unison.Sync.Types.DeclComponent text hash)
instance (GHC.Classes.Ord text, GHC.Classes.Ord hash) => GHC.Classes.Ord (Unison.Sync.Types.TermComponent text hash)
instance GHC.Base.Functor (Unison.Sync.Types.TermComponent text)
instance (GHC.Classes.Eq text, GHC.Classes.Eq hash) => GHC.Classes.Eq (Unison.Sync.Types.TermComponent text hash)
instance (GHC.Show.Show text, GHC.Show.Show hash) => GHC.Show.Show (Unison.Sync.Types.TermComponent text hash)
instance (GHC.Classes.Ord text, GHC.Classes.Ord oldHash, GHC.Classes.Ord newHash) => GHC.Classes.Ord (Unison.Sync.Types.Patch text oldHash newHash)
instance (GHC.Classes.Eq text, GHC.Classes.Eq oldHash, GHC.Classes.Eq newHash) => GHC.Classes.Eq (Unison.Sync.Types.Patch text oldHash newHash)
instance (GHC.Show.Show text, GHC.Show.Show oldHash, GHC.Show.Show newHash) => GHC.Show.Show (Unison.Sync.Types.Patch text oldHash newHash)
instance (GHC.Show.Show hash, GHC.Show.Show text, GHC.Show.Show oldHash) => GHC.Show.Show (Unison.Sync.Types.PatchDiff text oldHash hash)
instance (GHC.Classes.Ord hash, GHC.Classes.Ord text, GHC.Classes.Ord oldHash) => GHC.Classes.Ord (Unison.Sync.Types.PatchDiff text oldHash hash)
instance (GHC.Classes.Eq hash, GHC.Classes.Eq text, GHC.Classes.Eq oldHash) => GHC.Classes.Eq (Unison.Sync.Types.PatchDiff text oldHash hash)
instance (GHC.Show.Show text, GHC.Show.Show hash) => GHC.Show.Show (Unison.Sync.Types.Namespace text hash)
instance (GHC.Classes.Ord text, GHC.Classes.Ord hash) => GHC.Classes.Ord (Unison.Sync.Types.Namespace text hash)
instance GHC.Base.Functor (Unison.Sync.Types.Namespace text)
instance (GHC.Classes.Eq text, GHC.Classes.Eq hash) => GHC.Classes.Eq (Unison.Sync.Types.Namespace text hash)
instance (GHC.Show.Show hash, GHC.Show.Show text) => GHC.Show.Show (Unison.Sync.Types.NamespaceDiff text hash)
instance (GHC.Classes.Ord hash, GHC.Classes.Ord text) => GHC.Classes.Ord (Unison.Sync.Types.NamespaceDiff text hash)
instance (GHC.Classes.Eq hash, GHC.Classes.Eq text) => GHC.Classes.Eq (Unison.Sync.Types.NamespaceDiff text hash)
instance GHC.Show.Show hash => GHC.Show.Show (Unison.Sync.Types.Causal hash)
instance GHC.Classes.Ord hash => GHC.Classes.Ord (Unison.Sync.Types.Causal hash)
instance GHC.Classes.Eq hash => GHC.Classes.Eq (Unison.Sync.Types.Causal hash)
instance (GHC.Classes.Ord text, GHC.Classes.Ord noSyncHash, GHC.Classes.Ord hash) => GHC.Classes.Ord (Unison.Sync.Types.Entity text noSyncHash hash)
instance (GHC.Classes.Eq text, GHC.Classes.Eq noSyncHash, GHC.Classes.Eq hash) => GHC.Classes.Eq (Unison.Sync.Types.Entity text noSyncHash hash)
instance (GHC.Show.Show text, GHC.Show.Show noSyncHash, GHC.Show.Show hash) => GHC.Show.Show (Unison.Sync.Types.Entity text noSyncHash hash)
instance GHC.Show.Show Unison.Sync.Types.EntityType
instance GHC.Classes.Ord Unison.Sync.Types.EntityType
instance GHC.Classes.Eq Unison.Sync.Types.EntityType
instance GHC.Classes.Ord Unison.Sync.Types.GetCausalHashByPathRequest
instance GHC.Classes.Eq Unison.Sync.Types.GetCausalHashByPathRequest
instance GHC.Show.Show Unison.Sync.Types.GetCausalHashByPathRequest
instance GHC.Classes.Ord Unison.Sync.Types.GetCausalHashByPathResponse
instance GHC.Classes.Eq Unison.Sync.Types.GetCausalHashByPathResponse
instance GHC.Show.Show Unison.Sync.Types.GetCausalHashByPathResponse
instance GHC.Classes.Ord Unison.Sync.Types.DownloadEntitiesRequest
instance GHC.Classes.Eq Unison.Sync.Types.DownloadEntitiesRequest
instance GHC.Show.Show Unison.Sync.Types.DownloadEntitiesRequest
instance GHC.Classes.Ord Unison.Sync.Types.UploadEntitiesRequest
instance GHC.Classes.Eq Unison.Sync.Types.UploadEntitiesRequest
instance GHC.Show.Show Unison.Sync.Types.UploadEntitiesRequest
instance GHC.Classes.Ord Unison.Sync.Types.HashMismatchForEntity
instance GHC.Classes.Eq Unison.Sync.Types.HashMismatchForEntity
instance GHC.Show.Show Unison.Sync.Types.HashMismatchForEntity
instance GHC.Exception.Type.Exception Unison.Sync.Types.EntityValidationError
instance GHC.Classes.Ord Unison.Sync.Types.EntityValidationError
instance GHC.Classes.Eq Unison.Sync.Types.EntityValidationError
instance GHC.Show.Show Unison.Sync.Types.EntityValidationError
instance GHC.Show.Show Unison.Sync.Types.DownloadEntitiesError
instance GHC.Classes.Eq Unison.Sync.Types.DownloadEntitiesError
instance GHC.Show.Show Unison.Sync.Types.InvalidParentage
instance GHC.Classes.Ord hash => GHC.Classes.Ord (Unison.Sync.Types.NeedDependencies hash)
instance GHC.Classes.Eq hash => GHC.Classes.Eq (Unison.Sync.Types.NeedDependencies hash)
instance GHC.Show.Show hash => GHC.Show.Show (Unison.Sync.Types.NeedDependencies hash)
instance GHC.Classes.Ord Unison.Sync.Types.UploadEntitiesError
instance GHC.Classes.Eq Unison.Sync.Types.UploadEntitiesError
instance GHC.Show.Show Unison.Sync.Types.UploadEntitiesError
instance GHC.Classes.Ord Unison.Sync.Types.UploadEntitiesResponse
instance GHC.Classes.Eq Unison.Sync.Types.UploadEntitiesResponse
instance GHC.Show.Show Unison.Sync.Types.UploadEntitiesResponse
instance Data.Aeson.Types.ToJSON.ToJSON Unison.Sync.Types.UploadEntitiesResponse
instance Data.Aeson.Types.FromJSON.FromJSON Unison.Sync.Types.UploadEntitiesResponse
instance Data.Aeson.Types.ToJSON.ToJSON hash => Data.Aeson.Types.ToJSON.ToJSON (Unison.Sync.Types.NeedDependencies hash)
instance (Data.Aeson.Types.FromJSON.FromJSON hash, GHC.Classes.Ord hash) => Data.Aeson.Types.FromJSON.FromJSON (Unison.Sync.Types.NeedDependencies hash)
instance Data.Aeson.Types.ToJSON.ToJSON Unison.Sync.Types.InvalidParentage
instance Data.Aeson.Types.FromJSON.FromJSON Unison.Sync.Types.InvalidParentage
instance Data.Aeson.Types.ToJSON.ToJSON Unison.Sync.Types.DownloadEntitiesResponse
instance Data.Aeson.Types.FromJSON.FromJSON Unison.Sync.Types.DownloadEntitiesResponse
instance Data.Aeson.Types.ToJSON.ToJSON Unison.Sync.Types.EntityValidationError
instance Data.Aeson.Types.FromJSON.FromJSON Unison.Sync.Types.EntityValidationError
instance Data.Aeson.Types.ToJSON.ToJSON Unison.Sync.Types.HashMismatchForEntity
instance Data.Aeson.Types.FromJSON.FromJSON Unison.Sync.Types.HashMismatchForEntity
instance Data.Aeson.Types.ToJSON.ToJSON Unison.Sync.Types.UploadEntitiesRequest
instance Data.Aeson.Types.FromJSON.FromJSON Unison.Sync.Types.UploadEntitiesRequest
instance Data.Aeson.Types.ToJSON.ToJSON Unison.Sync.Types.DownloadEntitiesRequest
instance Data.Aeson.Types.FromJSON.FromJSON Unison.Sync.Types.DownloadEntitiesRequest
instance Data.Aeson.Types.ToJSON.ToJSON Unison.Sync.Types.GetCausalHashByPathResponse
instance Data.Aeson.Types.FromJSON.FromJSON Unison.Sync.Types.GetCausalHashByPathResponse
instance Data.Aeson.Types.ToJSON.ToJSON Unison.Sync.Types.GetCausalHashByPathRequest
instance Data.Aeson.Types.FromJSON.FromJSON Unison.Sync.Types.GetCausalHashByPathRequest
instance (Data.Aeson.Types.ToJSON.ToJSON text, Data.Aeson.Types.ToJSON.ToJSON noSyncHash, Data.Aeson.Types.ToJSON.ToJSON hash) => Data.Aeson.Types.ToJSON.ToJSON (Unison.Sync.Types.Entity text noSyncHash hash)
instance (Data.Aeson.Types.FromJSON.FromJSON text, Data.Aeson.Types.FromJSON.FromJSON noSyncHash, Data.Aeson.Types.FromJSON.FromJSON hash, GHC.Classes.Ord hash) => Data.Aeson.Types.FromJSON.FromJSON (Unison.Sync.Types.Entity text noSyncHash hash)
instance Data.Aeson.Types.ToJSON.ToJSON Unison.Sync.Types.EntityType
instance Data.Aeson.Types.FromJSON.FromJSON Unison.Sync.Types.EntityType
instance Data.Aeson.Types.ToJSON.ToJSON hash => Data.Aeson.Types.ToJSON.ToJSON (Unison.Sync.Types.Causal hash)
instance (Data.Aeson.Types.FromJSON.FromJSON hash, GHC.Classes.Ord hash) => Data.Aeson.Types.FromJSON.FromJSON (Unison.Sync.Types.Causal hash)
instance (Data.Aeson.Types.ToJSON.ToJSON text, Data.Aeson.Types.ToJSON.ToJSON hash) => Data.Aeson.Types.ToJSON.ToJSON (Unison.Sync.Types.NamespaceDiff text hash)
instance (Data.Aeson.Types.FromJSON.FromJSON text, Data.Aeson.Types.FromJSON.FromJSON hash) => Data.Aeson.Types.FromJSON.FromJSON (Unison.Sync.Types.NamespaceDiff text hash)
instance Data.Bifoldable.Bifoldable Unison.Sync.Types.Namespace
instance Data.Bifunctor.Bifunctor Unison.Sync.Types.Namespace
instance Data.Bitraversable.Bitraversable Unison.Sync.Types.Namespace
instance (Data.Aeson.Types.ToJSON.ToJSON text, Data.Aeson.Types.ToJSON.ToJSON hash) => Data.Aeson.Types.ToJSON.ToJSON (Unison.Sync.Types.Namespace text hash)
instance (Data.Aeson.Types.FromJSON.FromJSON text, Data.Aeson.Types.FromJSON.FromJSON hash) => Data.Aeson.Types.FromJSON.FromJSON (Unison.Sync.Types.Namespace text hash)
instance (Data.Aeson.Types.ToJSON.ToJSON text, Data.Aeson.Types.ToJSON.ToJSON oldHash, Data.Aeson.Types.ToJSON.ToJSON hash) => Data.Aeson.Types.ToJSON.ToJSON (Unison.Sync.Types.PatchDiff text oldHash hash)
instance (Data.Aeson.Types.FromJSON.FromJSON text, Data.Aeson.Types.FromJSON.FromJSON oldHash, Data.Aeson.Types.FromJSON.FromJSON hash) => Data.Aeson.Types.FromJSON.FromJSON (Unison.Sync.Types.PatchDiff text oldHash hash)
instance (Data.Aeson.Types.ToJSON.ToJSON text, Data.Aeson.Types.ToJSON.ToJSON oldHash, Data.Aeson.Types.ToJSON.ToJSON newHash) => Data.Aeson.Types.ToJSON.ToJSON (Unison.Sync.Types.Patch text oldHash newHash)
instance (Data.Aeson.Types.FromJSON.FromJSON text, Data.Aeson.Types.FromJSON.FromJSON oldHash, Data.Aeson.Types.FromJSON.FromJSON newHash) => Data.Aeson.Types.FromJSON.FromJSON (Unison.Sync.Types.Patch text oldHash newHash)
instance Data.Bifoldable.Bifoldable Unison.Sync.Types.TermComponent
instance Data.Bifunctor.Bifunctor Unison.Sync.Types.TermComponent
instance Data.Bitraversable.Bitraversable Unison.Sync.Types.TermComponent
instance (Data.Aeson.Types.ToJSON.ToJSON text, Data.Aeson.Types.ToJSON.ToJSON hash) => Data.Aeson.Types.ToJSON.ToJSON (Unison.Sync.Types.TermComponent text hash)
instance (Data.Aeson.Types.FromJSON.FromJSON text, Data.Aeson.Types.FromJSON.FromJSON hash) => Data.Aeson.Types.FromJSON.FromJSON (Unison.Sync.Types.TermComponent text hash)
instance Data.Bifoldable.Bifoldable Unison.Sync.Types.DeclComponent
instance Data.Bifunctor.Bifunctor Unison.Sync.Types.DeclComponent
instance Data.Bitraversable.Bitraversable Unison.Sync.Types.DeclComponent
instance (Data.Aeson.Types.ToJSON.ToJSON text, Data.Aeson.Types.ToJSON.ToJSON hash) => Data.Aeson.Types.ToJSON.ToJSON (Unison.Sync.Types.DeclComponent text hash)
instance (Data.Aeson.Types.FromJSON.FromJSON text, Data.Aeson.Types.FromJSON.FromJSON hash) => Data.Aeson.Types.FromJSON.FromJSON (Unison.Sync.Types.DeclComponent text hash)
instance Data.Bifoldable.Bifoldable Unison.Sync.Types.LocalIds
instance Data.Bifunctor.Bifunctor Unison.Sync.Types.LocalIds
instance Data.Bitraversable.Bitraversable Unison.Sync.Types.LocalIds
instance (Data.Aeson.Types.ToJSON.ToJSON text, Data.Aeson.Types.ToJSON.ToJSON hash) => Data.Aeson.Types.ToJSON.ToJSON (Unison.Sync.Types.LocalIds text hash)
instance (Data.Aeson.Types.FromJSON.FromJSON text, Data.Aeson.Types.FromJSON.FromJSON hash) => Data.Aeson.Types.FromJSON.FromJSON (Unison.Sync.Types.LocalIds text hash)
instance Data.Aeson.Types.ToJSON.ToJSON Unison.Sync.Types.Path
instance Data.Aeson.Types.FromJSON.FromJSON Unison.Sync.Types.Path
instance Data.Aeson.Types.ToJSON.ToJSON Unison.Sync.Types.Base64Bytes
instance Data.Aeson.Types.FromJSON.FromJSON Unison.Sync.Types.Base64Bytes


-- | Combinators or utilities shared by sync server AND client
module Unison.Sync.Common

-- | Read an entity out of the database that we know is in main storage.
expectEntity :: Hash32 -> Transaction (Entity Text Hash32 Hash32)
causalHashToHash32 :: CausalHash -> Hash32
hash32ToCausalHash :: Hash32 -> CausalHash

-- | Convert an entity that came over the wire from Unison Share into an
--   equivalent type that we can store in the <tt>temp_entity</tt> table.
entityToTempEntity :: forall hash. (hash -> Hash32) -> Entity Text Hash32 hash -> TempEntity
tempEntityToEntity :: TempEntity -> Entity Text Hash32 Hash32


-- | Module for validating hashes of entities received/sent via sync.
module Unison.Sync.EntityValidation

-- | Note: We currently only validate Namespace hashes. We should add more
--   validation as more entities are shared.
validateEntity :: Hash32 -> Entity Text Hash32 Hash32 -> Maybe EntityValidationError

module Unison.Sync.API
type API = "path" :> "get" :> GetCausalHashByPathEndpoint :<|> "entities" :> "download" :> DownloadEntitiesEndpoint :<|> "entities" :> "upload" :> UploadEntitiesEndpoint
api :: Proxy API

module Unison.Util.Find
fuzzyFinder :: forall a. String -> [a] -> (a -> String) -> [(a, Pretty ColorText)]
simpleFuzzyFinder :: forall a. Text -> [a] -> (a -> Text) -> [(a, Pretty ColorText)]
simpleFuzzyScore :: Text -> Text -> Maybe Int
fuzzyFindInBranch :: HasCallStack => Names -> HashQualified Name -> [(SearchResult, Pretty ColorText)]
fuzzyFindMatchArray :: forall a. String -> [a] -> (a -> String) -> [(MatchArray, (a, Pretty ColorText))]
prefixFindInBranch :: Names -> HashQualified Name -> [(SearchResult, Pretty ColorText)]
