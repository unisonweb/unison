-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Generic Programming using True Sums of Products
--   
--   A library to support the definition of generic functions. Datatypes
--   are viewed in a uniform, structured way: the choice between
--   constructors is represented using an n-ary sum, and the arguments of
--   each constructor are represented using an n-ary product.
--   
--   The module <a>Generics.SOP</a> is the main module of this library and
--   contains more detailed documentation.
--   
--   Since version 0.4.0.0, this package is now based on
--   <tt><a>sop-core</a></tt>. The core package contains all the
--   functionality of n-ary sums and products, whereas this package
--   provides the datatype-generic programming support on top.
--   
--   Examples of using this library are provided by the following packages:
--   
--   <ul>
--   <li><tt><a>basic-sop</a></tt> basic examples,</li>
--   <li><tt><a>pretty-sop</a></tt> generic pretty printing,</li>
--   <li><tt><a>lens-sop</a></tt> generically computed lenses,</li>
--   <li><tt><a>json-sop</a></tt> generic JSON conversions.</li>
--   </ul>
--   
--   A detailed description of the ideas behind this library is provided by
--   the paper:
--   
--   <ul>
--   <li>Edsko de Vries and Andres Löh. <a>True Sums of Products</a>.
--   Workshop on Generic Programming (WGP) 2014.</li>
--   </ul>
@package generics-sop
@version 0.5.1.3

module Generics.SOP.BasicFunctors

module Generics.SOP.Classes

module Generics.SOP.Constraint

module Generics.SOP.Dict

module Generics.SOP.NP


-- | Metadata about what a datatype looks like
--   
--   In <tt>generics-sop</tt>, the metadata is completely independent of
--   the main universe. Many generic functions will use this metadata, but
--   other don't, and yet others might need completely different metadata.
--   
--   This module defines a datatype to represent standard metadata, i.e.,
--   names of the datatype, its constructors, and possibly its record
--   selectors. Metadata descriptions are in general GADTs indexed by the
--   code of the datatype they're associated with, so matching on the
--   metadata will reveal information about the shape of the datatype.
module Generics.SOP.Metadata

-- | The fixity of an infix constructor.
type Fixity = Int

-- | Metadata for a single constructor.
--   
--   This is indexed by the product structure of the constructor
--   components.
data ConstructorInfo :: [Type] -> Type
[Constructor] :: SListI xs => ConstructorName -> ConstructorInfo xs
[Infix] :: ConstructorName -> Associativity -> Fixity -> ConstructorInfo '[x, y]
[Record] :: SListI xs => ConstructorName -> NP FieldInfo xs -> ConstructorInfo xs

-- | Metadata for a datatype.
--   
--   A value of type <tt><a>DatatypeInfo</a> c</tt> contains the
--   information about a datatype that is not contained in
--   <tt><tt>Code</tt> c</tt>. This information consists primarily of the
--   names of the datatype, its constructors, and possibly its record
--   selectors.
--   
--   The constructor indicates whether the datatype has been declared using
--   <tt>newtype</tt> or not.
data DatatypeInfo :: [[Type]] -> Type
[ADT] :: ModuleName -> DatatypeName -> NP ConstructorInfo xss -> POP StrictnessInfo xss -> DatatypeInfo xss
[Newtype] :: ModuleName -> DatatypeName -> ConstructorInfo '[x] -> DatatypeInfo '[ '[x]]

-- | For records, this functor maps the component to its selector name.
data FieldInfo :: Type -> Type
[FieldInfo] :: FieldName -> FieldInfo a

-- | The name of a datatype.
type DatatypeName = String

-- | The name of a module.
type ModuleName = String

-- | The name of a data constructor.
type ConstructorName = String

-- | The name of a field / record selector.
type FieldName = String

-- | Metadata for strictness information of a field.
--   
--   Indexed by the type of the field.
data StrictnessInfo :: Type -> Type
[StrictnessInfo] :: SourceUnpackedness -> SourceStrictness -> DecidedStrictness -> StrictnessInfo a

-- | The name of a datatype (or newtype).
datatypeName :: DatatypeInfo xss -> DatatypeName

-- | The module name where a datatype is defined.
moduleName :: DatatypeInfo xss -> ModuleName

-- | The name of a constructor.
constructorName :: ConstructorInfo xs -> ConstructorName

-- | The constructor info for a datatype (or newtype).
constructorInfo :: DatatypeInfo xss -> NP ConstructorInfo xss

-- | The name of a field.
fieldName :: FieldInfo a -> FieldName

-- | Datatype to represent the associativity of a constructor
data () => Associativity
LeftAssociative :: Associativity
RightAssociative :: Associativity
NotAssociative :: Associativity

-- | The strictness that GHC infers for a field during compilation. Whereas
--   there are nine different combinations of <a>SourceUnpackedness</a> and
--   <a>SourceStrictness</a>, the strictness that GHC decides will
--   ultimately be one of lazy, strict, or unpacked. What GHC decides is
--   affected both by what the user writes in the source code and by GHC
--   flags. As an example, consider this data type:
--   
--   <pre>
--   data E = ExampleConstructor {-# UNPACK #-} !Int !Int Int
--   </pre>
--   
--   <ul>
--   <li>If compiled without optimization or other language extensions,
--   then the fields of <tt>ExampleConstructor</tt> will have
--   <a>DecidedStrict</a>, <a>DecidedStrict</a>, and <a>DecidedLazy</a>,
--   respectively.</li>
--   <li>If compiled with <tt>-XStrictData</tt> enabled, then the fields
--   will have <a>DecidedStrict</a>, <a>DecidedStrict</a>, and
--   <a>DecidedStrict</a>, respectively.</li>
--   <li>If compiled with <tt>-O2</tt> enabled, then the fields will have
--   <a>DecidedUnpack</a>, <a>DecidedStrict</a>, and <a>DecidedLazy</a>,
--   respectively.</li>
--   </ul>
data () => DecidedStrictness
DecidedLazy :: DecidedStrictness
DecidedStrict :: DecidedStrictness
DecidedUnpack :: DecidedStrictness

-- | The strictness of a field as the user wrote it in the source code. For
--   example, in the following data type:
--   
--   <pre>
--   data E = ExampleConstructor Int ~Int !Int
--   </pre>
--   
--   The fields of <tt>ExampleConstructor</tt> have
--   <a>NoSourceStrictness</a>, <a>SourceLazy</a>, and <a>SourceStrict</a>,
--   respectively.
data () => SourceStrictness
NoSourceStrictness :: SourceStrictness
SourceLazy :: SourceStrictness
SourceStrict :: SourceStrictness

-- | The unpackedness of a field as the user wrote it in the source code.
--   For example, in the following data type:
--   
--   <pre>
--   data E = ExampleConstructor     Int
--              {-# NOUNPACK #-} Int
--              {-#   UNPACK #-} Int
--   </pre>
--   
--   The fields of <tt>ExampleConstructor</tt> have
--   <a>NoSourceUnpackedness</a>, <a>SourceNoUnpack</a>, and
--   <a>SourceUnpack</a>, respectively.
data () => SourceUnpackedness
NoSourceUnpackedness :: SourceUnpackedness
SourceNoUnpack :: SourceUnpackedness
SourceUnpack :: SourceUnpackedness
instance GHC.Base.Functor Generics.SOP.Metadata.StrictnessInfo
instance GHC.Classes.Ord (Generics.SOP.Metadata.StrictnessInfo a)
instance GHC.Classes.Eq (Generics.SOP.Metadata.StrictnessInfo a)
instance GHC.Show.Show (Generics.SOP.Metadata.StrictnessInfo a)
instance GHC.Base.Functor Generics.SOP.Metadata.FieldInfo
instance GHC.Classes.Ord (Generics.SOP.Metadata.FieldInfo a)
instance GHC.Classes.Eq (Generics.SOP.Metadata.FieldInfo a)
instance GHC.Show.Show (Generics.SOP.Metadata.FieldInfo a)
instance (Data.SOP.Constraint.All (Data.SOP.Constraint.Compose GHC.Show.Show Generics.SOP.Metadata.ConstructorInfo) xs, Data.SOP.Constraint.All (Data.SOP.Constraint.Compose GHC.Show.Show (Data.SOP.NP.NP Generics.SOP.Metadata.StrictnessInfo)) xs) => GHC.Show.Show (Generics.SOP.Metadata.DatatypeInfo xs)
instance (Data.SOP.Constraint.All (Data.SOP.Constraint.Compose GHC.Classes.Eq Generics.SOP.Metadata.ConstructorInfo) xs, Data.SOP.Constraint.All (Data.SOP.Constraint.Compose GHC.Classes.Eq (Data.SOP.NP.NP Generics.SOP.Metadata.StrictnessInfo)) xs) => GHC.Classes.Eq (Generics.SOP.Metadata.DatatypeInfo xs)
instance (Data.SOP.Constraint.All (Data.SOP.Constraint.Compose GHC.Classes.Eq Generics.SOP.Metadata.ConstructorInfo) xs, Data.SOP.Constraint.All (Data.SOP.Constraint.Compose GHC.Classes.Ord Generics.SOP.Metadata.ConstructorInfo) xs, Data.SOP.Constraint.All (Data.SOP.Constraint.Compose GHC.Classes.Eq (Data.SOP.NP.NP Generics.SOP.Metadata.StrictnessInfo)) xs, Data.SOP.Constraint.All (Data.SOP.Constraint.Compose GHC.Classes.Ord (Data.SOP.NP.NP Generics.SOP.Metadata.StrictnessInfo)) xs) => GHC.Classes.Ord (Generics.SOP.Metadata.DatatypeInfo xs)
instance Data.SOP.Constraint.All (Data.SOP.Constraint.Compose GHC.Show.Show Generics.SOP.Metadata.FieldInfo) xs => GHC.Show.Show (Generics.SOP.Metadata.ConstructorInfo xs)
instance Data.SOP.Constraint.All (Data.SOP.Constraint.Compose GHC.Classes.Eq Generics.SOP.Metadata.FieldInfo) xs => GHC.Classes.Eq (Generics.SOP.Metadata.ConstructorInfo xs)
instance (Data.SOP.Constraint.All (Data.SOP.Constraint.Compose GHC.Classes.Eq Generics.SOP.Metadata.FieldInfo) xs, Data.SOP.Constraint.All (Data.SOP.Constraint.Compose GHC.Classes.Ord Generics.SOP.Metadata.FieldInfo) xs) => GHC.Classes.Ord (Generics.SOP.Metadata.ConstructorInfo xs)

module Generics.SOP.NS

module Generics.SOP.Sing


-- | Type-level metadata
--   
--   This module provides datatypes (to be used promoted) that can
--   represent the metadata of Haskell datatypes on the type level.
--   
--   We do not reuse the term-level metadata types, because these are GADTs
--   that incorporate additional invariants. We could (at least in GHC 8)
--   impose the same invariants on the type level as well, but some tests
--   have revealed that the resulting type are rather inconvenient to work
--   with.
--   
--   So we use simple datatypes to represent the type-level metadata, even
--   if this means that some invariants are not explicitly captured.
--   
--   We establish a relation between the term- and type-level versions of
--   the metadata by automatically computing the term-level version from
--   the type-level version.
--   
--   As we now have two versions of metadata (term-level and type-level)
--   with very similar, yet slightly different datatype definitions, the
--   names between the modules clash, and this module is recommended to be
--   imported qualified when needed.
--   
--   The interface exported by this module is still somewhat experimental.
module Generics.SOP.Type.Metadata

-- | The fixity of an infix constructor.
type Fixity = Nat

-- | Metadata for a single constructors (to be used promoted).
data ConstructorInfo

-- | Normal constructor
Constructor :: ConstructorName -> ConstructorInfo

-- | Infix constructor
Infix :: ConstructorName -> Associativity -> Fixity -> ConstructorInfo

-- | Record constructor
Record :: ConstructorName -> [FieldInfo] -> ConstructorInfo

-- | Metadata for a datatype (to be used promoted).
--   
--   A type of kind <tt><a>DatatypeInfo</a></tt> contains meta-information
--   about a datatype that is not contained in its code. This information
--   consists primarily of the names of the datatype, its constructors, and
--   possibly its record selectors.
--   
--   The constructor indicates whether the datatype has been declared using
--   <tt>newtype</tt> or not.
data DatatypeInfo

-- | Standard algebraic datatype
ADT :: ModuleName -> DatatypeName -> [ConstructorInfo] -> [[StrictnessInfo]] -> DatatypeInfo

-- | Newtype
Newtype :: ModuleName -> DatatypeName -> ConstructorInfo -> DatatypeInfo

-- | Metadata for a single record field (to be used promoted).
data FieldInfo
FieldInfo :: FieldName -> FieldInfo

-- | The name of a datatype.
type DatatypeName = Symbol

-- | The name of a module.
type ModuleName = Symbol

-- | The name of a data constructor.
type ConstructorName = Symbol

-- | The name of a field / record selector.
type FieldName = Symbol

-- | Strictness information for a single field (to be used promoted).
data StrictnessInfo
StrictnessInfo :: SourceUnpackedness -> SourceStrictness -> DecidedStrictness -> StrictnessInfo

-- | Class for computing term-level datatype information from type-level
--   datatype information.
class DemoteDatatypeInfo (x :: DatatypeInfo) (xss :: [[Type]])

-- | Given a proxy of some type-level datatype information, return the
--   corresponding term-level information.
demoteDatatypeInfo :: DemoteDatatypeInfo x xss => proxy x -> DatatypeInfo xss

-- | Class for computing term-level constructor information from type-level
--   constructor information.
class DemoteConstructorInfos (cs :: [ConstructorInfo]) (xss :: [[Type]])

-- | Given a proxy of some type-level constructor information, return the
--   corresponding term-level information as a product.
demoteConstructorInfos :: DemoteConstructorInfos cs xss => proxy cs -> NP ConstructorInfo xss
class DemoteStrictnessInfoss (sss :: [[StrictnessInfo]]) (xss :: [[Type]])
demoteStrictnessInfoss :: DemoteStrictnessInfoss sss xss => proxy sss -> NP (NP StrictnessInfo) xss

-- | Class for computing term-level constructor information from type-level
--   constructor information.
class DemoteConstructorInfo (x :: ConstructorInfo) (xs :: [Type])

-- | Given a proxy of some type-level constructor information, return the
--   corresponding term-level information.
demoteConstructorInfo :: DemoteConstructorInfo x xs => proxy x -> ConstructorInfo xs

-- | Class for computing term-level associativity information from
--   type-level associativity information.
class DemoteAssociativity (a :: Associativity)

-- | Given a proxy of some type-level associativity information, return the
--   corresponding term-level information.
demoteAssociativity :: DemoteAssociativity a => proxy a -> Associativity

-- | Class for computing term-level field information from type-level field
--   information.
class SListI xs => DemoteFieldInfos (fs :: [FieldInfo]) (xs :: [Type])

-- | Given a proxy of some type-level field information, return the
--   corresponding term-level information as a product.
demoteFieldInfos :: DemoteFieldInfos fs xs => proxy fs -> NP FieldInfo xs
class DemoteStrictnessInfos (ss :: [StrictnessInfo]) (xs :: [Type])
demoteStrictnessInfos :: DemoteStrictnessInfos ss xs => proxy ss -> NP StrictnessInfo xs
class DemoteStrictnessInfo (s :: StrictnessInfo) (x :: Type)
demoteStrictnessInfo :: DemoteStrictnessInfo s x => proxy s -> StrictnessInfo x

-- | Class for computing term-level source unpackedness information from
--   type-level source unpackedness information.
class DemoteSourceUnpackedness (a :: SourceUnpackedness)

-- | Given a proxy of some type-level source unpackedness information,
--   return the corresponding term-level information.
demoteSourceUnpackedness :: DemoteSourceUnpackedness a => proxy a -> SourceUnpackedness

-- | Class for computing term-level source strictness information from
--   type-level source strictness information.
class DemoteSourceStrictness (a :: SourceStrictness)

-- | Given a proxy of some type-level source strictness information, return
--   the corresponding term-level information.
demoteSourceStrictness :: DemoteSourceStrictness a => proxy a -> SourceStrictness

-- | Class for computing term-level decided strictness information from
--   type-level decided strictness information.
class DemoteDecidedStrictness (a :: DecidedStrictness)

-- | Given a proxy of some type-level source strictness information, return
--   the corresponding term-level information.
demoteDecidedStrictness :: DemoteDecidedStrictness a => proxy a -> DecidedStrictness

-- | Class for computing term-level field information from type-level field
--   information.
class DemoteFieldInfo (x :: FieldInfo) (a :: Type)

-- | Given a proxy of some type-level field information, return the
--   corresponding term-level information.
demoteFieldInfo :: DemoteFieldInfo x a => proxy x -> FieldInfo a

-- | Datatype to represent the associativity of a constructor
data () => Associativity
LeftAssociative :: Associativity
RightAssociative :: Associativity
NotAssociative :: Associativity
instance (Generics.SOP.Type.Metadata.DemoteSourceUnpackedness su, Generics.SOP.Type.Metadata.DemoteSourceStrictness ss, Generics.SOP.Type.Metadata.DemoteDecidedStrictness ds) => Generics.SOP.Type.Metadata.DemoteStrictnessInfo ('Generics.SOP.Type.Metadata.StrictnessInfo su ss ds) x
instance Generics.SOP.Type.Metadata.DemoteDecidedStrictness 'GHC.Generics.DecidedLazy
instance Generics.SOP.Type.Metadata.DemoteDecidedStrictness 'GHC.Generics.DecidedStrict
instance Generics.SOP.Type.Metadata.DemoteDecidedStrictness 'GHC.Generics.DecidedUnpack
instance Generics.SOP.Type.Metadata.DemoteSourceStrictness 'GHC.Generics.NoSourceStrictness
instance Generics.SOP.Type.Metadata.DemoteSourceStrictness 'GHC.Generics.SourceLazy
instance Generics.SOP.Type.Metadata.DemoteSourceStrictness 'GHC.Generics.SourceStrict
instance Generics.SOP.Type.Metadata.DemoteSourceUnpackedness 'GHC.Generics.NoSourceUnpackedness
instance Generics.SOP.Type.Metadata.DemoteSourceUnpackedness 'GHC.Generics.SourceNoUnpack
instance Generics.SOP.Type.Metadata.DemoteSourceUnpackedness 'GHC.Generics.SourceUnpack
instance (GHC.TypeLits.KnownSymbol s, Generics.SOP.Type.Metadata.DemoteAssociativity a, GHC.TypeNats.KnownNat f) => Generics.SOP.Type.Metadata.DemoteConstructorInfo ('Generics.SOP.Type.Metadata.Infix s a f) '[y, z]
instance Generics.SOP.Type.Metadata.DemoteAssociativity 'GHC.Generics.LeftAssociative
instance Generics.SOP.Type.Metadata.DemoteAssociativity 'GHC.Generics.RightAssociative
instance Generics.SOP.Type.Metadata.DemoteAssociativity 'GHC.Generics.NotAssociative
instance (Generics.SOP.Type.Metadata.DemoteFieldInfo f x, Generics.SOP.Type.Metadata.DemoteFieldInfos fs xs) => Generics.SOP.Type.Metadata.DemoteFieldInfos (f : fs) (x : xs)
instance GHC.TypeLits.KnownSymbol s => Generics.SOP.Type.Metadata.DemoteFieldInfo ('Generics.SOP.Type.Metadata.FieldInfo s) a
instance (GHC.TypeLits.KnownSymbol s, Generics.SOP.Type.Metadata.DemoteFieldInfos fs xs) => Generics.SOP.Type.Metadata.DemoteConstructorInfo ('Generics.SOP.Type.Metadata.Record s fs) xs
instance Generics.SOP.Type.Metadata.DemoteFieldInfos '[] '[]
instance (Generics.SOP.Type.Metadata.DemoteStrictnessInfo s x, Generics.SOP.Type.Metadata.DemoteStrictnessInfos ss xs) => Generics.SOP.Type.Metadata.DemoteStrictnessInfos (s : ss) (x : xs)
instance (Generics.SOP.Type.Metadata.DemoteStrictnessInfos ss xs, Generics.SOP.Type.Metadata.DemoteStrictnessInfoss sss xss) => Generics.SOP.Type.Metadata.DemoteStrictnessInfoss (ss : sss) (xs : xss)
instance Generics.SOP.Type.Metadata.DemoteStrictnessInfos '[] '[]
instance (GHC.TypeLits.KnownSymbol m, GHC.TypeLits.KnownSymbol d, Generics.SOP.Type.Metadata.DemoteConstructorInfos cs xss, Generics.SOP.Type.Metadata.DemoteStrictnessInfoss sss xss) => Generics.SOP.Type.Metadata.DemoteDatatypeInfo ('Generics.SOP.Type.Metadata.ADT m d cs sss) xss
instance Generics.SOP.Type.Metadata.DemoteStrictnessInfoss '[] '[]
instance (GHC.TypeLits.KnownSymbol m, GHC.TypeLits.KnownSymbol d, Generics.SOP.Type.Metadata.DemoteConstructorInfo c '[x]) => Generics.SOP.Type.Metadata.DemoteDatatypeInfo ('Generics.SOP.Type.Metadata.Newtype m d c) '[ '[x]]
instance (Generics.SOP.Type.Metadata.DemoteConstructorInfo c xs, Generics.SOP.Type.Metadata.DemoteConstructorInfos cs xss) => Generics.SOP.Type.Metadata.DemoteConstructorInfos (c : cs) (xs : xss)
instance (GHC.TypeLits.KnownSymbol s, Data.SOP.Constraint.SListI xs) => Generics.SOP.Type.Metadata.DemoteConstructorInfo ('Generics.SOP.Type.Metadata.Constructor s) xs
instance Generics.SOP.Type.Metadata.DemoteConstructorInfos '[] '[]


-- | Derive <tt>generics-sop</tt> boilerplate instances from GHC's
--   <a>Generic</a>.
--   
--   The technique being used here is described in the following paper:
--   
--   <ul>
--   <li>José Pedro Magalhães and Andres Löh. <a>Generic Generic
--   Programming</a>. Practical Aspects of Declarative Languages (PADL)
--   2014.</li>
--   </ul>
module Generics.SOP.GGP

-- | Compute the SOP code of a datatype.
--   
--   This requires that <a>Rep</a> is defined, which in turn requires that
--   the type has a <a>Generic</a> (from module <a>GHC.Generics</a>)
--   instance.
--   
--   This is the default definition for <a>Code</a>. For more info, see
--   <a>Generic</a>.
type GCode (a :: Type) = ToSumCode (Rep a) '[]

-- | Constraint for the class that computes <a>gfrom</a>.
type GFrom a = GSumFrom (Rep a)

-- | Constraint for the class that computes <a>gto</a>.
type GTo a = GSumTo (Rep a)

-- | Constraint for the class that computes <a>gdatatypeInfo</a>.
type GDatatypeInfo a = DemoteDatatypeInfo (GDatatypeInfoOf a) (GCode a)

-- | Compute the datatype info of a datatype.
type GDatatypeInfoOf (a :: Type) = ToInfo (Rep a)

-- | An automatically computed version of <a>from</a>.
--   
--   This requires that the type being converted has a <a>Generic</a> (from
--   module <a>GHC.Generics</a>) instance.
--   
--   This is the default definition for <a>from</a>. For more info, see
--   <a>Generic</a>.
gfrom :: (GFrom a, Generic a) => a -> SOP I (GCode a)

-- | An automatically computed version of <a>to</a>.
--   
--   This requires that the type being converted has a <a>Generic</a> (from
--   module <a>GHC.Generics</a>) instance.
--   
--   This is the default definition for <a>to</a>. For more info, see
--   <a>Generic</a>.
gto :: forall a. (GTo a, Generic a) => SOP I (GCode a) -> a

-- | An automatically computed version of <a>datatypeInfo</a>.
--   
--   This requires that the type being converted has a <a>Generic</a> (from
--   module <a>GHC.Generics</a>) instance.
--   
--   This is the default definition for <a>datatypeInfo</a>. For more info,
--   see <a>HasDatatypeInfo</a>.
gdatatypeInfo :: forall proxy a. GDatatypeInfo a => proxy a -> DatatypeInfo (GCode a)
instance Generics.SOP.GGP.GSumTo GHC.Generics.V1
instance (Generics.SOP.GGP.GSumTo a, Generics.SOP.GGP.GSumTo b) => Generics.SOP.GGP.GSumTo (a GHC.Generics.:+: b)
instance Generics.SOP.GGP.GProductTo a => Generics.SOP.GGP.GSumTo (GHC.Generics.M1 GHC.Generics.C c a)
instance Generics.SOP.GGP.GSumTo a => Generics.SOP.GGP.GSumTo (GHC.Generics.M1 GHC.Generics.D c a)
instance Generics.SOP.GGP.GSumFrom GHC.Generics.V1
instance (Generics.SOP.GGP.GSumFrom a, Generics.SOP.GGP.GSumFrom b) => Generics.SOP.GGP.GSumFrom (a GHC.Generics.:+: b)
instance Generics.SOP.GGP.GSumFrom a => Generics.SOP.GGP.GSumFrom (GHC.Generics.M1 GHC.Generics.D c a)
instance Generics.SOP.GGP.GProductFrom a => Generics.SOP.GGP.GSumFrom (GHC.Generics.M1 GHC.Generics.C c a)
instance (Generics.SOP.GGP.GProductTo a, Generics.SOP.GGP.GProductTo b) => Generics.SOP.GGP.GProductTo (a GHC.Generics.:*: b)
instance Generics.SOP.GGP.GSingleTo a => Generics.SOP.GGP.GProductTo (GHC.Generics.M1 GHC.Generics.S c a)
instance Generics.SOP.GGP.GProductTo GHC.Generics.U1
instance Generics.SOP.GGP.GSingleTo (GHC.Generics.K1 i a)
instance (Generics.SOP.GGP.GProductFrom a, Generics.SOP.GGP.GProductFrom b) => Generics.SOP.GGP.GProductFrom (a GHC.Generics.:*: b)
instance Generics.SOP.GGP.GProductFrom GHC.Generics.U1
instance Generics.SOP.GGP.GSingleFrom a => Generics.SOP.GGP.GProductFrom (GHC.Generics.M1 GHC.Generics.S c a)
instance Generics.SOP.GGP.GSingleFrom (GHC.Generics.K1 i a)
instance (Generics.SOP.GGP.GFieldInfos a, Generics.SOP.GGP.GFieldInfos b) => Generics.SOP.GGP.GFieldInfos (a GHC.Generics.:*: b)
instance Generics.SOP.GGP.GFieldInfos GHC.Generics.U1
instance GHC.Generics.Selector c => Generics.SOP.GGP.GFieldInfos (GHC.Generics.M1 GHC.Generics.S c a)


-- | Codes and interpretations
module Generics.SOP.Universe

-- | The (generic) representation of a datatype.
--   
--   A datatype is isomorphic to the sum-of-products of its code. The
--   isomorphism is witnessed by <a>from</a> and <a>to</a> from the
--   <a>Generic</a> class.
type Rep a = SOP I (Code a)

-- | The class of representable datatypes.
--   
--   The SOP approach to generic programming is based on viewing datatypes
--   as a representation (<a>Rep</a>) built from the sum of products of its
--   components. The components of a datatype are specified using the
--   <a>Code</a> type family.
--   
--   The isomorphism between the original Haskell datatype and its
--   representation is witnessed by the methods of this class, <a>from</a>
--   and <a>to</a>. So for instances of this class, the following laws
--   should (in general) hold:
--   
--   <pre>
--   <a>to</a> <a>.</a> <a>from</a> === <a>id</a> :: a -&gt; a
--   <a>from</a> <a>.</a> <a>to</a> === <a>id</a> :: <a>Rep</a> a -&gt; <a>Rep</a> a
--   </pre>
--   
--   You typically don't define instances of this class by hand, but rather
--   derive the class instance automatically.
--   
--   <i>Option 1:</i> Derive via the built-in GHC-generics. For this, you
--   need to use the <tt>DeriveGeneric</tt> extension to first derive an
--   instance of the <a>Generic</a> class from module <a>GHC.Generics</a>.
--   With this, you can then give an empty instance for <a>Generic</a>, and
--   the default definitions will just work. The pattern looks as follows:
--   
--   <pre>
--   import qualified <a>GHC.Generics</a> as GHC
--   import <a>Generics.SOP</a>
--   
--   ...
--   
--   data T = ... deriving (GHC.<a>Generic</a>, ...)
--   
--   instance <a>Generic</a> T -- empty
--   instance <a>HasDatatypeInfo</a> T -- empty, if you want/need metadata
--   </pre>
--   
--   <i>Option 2:</i> Derive via Template Haskell. For this, you need to
--   enable the <tt>TemplateHaskell</tt> extension. You can then use
--   <a>deriveGeneric</a> from module <a>Generics.SOP.TH</a> to have the
--   instance generated for you. The pattern looks as follows:
--   
--   <pre>
--   import <a>Generics.SOP</a>
--   import <a>Generics.SOP.TH</a>
--   
--   ...
--   
--   data T = ...
--   
--   <a>deriveGeneric</a> ''T -- derives <a>HasDatatypeInfo</a> as well
--   </pre>
--   
--   <i>Tradeoffs:</i> Whether to use Option 1 or 2 is mainly a matter of
--   personal taste. The version based on Template Haskell probably has
--   less run-time overhead.
--   
--   <i>Non-standard instances:</i> It is possible to give <a>Generic</a>
--   instances manually that deviate from the standard scheme, as long as
--   at least
--   
--   <pre>
--   <a>to</a> <a>.</a> <a>from</a> === <a>id</a> :: a -&gt; a
--   </pre>
--   
--   still holds.
class (All SListI (Code a)) => Generic (a :: Type) where {
    
    -- | The code of a datatype.
    --   
    --   This is a list of lists of its components. The outer list contains one
    --   element per constructor. The inner list contains one element per
    --   constructor argument (field).
    --   
    --   <i>Example:</i> The datatype
    --   
    --   <pre>
    --   data Tree = Leaf Int | Node Tree Tree
    --   </pre>
    --   
    --   is supposed to have the following code:
    --   
    --   <pre>
    --   type instance Code (Tree a) =
    --     '[ '[ Int ]
    --      , '[ Tree, Tree ]
    --      ]
    --   </pre>
    type Code a :: [[Type]];
    type Code a = GCode a;
}

-- | Converts from a value to its structural representation.
from :: Generic a => a -> Rep a

-- | Converts from a value to its structural representation.
from :: (Generic a, GFrom a, Generic a, Rep a ~ SOP I (GCode a)) => a -> Rep a

-- | Converts from a structural representation back to the original value.
to :: Generic a => Rep a -> a

-- | Converts from a structural representation back to the original value.
to :: (Generic a, GTo a, Generic a, Rep a ~ SOP I (GCode a)) => Rep a -> a

-- | A class of datatypes that have associated metadata.
--   
--   It is possible to use the sum-of-products approach to generic
--   programming without metadata. If you need metadata in a function, an
--   additional constraint on this class is in order.
--   
--   You typically don't define instances of this class by hand, but rather
--   derive the class instance automatically. See the documentation of
--   <a>Generic</a> for the options.
class Generic a => HasDatatypeInfo a where {
    
    -- | Type-level datatype info
    type DatatypeInfoOf a :: DatatypeInfo;
    type DatatypeInfoOf a = GDatatypeInfoOf a;
}

-- | Term-level datatype info; by default, the term-level datatype info is
--   produced from the type-level info.
datatypeInfo :: HasDatatypeInfo a => proxy a -> DatatypeInfo (Code a)

-- | Term-level datatype info; by default, the term-level datatype info is
--   produced from the type-level info.
datatypeInfo :: (HasDatatypeInfo a, GDatatypeInfo a, GCode a ~ Code a) => proxy a -> DatatypeInfo (Code a)

-- | Constraint that captures that a datatype is a product type, i.e., a
--   type with a single constructor.
--   
--   It also gives access to the code for the arguments of that
--   constructor.
type IsProductType (a :: Type) (xs :: [Type]) = (Generic a, Code a ~ '[xs])

-- | Direct access to the part of the code that is relevant for a product
--   type.
type ProductCode (a :: Type) = Head (Code a)

-- | Convert from a product type to its product representation.
productTypeFrom :: IsProductType a xs => a -> NP I xs

-- | Convert a product representation to the original type.
productTypeTo :: IsProductType a xs => NP I xs -> a

-- | Constraint that captures that a datatype is an enumeration type, i.e.,
--   none of the constructors have any arguments.
type IsEnumType (a :: Type) = (Generic a, All ((~) '[]) (Code a))

-- | Convert from an enum type to its sum representation.
enumTypeFrom :: IsEnumType a => a -> NS (K ()) (Code a)

-- | Convert a sum representation to ihe original type.
enumTypeTo :: IsEnumType a => NS (K ()) (Code a) -> a

-- | Constraint that captures that a datatype is a single-constructor,
--   single-field datatype. This always holds for newtype-defined types,
--   but it can also be true for data-defined types.
--   
--   The constraint also gives access to the type that is wrapped.
type IsWrappedType (a :: Type) (x :: Type) = (Generic a, Code a ~ '[ '[x]])

-- | Direct access to the part of the code that is relevant for wrapped
--   types and newtypes.
type WrappedCode (a :: Type) = Head (Head (Code a))

-- | Convert from a wrapped type to its inner type.
wrappedTypeFrom :: IsWrappedType a x => a -> x

-- | Convert a type to a wrapped type.
wrappedTypeTo :: IsWrappedType a x => x -> a

-- | Constraint that captures that a datatype is a newtype. This makes use
--   of the fact that newtypes are always coercible to the type they wrap,
--   whereas datatypes are not.
type IsNewtype (a :: Type) (x :: Type) = (IsWrappedType a x, Coercible a x)

-- | Convert a newtype to its inner type.
--   
--   This is a specialised synonym for <a>coerce</a>.
newtypeFrom :: IsNewtype a x => a -> x

-- | Convert a type to a newtype.
--   
--   This is a specialised synonym for <a>coerce</a>.
newtypeTo :: IsNewtype a x => x -> a


-- | Generate <tt>generics-sop</tt> boilerplate instances using Template
--   Haskell.
module Generics.SOP.TH

-- | Generate <tt>generics-sop</tt> boilerplate for the given datatype.
--   
--   This function takes the name of a datatype and generates:
--   
--   <ul>
--   <li>a <a>Generic</a> instance</li>
--   <li>a <a>Generic</a> instance</li>
--   <li>a <a>HasDatatypeInfo</a> instance</li>
--   </ul>
--   
--   Note that the generated code will require the <tt>TypeFamilies</tt>
--   and <tt>DataKinds</tt> extensions to be enabled for the module.
--   
--   <i>Example:</i> If you have the datatype
--   
--   <pre>
--   data Tree = Leaf Int | Node Tree Tree
--   </pre>
--   
--   and say
--   
--   <pre>
--   deriveGeneric ''Tree
--   </pre>
--   
--   then you get code that is equivalent to:
--   
--   <pre>
--   instance Generic Tree where
--   
--     type Code Tree = '[ '[Int], '[Tree, Tree] ]
--   
--     from (Leaf x)   = SOP (   Z (I x :* Nil))
--     from (Node l r) = SOP (S (Z (I l :* I r :* Nil)))
--   
--     to (SOP    (Z (I x :* Nil)))         = Leaf x
--     to (SOP (S (Z (I l :* I r :* Nil)))) = Node l r
--     to (SOP (S (S x)))                   = x `seq` error "inaccessible"
--   
--   instance HasDatatypeInfo Tree where
--     type DatatypeInfoOf Tree =
--       T.ADT "Main" "Tree"
--         '[ T.Constructor "Leaf", T.Constructor "Node" ]
--   
--     datatypeInfo _ =
--       T.demoteDatatypeInfo (Proxy :: Proxy (DatatypeInfoOf Tree))
--   </pre>
--   
--   <i>Limitations:</i> Generation does not work for GADTs, for datatypes
--   that involve existential quantification, for datatypes with unboxed
--   fields.
deriveGeneric :: Name -> Q [Dec]

-- | Like <a>deriveGeneric</a>, but omit the <a>HasDatatypeInfo</a>
--   instance.
deriveGenericOnly :: Name -> Q [Dec]

-- | Variant of <a>deriveGeneric</a> that allows to restrict the type
--   parameters.
--   
--   Experimental function, exposed primarily for benchmarking.
deriveGenericSubst :: Name -> (Name -> Q Type) -> Q [Dec]

-- | Variant of <a>deriveGenericOnly</a> that allows to restrict the type
--   parameters.
--   
--   Experimental function, exposed primarily for benchmarking.
deriveGenericOnlySubst :: Name -> (Name -> Q Type) -> Q [Dec]

-- | Like <a>deriveGenericOnly</a>, but don't derive class instance, only
--   functions.
--   
--   <i>Example:</i> If you say
--   
--   <pre>
--   deriveGenericFunctions ''Tree "TreeCode" "fromTree" "toTree"
--   </pre>
--   
--   then you get code that is equivalent to:
--   
--   <pre>
--   type TreeCode = '[ '[Int], '[Tree, Tree] ]
--   
--   fromTree :: Tree -&gt; SOP I TreeCode
--   fromTree (Leaf x)   = SOP (   Z (I x :* Nil))
--   fromTree (Node l r) = SOP (S (Z (I l :* I r :* Nil)))
--   
--   toTree :: SOP I TreeCode -&gt; Tree
--   toTree (SOP    (Z (I x :* Nil)))         = Leaf x
--   toTree (SOP (S (Z (I l :* I r :* Nil)))) = Node l r
--   toTree (SOP (S (S x)))                   = x `seq` error "inaccessible"
--   </pre>
deriveGenericFunctions :: Name -> String -> String -> String -> Q [Dec]

-- | Derive <tt>DatatypeInfo</tt> value for the type.
--   
--   <i>Example:</i> If you say
--   
--   <pre>
--   deriveMetadataValue ''Tree "TreeCode" "treeDatatypeInfo"
--   </pre>
--   
--   then you get code that is equivalent to:
--   
--   <pre>
--   treeDatatypeInfo :: DatatypeInfo TreeCode
--   treeDatatypeInfo = ADT "Main" "Tree"
--       (Constructor "Leaf" :* Constructor "Node" :* Nil)
--   </pre>
--   
--   <i>Note:</i> CodeType needs to be derived with
--   <a>deriveGenericFunctions</a>.

-- | <i>Deprecated: Use <a>deriveMetadataType</a> and
--   <tt>demoteDatatypeInfo</tt> instead.</i>
deriveMetadataValue :: Name -> String -> String -> Q [Dec]

-- | Derive <tt>DatatypeInfo</tt> type for the type.
--   
--   <i>Example:</i> If you say
--   
--   <pre>
--   deriveMetadataType ''Tree "TreeDatatypeInfo"
--   </pre>
--   
--   then you get code that is equivalent to:
--   
--   <pre>
--   type TreeDatatypeInfo =
--     T.ADT "Main" "Tree"
--       [ T.Constructor "Leaf", T.Constructor "Node" ]
--   </pre>
deriveMetadataType :: Name -> String -> Q [Dec]


-- | Instances for <tt>Generic</tt> and <tt>HasMetadata</tt>.
--   
--   We define instances for datatypes from <tt>generics-sop</tt> and
--   <tt>base</tt> that are supported.
--   
--   (There are only instances defined in this module, so the documentation
--   is empty.)
module Generics.SOP.Instances
instance Generics.SOP.Universe.Generic Text.Read.Lex.Number
instance Generics.SOP.Universe.HasDatatypeInfo Text.Read.Lex.Number
instance Generics.SOP.Universe.Generic Text.Read.Lex.Lexeme
instance Generics.SOP.Universe.HasDatatypeInfo Text.Read.Lex.Lexeme
instance Generics.SOP.Universe.Generic Text.Printf.FormatParse
instance Generics.SOP.Universe.HasDatatypeInfo Text.Printf.FormatParse
instance Generics.SOP.Universe.Generic Text.Printf.FormatSign
instance Generics.SOP.Universe.HasDatatypeInfo Text.Printf.FormatSign
instance Generics.SOP.Universe.Generic Text.Printf.FormatAdjustment
instance Generics.SOP.Universe.HasDatatypeInfo Text.Printf.FormatAdjustment
instance Generics.SOP.Universe.Generic Text.Printf.FieldFormat
instance Generics.SOP.Universe.HasDatatypeInfo Text.Printf.FieldFormat
instance Generics.SOP.Universe.Generic GHC.IO.Handle.Types.NewlineMode
instance Generics.SOP.Universe.HasDatatypeInfo GHC.IO.Handle.Types.NewlineMode
instance Generics.SOP.Universe.Generic GHC.IO.Handle.Types.Newline
instance Generics.SOP.Universe.HasDatatypeInfo GHC.IO.Handle.Types.Newline
instance Generics.SOP.Universe.Generic GHC.IO.Device.SeekMode
instance Generics.SOP.Universe.HasDatatypeInfo GHC.IO.Device.SeekMode
instance Generics.SOP.Universe.Generic GHC.IO.Handle.Types.BufferMode
instance Generics.SOP.Universe.HasDatatypeInfo GHC.IO.Handle.Types.BufferMode
instance Generics.SOP.Universe.Generic GHC.IO.IOMode.IOMode
instance Generics.SOP.Universe.HasDatatypeInfo GHC.IO.IOMode.IOMode
instance Generics.SOP.Universe.Generic GHC.IO.Exception.ExitCode
instance Generics.SOP.Universe.HasDatatypeInfo GHC.IO.Exception.ExitCode
instance Generics.SOP.Universe.Generic (System.Console.GetOpt.ArgDescr a)
instance Generics.SOP.Universe.HasDatatypeInfo (System.Console.GetOpt.ArgDescr a)
instance Generics.SOP.Universe.Generic (System.Console.GetOpt.OptDescr a)
instance Generics.SOP.Universe.HasDatatypeInfo (System.Console.GetOpt.OptDescr a)
instance Generics.SOP.Universe.Generic (System.Console.GetOpt.ArgOrder a)
instance Generics.SOP.Universe.HasDatatypeInfo (System.Console.GetOpt.ArgOrder a)
instance Generics.SOP.Universe.Generic GHC.Stats.GCDetails
instance Generics.SOP.Universe.HasDatatypeInfo GHC.Stats.GCDetails
instance Generics.SOP.Universe.Generic GHC.Stats.RTSStats
instance Generics.SOP.Universe.HasDatatypeInfo GHC.Stats.RTSStats
instance Generics.SOP.Universe.Generic GHC.StaticPtr.StaticPtrInfo
instance Generics.SOP.Universe.HasDatatypeInfo GHC.StaticPtr.StaticPtrInfo
instance Generics.SOP.Universe.Generic GHC.Stack.Types.CallStack
instance Generics.SOP.Universe.HasDatatypeInfo GHC.Stack.Types.CallStack
instance Generics.SOP.Universe.Generic GHC.Stack.Types.SrcLoc
instance Generics.SOP.Universe.HasDatatypeInfo GHC.Stack.Types.SrcLoc
instance Generics.SOP.Universe.Generic GHC.RTS.Flags.ParFlags
instance Generics.SOP.Universe.HasDatatypeInfo GHC.RTS.Flags.ParFlags
instance Generics.SOP.Universe.Generic GHC.RTS.Flags.TickyFlags
instance Generics.SOP.Universe.HasDatatypeInfo GHC.RTS.Flags.TickyFlags
instance Generics.SOP.Universe.Generic GHC.RTS.Flags.TraceFlags
instance Generics.SOP.Universe.HasDatatypeInfo GHC.RTS.Flags.TraceFlags
instance Generics.SOP.Universe.Generic GHC.RTS.Flags.DoTrace
instance Generics.SOP.Universe.HasDatatypeInfo GHC.RTS.Flags.DoTrace
instance Generics.SOP.Universe.Generic GHC.RTS.Flags.ProfFlags
instance Generics.SOP.Universe.HasDatatypeInfo GHC.RTS.Flags.ProfFlags
instance Generics.SOP.Universe.Generic GHC.RTS.Flags.DoHeapProfile
instance Generics.SOP.Universe.HasDatatypeInfo GHC.RTS.Flags.DoHeapProfile
instance Generics.SOP.Universe.Generic GHC.RTS.Flags.CCFlags
instance Generics.SOP.Universe.HasDatatypeInfo GHC.RTS.Flags.CCFlags
instance Generics.SOP.Universe.Generic GHC.RTS.Flags.DoCostCentres
instance Generics.SOP.Universe.HasDatatypeInfo GHC.RTS.Flags.DoCostCentres
instance Generics.SOP.Universe.Generic GHC.RTS.Flags.DebugFlags
instance Generics.SOP.Universe.HasDatatypeInfo GHC.RTS.Flags.DebugFlags
instance Generics.SOP.Universe.Generic GHC.RTS.Flags.MiscFlags
instance Generics.SOP.Universe.HasDatatypeInfo GHC.RTS.Flags.MiscFlags
instance Generics.SOP.Universe.Generic GHC.RTS.Flags.ConcFlags
instance Generics.SOP.Universe.HasDatatypeInfo GHC.RTS.Flags.ConcFlags
instance Generics.SOP.Universe.Generic GHC.RTS.Flags.GCFlags
instance Generics.SOP.Universe.HasDatatypeInfo GHC.RTS.Flags.GCFlags
instance Generics.SOP.Universe.Generic GHC.RTS.Flags.GiveGCStats
instance Generics.SOP.Universe.HasDatatypeInfo GHC.RTS.Flags.GiveGCStats
instance Generics.SOP.Universe.Generic GHC.RTS.Flags.RTSFlags
instance Generics.SOP.Universe.HasDatatypeInfo GHC.RTS.Flags.RTSFlags
instance Generics.SOP.Universe.Generic GHC.IO.Handle.Lock.Common.LockMode
instance Generics.SOP.Universe.HasDatatypeInfo GHC.IO.Handle.Lock.Common.LockMode
instance Generics.SOP.Universe.Generic GHC.IO.Handle.HandlePosn
instance Generics.SOP.Universe.HasDatatypeInfo GHC.IO.Handle.HandlePosn
instance Generics.SOP.Universe.Generic GHC.IO.Exception.IOErrorType
instance Generics.SOP.Universe.HasDatatypeInfo GHC.IO.Exception.IOErrorType
instance Generics.SOP.Universe.Generic GHC.IO.Exception.FixIOException
instance Generics.SOP.Universe.HasDatatypeInfo GHC.IO.Exception.FixIOException
instance Generics.SOP.Universe.Generic GHC.Float.FFFormat
instance Generics.SOP.Universe.HasDatatypeInfo GHC.Float.FFFormat
instance Generics.SOP.Universe.Generic GHC.Fingerprint.Type.Fingerprint
instance Generics.SOP.Universe.HasDatatypeInfo GHC.Fingerprint.Type.Fingerprint
instance Generics.SOP.Universe.Generic GHC.IO.Encoding.Failure.CodingFailureMode
instance Generics.SOP.Universe.HasDatatypeInfo GHC.IO.Encoding.Failure.CodingFailureMode
instance Generics.SOP.Universe.Generic GHC.IO.Encoding.Types.CodingProgress
instance Generics.SOP.Universe.HasDatatypeInfo GHC.IO.Encoding.Types.CodingProgress
instance Generics.SOP.Universe.Generic (GHC.IO.Encoding.Types.BufferCodec from to state)
instance Generics.SOP.Universe.HasDatatypeInfo (GHC.IO.Encoding.Types.BufferCodec from to state)
instance Generics.SOP.Universe.Generic GHC.IO.Device.IODeviceType
instance Generics.SOP.Universe.HasDatatypeInfo GHC.IO.Device.IODeviceType
instance Generics.SOP.Universe.Generic GHC.IO.Buffer.BufferState
instance Generics.SOP.Universe.HasDatatypeInfo GHC.IO.Buffer.BufferState
instance Generics.SOP.Universe.Generic (GHC.IO.Buffer.Buffer e)
instance Generics.SOP.Universe.HasDatatypeInfo (GHC.IO.Buffer.Buffer e)
instance Generics.SOP.Universe.Generic GHC.Generics.Fixity
instance Generics.SOP.Universe.HasDatatypeInfo GHC.Generics.Fixity
instance Generics.SOP.Universe.Generic GHC.Generics.SourceUnpackedness
instance Generics.SOP.Universe.HasDatatypeInfo GHC.Generics.SourceUnpackedness
instance Generics.SOP.Universe.Generic GHC.Generics.SourceStrictness
instance Generics.SOP.Universe.HasDatatypeInfo GHC.Generics.SourceStrictness
instance Generics.SOP.Universe.Generic GHC.Generics.DecidedStrictness
instance Generics.SOP.Universe.HasDatatypeInfo GHC.Generics.DecidedStrictness
instance Generics.SOP.Universe.Generic GHC.Generics.Associativity
instance Generics.SOP.Universe.HasDatatypeInfo GHC.Generics.Associativity
instance Generics.SOP.Universe.Generic ((GHC.Generics.:.:) f g p)
instance Generics.SOP.Universe.HasDatatypeInfo ((GHC.Generics.:.:) f g p)
instance Generics.SOP.Universe.Generic ((GHC.Generics.:+:) f g p)
instance Generics.SOP.Universe.HasDatatypeInfo ((GHC.Generics.:+:) f g p)
instance Generics.SOP.Universe.Generic ((GHC.Generics.:*:) f g p)
instance Generics.SOP.Universe.HasDatatypeInfo ((GHC.Generics.:*:) f g p)
instance Generics.SOP.Universe.Generic GHC.Generics.C
instance Generics.SOP.Universe.HasDatatypeInfo GHC.Generics.C
instance Generics.SOP.Universe.Generic GHC.Generics.D
instance Generics.SOP.Universe.HasDatatypeInfo GHC.Generics.D
instance Generics.SOP.Universe.Generic GHC.Generics.S
instance Generics.SOP.Universe.HasDatatypeInfo GHC.Generics.S
instance Generics.SOP.Universe.Generic GHC.Generics.R
instance Generics.SOP.Universe.HasDatatypeInfo GHC.Generics.R
instance Generics.SOP.Universe.Generic (GHC.Generics.M1 i c f p)
instance Generics.SOP.Universe.HasDatatypeInfo (GHC.Generics.M1 i c f p)
instance Generics.SOP.Universe.Generic (GHC.Generics.Par1 p)
instance Generics.SOP.Universe.HasDatatypeInfo (GHC.Generics.Par1 p)
instance Generics.SOP.Universe.Generic (GHC.Generics.V1 p)
instance Generics.SOP.Universe.HasDatatypeInfo (GHC.Generics.V1 p)
instance Generics.SOP.Universe.Generic (GHC.Generics.U1 p)
instance Generics.SOP.Universe.HasDatatypeInfo (GHC.Generics.U1 p)
instance Generics.SOP.Universe.Generic (GHC.Generics.K1 i c p)
instance Generics.SOP.Universe.HasDatatypeInfo (GHC.Generics.K1 i c p)
instance Generics.SOP.Universe.Generic GHC.Types.VecElem
instance Generics.SOP.Universe.HasDatatypeInfo GHC.Types.VecElem
instance Generics.SOP.Universe.Generic GHC.Types.VecCount
instance Generics.SOP.Universe.HasDatatypeInfo GHC.Types.VecCount
instance Generics.SOP.Universe.Generic GHC.Types.RuntimeRep
instance Generics.SOP.Universe.HasDatatypeInfo GHC.Types.RuntimeRep
instance Generics.SOP.Universe.Generic GHC.ExecutionStack.Internal.SrcLoc
instance Generics.SOP.Universe.HasDatatypeInfo GHC.ExecutionStack.Internal.SrcLoc
instance Generics.SOP.Universe.Generic GHC.ExecutionStack.Internal.Location
instance Generics.SOP.Universe.HasDatatypeInfo GHC.ExecutionStack.Internal.Location
instance Generics.SOP.Universe.Generic GHC.Conc.Sync.BlockReason
instance Generics.SOP.Universe.HasDatatypeInfo GHC.Conc.Sync.BlockReason
instance Generics.SOP.Universe.Generic GHC.Conc.Sync.ThreadStatus
instance Generics.SOP.Universe.HasDatatypeInfo GHC.Conc.Sync.ThreadStatus
instance Generics.SOP.Universe.Generic GHC.ByteOrder.ByteOrder
instance Generics.SOP.Universe.HasDatatypeInfo GHC.ByteOrder.ByteOrder
instance Generics.SOP.Universe.Generic Foreign.C.Types.CDouble
instance Generics.SOP.Universe.HasDatatypeInfo Foreign.C.Types.CDouble
instance Generics.SOP.Universe.Generic Foreign.C.Types.CFloat
instance Generics.SOP.Universe.HasDatatypeInfo Foreign.C.Types.CFloat
instance Generics.SOP.Universe.Generic Foreign.C.Types.CSUSeconds
instance Generics.SOP.Universe.HasDatatypeInfo Foreign.C.Types.CSUSeconds
instance Generics.SOP.Universe.Generic Foreign.C.Types.CUSeconds
instance Generics.SOP.Universe.HasDatatypeInfo Foreign.C.Types.CUSeconds
instance Generics.SOP.Universe.Generic Foreign.C.Types.CTime
instance Generics.SOP.Universe.HasDatatypeInfo Foreign.C.Types.CTime
instance Generics.SOP.Universe.Generic Foreign.C.Types.CClock
instance Generics.SOP.Universe.HasDatatypeInfo Foreign.C.Types.CClock
instance Generics.SOP.Universe.Generic Foreign.C.Types.CUIntMax
instance Generics.SOP.Universe.HasDatatypeInfo Foreign.C.Types.CUIntMax
instance Generics.SOP.Universe.Generic Foreign.C.Types.CIntMax
instance Generics.SOP.Universe.HasDatatypeInfo Foreign.C.Types.CIntMax
instance Generics.SOP.Universe.Generic Foreign.C.Types.CUIntPtr
instance Generics.SOP.Universe.HasDatatypeInfo Foreign.C.Types.CUIntPtr
instance Generics.SOP.Universe.Generic Foreign.C.Types.CIntPtr
instance Generics.SOP.Universe.HasDatatypeInfo Foreign.C.Types.CIntPtr
instance Generics.SOP.Universe.Generic Foreign.C.Types.CULLong
instance Generics.SOP.Universe.HasDatatypeInfo Foreign.C.Types.CULLong
instance Generics.SOP.Universe.Generic Foreign.C.Types.CLLong
instance Generics.SOP.Universe.HasDatatypeInfo Foreign.C.Types.CLLong
instance Generics.SOP.Universe.Generic Foreign.C.Types.CSigAtomic
instance Generics.SOP.Universe.HasDatatypeInfo Foreign.C.Types.CSigAtomic
instance Generics.SOP.Universe.Generic Foreign.C.Types.CWchar
instance Generics.SOP.Universe.HasDatatypeInfo Foreign.C.Types.CWchar
instance Generics.SOP.Universe.Generic Foreign.C.Types.CSize
instance Generics.SOP.Universe.HasDatatypeInfo Foreign.C.Types.CSize
instance Generics.SOP.Universe.Generic Foreign.C.Types.CPtrdiff
instance Generics.SOP.Universe.HasDatatypeInfo Foreign.C.Types.CPtrdiff
instance Generics.SOP.Universe.Generic Foreign.C.Types.CULong
instance Generics.SOP.Universe.HasDatatypeInfo Foreign.C.Types.CULong
instance Generics.SOP.Universe.Generic Foreign.C.Types.CLong
instance Generics.SOP.Universe.HasDatatypeInfo Foreign.C.Types.CLong
instance Generics.SOP.Universe.Generic Foreign.C.Types.CUInt
instance Generics.SOP.Universe.HasDatatypeInfo Foreign.C.Types.CUInt
instance Generics.SOP.Universe.Generic Foreign.C.Types.CInt
instance Generics.SOP.Universe.HasDatatypeInfo Foreign.C.Types.CInt
instance Generics.SOP.Universe.Generic Foreign.C.Types.CUShort
instance Generics.SOP.Universe.HasDatatypeInfo Foreign.C.Types.CUShort
instance Generics.SOP.Universe.Generic Foreign.C.Types.CShort
instance Generics.SOP.Universe.HasDatatypeInfo Foreign.C.Types.CShort
instance Generics.SOP.Universe.Generic Foreign.C.Types.CUChar
instance Generics.SOP.Universe.HasDatatypeInfo Foreign.C.Types.CUChar
instance Generics.SOP.Universe.Generic Foreign.C.Types.CSChar
instance Generics.SOP.Universe.HasDatatypeInfo Foreign.C.Types.CSChar
instance Generics.SOP.Universe.Generic Foreign.C.Types.CChar
instance Generics.SOP.Universe.HasDatatypeInfo Foreign.C.Types.CChar
instance Generics.SOP.Universe.Generic Foreign.C.Error.Errno
instance Generics.SOP.Universe.HasDatatypeInfo Foreign.C.Error.Errno
instance Generics.SOP.Universe.Generic GHC.Base.Void
instance Generics.SOP.Universe.HasDatatypeInfo GHC.Base.Void
instance Generics.SOP.Universe.Generic Data.Version.Version
instance Generics.SOP.Universe.HasDatatypeInfo Data.Version.Version
instance Generics.SOP.Universe.Generic (Data.Semigroup.Arg a b)
instance Generics.SOP.Universe.HasDatatypeInfo (Data.Semigroup.Arg a b)
instance Generics.SOP.Universe.Generic (Data.Semigroup.WrappedMonoid m)
instance Generics.SOP.Universe.HasDatatypeInfo (Data.Semigroup.WrappedMonoid m)
instance Generics.SOP.Universe.Generic (Data.Semigroup.Last a)
instance Generics.SOP.Universe.HasDatatypeInfo (Data.Semigroup.Last a)
instance Generics.SOP.Universe.Generic (Data.Semigroup.First a)
instance Generics.SOP.Universe.HasDatatypeInfo (Data.Semigroup.First a)
instance Generics.SOP.Universe.Generic (Data.Semigroup.Max a)
instance Generics.SOP.Universe.HasDatatypeInfo (Data.Semigroup.Max a)
instance Generics.SOP.Universe.Generic (Data.Semigroup.Min a)
instance Generics.SOP.Universe.HasDatatypeInfo (Data.Semigroup.Min a)
instance Generics.SOP.Universe.Generic (Data.Proxy.Proxy t)
instance Generics.SOP.Universe.HasDatatypeInfo (Data.Proxy.Proxy t)
instance Generics.SOP.Universe.Generic (Data.Ord.Down a)
instance Generics.SOP.Universe.HasDatatypeInfo (Data.Ord.Down a)
instance Generics.SOP.Universe.Generic (Data.Semigroup.Internal.Alt f a)
instance Generics.SOP.Universe.HasDatatypeInfo (Data.Semigroup.Internal.Alt f a)
instance Generics.SOP.Universe.Generic (Data.Monoid.Last a)
instance Generics.SOP.Universe.HasDatatypeInfo (Data.Monoid.Last a)
instance Generics.SOP.Universe.Generic (Data.Monoid.First a)
instance Generics.SOP.Universe.HasDatatypeInfo (Data.Monoid.First a)
instance Generics.SOP.Universe.Generic (Data.Semigroup.Internal.Product a)
instance Generics.SOP.Universe.HasDatatypeInfo (Data.Semigroup.Internal.Product a)
instance Generics.SOP.Universe.Generic (Data.Semigroup.Internal.Sum a)
instance Generics.SOP.Universe.HasDatatypeInfo (Data.Semigroup.Internal.Sum a)
instance Generics.SOP.Universe.Generic Data.Semigroup.Internal.Any
instance Generics.SOP.Universe.HasDatatypeInfo Data.Semigroup.Internal.Any
instance Generics.SOP.Universe.Generic Data.Semigroup.Internal.All
instance Generics.SOP.Universe.HasDatatypeInfo Data.Semigroup.Internal.All
instance Generics.SOP.Universe.Generic (Data.Semigroup.Internal.Endo a)
instance Generics.SOP.Universe.HasDatatypeInfo (Data.Semigroup.Internal.Endo a)
instance Generics.SOP.Universe.Generic (Data.Semigroup.Internal.Dual a)
instance Generics.SOP.Universe.HasDatatypeInfo (Data.Semigroup.Internal.Dual a)
instance Generics.SOP.Universe.Generic (GHC.Base.NonEmpty a)
instance Generics.SOP.Universe.HasDatatypeInfo (GHC.Base.NonEmpty a)
instance Generics.SOP.Universe.Generic (Data.Functor.Sum.Sum f g a)
instance Generics.SOP.Universe.HasDatatypeInfo (Data.Functor.Sum.Sum f g a)
instance Generics.SOP.Universe.Generic (Data.Functor.Product.Product f g a)
instance Generics.SOP.Universe.HasDatatypeInfo (Data.Functor.Product.Product f g a)
instance Generics.SOP.Universe.Generic (Data.Functor.Identity.Identity a)
instance Generics.SOP.Universe.HasDatatypeInfo (Data.Functor.Identity.Identity a)
instance Generics.SOP.Universe.Generic (Data.Functor.Const.Const a b)
instance Generics.SOP.Universe.HasDatatypeInfo (Data.Functor.Const.Const a b)
instance Generics.SOP.Universe.Generic (Data.Functor.Compose.Compose f g a)
instance Generics.SOP.Universe.HasDatatypeInfo (Data.Functor.Compose.Compose f g a)
instance Generics.SOP.Universe.Generic Data.Fixed.E12
instance Generics.SOP.Universe.HasDatatypeInfo Data.Fixed.E12
instance Generics.SOP.Universe.Generic Data.Fixed.E9
instance Generics.SOP.Universe.HasDatatypeInfo Data.Fixed.E9
instance Generics.SOP.Universe.Generic Data.Fixed.E6
instance Generics.SOP.Universe.HasDatatypeInfo Data.Fixed.E6
instance Generics.SOP.Universe.Generic Data.Fixed.E3
instance Generics.SOP.Universe.HasDatatypeInfo Data.Fixed.E3
instance Generics.SOP.Universe.Generic Data.Fixed.E2
instance Generics.SOP.Universe.HasDatatypeInfo Data.Fixed.E2
instance Generics.SOP.Universe.Generic Data.Fixed.E1
instance Generics.SOP.Universe.HasDatatypeInfo Data.Fixed.E1
instance Generics.SOP.Universe.Generic Data.Fixed.E0
instance Generics.SOP.Universe.HasDatatypeInfo Data.Fixed.E0
instance Generics.SOP.Universe.Generic (Data.Fixed.Fixed a)
instance Generics.SOP.Universe.HasDatatypeInfo (Data.Fixed.Fixed a)
instance Generics.SOP.Universe.Generic Data.Data.ConstrRep
instance Generics.SOP.Universe.HasDatatypeInfo Data.Data.ConstrRep
instance Generics.SOP.Universe.Generic Data.Data.Fixity
instance Generics.SOP.Universe.HasDatatypeInfo Data.Data.Fixity
instance Generics.SOP.Universe.Generic Data.Data.DataRep
instance Generics.SOP.Universe.HasDatatypeInfo Data.Data.DataRep
instance Generics.SOP.Universe.Generic (Data.Complex.Complex a)
instance Generics.SOP.Universe.HasDatatypeInfo (Data.Complex.Complex a)
instance Generics.SOP.Universe.Generic GHC.Unicode.GeneralCategory
instance Generics.SOP.Universe.HasDatatypeInfo GHC.Unicode.GeneralCategory
instance Generics.SOP.Universe.Generic GHC.IO.MaskingState
instance Generics.SOP.Universe.HasDatatypeInfo GHC.IO.MaskingState
instance Generics.SOP.Universe.Generic Control.Exception.Base.TypeError
instance Generics.SOP.Universe.HasDatatypeInfo Control.Exception.Base.TypeError
instance Generics.SOP.Universe.Generic GHC.Exception.ErrorCall
instance Generics.SOP.Universe.HasDatatypeInfo GHC.Exception.ErrorCall
instance Generics.SOP.Universe.Generic Control.Exception.Base.RecUpdError
instance Generics.SOP.Universe.HasDatatypeInfo Control.Exception.Base.RecUpdError
instance Generics.SOP.Universe.Generic Control.Exception.Base.RecSelError
instance Generics.SOP.Universe.HasDatatypeInfo Control.Exception.Base.RecSelError
instance Generics.SOP.Universe.Generic Control.Exception.Base.RecConError
instance Generics.SOP.Universe.HasDatatypeInfo Control.Exception.Base.RecConError
instance Generics.SOP.Universe.Generic Control.Exception.Base.PatternMatchFail
instance Generics.SOP.Universe.HasDatatypeInfo Control.Exception.Base.PatternMatchFail
instance Generics.SOP.Universe.Generic Control.Exception.Base.NoMethodError
instance Generics.SOP.Universe.HasDatatypeInfo Control.Exception.Base.NoMethodError
instance Generics.SOP.Universe.Generic GHC.IO.Exception.Deadlock
instance Generics.SOP.Universe.HasDatatypeInfo GHC.IO.Exception.Deadlock
instance Generics.SOP.Universe.Generic GHC.IO.Exception.AllocationLimitExceeded
instance Generics.SOP.Universe.HasDatatypeInfo GHC.IO.Exception.AllocationLimitExceeded
instance Generics.SOP.Universe.Generic GHC.IO.Exception.BlockedIndefinitelyOnSTM
instance Generics.SOP.Universe.HasDatatypeInfo GHC.IO.Exception.BlockedIndefinitelyOnSTM
instance Generics.SOP.Universe.Generic GHC.IO.Exception.BlockedIndefinitelyOnMVar
instance Generics.SOP.Universe.HasDatatypeInfo GHC.IO.Exception.BlockedIndefinitelyOnMVar
instance Generics.SOP.Universe.Generic Control.Exception.Base.NestedAtomically
instance Generics.SOP.Universe.HasDatatypeInfo Control.Exception.Base.NestedAtomically
instance Generics.SOP.Universe.Generic Control.Exception.Base.NonTermination
instance Generics.SOP.Universe.HasDatatypeInfo Control.Exception.Base.NonTermination
instance Generics.SOP.Universe.Generic GHC.IO.Exception.AsyncException
instance Generics.SOP.Universe.HasDatatypeInfo GHC.IO.Exception.AsyncException
instance Generics.SOP.Universe.Generic GHC.IO.Exception.AssertionFailed
instance Generics.SOP.Universe.HasDatatypeInfo GHC.IO.Exception.AssertionFailed
instance Generics.SOP.Universe.Generic GHC.IO.Exception.ArrayException
instance Generics.SOP.Universe.HasDatatypeInfo GHC.IO.Exception.ArrayException
instance Generics.SOP.Universe.Generic GHC.Exception.Type.ArithException
instance Generics.SOP.Universe.HasDatatypeInfo GHC.Exception.Type.ArithException
instance Generics.SOP.Universe.Generic GHC.IO.Exception.IOException
instance Generics.SOP.Universe.HasDatatypeInfo GHC.IO.Exception.IOException
instance Generics.SOP.Universe.Generic [a]
instance Generics.SOP.Universe.HasDatatypeInfo [a]
instance Generics.SOP.Universe.Generic (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, t26, t27, t28, t29)
instance Generics.SOP.Universe.HasDatatypeInfo (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, t26, t27, t28, t29)
instance Generics.SOP.Universe.Generic (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, t26, t27, t28)
instance Generics.SOP.Universe.HasDatatypeInfo (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, t26, t27, t28)
instance Generics.SOP.Universe.Generic (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, t26, t27)
instance Generics.SOP.Universe.HasDatatypeInfo (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, t26, t27)
instance Generics.SOP.Universe.Generic (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, t26)
instance Generics.SOP.Universe.HasDatatypeInfo (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, t26)
instance Generics.SOP.Universe.Generic (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z)
instance Generics.SOP.Universe.HasDatatypeInfo (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z)
instance Generics.SOP.Universe.Generic (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y)
instance Generics.SOP.Universe.HasDatatypeInfo (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y)
instance Generics.SOP.Universe.Generic (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x)
instance Generics.SOP.Universe.HasDatatypeInfo (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x)
instance Generics.SOP.Universe.Generic (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w)
instance Generics.SOP.Universe.HasDatatypeInfo (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w)
instance Generics.SOP.Universe.Generic (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v)
instance Generics.SOP.Universe.HasDatatypeInfo (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v)
instance Generics.SOP.Universe.Generic (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u)
instance Generics.SOP.Universe.HasDatatypeInfo (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u)
instance Generics.SOP.Universe.Generic (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t)
instance Generics.SOP.Universe.HasDatatypeInfo (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t)
instance Generics.SOP.Universe.Generic (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s)
instance Generics.SOP.Universe.HasDatatypeInfo (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s)
instance Generics.SOP.Universe.Generic (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r)
instance Generics.SOP.Universe.HasDatatypeInfo (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r)
instance Generics.SOP.Universe.Generic (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q)
instance Generics.SOP.Universe.HasDatatypeInfo (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q)
instance Generics.SOP.Universe.Generic (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p)
instance Generics.SOP.Universe.HasDatatypeInfo (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p)
instance Generics.SOP.Universe.Generic (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o)
instance Generics.SOP.Universe.HasDatatypeInfo (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o)
instance Generics.SOP.Universe.Generic (a, b, c, d, e, f, g, h, i, j, k, l, m, n)
instance Generics.SOP.Universe.HasDatatypeInfo (a, b, c, d, e, f, g, h, i, j, k, l, m, n)
instance Generics.SOP.Universe.Generic (a, b, c, d, e, f, g, h, i, j, k, l, m)
instance Generics.SOP.Universe.HasDatatypeInfo (a, b, c, d, e, f, g, h, i, j, k, l, m)
instance Generics.SOP.Universe.Generic (a, b, c, d, e, f, g, h, i, j, k, l)
instance Generics.SOP.Universe.HasDatatypeInfo (a, b, c, d, e, f, g, h, i, j, k, l)
instance Generics.SOP.Universe.Generic (a, b, c, d, e, f, g, h, i, j, k)
instance Generics.SOP.Universe.HasDatatypeInfo (a, b, c, d, e, f, g, h, i, j, k)
instance Generics.SOP.Universe.Generic (a, b, c, d, e, f, g, h, i, j)
instance Generics.SOP.Universe.HasDatatypeInfo (a, b, c, d, e, f, g, h, i, j)
instance Generics.SOP.Universe.Generic (a, b, c, d, e, f, g, h, i)
instance Generics.SOP.Universe.HasDatatypeInfo (a, b, c, d, e, f, g, h, i)
instance Generics.SOP.Universe.Generic (a, b, c, d, e, f, g, h)
instance Generics.SOP.Universe.HasDatatypeInfo (a, b, c, d, e, f, g, h)
instance Generics.SOP.Universe.Generic (a, b, c, d, e, f, g)
instance Generics.SOP.Universe.HasDatatypeInfo (a, b, c, d, e, f, g)
instance Generics.SOP.Universe.Generic (a, b, c, d, e, f)
instance Generics.SOP.Universe.HasDatatypeInfo (a, b, c, d, e, f)
instance Generics.SOP.Universe.Generic (a, b, c, d, e)
instance Generics.SOP.Universe.HasDatatypeInfo (a, b, c, d, e)
instance Generics.SOP.Universe.Generic (a, b, c, d)
instance Generics.SOP.Universe.HasDatatypeInfo (a, b, c, d)
instance Generics.SOP.Universe.Generic (a, b, c)
instance Generics.SOP.Universe.HasDatatypeInfo (a, b, c)
instance Generics.SOP.Universe.Generic (a, b)
instance Generics.SOP.Universe.HasDatatypeInfo (a, b)
instance Generics.SOP.Universe.Generic ()
instance Generics.SOP.Universe.HasDatatypeInfo ()
instance Generics.SOP.Universe.Generic (Data.Either.Either a b)
instance Generics.SOP.Universe.HasDatatypeInfo (Data.Either.Either a b)
instance Generics.SOP.Universe.Generic (GHC.Maybe.Maybe a)
instance Generics.SOP.Universe.HasDatatypeInfo (GHC.Maybe.Maybe a)
instance Generics.SOP.Universe.Generic GHC.Types.Ordering
instance Generics.SOP.Universe.HasDatatypeInfo GHC.Types.Ordering
instance Generics.SOP.Universe.Generic GHC.Types.Bool
instance Generics.SOP.Universe.HasDatatypeInfo GHC.Types.Bool
instance Generics.SOP.Universe.Generic ((Data.SOP.Classes.-.->) f g a)
instance Generics.SOP.Universe.HasDatatypeInfo ((Data.SOP.Classes.-.->) f g a)
instance Generics.SOP.Universe.Generic ((Data.SOP.BasicFunctors.:.:) f g p)
instance Generics.SOP.Universe.HasDatatypeInfo ((Data.SOP.BasicFunctors.:.:) f g p)
instance Generics.SOP.Universe.Generic (Data.SOP.BasicFunctors.K a b)
instance Generics.SOP.Universe.HasDatatypeInfo (Data.SOP.BasicFunctors.K a b)
instance Generics.SOP.Universe.Generic (Data.SOP.BasicFunctors.I a)
instance Generics.SOP.Universe.HasDatatypeInfo (Data.SOP.BasicFunctors.I a)


-- | Main module of <tt>generics-sop</tt>
--   
--   In most cases, you will probably want to import just this module, and
--   possibly <a>Generics.SOP.TH</a> if you want to use Template Haskell to
--   generate <a>Generic</a> instances for you.
--   
--   <h1>Generic programming with sums of products</h1>
--   
--   You need this library if you want to define your own generic functions
--   in the sum-of-products SOP style. Generic programming in the SOP style
--   follows the following idea:
--   
--   <ol>
--   <li>A large class of datatypes can be viewed in a uniform, structured
--   way: the choice between constructors is represented using an n-ary sum
--   (called <a>NS</a>), and the arguments of each constructor are
--   represented using an n-ary product (called <a>NP</a>).</li>
--   <li>The library captures the notion of a datatype being representable
--   in the following way. There is a class <a>Generic</a>, which for a
--   given datatype <tt>A</tt>, associates the isomorphic SOP
--   representation with the original type under the name <tt><a>Rep</a>
--   A</tt>. The class also provides functions <a>from</a> and <a>to</a>
--   that convert between <tt>A</tt> and <tt><a>Rep</a> A</tt> and witness
--   the isomorphism.</li>
--   <li>Since all <a>Rep</a> types are sums of products, you can define
--   functions over them by performing induction on the structure, or by
--   using predefined combinators that the library provides. Such functions
--   then work for all <a>Rep</a> types.</li>
--   <li>By combining the conversion functions <a>from</a> and <a>to</a>
--   with the function that works on <a>Rep</a> types, we obtain a function
--   that works on all types that are in the <a>Generic</a> class.</li>
--   <li>Most types can very easily be made an instance of <a>Generic</a>.
--   For example, if the datatype can be represented using GHC's built-in
--   approach to generic programming and has an instance for the
--   <a>Generic</a> class from module <a>GHC.Generics</a>, then an instance
--   of the SOP <a>Generic</a> can automatically be derived. There is also
--   Template Haskell code in <a>Generics.SOP.TH</a> that allows to
--   auto-generate an instance of <a>Generic</a> for most types.</li>
--   </ol>
--   
--   <h1>Example</h1>
--   
--   <h2>Instantiating a datatype for use with SOP generics</h2>
--   
--   Let's assume we have the datatypes:
--   
--   <pre>
--   data A   = C Bool | D A Int | E (B ())
--   data B a = F | G a Char Bool
--   </pre>
--   
--   To create <a>Generic</a> instances for <tt>A</tt> and <tt>B</tt> via
--   <a>GHC.Generics</a>, we say
--   
--   <pre>
--   {-# LANGUAGE DeriveGeneric #-}
--   
--   import qualified GHC.Generics as GHC
--   import Generics.SOP
--   
--   data A   = C Bool | D A Int | E (B ())
--     deriving (Show, GHC.Generic)
--   data B a = F | G a Char Bool
--     deriving (Show, GHC.Generic)
--   
--   instance Generic A     -- empty
--   instance Generic (B a) -- empty
--   </pre>
--   
--   Now we can convert between <tt>A</tt> and <tt><a>Rep</a> A</tt> (and
--   between <tt>B</tt> and <tt><a>Rep</a> B</tt>). For example,
--   
--   <pre>
--   &gt;&gt;&gt; from (D (C True) 3) :: Rep A
--   SOP (S (Z (I (C True) :* I 3 :* Nil)))
--   
--   &gt;&gt;&gt; to it :: A
--   D (C True) 3
--   </pre>
--   
--   Note that the transformation is shallow: In <tt>D (C True) 3</tt>, the
--   inner value <tt>C True</tt> of type <tt>A</tt> is not affected by the
--   transformation.
--   
--   For more details about <tt><a>Rep</a> A</tt>, have a look at the
--   <a>Generics.SOP.Universe</a> module.
--   
--   <h2>Defining a generic function</h2>
--   
--   As an example of a generic function, let us define a generic version
--   of <a>rnf</a> from the <tt>deepseq</tt> package.
--   
--   The type of <a>rnf</a> is
--   
--   <pre>
--   NFData a =&gt; a -&gt; ()
--   </pre>
--   
--   and the idea is that for a term <tt>x</tt> of type <tt>a</tt> in the
--   <a>NFData</a> class, <tt>rnf x</tt> forces complete evaluation of
--   <tt>x</tt> (i.e., evaluation to <i>normal form</i>), and returns
--   <tt>()</tt>.
--   
--   We call the generic version of this function <tt>grnf</tt>. A direct
--   definition in SOP style, making use of structural recursion on the
--   sums and products, looks as follows:
--   
--   <pre>
--   grnf :: (<a>Generic</a> a, <a>All2</a> NFData (<a>Code</a> a)) =&gt; a -&gt; ()
--   grnf x = grnfS (<a>from</a> x)
--   
--   grnfS :: (<a>All2</a> NFData xss) =&gt; <a>SOP</a> <a>I</a> xss -&gt; ()
--   grnfS (<a>SOP</a> (<a>Z</a> xs))  = grnfP xs
--   grnfS (<a>SOP</a> (<a>S</a> xss)) = grnfS (<a>SOP</a> xss)
--   
--   grnfP :: (<a>All</a> NFData xs) =&gt; <a>NP</a> <a>I</a> xs -&gt; ()
--   grnfP <a>Nil</a>         = ()
--   grnfP (<a>I</a> x <a>:*</a> xs) = x `deepseq` (grnfP xs)
--   </pre>
--   
--   The <tt>grnf</tt> function performs the conversion between <tt>a</tt>
--   and <tt><a>Rep</a> a</tt> by applying <a>from</a> and then applies
--   <tt>grnfS</tt>. The type of <tt>grnf</tt> indicates that <tt>a</tt>
--   must be in the <a>Generic</a> class so that we can apply <a>from</a>,
--   and that all the components of <tt>a</tt> (i.e., all the types that
--   occur as constructor arguments) must be in the <tt>NFData</tt> class
--   (<a>All2</a>).
--   
--   The function <tt>grnfS</tt> traverses the outer sum structure of the
--   sum of products (note that <tt><a>Rep</a> a = <a>SOP</a> <a>I</a>
--   (<a>Code</a> a)</tt>). It encodes which constructor was used to
--   construct the original argument of type <tt>a</tt>. Once we've found
--   the constructor in question (<a>Z</a>), we traverse the arguments of
--   that constructor using <tt>grnfP</tt>.
--   
--   The function <tt>grnfP</tt> traverses the product structure of the
--   constructor arguments. Each argument is evaluated using the
--   <a>deepseq</a> function from the <a>NFData</a> class. This requires
--   that all components of the product must be in the <tt>NFData</tt>
--   class (<a>All</a>) and triggers the corresponding constraints on the
--   other functions. Once the end of the product is reached (<a>Nil</a>),
--   we return <tt>()</tt>.
--   
--   <h2>Defining a generic function using combinators</h2>
--   
--   In many cases, generic functions can be written in a much more concise
--   way by avoiding the explicit structural recursion and resorting to the
--   powerful combinators provided by this library instead.
--   
--   For example, the <tt>grnf</tt> function can also be defined as a
--   one-liner as follows:
--   
--   <pre>
--   grnf :: (<a>Generic</a> a, <a>All2</a> NFData (<a>Code</a> a)) =&gt; a -&gt; ()
--   grnf = <tt>rnf</tt> . <a>hcollapse</a> . <a>hcmap</a> (<a>Proxy</a> :: <a>Proxy</a> NFData) (<a>mapIK</a> rnf) . <a>from</a>
--   </pre>
--   
--   <a>mapIK</a> and friends (<a>mapII</a>, <a>mapKI</a>, etc.) are small
--   helpers for working with <a>I</a> and <a>K</a> functors, for example
--   <a>mapIK</a> is defined as <tt><a>mapIK</a> f = \ (<a>I</a> x) -&gt;
--   <a>K</a> (f x)</tt>
--   
--   The following interaction should provide an idea of the individual
--   transformation steps:
--   
--   <pre>
--   &gt;&gt;&gt; let x = G 2.5 'A' False :: B Double
--   
--   &gt;&gt;&gt; from x
--   SOP (S (Z (I 2.5 :* I 'A' :* I False :* Nil)))
--   
--   &gt;&gt;&gt; hcmap (Proxy :: Proxy NFData) (mapIK rnf) it
--   SOP (S (Z (K () :* K () :* K () :* Nil)))
--   
--   &gt;&gt;&gt; hcollapse it
--   [(),(),()]
--   
--   &gt;&gt;&gt; rnf it
--   ()
--   </pre>
--   
--   The <a>from</a> call converts into the structural representation. Via
--   <a>hcmap</a>, we apply <tt>rnf</tt> to all the components. The result
--   is a sum of products of the same shape, but the components are no
--   longer heterogeneous (<a>I</a>), but homogeneous (<tt><a>K</a>
--   ()</tt>). A homogeneous structure can be collapsed (<a>hcollapse</a>)
--   into a normal Haskell list. Finally, <tt>rnf</tt> actually forces
--   evaluation of this list (and thereby actually drives the evaluation of
--   all the previous steps) and produces the final result.
--   
--   <h2>Using a generic function</h2>
--   
--   We can directly invoke <tt>grnf</tt> on any type that is an instance
--   of class <a>Generic</a>.
--   
--   <pre>
--   &gt;&gt;&gt; grnf (G 2.5 'A' False)
--   ()
--   
--   &gt;&gt;&gt; grnf (G 2.5 undefined False)
--   *** Exception: Prelude.undefined
--   ...
--   </pre>
--   
--   Note that the type of <tt>grnf</tt> requires that all components of
--   the type are in the <a>NFData</a> class. For a recursive datatype such
--   as <tt>B</tt>, this means that we have to make <tt>A</tt> (and in this
--   case, also <tt>B</tt>) an instance of <a>NFData</a> in order to be
--   able to use the <tt>grnf</tt> function. But we can use <tt>grnf</tt>
--   to supply the instance definitions:
--   
--   <pre>
--   instance NFData A where rnf = grnf
--   instance NFData a =&gt; NFData (B a) where rnf = grnf
--   </pre>
--   
--   <h1>More examples</h1>
--   
--   The best way to learn about how to define generic functions in the SOP
--   style is to look at a few simple examples. Examples are provided by
--   the following packages:
--   
--   <ul>
--   <li><tt><a>basic-sop</a></tt> basic examples,</li>
--   <li><tt><a>pretty-sop</a></tt> generic pretty printing,</li>
--   <li><tt><a>lens-sop</a></tt> generically computed lenses,</li>
--   <li><tt><a>json-sop</a></tt> generic JSON conversions.</li>
--   </ul>
--   
--   The generic functions in these packages use a wide variety of the
--   combinators that are offered by the library.
--   
--   <h1>Paper</h1>
--   
--   A detailed description of the ideas behind this library is provided by
--   the paper:
--   
--   <ul>
--   <li>Edsko de Vries and Andres Löh. <a>True Sums of Products</a>.
--   Workshop on Generic Programming (WGP) 2014.</li>
--   </ul>
module Generics.SOP

-- | The class of representable datatypes.
--   
--   The SOP approach to generic programming is based on viewing datatypes
--   as a representation (<a>Rep</a>) built from the sum of products of its
--   components. The components of a datatype are specified using the
--   <a>Code</a> type family.
--   
--   The isomorphism between the original Haskell datatype and its
--   representation is witnessed by the methods of this class, <a>from</a>
--   and <a>to</a>. So for instances of this class, the following laws
--   should (in general) hold:
--   
--   <pre>
--   <a>to</a> <a>.</a> <a>from</a> === <a>id</a> :: a -&gt; a
--   <a>from</a> <a>.</a> <a>to</a> === <a>id</a> :: <a>Rep</a> a -&gt; <a>Rep</a> a
--   </pre>
--   
--   You typically don't define instances of this class by hand, but rather
--   derive the class instance automatically.
--   
--   <i>Option 1:</i> Derive via the built-in GHC-generics. For this, you
--   need to use the <tt>DeriveGeneric</tt> extension to first derive an
--   instance of the <a>Generic</a> class from module <a>GHC.Generics</a>.
--   With this, you can then give an empty instance for <a>Generic</a>, and
--   the default definitions will just work. The pattern looks as follows:
--   
--   <pre>
--   import qualified <a>GHC.Generics</a> as GHC
--   import <a>Generics.SOP</a>
--   
--   ...
--   
--   data T = ... deriving (GHC.<a>Generic</a>, ...)
--   
--   instance <a>Generic</a> T -- empty
--   instance <a>HasDatatypeInfo</a> T -- empty, if you want/need metadata
--   </pre>
--   
--   <i>Option 2:</i> Derive via Template Haskell. For this, you need to
--   enable the <tt>TemplateHaskell</tt> extension. You can then use
--   <a>deriveGeneric</a> from module <a>Generics.SOP.TH</a> to have the
--   instance generated for you. The pattern looks as follows:
--   
--   <pre>
--   import <a>Generics.SOP</a>
--   import <a>Generics.SOP.TH</a>
--   
--   ...
--   
--   data T = ...
--   
--   <a>deriveGeneric</a> ''T -- derives <a>HasDatatypeInfo</a> as well
--   </pre>
--   
--   <i>Tradeoffs:</i> Whether to use Option 1 or 2 is mainly a matter of
--   personal taste. The version based on Template Haskell probably has
--   less run-time overhead.
--   
--   <i>Non-standard instances:</i> It is possible to give <a>Generic</a>
--   instances manually that deviate from the standard scheme, as long as
--   at least
--   
--   <pre>
--   <a>to</a> <a>.</a> <a>from</a> === <a>id</a> :: a -&gt; a
--   </pre>
--   
--   still holds.
class (All SListI (Code a)) => Generic (a :: Type) where {
    
    -- | The code of a datatype.
    --   
    --   This is a list of lists of its components. The outer list contains one
    --   element per constructor. The inner list contains one element per
    --   constructor argument (field).
    --   
    --   <i>Example:</i> The datatype
    --   
    --   <pre>
    --   data Tree = Leaf Int | Node Tree Tree
    --   </pre>
    --   
    --   is supposed to have the following code:
    --   
    --   <pre>
    --   type instance Code (Tree a) =
    --     '[ '[ Int ]
    --      , '[ Tree, Tree ]
    --      ]
    --   </pre>
    type Code a :: [[Type]];
    type Code a = GCode a;
}

-- | Converts from a value to its structural representation.
from :: Generic a => a -> Rep a

-- | Converts from a value to its structural representation.
from :: (Generic a, GFrom a, Generic a, Rep a ~ SOP I (GCode a)) => a -> Rep a

-- | Converts from a structural representation back to the original value.
to :: Generic a => Rep a -> a

-- | Converts from a structural representation back to the original value.
to :: (Generic a, GTo a, Generic a, Rep a ~ SOP I (GCode a)) => Rep a -> a

-- | The (generic) representation of a datatype.
--   
--   A datatype is isomorphic to the sum-of-products of its code. The
--   isomorphism is witnessed by <a>from</a> and <a>to</a> from the
--   <a>Generic</a> class.
type Rep a = SOP I (Code a)

-- | Constraint that captures that a datatype is a product type, i.e., a
--   type with a single constructor.
--   
--   It also gives access to the code for the arguments of that
--   constructor.
type IsProductType (a :: Type) (xs :: [Type]) = (Generic a, Code a ~ '[xs])

-- | Direct access to the part of the code that is relevant for a product
--   type.
type ProductCode (a :: Type) = Head (Code a)

-- | Convert from a product type to its product representation.
productTypeFrom :: IsProductType a xs => a -> NP I xs

-- | Convert a product representation to the original type.
productTypeTo :: IsProductType a xs => NP I xs -> a

-- | Constraint that captures that a datatype is an enumeration type, i.e.,
--   none of the constructors have any arguments.
type IsEnumType (a :: Type) = (Generic a, All ((~) '[]) (Code a))

-- | Convert from an enum type to its sum representation.
enumTypeFrom :: IsEnumType a => a -> NS (K ()) (Code a)

-- | Convert a sum representation to ihe original type.
enumTypeTo :: IsEnumType a => NS (K ()) (Code a) -> a

-- | Constraint that captures that a datatype is a single-constructor,
--   single-field datatype. This always holds for newtype-defined types,
--   but it can also be true for data-defined types.
--   
--   The constraint also gives access to the type that is wrapped.
type IsWrappedType (a :: Type) (x :: Type) = (Generic a, Code a ~ '[ '[x]])

-- | Direct access to the part of the code that is relevant for wrapped
--   types and newtypes.
type WrappedCode (a :: Type) = Head (Head (Code a))

-- | Convert from a wrapped type to its inner type.
wrappedTypeFrom :: IsWrappedType a x => a -> x

-- | Convert a type to a wrapped type.
wrappedTypeTo :: IsWrappedType a x => x -> a

-- | Constraint that captures that a datatype is a newtype. This makes use
--   of the fact that newtypes are always coercible to the type they wrap,
--   whereas datatypes are not.
type IsNewtype (a :: Type) (x :: Type) = (IsWrappedType a x, Coercible a x)

-- | Convert a newtype to its inner type.
--   
--   This is a specialised synonym for <a>coerce</a>.
newtypeFrom :: IsNewtype a x => a -> x

-- | Convert a type to a newtype.
--   
--   This is a specialised synonym for <a>coerce</a>.
newtypeTo :: IsNewtype a x => x -> a

-- | An n-ary product.
--   
--   The product is parameterized by a type constructor <tt>f</tt> and
--   indexed by a type-level list <tt>xs</tt>. The length of the list
--   determines the number of elements in the product, and if the
--   <tt>i</tt>-th element of the list is of type <tt>x</tt>, then the
--   <tt>i</tt>-th element of the product is of type <tt>f x</tt>.
--   
--   The constructor names are chosen to resemble the names of the list
--   constructors.
--   
--   Two common instantiations of <tt>f</tt> are the identity functor
--   <a>I</a> and the constant functor <a>K</a>. For <a>I</a>, the product
--   becomes a heterogeneous list, where the type-level list describes the
--   types of its components. For <tt><a>K</a> a</tt>, the product becomes
--   a homogeneous list, where the contents of the type-level list are
--   ignored, but its length still specifies the number of elements.
--   
--   In the context of the SOP approach to generic programming, an n-ary
--   product describes the structure of the arguments of a single data
--   constructor.
--   
--   <i>Examples:</i>
--   
--   <pre>
--   I 'x'    :* I True  :* Nil  ::  NP I       '[ Char, Bool ]
--   K 0      :* K 1     :* Nil  ::  NP (K Int) '[ Char, Bool ]
--   Just 'x' :* Nothing :* Nil  ::  NP Maybe   '[ Char, Bool ]
--   </pre>
data () => NP (a :: k -> Type) (b :: [k])
[Nil] :: forall {k} (a :: k -> Type). NP a ('[] :: [k])
[:*] :: forall {k} (a :: k -> Type) (x :: k) (xs :: [k]). a x -> NP a xs -> NP a (x ': xs)
infixr 5 :*

-- | An n-ary sum.
--   
--   The sum is parameterized by a type constructor <tt>f</tt> and indexed
--   by a type-level list <tt>xs</tt>. The length of the list determines
--   the number of choices in the sum and if the <tt>i</tt>-th element of
--   the list is of type <tt>x</tt>, then the <tt>i</tt>-th choice of the
--   sum is of type <tt>f x</tt>.
--   
--   The constructor names are chosen to resemble Peano-style natural
--   numbers, i.e., <a>Z</a> is for "zero", and <a>S</a> is for
--   "successor". Chaining <a>S</a> and <a>Z</a> chooses the corresponding
--   component of the sum.
--   
--   <i>Examples:</i>
--   
--   <pre>
--   Z         :: f x -&gt; NS f (x ': xs)
--   S . Z     :: f y -&gt; NS f (x ': y ': xs)
--   S . S . Z :: f z -&gt; NS f (x ': y ': z ': xs)
--   ...
--   </pre>
--   
--   Note that empty sums (indexed by an empty list) have no non-bottom
--   elements.
--   
--   Two common instantiations of <tt>f</tt> are the identity functor
--   <a>I</a> and the constant functor <a>K</a>. For <a>I</a>, the sum
--   becomes a direct generalization of the <a>Either</a> type to
--   arbitrarily many choices. For <tt><a>K</a> a</tt>, the result is a
--   homogeneous choice type, where the contents of the type-level list are
--   ignored, but its length specifies the number of options.
--   
--   In the context of the SOP approach to generic programming, an n-ary
--   sum describes the top-level structure of a datatype, which is a choice
--   between all of its constructors.
--   
--   <i>Examples:</i>
--   
--   <pre>
--   Z (I 'x')      :: NS I       '[ Char, Bool ]
--   S (Z (I True)) :: NS I       '[ Char, Bool ]
--   S (Z (K 1))    :: NS (K Int) '[ Char, Bool ]
--   </pre>
data () => NS (a :: k -> Type) (b :: [k])
[Z] :: forall {k} (a :: k -> Type) (x :: k) (xs :: [k]). a x -> NS a (x ': xs)
[S] :: forall {k} (a :: k -> Type) (xs :: [k]) (x :: k). NS a xs -> NS a (x ': xs)

-- | A sum of products.
--   
--   This is a 'newtype' for an <a>NS</a> of an <a>NP</a>. The elements of
--   the (inner) products are applications of the parameter <tt>f</tt>. The
--   type <a>SOP</a> is indexed by the list of lists that determines the
--   sizes of both the (outer) sum and all the (inner) products, as well as
--   the types of all the elements of the inner products.
--   
--   A <tt><a>SOP</a> <a>I</a></tt> reflects the structure of a normal
--   Haskell datatype. The sum structure represents the choice between the
--   different constructors, the product structure represents the arguments
--   of each constructor.
newtype () => SOP (f :: k -> Type) (xss :: [[k]])
SOP :: NS (NP f) xss -> SOP (f :: k -> Type) (xss :: [[k]])

-- | Unwrap a sum of products.
unSOP :: forall {k} (f :: k -> Type) (xss :: [[k]]). SOP f xss -> NS (NP f) xss

-- | A product of products.
--   
--   This is a 'newtype' for an <a>NP</a> of an <a>NP</a>. The elements of
--   the inner products are applications of the parameter <tt>f</tt>. The
--   type <a>POP</a> is indexed by the list of lists that determines the
--   lengths of both the outer and all the inner products, as well as the
--   types of all the elements of the inner products.
--   
--   A <a>POP</a> is reminiscent of a two-dimensional table (but the inner
--   lists can all be of different length). In the context of the SOP
--   approach to generic programming, a <a>POP</a> is useful to represent
--   information that is available for all arguments of all constructors of
--   a datatype.
newtype () => POP (f :: k -> Type) (xss :: [[k]])
POP :: NP (NP f) xss -> POP (f :: k -> Type) (xss :: [[k]])

-- | Unwrap a product of products.
unPOP :: forall {k} (f :: k -> Type) (xss :: [[k]]). POP f xss -> NP (NP f) xss

-- | Metadata for a datatype.
--   
--   A value of type <tt><a>DatatypeInfo</a> c</tt> contains the
--   information about a datatype that is not contained in
--   <tt><tt>Code</tt> c</tt>. This information consists primarily of the
--   names of the datatype, its constructors, and possibly its record
--   selectors.
--   
--   The constructor indicates whether the datatype has been declared using
--   <tt>newtype</tt> or not.
data DatatypeInfo :: [[Type]] -> Type
[ADT] :: ModuleName -> DatatypeName -> NP ConstructorInfo xss -> POP StrictnessInfo xss -> DatatypeInfo xss
[Newtype] :: ModuleName -> DatatypeName -> ConstructorInfo '[x] -> DatatypeInfo '[ '[x]]

-- | The module name where a datatype is defined.
moduleName :: DatatypeInfo xss -> ModuleName

-- | The name of a datatype (or newtype).
datatypeName :: DatatypeInfo xss -> DatatypeName

-- | The constructor info for a datatype (or newtype).
constructorInfo :: DatatypeInfo xss -> NP ConstructorInfo xss

-- | Metadata for a single constructor.
--   
--   This is indexed by the product structure of the constructor
--   components.
data ConstructorInfo :: [Type] -> Type
[Constructor] :: SListI xs => ConstructorName -> ConstructorInfo xs
[Infix] :: ConstructorName -> Associativity -> Fixity -> ConstructorInfo '[x, y]
[Record] :: SListI xs => ConstructorName -> NP FieldInfo xs -> ConstructorInfo xs

-- | The name of a constructor.
constructorName :: ConstructorInfo xs -> ConstructorName

-- | For records, this functor maps the component to its selector name.
data FieldInfo :: Type -> Type
[FieldInfo] :: FieldName -> FieldInfo a

-- | The name of a field.
fieldName :: FieldInfo a -> FieldName

-- | A class of datatypes that have associated metadata.
--   
--   It is possible to use the sum-of-products approach to generic
--   programming without metadata. If you need metadata in a function, an
--   additional constraint on this class is in order.
--   
--   You typically don't define instances of this class by hand, but rather
--   derive the class instance automatically. See the documentation of
--   <a>Generic</a> for the options.
class Generic a => HasDatatypeInfo a where {
    
    -- | Type-level datatype info
    type DatatypeInfoOf a :: DatatypeInfo;
    type DatatypeInfoOf a = GDatatypeInfoOf a;
}

-- | Term-level datatype info; by default, the term-level datatype info is
--   produced from the type-level info.
datatypeInfo :: HasDatatypeInfo a => proxy a -> DatatypeInfo (Code a)

-- | Term-level datatype info; by default, the term-level datatype info is
--   produced from the type-level info.
datatypeInfo :: (HasDatatypeInfo a, GDatatypeInfo a, GCode a ~ Code a) => proxy a -> DatatypeInfo (Code a)

-- | The name of a datatype.
type DatatypeName = String

-- | The name of a module.
type ModuleName = String

-- | The name of a data constructor.
type ConstructorName = String

-- | The name of a field / record selector.
type FieldName = String

-- | Datatype to represent the associativity of a constructor
data () => Associativity
LeftAssociative :: Associativity
RightAssociative :: Associativity
NotAssociative :: Associativity

-- | The fixity of an infix constructor.
type Fixity = Int

-- | A generalization of <a>pure</a> or <a>return</a> to higher kinds.
class () => HPure (h :: k -> Type -> l -> Type)

-- | Corresponds to <a>pure</a> directly.
--   
--   <i>Instances:</i>
--   
--   <pre>
--   <a>hpure</a>, <a>pure_NP</a>  :: <a>SListI</a>  xs  =&gt; (forall a. f a) -&gt; <a>NP</a>  f xs
--   <a>hpure</a>, <a>pure_POP</a> :: <a>SListI2</a> xss =&gt; (forall a. f a) -&gt; <a>POP</a> f xss
--   </pre>
hpure :: forall (xs :: l) f. (HPure h, SListIN h xs) => (forall (a :: k). () => f a) -> h f xs

-- | A variant of <a>hpure</a> that allows passing in a constrained
--   argument.
--   
--   Calling <tt><a>hcpure</a> f s</tt> where <tt>s :: h f xs</tt> causes
--   <tt>f</tt> to be applied at all the types that are contained in
--   <tt>xs</tt>. Therefore, the constraint <tt>c</tt> has to be satisfied
--   for all elements of <tt>xs</tt>, which is what <tt><a>AllN</a> h c
--   xs</tt> states.
--   
--   <i>Instances:</i>
--   
--   <pre>
--   <a>hcpure</a>, <a>cpure_NP</a>  :: (<a>All</a>  c xs ) =&gt; proxy c -&gt; (forall a. c a =&gt; f a) -&gt; <a>NP</a>  f xs
--   <a>hcpure</a>, <a>cpure_POP</a> :: (<a>All2</a> c xss) =&gt; proxy c -&gt; (forall a. c a =&gt; f a) -&gt; <a>POP</a> f xss
--   </pre>
hcpure :: forall c (xs :: l) proxy f. (HPure h, AllN h c xs) => proxy c -> (forall (a :: k). c a => f a) -> h f xs

-- | Obtain the head of an n-ary product.
hd :: forall {k} f (x :: k) (xs :: [k]). NP f (x ': xs) -> f x

-- | Obtain the tail of an n-ary product.
tl :: forall {k} (f :: k -> Type) (x :: k) (xs :: [k]). NP f (x ': xs) -> NP f xs

-- | The type of projections from an n-ary product.
--   
--   A projection is a function from the n-ary product to a single element.
type Projection (f :: k -> Type) (xs :: [k]) = K NP f xs :: k -> Type -.-> f

-- | Compute all projections from an n-ary product.
--   
--   Each element of the resulting product contains one of the projections.
projections :: forall {k} (xs :: [k]) (f :: k -> Type). SListI xs => NP (Projection f xs) xs
shiftProjection :: forall {a1} (f :: a1 -> Type) (xs :: [a1]) (a2 :: a1) (x :: a1). Projection f xs a2 -> Projection f (x ': xs) a2

-- | Lifted functions.
newtype () => ( (f :: k -> Type) -.-> (g :: k -> Type) ) (a :: k)
Fn :: (f a -> g a) -> (-.->) (f :: k -> Type) (g :: k -> Type) (a :: k)
[apFn] :: (-.->) (f :: k -> Type) (g :: k -> Type) (a :: k) -> f a -> g a
infixr 1 -.->

-- | Construct a lifted function.
--   
--   Same as <a>Fn</a>. Only available for uniformity with the higher-arity
--   versions.
fn :: forall {k} f (a :: k) f'. (f a -> f' a) -> (f -.-> f') a

-- | Construct a binary lifted function.
fn_2 :: forall {k} f (a :: k) f' f''. (f a -> f' a -> f'' a) -> (f -.-> (f' -.-> f'')) a

-- | Construct a ternary lifted function.
fn_3 :: forall {k} f (a :: k) f' f'' f'''. (f a -> f' a -> f'' a -> f''' a) -> (f -.-> (f' -.-> (f'' -.-> f'''))) a

-- | Construct a quarternary lifted function.
fn_4 :: forall {k} f (a :: k) f' f'' f''' f''''. (f a -> f' a -> f'' a -> f''' a -> f'''' a) -> (f -.-> (f' -.-> (f'' -.-> (f''' -.-> f'''')))) a

-- | Maps a structure containing sums to the corresponding product
--   structure.
type family Prod (h :: k -> Type -> l -> Type) :: k -> Type -> l -> Type

-- | A generalization of <a>&lt;*&gt;</a>.
class (Prod Prod h ~ Prod h, HPure Prod h) => HAp (h :: k -> Type -> l -> Type)

-- | Corresponds to <a>&lt;*&gt;</a>.
--   
--   For products (<a>NP</a>) as well as products of products (<a>POP</a>),
--   the correspondence is rather direct. We combine a structure containing
--   (lifted) functions and a compatible structure containing corresponding
--   arguments into a compatible structure containing results.
--   
--   The same combinator can also be used to combine a product structure of
--   functions with a sum structure of arguments, which then results in
--   another sum structure of results. The sum structure determines which
--   part of the product structure will be used.
--   
--   <i>Instances:</i>
--   
--   <pre>
--   <a>hap</a>, <a>ap_NP</a>  :: <a>NP</a>  (f -.-&gt; g) xs  -&gt; <a>NP</a>  f xs  -&gt; <a>NP</a>  g xs
--   <a>hap</a>, <a>ap_NS</a>  :: <a>NP</a>  (f -.-&gt; g) xs  -&gt; <a>NS</a>  f xs  -&gt; <a>NS</a>  g xs
--   <a>hap</a>, <a>ap_POP</a> :: <a>POP</a> (f -.-&gt; g) xss -&gt; <a>POP</a> f xss -&gt; <a>POP</a> g xss
--   <a>hap</a>, <a>ap_SOP</a> :: <a>POP</a> (f -.-&gt; g) xss -&gt; <a>SOP</a> f xss -&gt; <a>SOP</a> g xss
--   </pre>
hap :: forall (f :: k -> Type) (g :: k -> Type) (xs :: l). HAp h => Prod h (f -.-> g) xs -> h f xs -> h g xs

-- | A generalized form of <a>liftA</a>, which in turn is a generalized
--   <a>map</a>.
--   
--   Takes a lifted function and applies it to every element of a structure
--   while preserving its shape.
--   
--   <i>Specification:</i>
--   
--   <pre>
--   <a>hliftA</a> f xs = <a>hpure</a> (<a>fn</a> f) ` <a>hap</a> ` xs
--   </pre>
--   
--   <i>Instances:</i>
--   
--   <pre>
--   <a>hliftA</a>, <a>liftA_NP</a>  :: <a>SListI</a>  xs  =&gt; (forall a. f a -&gt; f' a) -&gt; <a>NP</a>  f xs  -&gt; <a>NP</a>  f' xs
--   <a>hliftA</a>, <a>liftA_NS</a>  :: <a>SListI</a>  xs  =&gt; (forall a. f a -&gt; f' a) -&gt; <a>NS</a>  f xs  -&gt; <a>NS</a>  f' xs
--   <a>hliftA</a>, <a>liftA_POP</a> :: <a>SListI2</a> xss =&gt; (forall a. f a -&gt; f' a) -&gt; <a>POP</a> f xss -&gt; <a>POP</a> f' xss
--   <a>hliftA</a>, <a>liftA_SOP</a> :: <a>SListI2</a> xss =&gt; (forall a. f a -&gt; f' a) -&gt; <a>SOP</a> f xss -&gt; <a>SOP</a> f' xss
--   </pre>
hliftA :: forall {k} {l} h (xs :: l) f f'. (SListIN (Prod h) xs, HAp h) => (forall (a :: k). () => f a -> f' a) -> h f xs -> h f' xs

-- | A generalized form of <a>liftA2</a>, which in turn is a generalized
--   <a>zipWith</a>.
--   
--   Takes a lifted binary function and uses it to combine two structures
--   of equal shape into a single structure.
--   
--   It either takes two product structures to a product structure, or one
--   product and one sum structure to a sum structure.
--   
--   <i>Specification:</i>
--   
--   <pre>
--   <a>hliftA2</a> f xs ys = <a>hpure</a> (<a>fn_2</a> f) ` <a>hap</a> ` xs ` <a>hap</a> ` ys
--   </pre>
--   
--   <i>Instances:</i>
--   
--   <pre>
--   <a>hliftA2</a>, <a>liftA2_NP</a>  :: <a>SListI</a>  xs  =&gt; (forall a. f a -&gt; f' a -&gt; f'' a) -&gt; <a>NP</a>  f xs  -&gt; <a>NP</a>  f' xs  -&gt; <a>NP</a>  f'' xs
--   <a>hliftA2</a>, <a>liftA2_NS</a>  :: <a>SListI</a>  xs  =&gt; (forall a. f a -&gt; f' a -&gt; f'' a) -&gt; <a>NP</a>  f xs  -&gt; <a>NS</a>  f' xs  -&gt; <a>NS</a>  f'' xs
--   <a>hliftA2</a>, <a>liftA2_POP</a> :: <a>SListI2</a> xss =&gt; (forall a. f a -&gt; f' a -&gt; f'' a) -&gt; <a>POP</a> f xss -&gt; <a>POP</a> f' xss -&gt; <a>POP</a> f'' xss
--   <a>hliftA2</a>, <a>liftA2_SOP</a> :: <a>SListI2</a> xss =&gt; (forall a. f a -&gt; f' a -&gt; f'' a) -&gt; <a>POP</a> f xss -&gt; <a>SOP</a> f' xss -&gt; <a>SOP</a> f'' xss
--   </pre>
hliftA2 :: forall {k} {l} h (xs :: l) f f' f''. (SListIN (Prod h) xs, HAp h, HAp (Prod h)) => (forall (a :: k). () => f a -> f' a -> f'' a) -> Prod h f xs -> h f' xs -> h f'' xs

-- | A generalized form of <a>liftA3</a>, which in turn is a generalized
--   <a>zipWith3</a>.
--   
--   Takes a lifted ternary function and uses it to combine three
--   structures of equal shape into a single structure.
--   
--   It either takes three product structures to a product structure, or
--   two product structures and one sum structure to a sum structure.
--   
--   <i>Specification:</i>
--   
--   <pre>
--   <a>hliftA3</a> f xs ys zs = <a>hpure</a> (<a>fn_3</a> f) ` <a>hap</a> ` xs ` <a>hap</a> ` ys ` <a>hap</a> ` zs
--   </pre>
--   
--   <i>Instances:</i>
--   
--   <pre>
--   <a>hliftA3</a>, <a>liftA3_NP</a>  :: <a>SListI</a>  xs  =&gt; (forall a. f a -&gt; f' a -&gt; f'' a -&gt; f''' a) -&gt; <a>NP</a>  f xs  -&gt; <a>NP</a>  f' xs  -&gt; <a>NP</a>  f'' xs  -&gt; <a>NP</a>  f''' xs
--   <a>hliftA3</a>, <a>liftA3_NS</a>  :: <a>SListI</a>  xs  =&gt; (forall a. f a -&gt; f' a -&gt; f'' a -&gt; f''' a) -&gt; <a>NP</a>  f xs  -&gt; <a>NP</a>  f' xs  -&gt; <a>NS</a>  f'' xs  -&gt; <a>NS</a>  f''' xs
--   <a>hliftA3</a>, <a>liftA3_POP</a> :: <a>SListI2</a> xss =&gt; (forall a. f a -&gt; f' a -&gt; f'' a -&gt; f''' a) -&gt; <a>POP</a> f xss -&gt; <a>POP</a> f' xss -&gt; <a>POP</a> f'' xss -&gt; <a>POP</a> f''' xs
--   <a>hliftA3</a>, <a>liftA3_SOP</a> :: <a>SListI2</a> xss =&gt; (forall a. f a -&gt; f' a -&gt; f'' a -&gt; f''' a) -&gt; <a>POP</a> f xss -&gt; <a>POP</a> f' xss -&gt; <a>SOP</a> f'' xss -&gt; <a>SOP</a> f''' xs
--   </pre>
hliftA3 :: forall {k} {l} h (xs :: l) f f' f'' f'''. (SListIN (Prod h) xs, HAp h, HAp (Prod h)) => (forall (a :: k). () => f a -> f' a -> f'' a -> f''' a) -> Prod h f xs -> Prod h f' xs -> h f'' xs -> h f''' xs

-- | Variant of <a>hliftA</a> that takes a constrained function.
--   
--   <i>Specification:</i>
--   
--   <pre>
--   <a>hcliftA</a> p f xs = <a>hcpure</a> p (<a>fn</a> f) ` <a>hap</a> ` xs
--   </pre>
hcliftA :: forall {k} {l} h c (xs :: l) proxy f f'. (AllN (Prod h) c xs, HAp h) => proxy c -> (forall (a :: k). c a => f a -> f' a) -> h f xs -> h f' xs

-- | Variant of <a>hliftA2</a> that takes a constrained function.
--   
--   <i>Specification:</i>
--   
--   <pre>
--   <a>hcliftA2</a> p f xs ys = <a>hcpure</a> p (<a>fn_2</a> f) ` <a>hap</a> ` xs ` <a>hap</a> ` ys
--   </pre>
hcliftA2 :: forall {k} {l} h c (xs :: l) proxy f f' f''. (AllN (Prod h) c xs, HAp h, HAp (Prod h)) => proxy c -> (forall (a :: k). c a => f a -> f' a -> f'' a) -> Prod h f xs -> h f' xs -> h f'' xs

-- | Variant of <a>hliftA3</a> that takes a constrained function.
--   
--   <i>Specification:</i>
--   
--   <pre>
--   <a>hcliftA3</a> p f xs ys zs = <a>hcpure</a> p (<a>fn_3</a> f) ` <a>hap</a> ` xs ` <a>hap</a> ` ys ` <a>hap</a> ` zs
--   </pre>
hcliftA3 :: forall {k} {l} h c (xs :: l) proxy f f' f'' f'''. (AllN (Prod h) c xs, HAp h, HAp (Prod h)) => proxy c -> (forall (a :: k). c a => f a -> f' a -> f'' a -> f''' a) -> Prod h f xs -> Prod h f' xs -> h f'' xs -> h f''' xs

-- | Another name for <a>hliftA</a>.
hmap :: forall {k} {l} h (xs :: l) f f'. (SListIN (Prod h) xs, HAp h) => (forall (a :: k). () => f a -> f' a) -> h f xs -> h f' xs

-- | Another name for <a>hliftA2</a>.
hzipWith :: forall {k} {l} h (xs :: l) f f' f''. (SListIN (Prod h) xs, HAp h, HAp (Prod h)) => (forall (a :: k). () => f a -> f' a -> f'' a) -> Prod h f xs -> h f' xs -> h f'' xs

-- | Another name for <a>hliftA3</a>.
hzipWith3 :: forall {k} {l} h (xs :: l) f f' f'' f'''. (SListIN (Prod h) xs, HAp h, HAp (Prod h)) => (forall (a :: k). () => f a -> f' a -> f'' a -> f''' a) -> Prod h f xs -> Prod h f' xs -> h f'' xs -> h f''' xs

-- | Another name for <a>hcliftA</a>.
hcmap :: forall {k} {l} h c (xs :: l) proxy f f'. (AllN (Prod h) c xs, HAp h) => proxy c -> (forall (a :: k). c a => f a -> f' a) -> h f xs -> h f' xs

-- | Another name for <a>hcliftA2</a>.
hczipWith :: forall {k} {l} h c (xs :: l) proxy f f' f''. (AllN (Prod h) c xs, HAp h, HAp (Prod h)) => proxy c -> (forall (a :: k). c a => f a -> f' a -> f'' a) -> Prod h f xs -> h f' xs -> h f'' xs

-- | Another name for <a>hcliftA3</a>.
hczipWith3 :: forall {k} {l} h c (xs :: l) proxy f f' f'' f'''. (AllN (Prod h) c xs, HAp h, HAp (Prod h)) => proxy c -> (forall (a :: k). c a => f a -> f' a -> f'' a -> f''' a) -> Prod h f xs -> Prod h f' xs -> h f'' xs -> h f''' xs

-- | The type of injections into an n-ary sum.
--   
--   If you expand the type synonyms and newtypes involved, you get
--   
--   <pre>
--   Injection f xs a = (f -.-&gt; K (NS f xs)) a ~= f a -&gt; K (NS f xs) a ~= f a -&gt; NS f xs
--   </pre>
--   
--   If we pick <tt>a</tt> to be an element of <tt>xs</tt>, this indeed
--   corresponds to an injection into the sum.
type Injection (f :: k -> Type) (xs :: [k]) = f -.-> K NS f xs :: k -> Type

-- | Compute all injections into an n-ary sum.
--   
--   Each element of the resulting product contains one of the injections.
injections :: forall {k} (xs :: [k]) (f :: k -> Type). SListI xs => NP (Injection f xs) xs

-- | Shift an injection.
--   
--   Given an injection, return an injection into a sum that is one
--   component larger.
shift :: forall {a1} (f :: a1 -> Type) (xs :: [a1]) (a2 :: a1) (x :: a1). Injection f xs a2 -> Injection f (x ': xs) a2

-- | Shift an injection.
--   
--   Given an injection, return an injection into a sum that is one
--   component larger.
shiftInjection :: forall {a1} (f :: a1 -> Type) (xs :: [a1]) (a2 :: a1) (x :: a1). Injection f xs a2 -> Injection f (x ': xs) a2

-- | Maps a structure containing products to the corresponding sum
--   structure.
type family UnProd (h :: k -> Type -> l -> Type) :: k -> Type -> l -> Type

-- | A class for applying all injections corresponding to a sum-like
--   structure to a table containing suitable arguments.
class UnProd Prod h ~ h => HApInjs (h :: k -> Type -> l -> Type)

-- | For a given table (product-like structure), produce a list where each
--   element corresponds to the application of an injection function into
--   the corresponding sum-like structure.
--   
--   <i>Instances:</i>
--   
--   <pre>
--   <a>hapInjs</a>, <a>apInjs_NP</a>  :: <a>SListI</a>  xs  =&gt; <a>NP</a>  f xs -&gt; [<a>NS</a>  f xs ]
--   <a>hapInjs</a>, <a>apInjs_SOP</a> :: <a>SListI2</a> xss =&gt; <a>POP</a> f xs -&gt; [<a>SOP</a> f xss]
--   </pre>
--   
--   <i>Examples:</i>
--   
--   <pre>
--   &gt;&gt;&gt; hapInjs (I 'x' :* I True :* I 2 :* Nil) :: [NS I '[Char, Bool, Int]]
--   [Z (I 'x'),S (Z (I True)),S (S (Z (I 2)))]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; hapInjs (POP ((I 'x' :* Nil) :* (I True :* I 2 :* Nil) :* Nil)) :: [SOP I '[ '[Char], '[Bool, Int]]]
--   [SOP (Z (I 'x' :* Nil)),SOP (S (Z (I True :* I 2 :* Nil)))]
--   </pre>
--   
--   Unfortunately the type-signatures are required in GHC-7.10 and older.
hapInjs :: forall (xs :: l) (f :: k -> Type). (HApInjs h, SListIN h xs) => Prod h f xs -> [h f xs]

-- | Apply injections to a product.
--   
--   Given a product containing all possible choices, produce a list of
--   sums by applying each injection to the appropriate element.
--   
--   <i>Example:</i>
--   
--   <pre>
--   &gt;&gt;&gt; apInjs_NP (I 'x' :* I True :* I 2 :* Nil)
--   [Z (I 'x'),S (Z (I True)),S (S (Z (I 2)))]
--   </pre>
apInjs_NP :: forall {k} (xs :: [k]) (f :: k -> Type). SListI xs => NP f xs -> [NS f xs]

-- | Apply injections to a product of product.
--   
--   This operates on the outer product only. Given a product containing
--   all possible choices (that are products), produce a list of sums (of
--   products) by applying each injection to the appropriate element.
--   
--   <i>Example:</i>
--   
--   <pre>
--   &gt;&gt;&gt; apInjs_POP (POP ((I 'x' :* Nil) :* (I True :* I 2 :* Nil) :* Nil))
--   [SOP (Z (I 'x' :* Nil)),SOP (S (Z (I True :* I 2 :* Nil)))]
--   </pre>
apInjs_POP :: forall {k} (xss :: [[k]]) (f :: k -> Type). SListI xss => POP f xss -> [SOP f xss]

-- | Extract the payload from a unary sum.
--   
--   For larger sums, this function would be partial, so it is only
--   provided with a rather restrictive type.
--   
--   <i>Example:</i>
--   
--   <pre>
--   &gt;&gt;&gt; unZ (Z (I 'x'))
--   I 'x'
--   </pre>
unZ :: forall {k} f (x :: k). NS f '[x] -> f x

-- | A class for determining which choice in a sum-like structure a value
--   represents.
class () => HIndex (h :: k -> Type -> l -> Type)

-- | If <tt>h</tt> is a sum-like structure representing a choice between
--   <tt>n</tt> different options, and <tt>x</tt> is a value of type <tt>h
--   f xs</tt>, then <tt><a>hindex</a> x</tt> returns a number between
--   <tt>0</tt> and <tt>n - 1</tt> representing the index of the choice
--   made by <tt>x</tt>.
--   
--   <i>Instances:</i>
--   
--   <pre>
--   <a>hindex</a>, <a>index_NS</a>  :: <a>NS</a>  f xs -&gt; Int
--   <a>hindex</a>, <a>index_SOP</a> :: <a>SOP</a> f xs -&gt; Int
--   </pre>
--   
--   <i>Examples:</i>
--   
--   <pre>
--   &gt;&gt;&gt; hindex (S (S (Z (I False))))
--   2
--   
--   &gt;&gt;&gt; hindex (Z (K ()))
--   0
--   
--   &gt;&gt;&gt; hindex (SOP (S (Z (I True :* I 'x' :* Nil))))
--   1
--   </pre>
hindex :: forall (f :: k -> Type) (xs :: l). HIndex h => h f xs -> Int

-- | The type of ejections from an n-ary sum.
--   
--   An ejection is the pattern matching function for one part of the n-ary
--   sum.
--   
--   It is the opposite of an <a>Injection</a>.
type Ejection (f :: k -> Type) (xs :: [k]) = K NS f xs :: k -> Type -.-> Maybe :.: f

-- | Compute all ejections from an n-ary sum.
--   
--   Each element of the resulting product contains one of the ejections.
ejections :: forall {k} (xs :: [k]) (f :: k -> Type). SListI xs => NP (Ejection f xs) xs

shiftEjection :: forall {a1} (f :: a1 -> Type) (x :: a1) (xs :: [a1]) (a2 :: a1). Ejection f xs a2 -> Ejection f (x ': xs) a2

-- | Lift a constrained function operating on a list-indexed structure to a
--   function on a list-of-list-indexed structure.
--   
--   This is a variant of <a>hcliftA</a>.
--   
--   <i>Specification:</i>
--   
--   <pre>
--   <a>hcliftA'</a> p f xs = <a>hpure</a> (<a>fn_2</a> $ \ <tt>AllDictC</tt> -&gt; f) ` <a>hap</a> ` <tt>allDict_NP</tt> p ` <a>hap</a> ` xs
--   </pre>
--   
--   <i>Instances:</i>
--   
--   <pre>
--   <a>hcliftA'</a> :: <a>All2</a> c xss =&gt; proxy c -&gt; (forall xs. <a>All</a> c xs =&gt; f xs -&gt; f' xs) -&gt; <a>NP</a> f xss -&gt; <a>NP</a> f' xss
--   <a>hcliftA'</a> :: <a>All2</a> c xss =&gt; proxy c -&gt; (forall xs. <a>All</a> c xs =&gt; f xs -&gt; f' xs) -&gt; <a>NS</a> f xss -&gt; <a>NS</a> f' xss
--   </pre>
hcliftA' :: forall {k} (c :: k -> Constraint) (xss :: [[k]]) h proxy f f'. (All2 c xss, Prod h ~ (NP :: ([k] -> Type) -> [[k]] -> Type), HAp h) => proxy c -> (forall (xs :: [k]). All c xs => f xs -> f' xs) -> h f xss -> h f' xss

-- | Like <a>hcliftA'</a>, but for binary functions.
hcliftA2' :: forall {k} (c :: k -> Constraint) (xss :: [[k]]) h proxy f f' f''. (All2 c xss, Prod h ~ (NP :: ([k] -> Type) -> [[k]] -> Type), HAp h) => proxy c -> (forall (xs :: [k]). All c xs => f xs -> f' xs -> f'' xs) -> Prod h f xss -> h f' xss -> h f'' xss

-- | Like <a>hcliftA'</a>, but for ternary functions.
hcliftA3' :: forall {k} (c :: k -> Constraint) (xss :: [[k]]) h proxy f f' f'' f'''. (All2 c xss, Prod h ~ (NP :: ([k] -> Type) -> [[k]] -> Type), HAp h) => proxy c -> (forall (xs :: [k]). All c xs => f xs -> f' xs -> f'' xs -> f''' xs) -> Prod h f xss -> Prod h f' xss -> h f'' xss -> h f''' xss

-- | Compare two sums with respect to the choice they are making.
--   
--   A value that chooses the first option is considered smaller than one
--   that chooses the second option.
--   
--   If the choices are different, then either the first (if the first is
--   smaller than the second) or the third (if the first is larger than the
--   second) argument are called. If both choices are equal, then the
--   second argument is called, which has access to the elements contained
--   in the sums.
compare_NS :: forall {k} r f g (xs :: [k]). r -> (forall (x :: k). () => f x -> g x -> r) -> r -> NS f xs -> NS g xs -> r

-- | Constrained version of <a>compare_NS</a>.
ccompare_NS :: forall {k} c proxy r f g (xs :: [k]). All c xs => proxy c -> r -> (forall (x :: k). c x => f x -> g x -> r) -> r -> NS f xs -> NS g xs -> r

-- | Compare two sums of products with respect to the choice in the sum
--   they are making.
--   
--   Only the sum structure is used for comparison. This is a small wrapper
--   around <a>ccompare_NS</a> for a common special case.
compare_SOP :: forall {k} r (f :: k -> Type) (g :: k -> Type) (xss :: [[k]]). r -> (forall (xs :: [k]). () => NP f xs -> NP g xs -> r) -> r -> SOP f xss -> SOP g xss -> r

-- | Constrained version of <a>compare_SOP</a>.
ccompare_SOP :: forall {k} (c :: k -> Constraint) proxy r (f :: k -> Type) (g :: k -> Type) (xss :: [[k]]). All2 c xss => proxy c -> r -> (forall (xs :: [k]). All c xs => NP f xs -> NP g xs -> r) -> r -> SOP f xss -> SOP g xss -> r

-- | Maps products to lists, and sums to identities.
type family CollapseTo (h :: k -> Type -> l -> Type) x

-- | A class for collapsing a heterogeneous structure into a homogeneous
--   one.
class () => HCollapse (h :: k -> Type -> l -> Type)

-- | Collapse a heterogeneous structure with homogeneous elements into a
--   homogeneous structure.
--   
--   If a heterogeneous structure is instantiated to the constant functor
--   <a>K</a>, then it is in fact homogeneous. This function maps such a
--   value to a simpler Haskell datatype reflecting that. An <tt><a>NS</a>
--   (<a>K</a> a)</tt> contains a single <tt>a</tt>, and an <tt><a>NP</a>
--   (<a>K</a> a)</tt> contains a list of <tt>a</tt>s.
--   
--   <i>Instances:</i>
--   
--   <pre>
--   <a>hcollapse</a>, <a>collapse_NP</a>  :: <a>NP</a>  (<a>K</a> a) xs  -&gt;  [a]
--   <a>hcollapse</a>, <a>collapse_NS</a>  :: <a>NS</a>  (<a>K</a> a) xs  -&gt;   a
--   <a>hcollapse</a>, <a>collapse_POP</a> :: <a>POP</a> (<a>K</a> a) xss -&gt; [[a]]
--   <a>hcollapse</a>, <a>collapse_SOP</a> :: <a>SOP</a> (<a>K</a> a) xss -&gt;  [a]
--   </pre>
hcollapse :: forall (xs :: l) a. (HCollapse h, SListIN h xs) => h (K a :: k -> Type) xs -> CollapseTo h a

-- | A generalization of <a>traverse_</a> or <a>foldMap</a>.
class () => HTraverse_ (h :: k -> Type -> l -> Type)

-- | Corresponds to <a>traverse_</a>.
--   
--   <i>Instances:</i>
--   
--   <pre>
--   <a>hctraverse_</a>, <a>ctraverse__NP</a>  :: (<a>All</a>  c xs , <a>Applicative</a> g) =&gt; proxy c -&gt; (forall a. c a =&gt; f a -&gt; g ()) -&gt; <a>NP</a>  f xs  -&gt; g ()
--   <a>hctraverse_</a>, <a>ctraverse__NS</a>  :: (<a>All2</a> c xs , <a>Applicative</a> g) =&gt; proxy c -&gt; (forall a. c a =&gt; f a -&gt; g ()) -&gt; <a>NS</a>  f xs  -&gt; g ()
--   <a>hctraverse_</a>, <a>ctraverse__POP</a> :: (<a>All</a>  c xss, <a>Applicative</a> g) =&gt; proxy c -&gt; (forall a. c a =&gt; f a -&gt; g ()) -&gt; <a>POP</a> f xss -&gt; g ()
--   <a>hctraverse_</a>, <a>ctraverse__SOP</a> :: (<a>All2</a> c xss, <a>Applicative</a> g) =&gt; proxy c -&gt; (forall a. c a =&gt; f a -&gt; g ()) -&gt; <a>SOP</a> f xss -&gt; g ()
--   </pre>
hctraverse_ :: forall c (xs :: l) g proxy f. (HTraverse_ h, AllN h c xs, Applicative g) => proxy c -> (forall (a :: k). c a => f a -> g ()) -> h f xs -> g ()

-- | Unconstrained version of <a>hctraverse_</a>.
--   
--   <i>Instances:</i>
--   
--   <pre>
--   <tt>traverse_</tt>, <a>traverse__NP</a>  :: (<a>SListI</a>  xs , <a>Applicative</a> g) =&gt; (forall a. f a -&gt; g ()) -&gt; <a>NP</a>  f xs  -&gt; g ()
--   <tt>traverse_</tt>, <a>traverse__NS</a>  :: (<a>SListI</a>  xs , <a>Applicative</a> g) =&gt; (forall a. f a -&gt; g ()) -&gt; <a>NS</a>  f xs  -&gt; g ()
--   <tt>traverse_</tt>, <a>traverse__POP</a> :: (<a>SListI2</a> xss, <a>Applicative</a> g) =&gt; (forall a. f a -&gt; g ()) -&gt; <a>POP</a> f xss -&gt; g ()
--   <tt>traverse_</tt>, <a>traverse__SOP</a> :: (<a>SListI2</a> xss, <a>Applicative</a> g) =&gt; (forall a. f a -&gt; g ()) -&gt; <a>SOP</a> f xss -&gt; g ()
--   </pre>
htraverse_ :: forall (xs :: l) g f. (HTraverse_ h, SListIN h xs, Applicative g) => (forall (a :: k). () => f a -> g ()) -> h f xs -> g ()

-- | Special case of <a>hctraverse_</a>.
hcfoldMap :: forall {k} {l} h c (xs :: l) m proxy f. (HTraverse_ h, AllN h c xs, Monoid m) => proxy c -> (forall (a :: k). c a => f a -> m) -> h f xs -> m

-- | Flipped version of <a>hctraverse_</a>.
hcfor_ :: forall {k} {l} h c (xs :: l) g proxy f. (HTraverse_ h, AllN h c xs, Applicative g) => proxy c -> h f xs -> (forall (a :: k). c a => f a -> g ()) -> g ()

-- | A generalization of <a>sequenceA</a>.
class HAp h => HSequence (h :: k -> Type -> l -> Type)

-- | Corresponds to <a>sequenceA</a>.
--   
--   Lifts an applicative functor out of a structure.
--   
--   <i>Instances:</i>
--   
--   <pre>
--   <a>hsequence'</a>, <a>sequence'_NP</a>  :: (<a>SListI</a>  xs , <a>Applicative</a> f) =&gt; <a>NP</a>  (f <a>:.:</a> g) xs  -&gt; f (<a>NP</a>  g xs )
--   <a>hsequence'</a>, <a>sequence'_NS</a>  :: (<a>SListI</a>  xs , <a>Applicative</a> f) =&gt; <a>NS</a>  (f <a>:.:</a> g) xs  -&gt; f (<a>NS</a>  g xs )
--   <a>hsequence'</a>, <a>sequence'_POP</a> :: (<a>SListI2</a> xss, <a>Applicative</a> f) =&gt; <a>POP</a> (f <a>:.:</a> g) xss -&gt; f (<a>POP</a> g xss)
--   <a>hsequence'</a>, <a>sequence'_SOP</a> :: (<a>SListI2</a> xss, <a>Applicative</a> f) =&gt; <a>SOP</a> (f <a>:.:</a> g) xss -&gt; f (<a>SOP</a> g xss)
--   </pre>
hsequence' :: forall (xs :: l) f (g :: k -> Type). (HSequence h, SListIN h xs, Applicative f) => h (f :.: g) xs -> f (h g xs)

-- | Corresponds to <a>traverse</a>.
--   
--   <i>Instances:</i>
--   
--   <pre>
--   <a>hctraverse'</a>, <a>ctraverse'_NP</a>  :: (<a>All</a>  c xs , <a>Applicative</a> g) =&gt; proxy c -&gt; (forall a. c a =&gt; f a -&gt; g (f' a)) -&gt; <a>NP</a>  f xs  -&gt; g (<a>NP</a>  f' xs )
--   <a>hctraverse'</a>, <a>ctraverse'_NS</a>  :: (<a>All2</a> c xs , <a>Applicative</a> g) =&gt; proxy c -&gt; (forall a. c a =&gt; f a -&gt; g (f' a)) -&gt; <a>NS</a>  f xs  -&gt; g (<a>NS</a>  f' xs )
--   <a>hctraverse'</a>, <a>ctraverse'_POP</a> :: (<a>All</a>  c xss, <a>Applicative</a> g) =&gt; proxy c -&gt; (forall a. c a =&gt; f a -&gt; g (f' a)) -&gt; <a>POP</a> f xss -&gt; g (<a>POP</a> f' xss)
--   <a>hctraverse'</a>, <a>ctraverse'_SOP</a> :: (<a>All2</a> c xss, <a>Applicative</a> g) =&gt; proxy c -&gt; (forall a. c a =&gt; f a -&gt; g (f' a)) -&gt; <a>SOP</a> f xss -&gt; g (<a>SOP</a> f' xss)
--   </pre>
hctraverse' :: forall c (xs :: l) g proxy f f'. (HSequence h, AllN h c xs, Applicative g) => proxy c -> (forall (a :: k). c a => f a -> g (f' a)) -> h f xs -> g (h f' xs)

-- | Unconstrained variant of <a>hctraverse'</a>.
--   
--   <i>Instances:</i>
--   
--   <pre>
--   <a>htraverse'</a>, <a>traverse'_NP</a>  :: (<a>SListI</a>  xs , <a>Applicative</a> g) =&gt; (forall a. c a =&gt; f a -&gt; g (f' a)) -&gt; <a>NP</a>  f xs  -&gt; g (<a>NP</a>  f' xs )
--   <a>htraverse'</a>, <a>traverse'_NS</a>  :: (<a>SListI2</a> xs , <a>Applicative</a> g) =&gt; (forall a. c a =&gt; f a -&gt; g (f' a)) -&gt; <a>NS</a>  f xs  -&gt; g (<a>NS</a>  f' xs )
--   <a>htraverse'</a>, <a>traverse'_POP</a> :: (<a>SListI</a>  xss, <a>Applicative</a> g) =&gt; (forall a. c a =&gt; f a -&gt; g (f' a)) -&gt; <a>POP</a> f xss -&gt; g (<a>POP</a> f' xss)
--   <a>htraverse'</a>, <a>traverse'_SOP</a> :: (<a>SListI2</a> xss, <a>Applicative</a> g) =&gt; (forall a. c a =&gt; f a -&gt; g (f' a)) -&gt; <a>SOP</a> f xss -&gt; g (<a>SOP</a> f' xss)
--   </pre>
htraverse' :: forall (xs :: l) g f f'. (HSequence h, SListIN h xs, Applicative g) => (forall (a :: k). () => f a -> g (f' a)) -> h f xs -> g (h f' xs)

-- | Special case of <a>hsequence'</a> where <tt>g = <a>I</a></tt>.
hsequence :: forall {l} h (xs :: l) f. (SListIN h xs, SListIN (Prod h) xs, HSequence h, Applicative f) => h f xs -> f (h I xs)

-- | Special case of <a>hsequence'</a> where <tt>g = <a>K</a> a</tt>.
hsequenceK :: forall {k} {l} h (xs :: l) f a. (SListIN h xs, SListIN (Prod h) xs, Applicative f, HSequence h) => h (K (f a) :: k -> Type) xs -> f (h (K a :: k -> Type) xs)

-- | Special case of <a>hctraverse'</a> where <tt>f' = <a>I</a></tt>.
hctraverse :: forall {l} h c (xs :: l) g proxy f. (HSequence h, AllN h c xs, Applicative g) => proxy c -> (forall a. c a => f a -> g a) -> h f xs -> g (h I xs)

-- | Flipped version of <a>hctraverse</a>.
hcfor :: forall {l} h c (xs :: l) g proxy f. (HSequence h, AllN h c xs, Applicative g) => proxy c -> h f xs -> (forall a. c a => f a -> g a) -> g (h I xs)

-- | A class for expanding sum structures into corresponding product
--   structures, filling in the slots not targeted by the sum with default
--   values.
class () => HExpand (h :: k -> Type -> l -> Type)

-- | Expand a given sum structure into a corresponding product structure by
--   placing the value contained in the sum into the corresponding position
--   in the product, and using the given default value for all other
--   positions.
--   
--   <i>Instances:</i>
--   
--   <pre>
--   <a>hexpand</a>, <a>expand_NS</a>  :: <a>SListI</a> xs   =&gt; (forall x . f x) -&gt; <a>NS</a>  f xs  -&gt; <a>NP</a>  f xs
--   <a>hexpand</a>, <a>expand_SOP</a> :: <a>SListI2</a> xss =&gt; (forall x . f x) -&gt; <a>SOP</a> f xss -&gt; <a>POP</a> f xss
--   </pre>
--   
--   <i>Examples:</i>
--   
--   <pre>
--   &gt;&gt;&gt; hexpand Nothing (S (Z (Just 3))) :: NP Maybe '[Char, Int, Bool]
--   Nothing :* Just 3 :* Nothing :* Nil
--   
--   &gt;&gt;&gt; hexpand [] (SOP (S (Z ([1,2] :* "xyz" :* Nil)))) :: POP [] '[ '[Bool], '[Int, Char] ]
--   POP (([] :* Nil) :* ([1,2] :* "xyz" :* Nil) :* Nil)
--   </pre>
hexpand :: forall (xs :: l) f. (HExpand h, SListIN (Prod h) xs) => (forall (x :: k). () => f x) -> h f xs -> Prod h f xs

-- | Variant of <a>hexpand</a> that allows passing a constrained default.
--   
--   <i>Instances:</i>
--   
--   <pre>
--   <a>hcexpand</a>, <a>cexpand_NS</a>  :: <a>All</a>  c xs  =&gt; proxy c -&gt; (forall x . c x =&gt; f x) -&gt; <a>NS</a>  f xs  -&gt; <a>NP</a>  f xs
--   <a>hcexpand</a>, <a>cexpand_SOP</a> :: <a>All2</a> c xss =&gt; proxy c -&gt; (forall x . c x =&gt; f x) -&gt; <a>SOP</a> f xss -&gt; <a>POP</a> f xss
--   </pre>
--   
--   <i>Examples:</i>
--   
--   <pre>
--   &gt;&gt;&gt; hcexpand (Proxy :: Proxy Bounded) (I minBound) (S (Z (I 20))) :: NP I '[Bool, Int, Ordering]
--   I False :* I 20 :* I LT :* Nil
--   
--   &gt;&gt;&gt; hcexpand (Proxy :: Proxy Num) (I 0) (SOP (S (Z (I 1 :* I 2 :* Nil)))) :: POP I '[ '[Double], '[Int, Int] ]
--   POP ((I 0.0 :* Nil) :* (I 1 :* I 2 :* Nil) :* Nil)
--   </pre>
hcexpand :: forall c (xs :: l) proxy f. (HExpand h, AllN (Prod h) c xs) => proxy c -> (forall (x :: k). c x => f x) -> h f xs -> Prod h f xs

-- | A class for transforming structures into related structures with a
--   different index list, as long as the index lists have the same shape
--   and the elements and interpretation functions are suitably related.
class (Same h1 :: k2 -> Type -> l2 -> Type ~ h2, Same h2 :: k1 -> Type -> l1 -> Type ~ h1) => HTrans (h1 :: k1 -> Type -> l1 -> Type) (h2 :: k2 -> Type -> l2 -> Type)

-- | Transform a structure into a related structure given a conversion
--   function for the elements.
htrans :: forall c (xs :: l1) (ys :: l2) proxy f g. (HTrans h1 h2, AllZipN (Prod h1) c xs ys) => proxy c -> (forall (x :: k1) (y :: k2). c x y => f x -> g y) -> h1 f xs -> h2 g ys

-- | Safely coerce a structure into a representationally equal structure.
--   
--   This is a special case of <a>htrans</a>, but can be implemented more
--   efficiently; for example in terms of <a>unsafeCoerce</a>.
--   
--   <i>Examples:</i>
--   
--   <pre>
--   &gt;&gt;&gt; hcoerce (I (Just LT) :* I (Just 'x') :* I (Just True) :* Nil) :: NP Maybe '[Ordering, Char, Bool]
--   Just LT :* Just 'x' :* Just True :* Nil
--   
--   &gt;&gt;&gt; hcoerce (SOP (Z (K True :* K False :* Nil))) :: SOP I '[ '[Bool, Bool], '[Bool] ]
--   SOP (Z (I True :* I False :* Nil))
--   </pre>
hcoerce :: forall (f :: k1 -> Type) (g :: k2 -> Type) (xs :: l1) (ys :: l2). (HTrans h1 h2, AllZipN (Prod h1) (LiftedCoercible f g) xs ys) => h1 f xs -> h2 g ys

-- | Specialization of <a>hcoerce</a>.
hfromI :: forall {l1} {k2} {l2} h1 (f :: k2 -> Type) (xs :: l1) (ys :: l2) h2. (AllZipN (Prod h1) (LiftedCoercible I f) xs ys, HTrans h1 h2) => h1 I xs -> h2 f ys

-- | Specialization of <a>hcoerce</a>.
htoI :: forall {k1} {l1} {l2} h1 (f :: k1 -> Type) (xs :: l1) (ys :: l2) h2. (AllZipN (Prod h1) (LiftedCoercible f I) xs ys, HTrans h1 h2) => h1 f xs -> h2 I ys

-- | Construct a homogeneous n-ary product from a normal Haskell list.
--   
--   Returns <a>Nothing</a> if the length of the list does not exactly
--   match the expected size of the product.
fromList :: forall {k} (xs :: [k]) a. SListI xs => [a] -> Maybe (NP (K a :: k -> Type) xs)

-- | The constant type functor.
--   
--   Like <a>Constant</a>, but kind-polymorphic in its second argument and
--   with a shorter name.
newtype () => K a (b :: k)
K :: a -> K a (b :: k)

-- | Extract the contents of a <a>K</a> value.
unK :: forall {k} a (b :: k). K a b -> a

-- | The identity type functor.
--   
--   Like <a>Identity</a>, but with a shorter name.
newtype () => I a
I :: a -> I a

-- | Extract the contents of an <a>I</a> value.
unI :: I a -> a

-- | Composition of functors.
--   
--   Like <a>Compose</a>, but kind-polymorphic and with a shorter name.
newtype () => ( (f :: l -> Type) :.: (g :: k -> l) ) (p :: k)
Comp :: f (g p) -> (:.:) (f :: l -> Type) (g :: k -> l) (p :: k)
infixr 7 :.:

-- | Extract the contents of a <a>Comp</a> value.
unComp :: forall {l} {k} f (g :: k -> l) (p :: k). (f :.: g) p -> f (g p)

-- | Lift the given function.
mapII :: (a -> b) -> I a -> I b

-- | Lift the given function.
mapIK :: forall {k} a b (c :: k). (a -> b) -> I a -> K b c

-- | Lift the given function.
mapKI :: forall {k} a b (c :: k). (a -> b) -> K a c -> I b

-- | Lift the given function.
mapKK :: forall {k1} {k2} a b (c :: k1) (d :: k2). (a -> b) -> K a c -> K b d

-- | Lift the given function.
mapIII :: (a -> b -> c) -> I a -> I b -> I c

-- | Lift the given function.
mapIIK :: forall {k} a b c (d :: k). (a -> b -> c) -> I a -> I b -> K c d

-- | Lift the given function.
mapIKI :: forall {k} a b c (d :: k). (a -> b -> c) -> I a -> K b d -> I c

-- | Lift the given function.
mapIKK :: forall {k1} {k2} a b c (d :: k1) (e :: k2). (a -> b -> c) -> I a -> K b d -> K c e

-- | Lift the given function.
mapKII :: forall {k} a b c (d :: k). (a -> b -> c) -> K a d -> I b -> I c

-- | Lift the given function.
mapKIK :: forall {k1} {k2} a b c (d :: k1) (e :: k2). (a -> b -> c) -> K a d -> I b -> K c e

-- | Lift the given function.
mapKKI :: forall {k1} {k2} a b c (d :: k1) (e :: k2). (a -> b -> c) -> K a d -> K b e -> I c

-- | Lift the given function.
mapKKK :: forall {k1} {k2} {k3} a b c (d :: k1) (e :: k2) (f :: k3). (a -> b -> c) -> K a d -> K b e -> K c f

-- | Require a constraint for every element of a list.
--   
--   If you have a datatype that is indexed over a type-level list, then
--   you can use <a>All</a> to indicate that all elements of that
--   type-level list must satisfy a given constraint.
--   
--   <i>Example:</i> The constraint
--   
--   <pre>
--   All Eq '[ Int, Bool, Char ]
--   </pre>
--   
--   is equivalent to the constraint
--   
--   <pre>
--   (Eq Int, Eq Bool, Eq Char)
--   </pre>
--   
--   <i>Example:</i> A type signature such as
--   
--   <pre>
--   f :: All Eq xs =&gt; NP I xs -&gt; ...
--   </pre>
--   
--   means that <tt>f</tt> can assume that all elements of the n-ary
--   product satisfy <a>Eq</a>.
--   
--   Note on superclasses: ghc cannot deduce superclasses from <a>All</a>
--   constraints. You might expect the following to compile
--   
--   <pre>
--   class (Eq a) =&gt; MyClass a
--   
--   foo :: (All Eq xs) =&gt; NP f xs -&gt; z
--   foo = [..]
--   
--   bar :: (All MyClass xs) =&gt; NP f xs -&gt; x
--   bar = foo
--   </pre>
--   
--   but it will fail with an error saying that it was unable to deduce the
--   class constraint <tt><a>AllF</a> <a>Eq</a> xs</tt> (or similar) in the
--   definition of <tt>bar</tt>. In cases like this you can use <a>Dict</a>
--   from <a>Data.SOP.Dict</a> to prove conversions between constraints.
--   See <a>this answer on SO for more details</a>.
class (AllF c xs, SListI xs) => All (c :: k -> Constraint) (xs :: [k])

-- | Require a constraint for every element of a list of lists.
--   
--   If you have a datatype that is indexed over a type-level list of
--   lists, then you can use <a>All2</a> to indicate that all elements of
--   the inner lists must satisfy a given constraint.
--   
--   <i>Example:</i> The constraint
--   
--   <pre>
--   All2 Eq '[ '[ Int ], '[ Bool, Char ] ]
--   </pre>
--   
--   is equivalent to the constraint
--   
--   <pre>
--   (Eq Int, Eq Bool, Eq Char)
--   </pre>
--   
--   <i>Example:</i> A type signature such as
--   
--   <pre>
--   f :: All2 Eq xss =&gt; SOP I xs -&gt; ...
--   </pre>
--   
--   means that <tt>f</tt> can assume that all elements of the sum of
--   product satisfy <a>Eq</a>.
--   
--   Since 0.4.0.0, this is merely a synonym for 'All (All c)'.
type All2 (c :: k -> Constraint) = All All c

-- | Constrained paramorphism for a type-level list.
--   
--   The advantage of writing functions in terms of <a>cpara_SList</a> is
--   that they are then typically not recursive, and can be unfolded
--   statically if the type-level list is statically known.
cpara_SList :: All c xs => proxy c -> r ('[] :: [k]) -> (forall (y :: k) (ys :: [k]). (c y, All c ys) => r ys -> r (y ': ys)) -> r xs

-- | Constrained case distinction on a type-level list.
ccase_SList :: forall {k} c (xs :: [k]) proxy r. All c xs => proxy c -> r ('[] :: [k]) -> (forall (y :: k) (ys :: [k]). (c y, All c ys) => r (y ': ys)) -> r xs

-- | Require a constraint pointwise for every pair of elements from two
--   lists.
--   
--   <i>Example:</i> The constraint
--   
--   <pre>
--   AllZip (~) '[ Int, Bool, Char ] '[ a, b, c ]
--   </pre>
--   
--   is equivalent to the constraint
--   
--   <pre>
--   (Int ~ a, Bool ~ b, Char ~ c)
--   </pre>
class (SListI xs, SListI ys, SameShapeAs xs ys, SameShapeAs ys xs, AllZipF c xs ys) => AllZip (c :: a -> b -> Constraint) (xs :: [a]) (ys :: [b])

-- | Require a constraint pointwise for every pair of elements from two
--   lists of lists.
class (AllZipF AllZip f xss yss, SListI xss, SListI yss, SameShapeAs xss yss, SameShapeAs yss xss) => AllZip2 (f :: a -> b -> Constraint) (xss :: [[a]]) (yss :: [[b]])

-- | A generalization of <a>All</a> and <a>All2</a>.
--   
--   The family <a>AllN</a> expands to <a>All</a> or <a>All2</a> depending
--   on whether the argument is indexed by a list or a list of lists.
type family AllN (h :: k -> Type -> l -> Type) (c :: k -> Constraint) :: l -> Constraint

-- | A generalization of <a>AllZip</a> and <a>AllZip2</a>.
--   
--   The family <a>AllZipN</a> expands to <a>AllZip</a> or <a>AllZip2</a>
--   depending on whther the argument is indexed by a list or a list of
--   lists.
type family AllZipN (h :: k -> Type -> l -> Type) (c :: k1 -> k2 -> Constraint) :: l1 -> l2 -> Constraint

-- | Composition of constraints.
--   
--   Note that the result of the composition must be a constraint, and
--   therefore, in <tt><a>Compose</a> f g</tt>, the kind of <tt>f</tt> is
--   <tt>k -&gt; <a>Constraint</a></tt>. The kind of <tt>g</tt>, however,
--   is <tt>l -&gt; k</tt> and can thus be a normal type constructor.
--   
--   A typical use case is in connection with <a>All</a> on an <a>NP</a> or
--   an <a>NS</a>. For example, in order to denote that all elements on an
--   <tt><a>NP</a> f xs</tt> satisfy <a>Show</a>, we can say <tt><a>All</a>
--   (<a>Compose</a> <a>Show</a> f) xs</tt>.
class f g x => Compose (f :: k -> Constraint) (g :: k1 -> k) (x :: k1)
infixr 9 `Compose`

-- | Pairing of constraints.
class (f x, g x) => And (f :: k -> Constraint) (g :: k -> Constraint) (x :: k)
infixl 7 `And`

-- | A constraint that can always be satisfied.
class () => Top (x :: k)

-- | The constraint <tt><a>LiftedCoercible</a> f g x y</tt> is equivalent
--   to <tt><a>Coercible</a> (f x) (g y)</tt>.
class Coercible f x g y => LiftedCoercible (f :: k -> k1) (g :: k2 -> k1) (x :: k) (y :: k2)

-- | Type family that forces a type-level list to be of the same shape as
--   the given type-level list.
--   
--   Since 0.5.0.0, this only tests the top-level structure of the list,
--   and is intended to be used in conjunction with a separate construct
--   (such as the <a>AllZip</a>, <a>AllZipF</a> combination to tie the
--   recursive knot). The reason is that making <a>SameShapeAs</a> directly
--   recursive leads to quadratic compile times.
--   
--   The main use of this constraint is to help type inference to learn
--   something about otherwise unknown type-level lists.
type family SameShapeAs (xs :: [a]) (ys :: [b])

-- | Explicit singleton list.
--   
--   A singleton list can be used to reveal the structure of a type-level
--   list argument that the function is quantified over. For every
--   type-level list <tt>xs</tt>, there is one non-bottom value of type
--   <tt><a>SList</a> xs</tt>.
--   
--   Note that these singleton lists are polymorphic in the list elements;
--   we do not require a singleton representation for them.
data () => SList (a :: [k])
[SNil] :: forall {k}. SList ('[] :: [k])
[SCons] :: forall {k} (xs :: [k]) (x :: k). SListI xs => SList (x ': xs)

-- | Implicit singleton list.
--   
--   A singleton list can be used to reveal the structure of a type-level
--   list argument that the function is quantified over.
--   
--   Since 0.4.0.0, this is now defined in terms of <a>All</a>. A singleton
--   list provides a witness for a type-level list where the elements need
--   not satisfy any additional constraints.
type SListI = All Top :: k -> Constraint

-- | Require a singleton for every inner list in a list of lists.
type SListI2 = All SListI :: [k] -> Constraint

-- | Get hold of an explicit singleton (that one can then pattern match on)
--   for a type-level list
sList :: forall {k} (xs :: [k]). SListI xs => SList xs

-- | Paramorphism for a type-level list.
para_SList :: forall {k} (xs :: [k]) r. SListI xs => r ('[] :: [k]) -> (forall (y :: k) (ys :: [k]). SListI ys => r ys -> r (y ': ys)) -> r xs

-- | Case distinction on a type-level list.
case_SList :: forall {k} (xs :: [k]) r. SListI xs => r ('[] :: [k]) -> (forall (y :: k) (ys :: [k]). SListI ys => r (y ': ys)) -> r xs

-- | Occasionally it is useful to have an explicit, term-level,
--   representation of type-level lists (esp because of
--   <a>https://ghc.haskell.org/trac/ghc/ticket/9108</a> )
data () => Shape (a :: [k])
[ShapeNil] :: forall {k}. Shape ('[] :: [k])
[ShapeCons] :: forall {k} (xs :: [k]) (x :: k). SListI xs => Shape xs -> Shape (x ': xs)

-- | The shape of a type-level list.
shape :: forall k (xs :: [k]). SListI xs => Shape xs

-- | The length of a type-level list.
lengthSList :: forall k (xs :: [k]) proxy. SListI xs => proxy xs -> Int

-- | <a>Proxy</a> is a type that holds no data, but has a phantom parameter
--   of arbitrary type (or even kind). Its use is to provide type
--   information, even though there is no value available of that type (or
--   it may be too costly to create one).
--   
--   Historically, <tt><a>Proxy</a> :: <a>Proxy</a> a</tt> is a safer
--   alternative to the <tt><a>undefined</a> :: a</tt> idiom.
--   
--   <pre>
--   &gt;&gt;&gt; Proxy :: Proxy (Void, Int -&gt; Int)
--   Proxy
--   </pre>
--   
--   Proxy can even hold types of higher kinds,
--   
--   <pre>
--   &gt;&gt;&gt; Proxy :: Proxy Either
--   Proxy
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Proxy :: Proxy Functor
--   Proxy
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Proxy :: Proxy complicatedStructure
--   Proxy
--   </pre>
data () => Proxy (t :: k)
Proxy :: Proxy (t :: k)
