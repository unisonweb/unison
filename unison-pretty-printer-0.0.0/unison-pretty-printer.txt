-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


@package unison-pretty-printer
@version 0.0.0

module Unison.Util.Less
less :: String -> IO ()

module Unison.Util.Range

-- | True if <tt>_x</tt> contains <tt>_y</tt>
contains :: Range -> Range -> Bool
overlaps :: Range -> Range -> Bool
inRange :: Pos -> Range -> Bool
isMultiLine :: Range -> Bool
data Range
Range :: Pos -> Pos -> Range
[start] :: Range -> Pos
[end] :: Range -> Pos
startingLine :: Range -> Range
instance GHC.Show.Show Unison.Util.Range.Range
instance GHC.Classes.Ord Unison.Util.Range.Range
instance GHC.Classes.Eq Unison.Util.Range.Range
instance GHC.Base.Semigroup Unison.Util.Range.Range

module Unison.Util.AnnotatedText
data Segment a
Segment :: String -> Maybe a -> Segment a
[segment] :: Segment a -> String
[annotation] :: Segment a -> Maybe a
toPair :: Segment a -> (String, Maybe a)
newtype AnnotatedText a
AnnotatedText :: Seq (Segment a) -> AnnotatedText a
data AnnotatedExcerpt a
AnnotatedExcerpt :: Line -> String -> Map Range a -> AnnotatedExcerpt a
[lineOffset] :: AnnotatedExcerpt a -> Line
[text] :: AnnotatedExcerpt a -> String
[annotations] :: AnnotatedExcerpt a -> Map Range a
annotate' :: Maybe b -> AnnotatedText a -> AnnotatedText b
deannotate :: AnnotatedText a -> AnnotatedText b
annotate :: a -> AnnotatedText a -> AnnotatedText a
annotateMaybe :: AnnotatedText (Maybe a) -> AnnotatedText a
trailingNewLine :: AnnotatedText a -> Bool
markup :: AnnotatedExcerpt a -> Map Range a -> AnnotatedExcerpt a
textLength :: AnnotatedText a -> Int
textEmpty :: AnnotatedText a -> Bool
condensedExcerptToText :: Int -> AnnotatedExcerpt a -> AnnotatedText a
excerptToText :: forall a. AnnotatedExcerpt a -> AnnotatedText a
snipWithContext :: Int -> AnnotatedExcerpt a -> [AnnotatedExcerpt a]
instance GHC.Generics.Generic (Unison.Util.AnnotatedText.Segment a)
instance Data.Foldable.Foldable Unison.Util.AnnotatedText.Segment
instance GHC.Base.Functor Unison.Util.AnnotatedText.Segment
instance GHC.Show.Show a => GHC.Show.Show (Unison.Util.AnnotatedText.Segment a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Unison.Util.AnnotatedText.Segment a)
instance GHC.Generics.Generic (Unison.Util.AnnotatedText.AnnotatedText a)
instance GHC.Show.Show a => GHC.Show.Show (Unison.Util.AnnotatedText.AnnotatedText a)
instance Data.Foldable.Foldable Unison.Util.AnnotatedText.AnnotatedText
instance GHC.Base.Functor Unison.Util.AnnotatedText.AnnotatedText
instance GHC.Classes.Eq a => GHC.Classes.Eq (Unison.Util.AnnotatedText.AnnotatedText a)
instance GHC.Base.Functor Unison.Util.AnnotatedText.AnnotatedExcerpt
instance Data.String.IsString (Unison.Util.AnnotatedText.AnnotatedExcerpt a)
instance GHC.Base.Semigroup (Unison.Util.AnnotatedText.AnnotatedText a)
instance GHC.Base.Monoid (Unison.Util.AnnotatedText.AnnotatedText a)
instance Data.ListLike.FoldableLL.FoldableLL (Unison.Util.AnnotatedText.AnnotatedText a) GHC.Types.Char
instance Data.ListLike.Base.ListLike (Unison.Util.AnnotatedText.AnnotatedText a) GHC.Types.Char
instance Data.String.IsString (Unison.Util.AnnotatedText.AnnotatedText a)
instance GHC.IsList.IsList (Unison.Util.AnnotatedText.AnnotatedText a)

module Unison.Util.SyntaxText
type SyntaxText' r = AnnotatedText (Element r)
data Element r
NumericLiteral :: Element r
TextLiteral :: Element r
BytesLiteral :: Element r
CharLiteral :: Element r
BooleanLiteral :: Element r
Blank :: Element r
Var :: Element r
TypeReference :: r -> Element r
TermReference :: Referent' r -> Element r
Op :: SeqOp -> Element r
AbilityBraces :: Element r
ControlKeyword :: Element r
TypeOperator :: Element r
BindingEquals :: Element r
TypeAscriptionColon :: Element r
DataTypeKeyword :: Element r
DataTypeParams :: Element r
Unit :: Element r
DataTypeModifier :: Element r
UseKeyword :: Element r
UsePrefix :: Element r
UseSuffix :: Element r
HashQualifier :: HashQualified Name -> Element r
DelayForceChar :: Element r
DelimiterChar :: Element r
Parenthesis :: Element r
LinkKeyword :: Element r
DocDelimiter :: Element r
DocKeyword :: Element r
syntax :: Element r -> SyntaxText' r -> SyntaxText' r
toPlain :: SyntaxText' r -> String
instance GHC.Base.Functor Unison.Util.SyntaxText.Element
instance GHC.Show.Show r => GHC.Show.Show (Unison.Util.SyntaxText.Element r)
instance GHC.Classes.Ord r => GHC.Classes.Ord (Unison.Util.SyntaxText.Element r)
instance GHC.Classes.Eq r => GHC.Classes.Eq (Unison.Util.SyntaxText.Element r)

module Unison.Util.ColorText
type ColorText = AnnotatedText Color
data Color
Black :: Color
Red :: Color
Green :: Color
Yellow :: Color
Blue :: Color
Purple :: Color
Cyan :: Color
White :: Color
HiBlack :: Color
HiRed :: Color
HiGreen :: Color
HiYellow :: Color
HiBlue :: Color
HiPurple :: Color
HiCyan :: Color
HiWhite :: Color
Bold :: Color
Underline :: Color
Invert :: Color -> Color
Background :: Color -> Color -> Color
Default :: Color
style :: Color -> ColorText -> ColorText
toANSI :: ColorText -> String
toPlain :: ColorText -> String
toHTML :: String -> ColorText -> String
defaultColors :: Element r -> Maybe Color
black :: ColorText -> ColorText
red :: ColorText -> ColorText
green :: ColorText -> ColorText
yellow :: ColorText -> ColorText
blue :: ColorText -> ColorText
purple :: ColorText -> ColorText
cyan :: ColorText -> ColorText
white :: ColorText -> ColorText
hiBlack :: ColorText -> ColorText
hiRed :: ColorText -> ColorText
hiGreen :: ColorText -> ColorText
hiYellow :: ColorText -> ColorText
hiBlue :: ColorText -> ColorText
hiPurple :: ColorText -> ColorText
hiCyan :: ColorText -> ColorText
hiWhite :: ColorText -> ColorText
bold :: ColorText -> ColorText
underline :: ColorText -> ColorText
invert :: ColorText -> ColorText
background :: Color -> ColorText -> ColorText
unstyled :: ColorText -> ColorText
newtype AnnotatedText a
AnnotatedText :: Seq (Segment a) -> AnnotatedText a
data Segment a
Segment :: String -> Maybe a -> Segment a
[segment] :: Segment a -> String
[annotation] :: Segment a -> Maybe a
toPair :: Segment a -> (String, Maybe a)
annotate :: a -> AnnotatedText a -> AnnotatedText a
instance GHC.Read.Read Unison.Util.ColorText.Color
instance GHC.Show.Show Unison.Util.ColorText.Color
instance GHC.Classes.Ord Unison.Util.ColorText.Color
instance GHC.Classes.Eq Unison.Util.ColorText.Color

module Unison.Util.Pretty
data Pretty s
type ColorText = ColorText
align :: (ListLike s Char, IsString s) => [(Pretty s, Pretty s)] -> [Pretty s]
align' :: (ListLike s Char, IsString s) => [(Pretty s, Maybe (Pretty s))] -> [(Pretty s, Pretty s)]
alternations :: ListLike s c => (c -> Bool) -> s -> [s]
background :: (Pretty ColorText -> Pretty ColorText) -> Pretty ColorText -> Pretty ColorText
backticked :: IsString s => Pretty s -> Pretty s

-- | Attach some punctuation after the closing backtick.
backticked' :: IsString s => Pretty s -> Pretty s -> Pretty s
boxForkLeft :: forall s. (ListLike s Char, IsString s) => [Pretty s] -> [Pretty s]
boxLeft :: forall s. (ListLike s Char, IsString s) => [Pretty s] -> [Pretty s]
boxLeftM :: forall m s. (Monad m, ListLike s Char, IsString s) => [m (Pretty s)] -> [m (Pretty s)]
boxRight :: forall s. (ListLike s Char, IsString s) => [Pretty s] -> [Pretty s]
boxRightM :: forall m s. (Monad m, ListLike s Char, IsString s) => [m (Pretty s)] -> [m (Pretty s)]
bulleted :: (Foldable f, ListLike s Char, IsString s) => f (Pretty s) -> Pretty s
bracket :: (ListLike s Char, IsString s) => Pretty s -> Pretty s
callout :: (ListLike s Char, IsString s) => Pretty s -> Pretty s -> Pretty s
excerptSep :: IsString s => Maybe Int -> Pretty s -> [Pretty s] -> Pretty s
excerptSep' :: IsString s => Maybe Int -> (Int -> Pretty s) -> Pretty s -> [Pretty s] -> Pretty s
excerptColumn2 :: (ListLike s Char, IsString s) => Maybe Int -> [(Pretty s, Pretty s)] -> Pretty s
excerptColumn2Headed :: (ListLike s Char, IsString s) => Maybe Int -> (Pretty s, Pretty s) -> [(Pretty s, Pretty s)] -> Pretty s
warnCallout :: (ListLike s Char, IsString s) => Pretty s -> Pretty s
blockedCallout :: (ListLike s Char, IsString s) => Pretty s -> Pretty s
fatalCallout :: (ListLike s Char, IsString s) => Pretty s -> Pretty s
okCallout :: (ListLike s Char, IsString s) => Pretty s -> Pretty s
column2 :: (ListLike s Char, IsString s) => [(Pretty s, Pretty s)] -> Pretty s
column2sep :: (ListLike s Char, IsString s) => Pretty s -> [(Pretty s, Pretty s)] -> Pretty s
column2Header :: Pretty ColorText -> Pretty ColorText -> [(Pretty ColorText, Pretty ColorText)] -> Pretty ColorText
column2M :: (Applicative m, ListLike s Char, IsString s) => [m (Pretty s, Pretty s)] -> m (Pretty s)
column2UnzippedM :: forall m s. (ListLike s Char, IsString s, Monad m) => Pretty s -> [m (Pretty s)] -> [m (Pretty s)] -> m (Pretty s)
column3 :: (ListLike s Char, IsString s) => [(Pretty s, Pretty s, Pretty s)] -> Pretty s
column3M :: (ListLike s Char, IsString s, Monad m) => [m (Pretty s, Pretty s, Pretty s)] -> m (Pretty s)
column3UnzippedM :: forall m s. (ListLike s Char, IsString s, Monad m) => Pretty s -> [m (Pretty s)] -> [m (Pretty s)] -> [m (Pretty s)] -> m (Pretty s)
column3sep :: (ListLike s Char, IsString s) => Pretty s -> [(Pretty s, Pretty s, Pretty s)] -> Pretty s
column3Header :: Pretty ColorText -> Pretty ColorText -> Pretty ColorText -> [(Pretty ColorText, Pretty ColorText, Pretty ColorText)] -> Pretty ColorText

-- | Creates an aligned table with an arbitrary number of columns and
--   column headers. Ensure all rows have the same number of columns or the
--   alignment may be off.
columnNHeader :: [Pretty ColorText] -> [[Pretty ColorText]] -> Pretty ColorText
commas :: (Foldable f, IsString s) => f (Pretty s) -> Pretty s
commented :: (Foldable f, ListLike s Char, IsString s) => f (Pretty s) -> Pretty s
oxfordCommas :: (Foldable f, IsString s) => f (Pretty s) -> Pretty s
oxfordCommasWith :: (Foldable f, IsString s) => Pretty s -> f (Pretty s) -> Pretty s
plural :: Foldable f => f a -> Pretty ColorText -> Pretty ColorText
dashed :: (Foldable f, ListLike s Char, IsString s) => f (Pretty s) -> Pretty s
flatMap :: (s -> Pretty s2) -> Pretty s -> Pretty s2
group :: Pretty s -> Pretty s
hang' :: (ListLike s Char, IsString s) => Pretty s -> Pretty s -> Pretty s -> Pretty s
hang :: (ListLike s Char, IsString s) => Pretty s -> Pretty s -> Pretty s
hangUngrouped' :: (ListLike s Char, IsString s) => Pretty s -> Pretty s -> Pretty s -> Pretty s
hangUngrouped :: (ListLike s Char, IsString s) => Pretty s -> Pretty s -> Pretty s
softHang' :: (ListLike s Char, IsString s) => Pretty s -> Pretty s -> Pretty s -> Pretty s
softHang :: (ListLike s Char, IsString s) => Pretty s -> Pretty s -> Pretty s
softHangNoSpace' :: (ListLike s Char, IsString s) => Pretty s -> Pretty s -> Pretty s -> Pretty s
indent :: (ListLike s Char, IsString s) => Pretty s -> Pretty s -> Pretty s
indentAfterNewline :: (ListLike s Char, IsString s) => Pretty s -> Pretty s -> Pretty s
indentN :: (ListLike s Char, IsString s) => Width -> Pretty s -> Pretty s
indentNonEmptyN :: (ListLike s Char, IsString s) => Width -> Pretty s -> Pretty s
indentNAfterNewline :: (ListLike s Char, IsString s) => Width -> Pretty s -> Pretty s
invert :: Pretty ColorText -> Pretty ColorText
isMultiLine :: Pretty s -> Bool
isEmpty :: Eq s => IsString s => Pretty s -> Bool
leftPad :: IsString s => Width -> Pretty s -> Pretty s
lines :: (Foldable f, IsString s) => f (Pretty s) -> Pretty s
linesNonEmpty :: (Foldable f, IsString s) => f (Pretty s) -> Pretty s
linesSpaced :: (Foldable f, IsString s) => f (Pretty s) -> Pretty s
lit :: (IsString s, ListLike s Char) => s -> Pretty s
map :: ListLike s2 Char => (s -> s2) -> Pretty s -> Pretty s2
mayColumn2 :: (ListLike s Char, IsString s) => [(Pretty s, Maybe (Pretty s))] -> Pretty s
nest :: (ListLike s Char, IsString s) => Pretty s -> Pretty s -> Pretty s
num :: (Show n, Num n, IsString s) => n -> Pretty s
newline :: IsString s => Pretty s
leftJustify :: (Eq s, ListLike s Char, IsString s) => [(Pretty s, a)] -> [(Pretty s, a)]
lineSkip :: IsString s => Pretty s
nonEmpty :: (Foldable f, IsString s) => f (Pretty s) -> [Pretty s]
numbered :: (Foldable f, ListLike s Char, IsString s) => (Int -> Pretty s) -> f (Pretty s) -> Pretty s
numberedColumn2ListFrom :: Foldable f => Int -> f (Pretty ColorText, Pretty ColorText) -> Pretty ColorText
numberedColumn2Header :: (Foldable f, ListLike s Char, IsString s) => (Int -> Pretty s) -> f (Pretty s, Pretty s) -> Pretty s
numberedColumnNHeader :: [Pretty ColorText] -> [[Pretty ColorText]] -> Pretty ColorText
numberedList :: Foldable f => f (Pretty ColorText) -> Pretty ColorText
numberedListFrom :: Foldable f => Int -> f (Pretty ColorText) -> Pretty ColorText
orElse :: Pretty s -> Pretty s -> Pretty s
orElses :: [Pretty s] -> Pretty s
paragraphyText :: (ListLike s Char, IsString s) => Text -> Pretty s
parenthesize :: IsString s => Pretty s -> Pretty s
parenthesizeCommas :: (Foldable f, IsString s) => f (Pretty s) -> Pretty s
parenthesizeIf :: IsString s => Bool -> Pretty s -> Pretty s
render :: (Monoid s, IsString s) => Width -> Pretty s -> s
renderUnbroken :: (Monoid s, IsString s) => Pretty s -> s
rightPad :: IsString s => Width -> Pretty s -> Pretty s
sep :: (Foldable f, IsString s) => Pretty s -> f (Pretty s) -> Pretty s
sepNonEmpty :: (Foldable f, IsString s) => Pretty s -> f (Pretty s) -> Pretty s
sepSpaced :: (Foldable f, IsString s) => Pretty s -> f (Pretty s) -> Pretty s
shown :: (Show a, IsString s) => a -> Pretty s

-- | Like <a>shown</a>, but uses a pretty layout (so long as the Show
--   instance is derived).
pshown :: (Show a, IsString s) => a -> Pretty s
singleQuoted :: IsString s => Pretty s -> Pretty s
singleQuoted' :: IsString s => Pretty s -> Pretty s -> Pretty s
softbreak :: IsString s => Pretty s
spaceIfBreak :: IsString s => Pretty s
spaceIfNeeded :: Eq s => IsString s => Pretty s -> Pretty s -> Pretty s
spaced :: (Foldable f, IsString s) => f (Pretty s) -> Pretty s
spacedMap :: (Foldable f, IsString s) => (a -> Pretty s) -> f a -> Pretty s
spacedTraverse :: (Traversable f, IsString s, Applicative m) => (a -> m (Pretty s)) -> f a -> m (Pretty s)
spacesIfBreak :: IsString s => Int -> Pretty s
string :: IsString s => String -> Pretty s
surroundCommas :: (Foldable f, IsString s) => Pretty s -> Pretty s -> f (Pretty s) -> Pretty s
syntaxToColor :: Pretty (SyntaxText' r) -> Pretty ColorText
table :: (IsString s, ListLike s Char) => [[Pretty s]] -> Pretty s
text :: IsString s => Text -> Pretty s
toANSI :: Width -> Pretty ColorText -> String
toAnsiUnbroken :: Pretty ColorText -> String
toHTML :: String -> Width -> Pretty ColorText -> String
toPlain :: Width -> Pretty ColorText -> String
toPlainUnbroken :: Pretty ColorText -> String
underline :: Pretty ColorText -> Pretty ColorText
withSyntax :: Element r -> Pretty (SyntaxText' r) -> Pretty (SyntaxText' r)
wrap :: (ListLike s Char, IsString s) => Pretty s -> Pretty s
wrap' :: IsString s => (s -> [Pretty s]) -> Pretty s -> Pretty s
wrapColumn2 :: (ListLike s Char, IsString s) => [(Pretty s, Pretty s)] -> Pretty s
wrapString :: (ListLike s Char, IsString s) => String -> Pretty s
black :: Pretty ColorText -> Pretty ColorText
red :: Pretty ColorText -> Pretty ColorText
green :: Pretty ColorText -> Pretty ColorText
yellow :: Pretty ColorText -> Pretty ColorText
blue :: Pretty ColorText -> Pretty ColorText
purple :: Pretty ColorText -> Pretty ColorText
cyan :: Pretty ColorText -> Pretty ColorText
white :: Pretty ColorText -> Pretty ColorText
hiBlack :: Pretty ColorText -> Pretty ColorText
hiRed :: Pretty ColorText -> Pretty ColorText
hiGreen :: Pretty ColorText -> Pretty ColorText
hiYellow :: Pretty ColorText -> Pretty ColorText
hiBlue :: Pretty ColorText -> Pretty ColorText
hiPurple :: Pretty ColorText -> Pretty ColorText
hiCyan :: Pretty ColorText -> Pretty ColorText
hiWhite :: Pretty ColorText -> Pretty ColorText
bold :: Pretty ColorText -> Pretty ColorText
border :: (ListLike s Char, IsString s) => Width -> Pretty s -> Pretty s
newtype Width
Width :: Int -> Width
[widthToInt] :: Width -> Int
delta :: Pretty s -> Delta
data Delta
instance GHC.Enum.Bounded Unison.Util.Pretty.Width
instance GHC.Num.Num Unison.Util.Pretty.Width
instance GHC.Generics.Generic Unison.Util.Pretty.Width
instance GHC.Show.Show Unison.Util.Pretty.Width
instance GHC.Classes.Ord Unison.Util.Pretty.Width
instance GHC.Classes.Eq Unison.Util.Pretty.Width
instance GHC.Base.Functor (Unison.Util.Pretty.F s)
instance Data.Traversable.Traversable (Unison.Util.Pretty.F s)
instance Data.Foldable.Foldable (Unison.Util.Pretty.F s)
instance (GHC.Show.Show s, GHC.Show.Show r) => GHC.Show.Show (Unison.Util.Pretty.F s r)
instance (GHC.Classes.Eq s, GHC.Classes.Eq r) => GHC.Classes.Eq (Unison.Util.Pretty.F s r)
instance GHC.Show.Show Unison.Util.Pretty.Delta
instance GHC.Classes.Ord Unison.Util.Pretty.Delta
instance GHC.Classes.Eq Unison.Util.Pretty.Delta
instance GHC.Classes.Eq s => GHC.Classes.Eq (Unison.Util.Pretty.Pretty s)
instance GHC.Base.Functor Unison.Util.Pretty.Pretty
instance Data.String.IsString s => Data.String.IsString (Unison.Util.Pretty.Pretty s)
instance GHC.Base.Semigroup (Unison.Util.Pretty.Pretty s)
instance GHC.Base.Monoid (Unison.Util.Pretty.Pretty s)
instance GHC.Show.Show s => GHC.Show.Show (Unison.Util.Pretty.Pretty s)
instance GHC.Base.Semigroup Unison.Util.Pretty.Delta
instance GHC.Base.Monoid Unison.Util.Pretty.Delta

module Unison.PrettyTerminal
stripSurroundingBlanks :: String -> String
putPrettyLn :: Pretty ColorText -> IO ()
putPrettyLnUnpaged :: Pretty ColorText -> IO ()
putPrettyLn' :: Pretty ColorText -> IO ()
clearCurrentLine :: IO ()
putPretty' :: Pretty ColorText -> IO ()
getAvailableWidth :: IO Width
putPrettyNonempty :: Pretty ColorText -> IO ()
