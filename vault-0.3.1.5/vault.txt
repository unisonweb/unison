-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | a persistent store for values of arbitrary types
--   
--   A <i>vault</i> is a persistent store for values of arbitrary types.
--   It's like having first-class access to the storage space behind
--   IORefs.
--   
--   The data structure is analogous to a bank vault, where you can access
--   different bank boxes with different keys; hence the name.
--   
--   Also provided is a <i>locker</i> type, representing a store for a
--   single element.
@package vault
@version 0.3.1.5


-- | An abstract interface to a unique symbol generator.
module Data.Unique.Really

-- | An abstract unique value. Values of type <a>Unique</a> may be compared
--   for equality and hashed into Int.
--   
--   Note: Unlike the symbols from <a>Data.Unique</a>, the symbols from
--   this module do not become equal after reloads in the GHC interpreter!
data Unique

-- | Creates a new object of type <a>Unique</a>. The value returned will
--   not compare equal to any other value of type <a>Unique</a> returned by
--   previous calls to <a>newUnique</a>. There is no limit on the number of
--   times you may call this function.
newUnique :: IO Unique

-- | Hashes a <a>Unique</a> into an <a>Int</a>. Two Uniques may hash to the
--   same value, although in practice this is unlikely. The <a>Int</a>
--   returned makes a good hash key.
hashUnique :: Unique -> Int
instance GHC.Classes.Eq Data.Unique.Really.Unique
instance Data.Hashable.Class.Hashable Data.Unique.Really.Unique


-- | A persistent store for values of arbitrary types. Variant for the
--   <a>ST</a> monad.
--   
--   The <a>Vault</a> type in this module is strict in the keys but lazy in
--   the values.
module Data.Vault.ST.Lazy
data Vault s
data Key s a

-- | The empty vault.
empty :: Vault s

-- | Create a new key for use with a vault.
newKey :: ST s (Key s a)

-- | Lookup the value of a key in the vault.
lookup :: Key s a -> Vault s -> Maybe a

-- | Insert a value for a given key. Overwrites any previous value.
insert :: Key s a -> a -> Vault s -> Vault s

-- | Adjust the value for a given key if it's present in the vault.
adjust :: (a -> a) -> Key s a -> Vault s -> Vault s

-- | Delete a key from the vault.
delete :: Key s a -> Vault s -> Vault s

-- | Merge two vaults (left-biased).
union :: Vault s -> Vault s -> Vault s
data Locker s

-- | Put a single value into a <a>Locker</a>.
lock :: Key s a -> a -> Locker s

-- | Retrieve the value from the <a>Locker</a>.
unlock :: Key s a -> Locker s -> Maybe a
instance GHC.Base.Semigroup (Data.Vault.ST.Lazy.Vault s)
instance GHC.Base.Monoid (Data.Vault.ST.Lazy.Vault s)


-- | A persistent store for values of arbitrary types.
--   
--   The <a>Vault</a> type in this module is strict in the keys but lazy in
--   the values.
module Data.Vault.Lazy

-- | A persistent store for values of arbitrary types.
--   
--   This variant is the simplest and creates keys in the <a>IO</a> monad.
--   See the module <a>Data.Vault.ST</a> if you want to use it with the
--   <a>ST</a> monad instead.
type Vault = Vault RealWorld

-- | Keys for the vault.
type Key = Key RealWorld

-- | The empty vault.
empty :: Vault

-- | Create a new key for use with a vault.
newKey :: IO (Key a)

-- | Lookup the value of a key in the vault.
lookup :: Key a -> Vault -> Maybe a

-- | Insert a value for a given key. Overwrites any previous value.
insert :: Key a -> a -> Vault -> Vault

-- | Adjust the value for a given key if it's present in the vault.
adjust :: (a -> a) -> Key a -> Vault -> Vault

-- | Delete a key from the vault.
delete :: Key a -> Vault -> Vault

-- | Merge two vaults (left-biased).
union :: Vault -> Vault -> Vault

-- | A persistent store for a single value.
type Locker = Locker RealWorld

-- | Put a single value into a <a>Locker</a>.
lock :: Key a -> a -> Locker

-- | Retrieve the value from the <a>Locker</a>.
unlock :: Key a -> Locker -> Maybe a


-- | A persistent store for values of arbitrary types. Variant for the
--   <a>ST</a> monad.
--   
--   The <a>Vault</a> type in this module is strict in both keys and
--   values.
module Data.Vault.ST.Strict
data Vault s
data Key s a

-- | The empty vault.
empty :: Vault s

-- | Create a new key for use with a vault.
newKey :: ST s (Key s a)

-- | Lookup the value of a key in the vault.
lookup :: Key s a -> Vault s -> Maybe a

-- | Insert a value for a given key. Overwrites any previous value.
insert :: Key s a -> a -> Vault s -> Vault s

-- | Adjust the value for a given key if it's present in the vault.
adjust :: (a -> a) -> Key s a -> Vault s -> Vault s

-- | Delete a key from the vault.
delete :: Key s a -> Vault s -> Vault s

-- | Merge two vaults (left-biased).
union :: Vault s -> Vault s -> Vault s
data Locker s

-- | Put a single value into a <a>Locker</a>.
lock :: Key s a -> a -> Locker s

-- | Retrieve the value from the <a>Locker</a>.
unlock :: Key s a -> Locker s -> Maybe a
instance GHC.Base.Semigroup (Data.Vault.ST.Strict.Vault s)
instance GHC.Base.Monoid (Data.Vault.ST.Strict.Vault s)


-- | A persistent store for values of arbitrary types.
--   
--   The <a>Vault</a> type in this module is strict in both keys and
--   values.
module Data.Vault.Strict

-- | A persistent store for values of arbitrary types.
--   
--   This variant is the simplest and creates keys in the <a>IO</a> monad.
--   See the module <a>Data.Vault.ST</a> if you want to use it with the
--   <a>ST</a> monad instead.
type Vault = Vault RealWorld

-- | Keys for the vault.
type Key = Key RealWorld

-- | The empty vault.
empty :: Vault

-- | Create a new key for use with a vault.
newKey :: IO (Key a)

-- | Lookup the value of a key in the vault.
lookup :: Key a -> Vault -> Maybe a

-- | Insert a value for a given key. Overwrites any previous value.
insert :: Key a -> a -> Vault -> Vault

-- | Adjust the value for a given key if it's present in the vault.
adjust :: (a -> a) -> Key a -> Vault -> Vault

-- | Delete a key from the vault.
delete :: Key a -> Vault -> Vault

-- | Merge two vaults (left-biased).
union :: Vault -> Vault -> Vault

-- | A persistent store for a single value.
type Locker = Locker RealWorld

-- | Put a single value into a <a>Locker</a>.
lock :: Key a -> a -> Locker

-- | Retrieve the value from the <a>Locker</a>.
unlock :: Key a -> Locker -> Maybe a
