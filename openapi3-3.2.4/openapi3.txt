-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | OpenAPI 3.0 data model
--   
--   This library is intended to be used for decoding and encoding OpenAPI
--   3.0 API specifications as well as manipulating them.
--   
--   The original OpenAPI 3.0 specification is available at
--   <a>http://swagger.io/specification/</a>.
@package openapi3
@version 3.2.4

module Data.OpenApi.Aeson.Compat
deleteKey :: Key -> KeyMap v -> KeyMap v
objectToList :: KeyMap v -> [(Key, v)]
objectKeys :: KeyMap v -> [Text]
stringToKey :: String -> Key
keyToString :: Key -> String
keyToText :: Key -> Text
toInsOrdHashMap :: KeyMap v -> InsOrdHashMap Text v
fromInsOrdHashMap :: InsOrdHashMap Text v -> KeyMap v
lookupKey :: Text -> KeyMap v -> Maybe v
hasKey :: Text -> KeyMap a -> Bool


-- | Declare monad transformer and associated functions.
module Data.OpenApi.Declare

-- | A declare monad transformer parametrized by:
--   
--   <ul>
--   <li><tt>d</tt> — the output to accumulate (declarations);</li>
--   <li><tt>m</tt> — the inner monad.</li>
--   </ul>
--   
--   This monad transformer is similar to both state and writer monad
--   transformers. Thus it can be seen as
--   
--   <ul>
--   <li>a restricted append-only version of a state monad transformer
--   or</li>
--   <li>a writer monad transformer with the extra ability to read all
--   previous output.</li>
--   </ul>
newtype DeclareT d m a
DeclareT :: (d -> m (d, a)) -> DeclareT d m a
[runDeclareT] :: DeclareT d m a -> d -> m (d, a)

-- | Definitions of <tt>declare</tt> and <tt>look</tt> must satisfy the
--   following laws:
--   
--   <ul>
--   <li><i><i>monoid homomorphism (mempty)</i></i> <tt><a>declare</a>
--   mempty == return ()</tt></li>
--   <li><i><i>monoid homomorphism (mappend)</i></i> <tt><a>declare</a> x
--   &gt;&gt; <a>declare</a> y == <a>declare</a> (x &lt;&gt; y)</tt> for
--   every <tt>x</tt>, <tt>y</tt></li>
--   <li><i><i><tt>declare</tt>-<tt>look</tt></i></i> <tt><a>declare</a> x
--   &gt;&gt; <a>look</a> == <a>fmap</a> (&lt;&gt; x) <a>look</a> &lt;*
--   <a>declare</a> x</tt> for every <tt>x</tt></li>
--   <li><i><i><tt>look</tt> as left identity</i></i> <tt><a>look</a>
--   &gt;&gt; m == m</tt> for every <tt>m</tt></li>
--   </ul>
class (Applicative m, Monad m) => MonadDeclare d m | m -> d

-- | <tt><a>declare</a> x</tt> is an action that produces the output
--   <tt>x</tt>.
declare :: MonadDeclare d m => d -> m ()

-- | <tt><a>look</a></tt> is an action that returns all the output so far.
look :: MonadDeclare d m => m d

-- | Lift a computation from the simple Declare monad.
liftDeclare :: MonadDeclare d m => Declare d a -> m a

-- | Retrieve a function of all the output so far.
looks :: MonadDeclare d m => (d -> a) -> m a

-- | Evaluate <tt><a>DeclareT</a> d m a</tt> computation, ignoring new
--   output <tt>d</tt>.
evalDeclareT :: Monad m => DeclareT d m a -> d -> m a

-- | Execute <tt><tt>DeclateT</tt> d m a</tt> computation, ignoring result
--   and only producing new output <tt>d</tt>.
execDeclareT :: Monad m => DeclareT d m a -> d -> m d

-- | Evaluate <tt><a>DeclareT</a> d m a</tt> computation, starting with
--   empty output history.
undeclareT :: (Monad m, Monoid d) => DeclareT d m a -> m a

-- | A declare monad parametrized by <tt>d</tt> — the output to accumulate
--   (declarations).
--   
--   This monad is similar to both state and writer monads. Thus it can be
--   seen as
--   
--   <ul>
--   <li>a restricted append-only version of a state monad or</li>
--   <li>a writer monad with the extra ability to read all previous
--   output.</li>
--   </ul>
type Declare d = DeclareT d Identity

-- | Run <tt><a>Declare</a> d a</tt> computation with output history
--   <tt>d</tt>, producing result <tt>a</tt> and new output <tt>d</tt>.
runDeclare :: Declare d a -> d -> (d, a)

-- | Evaluate <tt><a>Declare</a> d a</tt> computation, ignoring output
--   <tt>d</tt>.
evalDeclare :: Declare d a -> d -> a

-- | Execute <tt><tt>Declate</tt> d a</tt> computation, ignoring result and
--   only producing output <tt>d</tt>.
execDeclare :: Declare d a -> d -> d

-- | Evaluate <tt><a>DeclareT</a> d m a</tt> computation, starting with
--   empty output history.
undeclare :: Monoid d => Declare d a -> a
instance GHC.Base.Functor m => GHC.Base.Functor (Data.OpenApi.Declare.DeclareT d m)
instance (GHC.Base.Applicative m, GHC.Base.Monad m, GHC.Base.Monoid d) => Data.OpenApi.Declare.MonadDeclare d (Data.OpenApi.Declare.DeclareT d m)
instance Data.OpenApi.Declare.MonadDeclare d m => Data.OpenApi.Declare.MonadDeclare d (Control.Monad.Trans.Cont.ContT r m)
instance Data.OpenApi.Declare.MonadDeclare d m => Data.OpenApi.Declare.MonadDeclare d (Control.Monad.Trans.Except.ExceptT e m)
instance Data.OpenApi.Declare.MonadDeclare d m => Data.OpenApi.Declare.MonadDeclare d (Control.Monad.Trans.Identity.IdentityT m)
instance Data.OpenApi.Declare.MonadDeclare d m => Data.OpenApi.Declare.MonadDeclare d (Control.Monad.Trans.Maybe.MaybeT m)
instance Data.OpenApi.Declare.MonadDeclare d m => Data.OpenApi.Declare.MonadDeclare d (Control.Monad.Trans.Reader.ReaderT r m)
instance (GHC.Base.Monoid w, Data.OpenApi.Declare.MonadDeclare d m) => Data.OpenApi.Declare.MonadDeclare d (Control.Monad.Trans.RWS.Lazy.RWST r w s m)
instance (GHC.Base.Monoid w, Data.OpenApi.Declare.MonadDeclare d m) => Data.OpenApi.Declare.MonadDeclare d (Control.Monad.Trans.RWS.Strict.RWST r w s m)
instance Data.OpenApi.Declare.MonadDeclare d m => Data.OpenApi.Declare.MonadDeclare d (Control.Monad.Trans.State.Lazy.StateT s m)
instance Data.OpenApi.Declare.MonadDeclare d m => Data.OpenApi.Declare.MonadDeclare d (Control.Monad.Trans.State.Strict.StateT s m)
instance (GHC.Base.Monoid w, Data.OpenApi.Declare.MonadDeclare d m) => Data.OpenApi.Declare.MonadDeclare d (Control.Monad.Trans.Writer.Lazy.WriterT w m)
instance (GHC.Base.Monoid w, Data.OpenApi.Declare.MonadDeclare d m) => Data.OpenApi.Declare.MonadDeclare d (Control.Monad.Trans.Writer.Strict.WriterT w m)
instance (GHC.Base.Applicative m, GHC.Base.Monad m, GHC.Base.Monoid d) => GHC.Base.Applicative (Data.OpenApi.Declare.DeclareT d m)
instance (GHC.Base.Applicative m, GHC.Base.Monad m, GHC.Base.Monoid d) => GHC.Base.Monad (Data.OpenApi.Declare.DeclareT d m)
instance GHC.Base.Monoid d => Control.Monad.Trans.Class.MonadTrans (Data.OpenApi.Declare.DeclareT d)

module Data.OpenApi.Internal.AesonUtils
class AesonDefaultValue a
defaultValue :: AesonDefaultValue a => Maybe a

-- | Generic serialisation for swagger records.
--   
--   Features
--   
--   <ul>
--   <li>omits nulls, empty objects and empty arrays (configurable)</li>
--   <li>possible to add fields</li>
--   <li>possible to merge sub-object</li>
--   </ul>
sopSwaggerGenericToJSON :: forall a xs. (HasDatatypeInfo a, HasSwaggerAesonOptions a, All2 ToJSON (Code a), All2 Eq (Code a), Code a ~ '[xs]) => a -> Value
sopSwaggerGenericToEncoding :: forall a xs. (HasDatatypeInfo a, HasSwaggerAesonOptions a, All2 ToJSON (Code a), All2 Eq (Code a), Code a ~ '[xs]) => a -> Encoding

-- | <ul>
--   <li>TODO:* This is only used by ToJSON (ParamSchema
--   SwaggerKindSchema)</li>
--   </ul>
--   
--   Also uses default <a>aesonDefaults</a>
sopSwaggerGenericToJSONWithOpts :: forall a xs. (Generic a, All2 AesonDefaultValue (Code a), HasDatatypeInfo a, All2 ToJSON (Code a), All2 Eq (Code a), Code a ~ '[xs]) => SwaggerAesonOptions -> a -> Value
sopSwaggerGenericParseJSON :: forall a xs. (HasDatatypeInfo a, HasSwaggerAesonOptions a, All2 FromJSON (Code a), All2 Eq (Code a), Code a ~ '[xs]) => Value -> Parser a
class (Generic a, All2 AesonDefaultValue (Code a)) => HasSwaggerAesonOptions a
swaggerAesonOptions :: HasSwaggerAesonOptions a => Proxy a -> SwaggerAesonOptions
aesonDefaults :: HasSwaggerAesonOptions a => Proxy a -> POP Maybe (Code a)
data SwaggerAesonOptions
mkSwaggerAesonOptions :: String -> SwaggerAesonOptions
saoPrefix :: Lens' SwaggerAesonOptions String
saoAdditionalPairs :: Lens' SwaggerAesonOptions [Pair]
saoSubObject :: Lens' SwaggerAesonOptions (Maybe String)
instance Data.OpenApi.Internal.AesonUtils.AesonDefaultValue Data.Text.Internal.Text
instance Data.OpenApi.Internal.AesonUtils.AesonDefaultValue (GHC.Maybe.Maybe a)
instance Data.OpenApi.Internal.AesonUtils.AesonDefaultValue [a]
instance Data.OpenApi.Internal.AesonUtils.AesonDefaultValue (Data.Set.Internal.Set a)
instance Data.OpenApi.Internal.AesonUtils.AesonDefaultValue (Data.HashSet.InsOrd.InsOrdHashSet k)
instance Data.OpenApi.Internal.AesonUtils.AesonDefaultValue (Data.HashMap.Strict.InsOrd.InsOrdHashMap k v)

module Data.OpenApi.Internal.TypeShape

-- | Shape of a datatype.
data TypeShape

-- | A simple enumeration.
Enumeration :: TypeShape

-- | A product or a sum of non-unit products.
SumOfProducts :: TypeShape

-- | Mixed sum type with both unit and non-unit constructors.
Mixed :: TypeShape

-- | A combined shape for a product type.
type family ProdCombine (a :: TypeShape) (b :: TypeShape) :: TypeShape

-- | A combined shape for a sum type.
type family SumCombine (a :: TypeShape) (b :: TypeShape) :: TypeShape
type family TypeHasSimpleShape t (f :: Symbol) :: Constraint
type family GenericHasSimpleShape t (f :: Symbol) (s :: TypeShape) :: Constraint

-- | Infer a <a>TypeShape</a> for a generic representation of a type.
type family GenericShape (g :: * -> *) :: TypeShape

module Data.OpenApi.Internal.Utils
swaggerFieldRules :: LensRules
gunfoldEnum :: String -> [a] -> (forall b r. Data b => c (b -> r) -> c r) -> (forall r. r -> c r) -> Constr -> c a
jsonPrefix :: String -> Options
parseOneOf :: ToJSON a => [a] -> Value -> Parser a
(<+>) :: Value -> Value -> Value
genericMempty :: (Generic a, GMonoid (Rep a)) => a
genericMappend :: (Generic a, GMonoid (Rep a)) => a -> a -> a
class GMonoid f
gmempty :: GMonoid f => f p
gmappend :: GMonoid f => f p -> f p -> f p
class SwaggerMonoid m
swaggerMempty :: SwaggerMonoid m => m
swaggerMappend :: SwaggerMonoid m => m -> m -> m
swaggerMempty :: (SwaggerMonoid m, Monoid m) => m
swaggerMappend :: (SwaggerMonoid m, Monoid m) => m -> m -> m
encodePretty :: ToJSON a => a -> ByteString
instance Data.OpenApi.Internal.Utils.SwaggerMonoid a => Data.OpenApi.Internal.Utils.GMonoid (GHC.Generics.K1 i a)
instance Data.OpenApi.Internal.Utils.SwaggerMonoid [a]
instance GHC.Classes.Ord a => Data.OpenApi.Internal.Utils.SwaggerMonoid (Data.Set.Internal.Set a)
instance GHC.Classes.Ord k => Data.OpenApi.Internal.Utils.SwaggerMonoid (Data.Map.Internal.Map k v)
instance (GHC.Classes.Eq k, Data.Hashable.Class.Hashable k) => Data.OpenApi.Internal.Utils.SwaggerMonoid (Data.HashMap.Internal.HashMap k v)
instance (GHC.Classes.Eq k, Data.Hashable.Class.Hashable k) => Data.OpenApi.Internal.Utils.SwaggerMonoid (Data.HashMap.Strict.InsOrd.InsOrdHashMap k v)
instance Data.OpenApi.Internal.Utils.SwaggerMonoid Data.Text.Internal.Text
instance Data.OpenApi.Internal.Utils.SwaggerMonoid (GHC.Maybe.Maybe a)
instance Data.OpenApi.Internal.Utils.GMonoid GHC.Generics.U1
instance (Data.OpenApi.Internal.Utils.GMonoid f, Data.OpenApi.Internal.Utils.GMonoid g) => Data.OpenApi.Internal.Utils.GMonoid (f GHC.Generics.:*: g)
instance Data.OpenApi.Internal.Utils.GMonoid f => Data.OpenApi.Internal.Utils.GMonoid (GHC.Generics.M1 i t f)

module Data.OpenApi.Internal

-- | A list of definitions that can be used in references.
type Definitions = InsOrdHashMap Text

-- | This is the root document object for the API specification.
data OpenApi
OpenApi :: Info -> [Server] -> InsOrdHashMap FilePath PathItem -> Components -> [SecurityRequirement] -> InsOrdHashSet Tag -> Maybe ExternalDocs -> OpenApiSpecVersion -> OpenApi

-- | Provides metadata about the API. The metadata can be used by the
--   clients if needed.
[_openApiInfo] :: OpenApi -> Info

-- | An array of Server Objects, which provide connectivity information to
--   a target server. If the servers property is not provided, or is an
--   empty array, the default value would be a <a>Server</a> object with a
--   url value of <tt>/</tt>.
[_openApiServers] :: OpenApi -> [Server]

-- | The available paths and operations for the API.
[_openApiPaths] :: OpenApi -> InsOrdHashMap FilePath PathItem

-- | An element to hold various schemas for the specification.
[_openApiComponents] :: OpenApi -> Components

-- | A declaration of which security mechanisms can be used across the API.
--   The list of values includes alternative security requirement objects
--   that can be used. Only one of the security requirement objects need to
--   be satisfied to authorize a request. Individual operations can
--   override this definition. To make security optional, an empty security
--   requirement can be included in the array.
[_openApiSecurity] :: OpenApi -> [SecurityRequirement]

-- | A list of tags used by the specification with additional metadata. The
--   order of the tags can be used to reflect on their order by the parsing
--   tools. Not all tags that are used by the <a>Operation</a> Object must
--   be declared. The tags that are not declared MAY be organized randomly
--   or based on the tools' logic. Each tag name in the list MUST be
--   unique.
[_openApiTags] :: OpenApi -> InsOrdHashSet Tag

-- | Additional external documentation.
[_openApiExternalDocs] :: OpenApi -> Maybe ExternalDocs

-- | The spec of OpenApi this spec adheres to. Must be between
--   <a>lowerOpenApiSpecVersion</a> and <a>upperOpenApiSpecVersion</a>
[_openApiOpenapi] :: OpenApi -> OpenApiSpecVersion

-- | This is the lower version of the OpenApi Spec this library can parse
--   or produce
lowerOpenApiSpecVersion :: Version

-- | This is the upper version of the OpenApi Spec this library can parse
--   or produce
upperOpenApiSpecVersion :: Version

-- | The object provides metadata about the API. The metadata MAY be used
--   by the clients if needed, and MAY be presented in editing or
--   documentation generation tools for convenience.
data Info
Info :: Text -> Maybe Text -> Maybe Text -> Maybe Contact -> Maybe License -> Text -> Info

-- | The title of the API.
[_infoTitle] :: Info -> Text

-- | A short description of the API. <a>CommonMark syntax</a> MAY be used
--   for rich text representation.
[_infoDescription] :: Info -> Maybe Text

-- | A URL to the Terms of Service for the API. MUST be in the format of a
--   URL.
[_infoTermsOfService] :: Info -> Maybe Text

-- | The contact information for the exposed API.
[_infoContact] :: Info -> Maybe Contact

-- | The license information for the exposed API.
[_infoLicense] :: Info -> Maybe License

-- | The version of the OpenAPI document (which is distinct from the
--   OpenAPI Specification version or the API implementation version).
[_infoVersion] :: Info -> Text

-- | Contact information for the exposed API.
data Contact
Contact :: Maybe Text -> Maybe URL -> Maybe Text -> Contact

-- | The identifying name of the contact person/organization.
[_contactName] :: Contact -> Maybe Text

-- | The URL pointing to the contact information.
[_contactUrl] :: Contact -> Maybe URL

-- | The email address of the contact person/organization.
[_contactEmail] :: Contact -> Maybe Text

-- | License information for the exposed API.
data License
License :: Text -> Maybe URL -> License

-- | The license name used for the API.
[_licenseName] :: License -> Text

-- | A URL to the license used for the API.
[_licenseUrl] :: License -> Maybe URL

-- | An object representing a Server.
data Server
Server :: Text -> Maybe Text -> InsOrdHashMap Text ServerVariable -> Server

-- | A URL to the target host. This URL supports Server Variables and MAY
--   be relative, to indicate that the host location is relative to the
--   location where the OpenAPI document is being served. Variable
--   substitutions will be made when a variable is named in
--   <tt>{brackets}</tt>.
[_serverUrl] :: Server -> Text

-- | An optional string describing the host designated by the URL.
--   <a>CommonMark syntax</a> MAY be used for rich text representation.
[_serverDescription] :: Server -> Maybe Text

-- | A map between a variable name and its value. The value is used for
--   substitution in the server's URL template.
[_serverVariables] :: Server -> InsOrdHashMap Text ServerVariable
data ServerVariable
ServerVariable :: Maybe (InsOrdHashSet Text) -> Text -> Maybe Text -> ServerVariable

-- | An enumeration of string values to be used if the substitution options
--   are from a limited set. The array SHOULD NOT be empty.
[_serverVariableEnum] :: ServerVariable -> Maybe (InsOrdHashSet Text)

-- | The default value to use for substitution, which SHALL be sent if an
--   alternate value is not supplied. Note this behavior is different than
--   the 'Schema Object's treatment of default values, because in those
--   cases parameter values are optional. If the <a>_serverVariableEnum</a>
--   is defined, the value SHOULD exist in the enum's values.
[_serverVariableDefault] :: ServerVariable -> Text

-- | An optional description for the server variable. <a>CommonMark
--   syntax</a> MAY be used for rich text representation.
[_serverVariableDescription] :: ServerVariable -> Maybe Text

-- | Holds a set of reusable objects for different aspects of the OAS. All
--   objects defined within the components object will have no effect on
--   the API unless they are explicitly referenced from properties outside
--   the components object.
data Components
Components :: Definitions Schema -> Definitions Response -> Definitions Param -> Definitions Example -> Definitions RequestBody -> Definitions Header -> SecurityDefinitions -> Definitions Link -> Definitions Callback -> Components
[_componentsSchemas] :: Components -> Definitions Schema
[_componentsResponses] :: Components -> Definitions Response
[_componentsParameters] :: Components -> Definitions Param
[_componentsExamples] :: Components -> Definitions Example
[_componentsRequestBodies] :: Components -> Definitions RequestBody
[_componentsHeaders] :: Components -> Definitions Header
[_componentsSecuritySchemes] :: Components -> SecurityDefinitions
[_componentsLinks] :: Components -> Definitions Link
[_componentsCallbacks] :: Components -> Definitions Callback

-- | Describes the operations available on a single path. A
--   <tt><a>PathItem</a></tt> may be empty, due to ACL constraints. The
--   path itself is still exposed to the documentation viewer but they will
--   not know which operations and parameters are available.
data PathItem
PathItem :: Maybe Text -> Maybe Text -> Maybe Operation -> Maybe Operation -> Maybe Operation -> Maybe Operation -> Maybe Operation -> Maybe Operation -> Maybe Operation -> Maybe Operation -> [Server] -> [Referenced Param] -> PathItem

-- | An optional, string summary, intended to apply to all operations in
--   this path.
[_pathItemSummary] :: PathItem -> Maybe Text

-- | An optional, string description, intended to apply to all operations
--   in this path. <a>CommonMark syntax</a> MAY be used for rich text
--   representation.
[_pathItemDescription] :: PathItem -> Maybe Text

-- | A definition of a GET operation on this path.
[_pathItemGet] :: PathItem -> Maybe Operation

-- | A definition of a PUT operation on this path.
[_pathItemPut] :: PathItem -> Maybe Operation

-- | A definition of a POST operation on this path.
[_pathItemPost] :: PathItem -> Maybe Operation

-- | A definition of a DELETE operation on this path.
[_pathItemDelete] :: PathItem -> Maybe Operation

-- | A definition of a OPTIONS operation on this path.
[_pathItemOptions] :: PathItem -> Maybe Operation

-- | A definition of a HEAD operation on this path.
[_pathItemHead] :: PathItem -> Maybe Operation

-- | A definition of a PATCH operation on this path.
[_pathItemPatch] :: PathItem -> Maybe Operation

-- | A definition of a TRACE operation on this path.
[_pathItemTrace] :: PathItem -> Maybe Operation

-- | An alternative server array to service all operations in this path.
[_pathItemServers] :: PathItem -> [Server]

-- | A list of parameters that are applicable for all the operations
--   described under this path. These parameters can be overridden at the
--   operation level, but cannot be removed there. The list MUST NOT
--   include duplicated parameters. A unique parameter is defined by a
--   combination of a name and location.
[_pathItemParameters] :: PathItem -> [Referenced Param]

-- | Describes a single API operation on a path.
data Operation
Operation :: InsOrdHashSet TagName -> Maybe Text -> Maybe Text -> Maybe ExternalDocs -> Maybe Text -> [Referenced Param] -> Maybe (Referenced RequestBody) -> Responses -> InsOrdHashMap Text (Referenced Callback) -> Maybe Bool -> [SecurityRequirement] -> [Server] -> Operation

-- | A list of tags for API documentation control. Tags can be used for
--   logical grouping of operations by resources or any other qualifier.
[_operationTags] :: Operation -> InsOrdHashSet TagName

-- | A short summary of what the operation does. For maximum readability in
--   the swagger-ui, this field SHOULD be less than 120 characters.
[_operationSummary] :: Operation -> Maybe Text

-- | A verbose explanation of the operation behavior. <a>CommonMark
--   syntax</a> can be used for rich text representation.
[_operationDescription] :: Operation -> Maybe Text

-- | Additional external documentation for this operation.
[_operationExternalDocs] :: Operation -> Maybe ExternalDocs

-- | Unique string used to identify the operation. The id MUST be unique
--   among all operations described in the API. The operationId value is
--   **case-sensitive**. Tools and libraries MAY use the operationId to
--   uniquely identify an operation, therefore, it is RECOMMENDED to follow
--   common programming naming conventions.
[_operationOperationId] :: Operation -> Maybe Text

-- | A list of parameters that are applicable for this operation. If a
--   parameter is already defined at the <tt><a>PathItem</a></tt>, the new
--   definition will override it, but can never remove it. The list MUST
--   NOT include duplicated parameters. A unique parameter is defined by a
--   combination of a name and location.
[_operationParameters] :: Operation -> [Referenced Param]

-- | The request body applicable for this operation. The requestBody is
--   only supported in HTTP methods where the HTTP 1.1 specification
--   <a>RFC7231</a> has explicitly defined semantics for request bodies. In
--   other cases where the HTTP spec is vague, requestBody SHALL be ignored
--   by consumers.
[_operationRequestBody] :: Operation -> Maybe (Referenced RequestBody)

-- | The list of possible responses as they are returned from executing
--   this operation.
[_operationResponses] :: Operation -> Responses

-- | A map of possible out-of band callbacks related to the parent
--   operation. The key is a unique identifier for the <a>Callback</a>
--   Object. Each value in the map is a <a>Callback</a> Object that
--   describes a request that may be initiated by the API provider and the
--   expected responses.
[_operationCallbacks] :: Operation -> InsOrdHashMap Text (Referenced Callback)

-- | Declares this operation to be deprecated. Usage of the declared
--   operation should be refrained. Default value is <tt>False</tt>.
[_operationDeprecated] :: Operation -> Maybe Bool

-- | A declaration of which security schemes are applied for this
--   operation. The list of values describes alternative security schemes
--   that can be used (that is, there is a logical OR between the security
--   requirements). This definition overrides any declared top-level
--   security. To remove a top-level security declaration, <tt>Just []</tt>
--   can be used.
[_operationSecurity] :: Operation -> [SecurityRequirement]

-- | An alternative server array to service this operation. If an
--   alternative server object is specified at the <a>PathItem</a> Object
--   or Root level, it will be overridden by this value.
[_operationServers] :: Operation -> [Server]
mediaTypeConstr :: Constr
mediaTypeData :: DataType

-- | Describes a single request body.
data RequestBody
RequestBody :: Maybe Text -> InsOrdHashMap MediaType MediaTypeObject -> Maybe Bool -> RequestBody

-- | A brief description of the request body. This could contain examples
--   of use. <a>CommonMark syntax</a> MAY be used for rich text
--   representation.
[_requestBodyDescription] :: RequestBody -> Maybe Text

-- | The content of the request body. The key is a media type or media type
--   range and the value describes it. For requests that match multiple
--   keys, only the most specific key is applicable. e.g.
--   <tt>text/plain</tt> overrides <tt>text/*</tt>
[_requestBodyContent] :: RequestBody -> InsOrdHashMap MediaType MediaTypeObject

-- | Determines if the request body is required in the request. Defaults to
--   <a>False</a>.
[_requestBodyRequired] :: RequestBody -> Maybe Bool

-- | Each Media Type Object provides schema and examples for the media type
--   identified by its key.
data MediaTypeObject
MediaTypeObject :: Maybe (Referenced Schema) -> Maybe Value -> InsOrdHashMap Text (Referenced Example) -> InsOrdHashMap Text Encoding -> MediaTypeObject
[_mediaTypeObjectSchema] :: MediaTypeObject -> Maybe (Referenced Schema)

-- | Example of the media type. The example object SHOULD be in the correct
--   format as specified by the media type.
[_mediaTypeObjectExample] :: MediaTypeObject -> Maybe Value

-- | Examples of the media type. Each example object SHOULD match the media
--   type and specified schema if present.
[_mediaTypeObjectExamples] :: MediaTypeObject -> InsOrdHashMap Text (Referenced Example)

-- | A map between a property name and its encoding information. The key,
--   being the property name, MUST exist in the schema as a property. The
--   encoding object SHALL only apply to <a>RequestBody</a> objects when
--   the media type is <tt>multipart</tt> or
--   <tt>application/x-www-form-urlencoded</tt>.
[_mediaTypeObjectEncoding] :: MediaTypeObject -> InsOrdHashMap Text Encoding

-- | In order to support common ways of serializing simple parameters, a
--   set of style values are defined.
data Style

-- | Path-style parameters defined by <a>RFC6570</a>.
StyleMatrix :: Style

-- | Label style parameters defined by <a>RFC6570</a>.
StyleLabel :: Style

-- | Form style parameters defined by <a>RFC6570</a>. This option replaces
--   <tt>collectionFormat</tt> with a <tt>csv</tt> (when <tt>explode</tt>
--   is false) or <tt>multi</tt> (when explode is true) value from OpenAPI
--   2.0.
StyleForm :: Style

-- | Simple style parameters defined by <a>RFC6570</a>. This option
--   replaces <tt>collectionFormat</tt> with a <tt>csv</tt> value from
--   OpenAPI 2.0.
StyleSimple :: Style

-- | Space separated array values. This option replaces
--   <tt>collectionFormat</tt> equal to <tt>ssv</tt> from OpenAPI 2.0.
StyleSpaceDelimited :: Style

-- | Pipe separated array values. This option replaces
--   <tt>collectionFormat</tt> equal to <tt>pipes</tt> from OpenAPI 2.0.
StylePipeDelimited :: Style

-- | Provides a simple way of rendering nested objects using form
--   parameters.
StyleDeepObject :: Style
data Encoding
Encoding :: Maybe MediaType -> InsOrdHashMap Text (Referenced Header) -> Maybe Style -> Maybe Bool -> Maybe Bool -> Encoding

-- | The Content-Type for encoding a specific property. Default value
--   depends on the property type: for <tt>string</tt> with format being
--   <tt>binary</tt> – <tt>application/octet-stream</tt>; for other
--   primitive types – <tt>text/plain</tt>; for object -
--   <tt>application/json</tt>; for array – the default is defined based on
--   the inner type. The value can be a specific media type (e.g.
--   <tt>application/json</tt>), a wildcard media type (e.g.
--   <tt>image/*</tt>), or a comma-separated list of the two types.
[_encodingContentType] :: Encoding -> Maybe MediaType

-- | A map allowing additional information to be provided as headers, for
--   example <tt>Content-Disposition</tt>. <tt>Content-Type</tt> is
--   described separately and SHALL be ignored in this section. This
--   property SHALL be ignored if the request body media type is not a
--   <tt>multipart</tt>.
[_encodingHeaders] :: Encoding -> InsOrdHashMap Text (Referenced Header)

-- | Describes how a specific property value will be serialized depending
--   on its type. See <a>Param</a> Object for details on the style
--   property. The behavior follows the same values as query parameters,
--   including default values. This property SHALL be ignored if the
--   request body media type is not
--   <tt>application/x-www-form-urlencoded</tt>.
[_encodingStyle] :: Encoding -> Maybe Style

-- | When this is true, property values of type <tt>array</tt> or
--   <tt>object</tt> generate separate parameters for each value of the
--   array, or key-value-pair of the map. For other types of properties
--   this property has no effect. When style is form, the default value is
--   <tt>true</tt>. For all other styles, the default value is
--   <tt>false</tt>. This property SHALL be ignored if the request body
--   media type is not <tt>application/x-www-form-urlencoded</tt>.
[_encodingExplode] :: Encoding -> Maybe Bool

-- | Determines whether the parameter value SHOULD allow reserved
--   characters, as defined by <a>RFC3986</a>
--   <tt>:/?#[]</tt>!$&amp;'()*+,;=<tt> to be included without
--   percent-encoding. The default value is </tt>false<tt>. This property
--   SHALL be ignored if the request body media type is not
--   </tt>application/x-www-form-urlencoded@.
[_encodingAllowReserved] :: Encoding -> Maybe Bool
newtype MimeList
MimeList :: [MediaType] -> MimeList
[getMimeList] :: MimeList -> [MediaType]
mimeListConstr :: Constr
mimeListDataType :: DataType

-- | Describes a single operation parameter. A unique parameter is defined
--   by a combination of a name and location.
data Param
Param :: Text -> Maybe Text -> Maybe Bool -> Maybe Bool -> ParamLocation -> Maybe Bool -> Maybe Bool -> Maybe (Referenced Schema) -> Maybe Style -> Maybe Bool -> Maybe Value -> InsOrdHashMap Text (Referenced Example) -> Param

-- | The name of the parameter. Parameter names are case sensitive.
[_paramName] :: Param -> Text

-- | A brief description of the parameter. This could contain examples of
--   use. CommonMark syntax MAY be used for rich text representation.
[_paramDescription] :: Param -> Maybe Text

-- | Determines whether this parameter is mandatory. If the parameter is in
--   "path", this property is required and its value MUST be true.
--   Otherwise, the property MAY be included and its default value is
--   <tt>False</tt>.
[_paramRequired] :: Param -> Maybe Bool

-- | Specifies that a parameter is deprecated and SHOULD be transitioned
--   out of usage. Default value is <tt>false</tt>.
[_paramDeprecated] :: Param -> Maybe Bool

-- | The location of the parameter.
[_paramIn] :: Param -> ParamLocation

-- | Sets the ability to pass empty-valued parameters. This is valid only
--   for <a>ParamQuery</a> parameters and allows sending a parameter with
--   an empty value. Default value is <tt>false</tt>.
[_paramAllowEmptyValue] :: Param -> Maybe Bool

-- | Determines whether the parameter value SHOULD allow reserved
--   characters, as defined by <a>RFC3986</a>
--   <tt>:/?#[]</tt>!$&amp;'()*+,;=@ to be included without
--   percent-encoding. This property only applies to parameters with an
--   <a>_paramIn</a> value of <a>ParamQuery</a>. The default value is
--   <a>False</a>.
[_paramAllowReserved] :: Param -> Maybe Bool

-- | Parameter schema.
[_paramSchema] :: Param -> Maybe (Referenced Schema)

-- | Describes how the parameter value will be serialized depending on the
--   type of the parameter value. Default values (based on value of
--   <a>_paramIn</a>): for <a>ParamQuery</a> - <a>StyleForm</a>; for
--   <a>ParamPath</a> - <a>StyleSimple</a>; for <a>ParamHeader</a> -
--   <a>StyleSimple</a>; for <a>ParamCookie</a> - <a>StyleForm</a>.
[_paramStyle] :: Param -> Maybe Style

-- | When this is true, parameter values of type <tt>array</tt> or
--   <tt>object</tt> generate separate parameters for each value of the
--   array or key-value pair of the map. For other types of parameters this
--   property has no effect. When style is <tt>form</tt>, the default value
--   is true. For all other styles, the default value is false.
[_paramExplode] :: Param -> Maybe Bool

-- | Example of the parameter's potential value. The example SHOULD match
--   the specified schema and encoding properties if present. The
--   <a>_paramExample</a> field is mutually exclusive of the
--   <a>_paramExamples</a> field. Furthermore, if referencing a schema that
--   contains an example, the example value SHALL override the example
--   provided by the schema. To represent examples of media types that
--   cannot naturally be represented in JSON or YAML, a string value can
--   contain the example with escaping where necessary.
[_paramExample] :: Param -> Maybe Value

-- | Examples of the parameter's potential value. Each example SHOULD
--   contain a value in the correct format as specified in the parameter
--   encoding. The <a>_paramExamples</a> field is mutually exclusive of the
--   <a>_paramExample</a> field. Furthermore, if referencing a schema that
--   contains an example, the examples value SHALL override the example
--   provided by the schema.
[_paramExamples] :: Param -> InsOrdHashMap Text (Referenced Example)
data Example
Example :: Maybe Text -> Maybe Text -> Maybe Value -> Maybe URL -> Example

-- | Short description for the example.
[_exampleSummary] :: Example -> Maybe Text

-- | Long description for the example. CommonMark syntax MAY be used for
--   rich text representation.
[_exampleDescription] :: Example -> Maybe Text

-- | Embedded literal example. The <a>_exampleValue</a> field and
--   <a>_exampleExternalValue</a> field are mutually exclusive.
--   
--   To represent examples of media types that cannot naturally represented
--   in JSON or YAML, use a string value to contain the example, escaping
--   where necessary.
[_exampleValue] :: Example -> Maybe Value

-- | A URL that points to the literal example. This provides the capability
--   to reference examples that cannot easily be included in JSON or YAML
--   documents. The <a>_exampleValue</a> field and
--   <a>_exampleExternalValue</a> field are mutually exclusive.
[_exampleExternalValue] :: Example -> Maybe URL
data ExpressionOrValue
Expression :: Text -> ExpressionOrValue
Value :: Value -> ExpressionOrValue

-- | The Link object represents a possible design-time link for a response.
--   The presence of a link does not guarantee the caller's ability to
--   successfully invoke it, rather it provides a known relationship and
--   traversal mechanism between responses and other operations.
data Link
Link :: Maybe Text -> Maybe Text -> InsOrdHashMap Text ExpressionOrValue -> Maybe ExpressionOrValue -> Maybe Text -> Maybe Server -> Link

-- | A relative or absolute URI reference to an OAS operation. This field
--   is mutually exclusive of the <a>_linkOperationId</a> field, and MUST
--   point to an <a>Operation</a> Object. Relative <a>_linkOperationRef</a>
--   values MAY be used to locate an existing <a>Operation</a> Object in
--   the OpenAPI definition.
[_linkOperationRef] :: Link -> Maybe Text

-- | The name of an <i>existing</i>, resolvable OAS operation, as defined
--   with a unique <a>_operationOperationId</a>. This field is mutually
--   exclusive of the <a>_linkOperationRef</a> field.
[_linkOperationId] :: Link -> Maybe Text

-- | A map representing parameters to pass to an operation as specified
--   with <a>_linkOperationId</a> or identified via
--   <a>_linkOperationRef</a>. The key is the parameter name to be used,
--   whereas the value can be a constant or an expression to be evaluated
--   and passed to the linked operation. The parameter name can be
--   qualified using the parameter location <tt>[{in}.]{name}</tt> for
--   operations that use the same parameter name in different locations
--   (e.g. path.id).
[_linkParameters] :: Link -> InsOrdHashMap Text ExpressionOrValue

-- | A literal value or <tt>{expression}</tt> to use as a request body when
--   calling the target operation.
[_linkRequestBody] :: Link -> Maybe ExpressionOrValue

-- | A description of the link.
[_linkDescription] :: Link -> Maybe Text

-- | A server object to be used by the target operation.
[_linkServer] :: Link -> Maybe Server

-- | Items for <tt><a>OpenApiArray</a></tt> schemas.
--   
--   <b>Warning</b>: OpenAPI 3.0 does not support tuple arrays. However,
--   OpenAPI 3.1 will, as it will incorporate Json Schema mostly verbatim.
--   
--   <tt><a>OpenApiItemsObject</a></tt> should be used to specify
--   homogenous array <tt><a>Schema</a></tt>s.
--   
--   <tt><a>OpenApiItemsArray</a></tt> should be used to specify tuple
--   <tt><a>Schema</a></tt>s.
data OpenApiItems
[OpenApiItemsObject] :: Referenced Schema -> OpenApiItems
[OpenApiItemsArray] :: [Referenced Schema] -> OpenApiItems
data OpenApiType
[OpenApiString] :: OpenApiType
[OpenApiNumber] :: OpenApiType
[OpenApiInteger] :: OpenApiType
[OpenApiBoolean] :: OpenApiType
[OpenApiArray] :: OpenApiType
[OpenApiNull] :: OpenApiType
[OpenApiObject] :: OpenApiType
data ParamLocation

-- | Parameters that are appended to the URL. For example, in
--   <tt>/items?id=###</tt>, the query parameter is <tt>id</tt>.
ParamQuery :: ParamLocation

-- | Custom headers that are expected as part of the request.
ParamHeader :: ParamLocation

-- | Used together with Path Templating, where the parameter value is
--   actually part of the operation's URL. This does not include the host
--   or base path of the API. For example, in
--   <tt><i>items</i>{itemId}</tt>, the path parameter is <tt>itemId</tt>.
ParamPath :: ParamLocation

-- | Used to pass a specific cookie value to the API.
ParamCookie :: ParamLocation
type Format = Text
type ParamName = Text
data Schema
Schema :: Maybe Text -> Maybe Text -> [ParamName] -> Maybe Bool -> Maybe [Referenced Schema] -> Maybe [Referenced Schema] -> Maybe (Referenced Schema) -> Maybe [Referenced Schema] -> InsOrdHashMap Text (Referenced Schema) -> Maybe AdditionalProperties -> Maybe Discriminator -> Maybe Bool -> Maybe Bool -> Maybe Xml -> Maybe ExternalDocs -> Maybe Value -> Maybe Bool -> Maybe Integer -> Maybe Integer -> Maybe Value -> Maybe OpenApiType -> Maybe Format -> Maybe OpenApiItems -> Maybe Scientific -> Maybe Bool -> Maybe Scientific -> Maybe Bool -> Maybe Integer -> Maybe Integer -> Maybe Pattern -> Maybe Integer -> Maybe Integer -> Maybe Bool -> Maybe [Value] -> Maybe Scientific -> Schema
[_schemaTitle] :: Schema -> Maybe Text
[_schemaDescription] :: Schema -> Maybe Text
[_schemaRequired] :: Schema -> [ParamName]
[_schemaNullable] :: Schema -> Maybe Bool
[_schemaAllOf] :: Schema -> Maybe [Referenced Schema]
[_schemaOneOf] :: Schema -> Maybe [Referenced Schema]
[_schemaNot] :: Schema -> Maybe (Referenced Schema)
[_schemaAnyOf] :: Schema -> Maybe [Referenced Schema]
[_schemaProperties] :: Schema -> InsOrdHashMap Text (Referenced Schema)
[_schemaAdditionalProperties] :: Schema -> Maybe AdditionalProperties
[_schemaDiscriminator] :: Schema -> Maybe Discriminator
[_schemaReadOnly] :: Schema -> Maybe Bool
[_schemaWriteOnly] :: Schema -> Maybe Bool
[_schemaXml] :: Schema -> Maybe Xml
[_schemaExternalDocs] :: Schema -> Maybe ExternalDocs
[_schemaExample] :: Schema -> Maybe Value
[_schemaDeprecated] :: Schema -> Maybe Bool
[_schemaMaxProperties] :: Schema -> Maybe Integer
[_schemaMinProperties] :: Schema -> Maybe Integer

-- | Declares the value of the parameter that the server will use if none
--   is provided, for example a <tt>"count"</tt> to control the number of
--   results per page might default to <tt>100</tt> if not supplied by the
--   client in the request. (Note: "default" has no meaning for required
--   parameters.) Unlike JSON Schema this value MUST conform to the defined
--   type for this parameter.
[_schemaDefault] :: Schema -> Maybe Value
[_schemaType] :: Schema -> Maybe OpenApiType
[_schemaFormat] :: Schema -> Maybe Format
[_schemaItems] :: Schema -> Maybe OpenApiItems
[_schemaMaximum] :: Schema -> Maybe Scientific
[_schemaExclusiveMaximum] :: Schema -> Maybe Bool
[_schemaMinimum] :: Schema -> Maybe Scientific
[_schemaExclusiveMinimum] :: Schema -> Maybe Bool
[_schemaMaxLength] :: Schema -> Maybe Integer
[_schemaMinLength] :: Schema -> Maybe Integer
[_schemaPattern] :: Schema -> Maybe Pattern
[_schemaMaxItems] :: Schema -> Maybe Integer
[_schemaMinItems] :: Schema -> Maybe Integer
[_schemaUniqueItems] :: Schema -> Maybe Bool
[_schemaEnum] :: Schema -> Maybe [Value]
[_schemaMultipleOf] :: Schema -> Maybe Scientific

-- | Regex pattern for <tt>string</tt> type.
type Pattern = Text
data Discriminator
Discriminator :: Text -> InsOrdHashMap Text Text -> Discriminator

-- | The name of the property in the payload that will hold the
--   discriminator value.
[_discriminatorPropertyName] :: Discriminator -> Text

-- | An object to hold mappings between payload values and schema names or
--   references.
[_discriminatorMapping] :: Discriminator -> InsOrdHashMap Text Text

-- | A <tt><a>Schema</a></tt> with an optional name. This name can be used
--   in references.
data NamedSchema
NamedSchema :: Maybe Text -> Schema -> NamedSchema
[_namedSchemaName] :: NamedSchema -> Maybe Text
[_namedSchemaSchema] :: NamedSchema -> Schema
data Xml
Xml :: Maybe Text -> Maybe Text -> Maybe Text -> Maybe Bool -> Maybe Bool -> Xml

-- | Replaces the name of the element/attribute used for the described
--   schema property. When defined within the <tt><a>OpenApiItems</a></tt>
--   (items), it will affect the name of the individual XML elements within
--   the list. When defined alongside type being array (outside the items),
--   it will affect the wrapping element and only if wrapped is true. If
--   wrapped is false, it will be ignored.
[_xmlName] :: Xml -> Maybe Text

-- | The URL of the namespace definition. Value SHOULD be in the form of a
--   URL.
[_xmlNamespace] :: Xml -> Maybe Text

-- | The prefix to be used for the name.
[_xmlPrefix] :: Xml -> Maybe Text

-- | Declares whether the property definition translates to an attribute
--   instead of an element. Default value is <tt>False</tt>.
[_xmlAttribute] :: Xml -> Maybe Bool

-- | MAY be used only for an array definition. Signifies whether the array
--   is wrapped (for example,
--   <tt>&lt;books&gt;&lt;book<i>&gt;&lt;book</i>&gt;&lt;/books&gt;</tt>)
--   or unwrapped (<tt>&lt;book<i>&gt;&lt;book</i>&gt;</tt>). Default value
--   is <tt>False</tt>. The definition takes effect only when defined
--   alongside type being array (outside the items).
[_xmlWrapped] :: Xml -> Maybe Bool

-- | A container for the expected responses of an operation. The container
--   maps a HTTP response code to the expected response. It is not expected
--   from the documentation to necessarily cover all possible HTTP response
--   codes, since they may not be known in advance. However, it is expected
--   from the documentation to cover a successful operation response and
--   any known errors.
data Responses
Responses :: Maybe (Referenced Response) -> InsOrdHashMap HttpStatusCode (Referenced Response) -> Responses

-- | The documentation of responses other than the ones declared for
--   specific HTTP response codes. It can be used to cover undeclared
--   responses.
[_responsesDefault] :: Responses -> Maybe (Referenced Response)

-- | Any HTTP status code can be used as the property name (one property
--   per HTTP status code). Describes the expected response for those HTTP
--   status codes.
[_responsesResponses] :: Responses -> InsOrdHashMap HttpStatusCode (Referenced Response)
type HttpStatusCode = Int

-- | Describes a single response from an API Operation.
data Response
Response :: Text -> InsOrdHashMap MediaType MediaTypeObject -> InsOrdHashMap HeaderName (Referenced Header) -> InsOrdHashMap Text (Referenced Link) -> Response

-- | A short description of the response. <a>CommonMark syntax</a> can be
--   used for rich text representation.
[_responseDescription] :: Response -> Text

-- | A map containing descriptions of potential response payloads. The key
--   is a media type or media type range and the value describes it. For
--   responses that match multiple keys, only the most specific key is
--   applicable. e.g. <tt>text/plain</tt> overrides <tt>text/*</tt>.
[_responseContent] :: Response -> InsOrdHashMap MediaType MediaTypeObject

-- | Maps a header name to its definition.
[_responseHeaders] :: Response -> InsOrdHashMap HeaderName (Referenced Header)

-- | A map of operations links that can be followed from the response. The
--   key of the map is a short name for the link, following the naming
--   constraints of the names for <tt>Component</tt> Objects.
[_responseLinks] :: Response -> InsOrdHashMap Text (Referenced Link)

-- | A map of possible out-of band callbacks related to the parent
--   operation. Each value in the map is a <a>PathItem</a> Object that
--   describes a set of requests that may be initiated by the API provider
--   and the expected responses. The key value used to identify the path
--   item object is an expression, evaluated at runtime, that identifies a
--   URL to use for the callback operation.
newtype Callback
Callback :: InsOrdHashMap Text PathItem -> Callback
type HeaderName = Text

-- | Header fields have the same meaning as for <a>Param</a>.
--   
--   Style is always treated as <a>StyleSimple</a>, as it is the only value
--   allowed for headers.
data Header
Header :: Maybe HeaderName -> Maybe Bool -> Maybe Bool -> Maybe Bool -> Maybe Bool -> Maybe Value -> InsOrdHashMap Text (Referenced Example) -> Maybe (Referenced Schema) -> Header

-- | A short description of the header.
[_headerDescription] :: Header -> Maybe HeaderName
[_headerRequired] :: Header -> Maybe Bool
[_headerDeprecated] :: Header -> Maybe Bool
[_headerAllowEmptyValue] :: Header -> Maybe Bool
[_headerExplode] :: Header -> Maybe Bool
[_headerExample] :: Header -> Maybe Value
[_headerExamples] :: Header -> InsOrdHashMap Text (Referenced Example)
[_headerSchema] :: Header -> Maybe (Referenced Schema)

-- | The location of the API key.
data ApiKeyLocation
ApiKeyQuery :: ApiKeyLocation
ApiKeyHeader :: ApiKeyLocation
ApiKeyCookie :: ApiKeyLocation
data ApiKeyParams
ApiKeyParams :: Text -> ApiKeyLocation -> ApiKeyParams

-- | The name of the header or query parameter to be used.
[_apiKeyName] :: ApiKeyParams -> Text

-- | The location of the API key.
[_apiKeyIn] :: ApiKeyParams -> ApiKeyLocation

-- | The authorization URL to be used for OAuth2 flow. This SHOULD be in
--   the form of a URL.
type AuthorizationURL = Text

-- | The token URL to be used for OAuth2 flow. This SHOULD be in the form
--   of a URL.
type TokenURL = Text
newtype OAuth2ImplicitFlow
OAuth2ImplicitFlow :: AuthorizationURL -> OAuth2ImplicitFlow
[_oAuth2ImplicitFlowAuthorizationUrl] :: OAuth2ImplicitFlow -> AuthorizationURL
newtype OAuth2PasswordFlow
OAuth2PasswordFlow :: TokenURL -> OAuth2PasswordFlow
[_oAuth2PasswordFlowTokenUrl] :: OAuth2PasswordFlow -> TokenURL
newtype OAuth2ClientCredentialsFlow
OAuth2ClientCredentialsFlow :: TokenURL -> OAuth2ClientCredentialsFlow
[_oAuth2ClientCredentialsFlowTokenUrl] :: OAuth2ClientCredentialsFlow -> TokenURL
data OAuth2AuthorizationCodeFlow
OAuth2AuthorizationCodeFlow :: AuthorizationURL -> TokenURL -> OAuth2AuthorizationCodeFlow
[_oAuth2AuthorizationCodeFlowAuthorizationUrl] :: OAuth2AuthorizationCodeFlow -> AuthorizationURL
[_oAuth2AuthorizationCodeFlowTokenUrl] :: OAuth2AuthorizationCodeFlow -> TokenURL
data OAuth2Flow p
OAuth2Flow :: p -> Maybe URL -> InsOrdHashMap Text Text -> OAuth2Flow p
[_oAuth2Params] :: OAuth2Flow p -> p

-- | The URL to be used for obtaining refresh tokens.
[_oAath2RefreshUrl] :: OAuth2Flow p -> Maybe URL

-- | The available scopes for the OAuth2 security scheme. A map between the
--   scope name and a short description for it. The map MAY be empty.
[_oAuth2Scopes] :: OAuth2Flow p -> InsOrdHashMap Text Text
data OAuth2Flows
OAuth2Flows :: Maybe (OAuth2Flow OAuth2ImplicitFlow) -> Maybe (OAuth2Flow OAuth2PasswordFlow) -> Maybe (OAuth2Flow OAuth2ClientCredentialsFlow) -> Maybe (OAuth2Flow OAuth2AuthorizationCodeFlow) -> OAuth2Flows

-- | Configuration for the OAuth Implicit flow
[_oAuth2FlowsImplicit] :: OAuth2Flows -> Maybe (OAuth2Flow OAuth2ImplicitFlow)

-- | Configuration for the OAuth Resource Owner Password flow
[_oAuth2FlowsPassword] :: OAuth2Flows -> Maybe (OAuth2Flow OAuth2PasswordFlow)

-- | Configuration for the OAuth Client Credentials flow
[_oAuth2FlowsClientCredentials] :: OAuth2Flows -> Maybe (OAuth2Flow OAuth2ClientCredentialsFlow)

-- | Configuration for the OAuth Authorization Code flow
[_oAuth2FlowsAuthorizationCode] :: OAuth2Flows -> Maybe (OAuth2Flow OAuth2AuthorizationCodeFlow)
type BearerFormat = Text
data HttpSchemeType
HttpSchemeBearer :: Maybe BearerFormat -> HttpSchemeType
HttpSchemeBasic :: HttpSchemeType
HttpSchemeCustom :: Text -> HttpSchemeType

-- | <pre>
--   &gt;&gt;&gt; BSL.putStrLn $ encodePretty (SecuritySchemeHttp (HttpSchemeBearer Nothing))
--   {
--       "scheme": "bearer",
--       "type": "http"
--   }
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; BSL.putStrLn $ encodePretty (SecuritySchemeHttp (HttpSchemeBearer (Just "jwt")))
--   {
--       "bearerFormat": "jwt",
--       "scheme": "bearer",
--       "type": "http"
--   }
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; BSL.putStrLn $ encodePretty (SecuritySchemeHttp HttpSchemeBasic)
--   {
--       "scheme": "basic",
--       "type": "http"
--   }
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; BSL.putStrLn $ encodePretty (SecuritySchemeHttp (HttpSchemeCustom "CANARY"))
--   {
--       "scheme": "CANARY",
--       "type": "http"
--   }
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; BSL.putStrLn $ encodePretty (SecuritySchemeApiKey (ApiKeyParams "id" ApiKeyCookie))
--   {
--       "in": "cookie",
--       "name": "id",
--       "type": "apiKey"
--   }
--   </pre>
data SecuritySchemeType
SecuritySchemeHttp :: HttpSchemeType -> SecuritySchemeType
SecuritySchemeApiKey :: ApiKeyParams -> SecuritySchemeType
SecuritySchemeOAuth2 :: OAuth2Flows -> SecuritySchemeType
SecuritySchemeOpenIdConnect :: URL -> SecuritySchemeType
data SecurityScheme
SecurityScheme :: SecuritySchemeType -> Maybe Text -> SecurityScheme

-- | The type of the security scheme.
[_securitySchemeType] :: SecurityScheme -> SecuritySchemeType

-- | A short description for security scheme.
[_securitySchemeDescription] :: SecurityScheme -> Maybe Text
newtype SecurityDefinitions
SecurityDefinitions :: Definitions SecurityScheme -> SecurityDefinitions

-- | Lists the required security schemes to execute this operation. The
--   object can have multiple security schemes declared in it which are all
--   required (that is, there is a logical AND between the schemes).
newtype SecurityRequirement
SecurityRequirement :: InsOrdHashMap Text [Text] -> SecurityRequirement
[getSecurityRequirement] :: SecurityRequirement -> InsOrdHashMap Text [Text]

-- | Tag name.
type TagName = Text

-- | Allows adding meta data to a single tag that is used by
--   <tt>Operation</tt>. It is not mandatory to have a <tt>Tag</tt> per tag
--   used there.
data Tag
Tag :: TagName -> Maybe Text -> Maybe ExternalDocs -> Tag

-- | The name of the tag.
[_tagName] :: Tag -> TagName

-- | A short description for the tag. <a>CommonMark syntax</a> MAY be used
--   for rich text representation.
[_tagDescription] :: Tag -> Maybe Text

-- | Additional external documentation for this tag.
[_tagExternalDocs] :: Tag -> Maybe ExternalDocs

-- | Allows referencing an external resource for extended documentation.
data ExternalDocs
ExternalDocs :: Maybe Text -> URL -> ExternalDocs

-- | A short description of the target documentation. <a>CommonMark
--   syntax</a> MAY be used for rich text representation.
[_externalDocsDescription] :: ExternalDocs -> Maybe Text

-- | The URL for the target documentation.
[_externalDocsUrl] :: ExternalDocs -> URL

-- | A simple object to allow referencing other definitions in the
--   specification. It can be used to reference parameters and responses
--   that are defined at the top level for reuse.
newtype Reference
Reference :: Text -> Reference
[getReference] :: Reference -> Text
data Referenced a
Ref :: Reference -> Referenced a
Inline :: a -> Referenced a
newtype URL
URL :: Text -> URL
[getUrl] :: URL -> Text
data AdditionalProperties
AdditionalPropertiesAllowed :: Bool -> AdditionalProperties
AdditionalPropertiesSchema :: Referenced Schema -> AdditionalProperties
newtype OpenApiSpecVersion
OpenApiSpecVersion :: Version -> OpenApiSpecVersion
[getVersion] :: OpenApiSpecVersion -> Version
referencedToJSON :: ToJSON a => Text -> Referenced a -> Value
referencedParseJSON :: FromJSON a => Text -> Value -> Parser (Referenced a)
instance Data.OpenApi.Internal.Utils.SwaggerMonoid Data.OpenApi.Internal.URL
instance Generics.SOP.Universe.Generic Data.OpenApi.Internal.OpenApiSpecVersion
instance Generics.SOP.Universe.HasDatatypeInfo Data.OpenApi.Internal.OpenApiSpecVersion
instance GHC.Base.Semigroup Data.OpenApi.Internal.OpenApiSpecVersion
instance GHC.Base.Monoid Data.OpenApi.Internal.OpenApiSpecVersion
instance GHC.Base.Semigroup Data.OpenApi.Internal.OpenApi
instance GHC.Base.Monoid Data.OpenApi.Internal.OpenApi
instance GHC.Base.Semigroup Data.OpenApi.Internal.Info
instance GHC.Base.Monoid Data.OpenApi.Internal.Info
instance GHC.Base.Semigroup Data.OpenApi.Internal.Contact
instance GHC.Base.Monoid Data.OpenApi.Internal.Contact
instance GHC.Base.Semigroup Data.OpenApi.Internal.Components
instance GHC.Base.Monoid Data.OpenApi.Internal.Components
instance GHC.Base.Semigroup Data.OpenApi.Internal.PathItem
instance GHC.Base.Monoid Data.OpenApi.Internal.PathItem
instance GHC.Base.Semigroup Data.OpenApi.Internal.Schema
instance GHC.Base.Monoid Data.OpenApi.Internal.Schema
instance GHC.Base.Semigroup Data.OpenApi.Internal.Param
instance GHC.Base.Monoid Data.OpenApi.Internal.Param
instance GHC.Base.Semigroup Data.OpenApi.Internal.Header
instance GHC.Base.Monoid Data.OpenApi.Internal.Header
instance GHC.Base.Semigroup Data.OpenApi.Internal.Responses
instance GHC.Base.Monoid Data.OpenApi.Internal.Responses
instance GHC.Base.Semigroup Data.OpenApi.Internal.Response
instance GHC.Base.Monoid Data.OpenApi.Internal.Response
instance GHC.Base.Semigroup Data.OpenApi.Internal.MediaTypeObject
instance GHC.Base.Monoid Data.OpenApi.Internal.MediaTypeObject
instance GHC.Base.Semigroup Data.OpenApi.Internal.Encoding
instance GHC.Base.Monoid Data.OpenApi.Internal.Encoding
instance GHC.Base.Semigroup Data.OpenApi.Internal.ExternalDocs
instance GHC.Base.Monoid Data.OpenApi.Internal.ExternalDocs
instance GHC.Base.Semigroup Data.OpenApi.Internal.Operation
instance GHC.Base.Monoid Data.OpenApi.Internal.Operation
instance GHC.Base.Semigroup (Data.OpenApi.Internal.OAuth2Flow p)
instance GHC.Base.Semigroup Data.OpenApi.Internal.OAuth2Flows
instance GHC.Base.Monoid Data.OpenApi.Internal.OAuth2Flows
instance GHC.Base.Semigroup Data.OpenApi.Internal.SecurityScheme
instance GHC.Base.Semigroup Data.OpenApi.Internal.SecurityDefinitions
instance GHC.Base.Monoid Data.OpenApi.Internal.SecurityDefinitions
instance GHC.Base.Semigroup Data.OpenApi.Internal.RequestBody
instance GHC.Base.Monoid Data.OpenApi.Internal.RequestBody
instance Data.OpenApi.Internal.Utils.SwaggerMonoid Data.OpenApi.Internal.Info
instance Data.OpenApi.Internal.Utils.SwaggerMonoid Data.OpenApi.Internal.Components
instance Data.OpenApi.Internal.Utils.SwaggerMonoid Data.OpenApi.Internal.PathItem
instance Data.OpenApi.Internal.Utils.SwaggerMonoid Data.OpenApi.Internal.Schema
instance Data.OpenApi.Internal.Utils.SwaggerMonoid Data.OpenApi.Internal.Param
instance Data.OpenApi.Internal.Utils.SwaggerMonoid Data.OpenApi.Internal.Responses
instance Data.OpenApi.Internal.Utils.SwaggerMonoid Data.OpenApi.Internal.Response
instance Data.OpenApi.Internal.Utils.SwaggerMonoid Data.OpenApi.Internal.ExternalDocs
instance Data.OpenApi.Internal.Utils.SwaggerMonoid Data.OpenApi.Internal.Operation
instance (GHC.Classes.Eq a, Data.Hashable.Class.Hashable a) => Data.OpenApi.Internal.Utils.SwaggerMonoid (Data.HashSet.InsOrd.InsOrdHashSet a)
instance Data.OpenApi.Internal.Utils.SwaggerMonoid Data.OpenApi.Internal.SecurityDefinitions
instance Data.OpenApi.Internal.Utils.SwaggerMonoid Data.OpenApi.Internal.OpenApiSpecVersion
instance Data.OpenApi.Internal.Utils.SwaggerMonoid Data.OpenApi.Internal.MimeList
instance Data.OpenApi.Internal.Utils.SwaggerMonoid Data.OpenApi.Internal.OpenApiType
instance Data.OpenApi.Internal.Utils.SwaggerMonoid Data.OpenApi.Internal.ParamLocation
instance Data.OpenApi.Internal.Utils.SwaggerMonoid (Data.HashMap.Strict.InsOrd.InsOrdHashMap GHC.IO.FilePath Data.OpenApi.Internal.PathItem)
instance GHC.Base.Monoid a => Data.OpenApi.Internal.Utils.SwaggerMonoid (Data.OpenApi.Internal.Referenced a)
instance Data.Aeson.Types.ToJSON.ToJSON Data.OpenApi.Internal.Style
instance Data.Aeson.Types.ToJSON.ToJSON Data.OpenApi.Internal.OpenApiType
instance Data.Aeson.Types.ToJSON.ToJSON Data.OpenApi.Internal.ParamLocation
instance Data.Aeson.Types.ToJSON.ToJSON Data.OpenApi.Internal.Info
instance Data.Aeson.Types.ToJSON.ToJSON Data.OpenApi.Internal.Contact
instance Data.Aeson.Types.ToJSON.ToJSON Data.OpenApi.Internal.License
instance Data.Aeson.Types.ToJSON.ToJSON Data.OpenApi.Internal.ServerVariable
instance Data.Aeson.Types.ToJSON.ToJSON Data.OpenApi.Internal.ApiKeyLocation
instance Data.Aeson.Types.ToJSON.ToJSON Data.OpenApi.Internal.ApiKeyParams
instance Data.Aeson.Types.ToJSON.ToJSON Data.OpenApi.Internal.Tag
instance Data.Aeson.Types.ToJSON.ToJSON Data.OpenApi.Internal.ExternalDocs
instance Data.Aeson.Types.ToJSON.ToJSON Data.OpenApi.Internal.Xml
instance Data.Aeson.Types.ToJSON.ToJSON Data.OpenApi.Internal.Discriminator
instance Data.Aeson.Types.ToJSON.ToJSON Data.OpenApi.Internal.OAuth2ImplicitFlow
instance Data.Aeson.Types.ToJSON.ToJSON Data.OpenApi.Internal.OAuth2PasswordFlow
instance Data.Aeson.Types.ToJSON.ToJSON Data.OpenApi.Internal.OAuth2ClientCredentialsFlow
instance Data.Aeson.Types.ToJSON.ToJSON Data.OpenApi.Internal.OAuth2AuthorizationCodeFlow
instance Data.Aeson.Types.FromJSON.FromJSON Data.OpenApi.Internal.Style
instance Data.Aeson.Types.FromJSON.FromJSON Data.OpenApi.Internal.OpenApiType
instance Data.Aeson.Types.FromJSON.FromJSON Data.OpenApi.Internal.ParamLocation
instance Data.Aeson.Types.FromJSON.FromJSON Data.OpenApi.Internal.Info
instance Data.Aeson.Types.FromJSON.FromJSON Data.OpenApi.Internal.Contact
instance Data.Aeson.Types.FromJSON.FromJSON Data.OpenApi.Internal.License
instance Data.Aeson.Types.FromJSON.FromJSON Data.OpenApi.Internal.ServerVariable
instance Data.Aeson.Types.FromJSON.FromJSON Data.OpenApi.Internal.ApiKeyLocation
instance Data.Aeson.Types.FromJSON.FromJSON Data.OpenApi.Internal.ApiKeyParams
instance Data.Aeson.Types.FromJSON.FromJSON Data.OpenApi.Internal.Tag
instance Data.Aeson.Types.FromJSON.FromJSON Data.OpenApi.Internal.ExternalDocs
instance Data.Aeson.Types.FromJSON.FromJSON Data.OpenApi.Internal.Discriminator
instance Data.Aeson.Types.FromJSON.FromJSON Data.OpenApi.Internal.OAuth2ImplicitFlow
instance Data.Aeson.Types.FromJSON.FromJSON Data.OpenApi.Internal.OAuth2PasswordFlow
instance Data.Aeson.Types.FromJSON.FromJSON Data.OpenApi.Internal.OAuth2ClientCredentialsFlow
instance Data.Aeson.Types.FromJSON.FromJSON Data.OpenApi.Internal.OAuth2AuthorizationCodeFlow
instance Data.Aeson.Types.ToJSON.ToJSON Data.OpenApi.Internal.OpenApiSpecVersion
instance Data.Aeson.Types.ToJSON.ToJSON Network.HTTP.Media.MediaType.Internal.MediaType
instance Data.Aeson.Types.ToJSON.ToJSONKey Network.HTTP.Media.MediaType.Internal.MediaType
instance (GHC.Classes.Eq p, Data.Aeson.Types.ToJSON.ToJSON p, Data.OpenApi.Internal.AesonUtils.AesonDefaultValue p) => Data.Aeson.Types.ToJSON.ToJSON (Data.OpenApi.Internal.OAuth2Flow p)
instance Data.Aeson.Types.ToJSON.ToJSON Data.OpenApi.Internal.OAuth2Flows
instance Data.Aeson.Types.ToJSON.ToJSON Data.OpenApi.Internal.SecuritySchemeType
instance Data.Aeson.Types.ToJSON.ToJSON Data.OpenApi.Internal.OpenApi
instance Data.Aeson.Types.ToJSON.ToJSON Data.OpenApi.Internal.Server
instance Data.Aeson.Types.ToJSON.ToJSON Data.OpenApi.Internal.SecurityScheme
instance Data.Aeson.Types.ToJSON.ToJSON Data.OpenApi.Internal.Schema
instance Data.Aeson.Types.ToJSON.ToJSON Data.OpenApi.Internal.Header
instance Data.Aeson.Types.ToJSON.ToJSON Data.OpenApi.Internal.OpenApiItems
instance Data.Aeson.Types.ToJSON.ToJSON Data.OpenApi.Internal.Components
instance Data.Aeson.Types.ToJSON.ToJSON Data.OpenApi.Internal.MimeList
instance Data.Aeson.Types.ToJSON.ToJSON Data.OpenApi.Internal.Param
instance Data.Aeson.Types.ToJSON.ToJSON Data.OpenApi.Internal.Responses
instance Data.Aeson.Types.ToJSON.ToJSON Data.OpenApi.Internal.Response
instance Data.Aeson.Types.ToJSON.ToJSON Data.OpenApi.Internal.Operation
instance Data.Aeson.Types.ToJSON.ToJSON Data.OpenApi.Internal.PathItem
instance Data.Aeson.Types.ToJSON.ToJSON Data.OpenApi.Internal.RequestBody
instance Data.Aeson.Types.ToJSON.ToJSON Data.OpenApi.Internal.MediaTypeObject
instance Data.Aeson.Types.ToJSON.ToJSON Data.OpenApi.Internal.Example
instance Data.Aeson.Types.ToJSON.ToJSON Data.OpenApi.Internal.Encoding
instance Data.Aeson.Types.ToJSON.ToJSON Data.OpenApi.Internal.Link
instance Data.Aeson.Types.ToJSON.ToJSON Data.OpenApi.Internal.SecurityDefinitions
instance Data.Aeson.Types.ToJSON.ToJSON Data.OpenApi.Internal.Reference
instance Data.Aeson.Types.ToJSON.ToJSON (Data.OpenApi.Internal.Referenced Data.OpenApi.Internal.Schema)
instance Data.Aeson.Types.ToJSON.ToJSON (Data.OpenApi.Internal.Referenced Data.OpenApi.Internal.Param)
instance Data.Aeson.Types.ToJSON.ToJSON (Data.OpenApi.Internal.Referenced Data.OpenApi.Internal.Response)
instance Data.Aeson.Types.ToJSON.ToJSON (Data.OpenApi.Internal.Referenced Data.OpenApi.Internal.RequestBody)
instance Data.Aeson.Types.ToJSON.ToJSON (Data.OpenApi.Internal.Referenced Data.OpenApi.Internal.Example)
instance Data.Aeson.Types.ToJSON.ToJSON (Data.OpenApi.Internal.Referenced Data.OpenApi.Internal.Header)
instance Data.Aeson.Types.ToJSON.ToJSON (Data.OpenApi.Internal.Referenced Data.OpenApi.Internal.Link)
instance Data.Aeson.Types.ToJSON.ToJSON (Data.OpenApi.Internal.Referenced Data.OpenApi.Internal.Callback)
instance Data.Aeson.Types.ToJSON.ToJSON Data.OpenApi.Internal.AdditionalProperties
instance Data.Aeson.Types.ToJSON.ToJSON Data.OpenApi.Internal.ExpressionOrValue
instance Data.Aeson.Types.ToJSON.ToJSON Data.OpenApi.Internal.Callback
instance Data.Aeson.Types.FromJSON.FromJSON Data.OpenApi.Internal.OpenApiSpecVersion
instance Data.Aeson.Types.FromJSON.FromJSON Network.HTTP.Media.MediaType.Internal.MediaType
instance Data.Aeson.Types.FromJSON.FromJSONKey Network.HTTP.Media.MediaType.Internal.MediaType
instance (GHC.Classes.Eq p, Data.Aeson.Types.FromJSON.FromJSON p, Data.OpenApi.Internal.AesonUtils.AesonDefaultValue p) => Data.Aeson.Types.FromJSON.FromJSON (Data.OpenApi.Internal.OAuth2Flow p)
instance Data.Aeson.Types.FromJSON.FromJSON Data.OpenApi.Internal.OAuth2Flows
instance Data.Aeson.Types.FromJSON.FromJSON Data.OpenApi.Internal.SecuritySchemeType
instance Data.Aeson.Types.FromJSON.FromJSON Data.OpenApi.Internal.OpenApi
instance Data.Aeson.Types.FromJSON.FromJSON Data.OpenApi.Internal.Server
instance Data.Aeson.Types.FromJSON.FromJSON Data.OpenApi.Internal.SecurityScheme
instance Data.Aeson.Types.FromJSON.FromJSON Data.OpenApi.Internal.Schema
instance Data.Aeson.Types.FromJSON.FromJSON Data.OpenApi.Internal.Header
instance Data.Aeson.Types.FromJSON.FromJSON Data.OpenApi.Internal.OpenApiItems
instance Data.Aeson.Types.FromJSON.FromJSON Data.OpenApi.Internal.Components
instance Data.Aeson.Types.FromJSON.FromJSON Data.OpenApi.Internal.MimeList
instance Data.Aeson.Types.FromJSON.FromJSON Data.OpenApi.Internal.Param
instance Data.Aeson.Types.FromJSON.FromJSON Data.OpenApi.Internal.Responses
instance Data.Aeson.Types.FromJSON.FromJSON Data.OpenApi.Internal.Example
instance Data.Aeson.Types.FromJSON.FromJSON Data.OpenApi.Internal.Response
instance Data.Aeson.Types.FromJSON.FromJSON Data.OpenApi.Internal.Operation
instance Data.Aeson.Types.FromJSON.FromJSON Data.OpenApi.Internal.PathItem
instance Data.Aeson.Types.FromJSON.FromJSON Data.OpenApi.Internal.SecurityDefinitions
instance Data.Aeson.Types.FromJSON.FromJSON Data.OpenApi.Internal.RequestBody
instance Data.Aeson.Types.FromJSON.FromJSON Data.OpenApi.Internal.MediaTypeObject
instance Data.Aeson.Types.FromJSON.FromJSON Data.OpenApi.Internal.Encoding
instance Data.Aeson.Types.FromJSON.FromJSON Data.OpenApi.Internal.Link
instance Data.Aeson.Types.FromJSON.FromJSON Data.OpenApi.Internal.Reference
instance Data.Aeson.Types.FromJSON.FromJSON (Data.OpenApi.Internal.Referenced Data.OpenApi.Internal.Schema)
instance Data.Aeson.Types.FromJSON.FromJSON (Data.OpenApi.Internal.Referenced Data.OpenApi.Internal.Param)
instance Data.Aeson.Types.FromJSON.FromJSON (Data.OpenApi.Internal.Referenced Data.OpenApi.Internal.Response)
instance Data.Aeson.Types.FromJSON.FromJSON (Data.OpenApi.Internal.Referenced Data.OpenApi.Internal.RequestBody)
instance Data.Aeson.Types.FromJSON.FromJSON (Data.OpenApi.Internal.Referenced Data.OpenApi.Internal.Example)
instance Data.Aeson.Types.FromJSON.FromJSON (Data.OpenApi.Internal.Referenced Data.OpenApi.Internal.Header)
instance Data.Aeson.Types.FromJSON.FromJSON (Data.OpenApi.Internal.Referenced Data.OpenApi.Internal.Link)
instance Data.Aeson.Types.FromJSON.FromJSON (Data.OpenApi.Internal.Referenced Data.OpenApi.Internal.Callback)
instance Data.Aeson.Types.FromJSON.FromJSON Data.OpenApi.Internal.Xml
instance Data.Aeson.Types.FromJSON.FromJSON Data.OpenApi.Internal.AdditionalProperties
instance Data.Aeson.Types.FromJSON.FromJSON Data.OpenApi.Internal.ExpressionOrValue
instance Data.Aeson.Types.FromJSON.FromJSON Data.OpenApi.Internal.Callback
instance Data.OpenApi.Internal.AesonUtils.HasSwaggerAesonOptions Data.OpenApi.Internal.Server
instance Data.OpenApi.Internal.AesonUtils.HasSwaggerAesonOptions Data.OpenApi.Internal.Components
instance Data.OpenApi.Internal.AesonUtils.HasSwaggerAesonOptions Data.OpenApi.Internal.Header
instance Data.OpenApi.Internal.AesonUtils.AesonDefaultValue p => Data.OpenApi.Internal.AesonUtils.HasSwaggerAesonOptions (Data.OpenApi.Internal.OAuth2Flow p)
instance Data.OpenApi.Internal.AesonUtils.HasSwaggerAesonOptions Data.OpenApi.Internal.OAuth2Flows
instance Data.OpenApi.Internal.AesonUtils.HasSwaggerAesonOptions Data.OpenApi.Internal.Operation
instance Data.OpenApi.Internal.AesonUtils.HasSwaggerAesonOptions Data.OpenApi.Internal.Param
instance Data.OpenApi.Internal.AesonUtils.HasSwaggerAesonOptions Data.OpenApi.Internal.PathItem
instance Data.OpenApi.Internal.AesonUtils.HasSwaggerAesonOptions Data.OpenApi.Internal.Response
instance Data.OpenApi.Internal.AesonUtils.HasSwaggerAesonOptions Data.OpenApi.Internal.RequestBody
instance Data.OpenApi.Internal.AesonUtils.HasSwaggerAesonOptions Data.OpenApi.Internal.MediaTypeObject
instance Data.OpenApi.Internal.AesonUtils.HasSwaggerAesonOptions Data.OpenApi.Internal.Responses
instance Data.OpenApi.Internal.AesonUtils.HasSwaggerAesonOptions Data.OpenApi.Internal.SecurityScheme
instance Data.OpenApi.Internal.AesonUtils.HasSwaggerAesonOptions Data.OpenApi.Internal.Schema
instance Data.OpenApi.Internal.AesonUtils.HasSwaggerAesonOptions Data.OpenApi.Internal.OpenApiSpecVersion
instance Data.OpenApi.Internal.AesonUtils.HasSwaggerAesonOptions Data.OpenApi.Internal.OpenApi
instance Data.OpenApi.Internal.AesonUtils.HasSwaggerAesonOptions Data.OpenApi.Internal.Example
instance Data.OpenApi.Internal.AesonUtils.HasSwaggerAesonOptions Data.OpenApi.Internal.Encoding
instance Data.OpenApi.Internal.AesonUtils.HasSwaggerAesonOptions Data.OpenApi.Internal.Link
instance Data.OpenApi.Internal.AesonUtils.AesonDefaultValue Data.Version.Version
instance Data.OpenApi.Internal.AesonUtils.AesonDefaultValue Data.OpenApi.Internal.OpenApiSpecVersion
instance Data.OpenApi.Internal.AesonUtils.AesonDefaultValue Data.OpenApi.Internal.Server
instance Data.OpenApi.Internal.AesonUtils.AesonDefaultValue Data.OpenApi.Internal.Components
instance Data.OpenApi.Internal.AesonUtils.AesonDefaultValue Data.OpenApi.Internal.OAuth2ImplicitFlow
instance Data.OpenApi.Internal.AesonUtils.AesonDefaultValue Data.OpenApi.Internal.OAuth2PasswordFlow
instance Data.OpenApi.Internal.AesonUtils.AesonDefaultValue Data.OpenApi.Internal.OAuth2ClientCredentialsFlow
instance Data.OpenApi.Internal.AesonUtils.AesonDefaultValue Data.OpenApi.Internal.OAuth2AuthorizationCodeFlow
instance Data.OpenApi.Internal.AesonUtils.AesonDefaultValue p => Data.OpenApi.Internal.AesonUtils.AesonDefaultValue (Data.OpenApi.Internal.OAuth2Flow p)
instance Data.OpenApi.Internal.AesonUtils.AesonDefaultValue Data.OpenApi.Internal.Responses
instance Data.OpenApi.Internal.AesonUtils.AesonDefaultValue Data.OpenApi.Internal.SecuritySchemeType
instance Data.OpenApi.Internal.AesonUtils.AesonDefaultValue Data.OpenApi.Internal.OpenApiType
instance Data.OpenApi.Internal.AesonUtils.AesonDefaultValue Data.OpenApi.Internal.MimeList
instance Data.OpenApi.Internal.AesonUtils.AesonDefaultValue Data.OpenApi.Internal.Info
instance Data.OpenApi.Internal.AesonUtils.AesonDefaultValue Data.OpenApi.Internal.ParamLocation
instance Data.OpenApi.Internal.AesonUtils.AesonDefaultValue Data.OpenApi.Internal.Link
instance Data.OpenApi.Internal.AesonUtils.AesonDefaultValue Data.OpenApi.Internal.SecurityDefinitions
instance Generics.SOP.Universe.Generic Data.OpenApi.Internal.Link
instance Generics.SOP.Universe.HasDatatypeInfo Data.OpenApi.Internal.Link
instance Generics.SOP.Universe.Generic Data.OpenApi.Internal.Encoding
instance Generics.SOP.Universe.HasDatatypeInfo Data.OpenApi.Internal.Encoding
instance Generics.SOP.Universe.Generic Data.OpenApi.Internal.Example
instance Generics.SOP.Universe.HasDatatypeInfo Data.OpenApi.Internal.Example
instance Generics.SOP.Universe.Generic Data.OpenApi.Internal.OpenApi
instance Generics.SOP.Universe.HasDatatypeInfo Data.OpenApi.Internal.OpenApi
instance Generics.SOP.Universe.Generic Data.OpenApi.Internal.Schema
instance Generics.SOP.Universe.HasDatatypeInfo Data.OpenApi.Internal.Schema
instance Generics.SOP.Universe.Generic Data.OpenApi.Internal.SecurityScheme
instance Generics.SOP.Universe.HasDatatypeInfo Data.OpenApi.Internal.SecurityScheme
instance Generics.SOP.Universe.Generic Data.OpenApi.Internal.Responses
instance Generics.SOP.Universe.HasDatatypeInfo Data.OpenApi.Internal.Responses
instance Generics.SOP.Universe.Generic Data.OpenApi.Internal.MediaTypeObject
instance Generics.SOP.Universe.HasDatatypeInfo Data.OpenApi.Internal.MediaTypeObject
instance Generics.SOP.Universe.Generic Data.OpenApi.Internal.RequestBody
instance Generics.SOP.Universe.HasDatatypeInfo Data.OpenApi.Internal.RequestBody
instance Generics.SOP.Universe.Generic Data.OpenApi.Internal.Response
instance Generics.SOP.Universe.HasDatatypeInfo Data.OpenApi.Internal.Response
instance Generics.SOP.Universe.Generic Data.OpenApi.Internal.PathItem
instance Generics.SOP.Universe.HasDatatypeInfo Data.OpenApi.Internal.PathItem
instance Generics.SOP.Universe.Generic Data.OpenApi.Internal.Param
instance Generics.SOP.Universe.HasDatatypeInfo Data.OpenApi.Internal.Param
instance Generics.SOP.Universe.Generic Data.OpenApi.Internal.Operation
instance Generics.SOP.Universe.HasDatatypeInfo Data.OpenApi.Internal.Operation
instance Generics.SOP.Universe.Generic Data.OpenApi.Internal.OAuth2Flows
instance Generics.SOP.Universe.HasDatatypeInfo Data.OpenApi.Internal.OAuth2Flows
instance Generics.SOP.Universe.Generic (Data.OpenApi.Internal.OAuth2Flow p)
instance Generics.SOP.Universe.HasDatatypeInfo (Data.OpenApi.Internal.OAuth2Flow p)
instance Generics.SOP.Universe.Generic Data.OpenApi.Internal.Header
instance Generics.SOP.Universe.HasDatatypeInfo Data.OpenApi.Internal.Header
instance Generics.SOP.Universe.Generic Data.OpenApi.Internal.Components
instance Generics.SOP.Universe.HasDatatypeInfo Data.OpenApi.Internal.Components
instance Generics.SOP.Universe.Generic Data.OpenApi.Internal.Server
instance Generics.SOP.Universe.HasDatatypeInfo Data.OpenApi.Internal.Server
instance Data.Data.Data Data.OpenApi.Internal.ServerVariable
instance GHC.Generics.Generic Data.OpenApi.Internal.ServerVariable
instance GHC.Show.Show Data.OpenApi.Internal.ServerVariable
instance GHC.Classes.Eq Data.OpenApi.Internal.ServerVariable
instance Data.Data.Data Data.OpenApi.Internal.Server
instance GHC.Generics.Generic Data.OpenApi.Internal.Server
instance GHC.Show.Show Data.OpenApi.Internal.Server
instance GHC.Classes.Eq Data.OpenApi.Internal.Server
instance Data.Data.Data Data.OpenApi.Internal.Style
instance GHC.Generics.Generic Data.OpenApi.Internal.Style
instance GHC.Show.Show Data.OpenApi.Internal.Style
instance GHC.Classes.Eq Data.OpenApi.Internal.Style
instance GHC.Base.Monoid Data.OpenApi.Internal.MimeList
instance GHC.Base.Semigroup Data.OpenApi.Internal.MimeList
instance GHC.Show.Show Data.OpenApi.Internal.MimeList
instance GHC.Classes.Eq Data.OpenApi.Internal.MimeList
instance Data.Data.Data Data.OpenApi.Internal.ExpressionOrValue
instance GHC.Generics.Generic Data.OpenApi.Internal.ExpressionOrValue
instance GHC.Show.Show Data.OpenApi.Internal.ExpressionOrValue
instance GHC.Classes.Eq Data.OpenApi.Internal.ExpressionOrValue
instance Data.Data.Data Data.OpenApi.Internal.Link
instance GHC.Generics.Generic Data.OpenApi.Internal.Link
instance GHC.Show.Show Data.OpenApi.Internal.Link
instance GHC.Classes.Eq Data.OpenApi.Internal.Link
instance Data.Data.Data Data.OpenApi.Internal.OpenApiType
instance GHC.Generics.Generic Data.OpenApi.Internal.OpenApiType
instance GHC.Show.Show Data.OpenApi.Internal.OpenApiType
instance GHC.Classes.Eq Data.OpenApi.Internal.OpenApiType
instance Data.Data.Data Data.OpenApi.Internal.ParamLocation
instance GHC.Generics.Generic Data.OpenApi.Internal.ParamLocation
instance GHC.Show.Show Data.OpenApi.Internal.ParamLocation
instance GHC.Classes.Eq Data.OpenApi.Internal.ParamLocation
instance Data.Data.Data Data.OpenApi.Internal.Discriminator
instance GHC.Generics.Generic Data.OpenApi.Internal.Discriminator
instance GHC.Show.Show Data.OpenApi.Internal.Discriminator
instance GHC.Classes.Eq Data.OpenApi.Internal.Discriminator
instance Data.Data.Data Data.OpenApi.Internal.Xml
instance GHC.Generics.Generic Data.OpenApi.Internal.Xml
instance GHC.Show.Show Data.OpenApi.Internal.Xml
instance GHC.Classes.Eq Data.OpenApi.Internal.Xml
instance Data.Data.Data Data.OpenApi.Internal.ApiKeyLocation
instance GHC.Generics.Generic Data.OpenApi.Internal.ApiKeyLocation
instance GHC.Show.Show Data.OpenApi.Internal.ApiKeyLocation
instance GHC.Classes.Eq Data.OpenApi.Internal.ApiKeyLocation
instance Data.Data.Data Data.OpenApi.Internal.ApiKeyParams
instance GHC.Generics.Generic Data.OpenApi.Internal.ApiKeyParams
instance GHC.Show.Show Data.OpenApi.Internal.ApiKeyParams
instance GHC.Classes.Eq Data.OpenApi.Internal.ApiKeyParams
instance Data.Data.Data Data.OpenApi.Internal.OAuth2ImplicitFlow
instance GHC.Generics.Generic Data.OpenApi.Internal.OAuth2ImplicitFlow
instance GHC.Show.Show Data.OpenApi.Internal.OAuth2ImplicitFlow
instance GHC.Classes.Eq Data.OpenApi.Internal.OAuth2ImplicitFlow
instance Data.Data.Data Data.OpenApi.Internal.OAuth2PasswordFlow
instance GHC.Generics.Generic Data.OpenApi.Internal.OAuth2PasswordFlow
instance GHC.Show.Show Data.OpenApi.Internal.OAuth2PasswordFlow
instance GHC.Classes.Eq Data.OpenApi.Internal.OAuth2PasswordFlow
instance Data.Data.Data Data.OpenApi.Internal.OAuth2ClientCredentialsFlow
instance GHC.Generics.Generic Data.OpenApi.Internal.OAuth2ClientCredentialsFlow
instance GHC.Show.Show Data.OpenApi.Internal.OAuth2ClientCredentialsFlow
instance GHC.Classes.Eq Data.OpenApi.Internal.OAuth2ClientCredentialsFlow
instance Data.Data.Data Data.OpenApi.Internal.OAuth2AuthorizationCodeFlow
instance GHC.Generics.Generic Data.OpenApi.Internal.OAuth2AuthorizationCodeFlow
instance GHC.Show.Show Data.OpenApi.Internal.OAuth2AuthorizationCodeFlow
instance GHC.Classes.Eq Data.OpenApi.Internal.OAuth2AuthorizationCodeFlow
instance Data.Data.Data Data.OpenApi.Internal.HttpSchemeType
instance GHC.Generics.Generic Data.OpenApi.Internal.HttpSchemeType
instance GHC.Show.Show Data.OpenApi.Internal.HttpSchemeType
instance GHC.Classes.Eq Data.OpenApi.Internal.HttpSchemeType
instance Data.Data.Data Data.OpenApi.Internal.SecurityRequirement
instance Data.Aeson.Types.FromJSON.FromJSON Data.OpenApi.Internal.SecurityRequirement
instance Data.Aeson.Types.ToJSON.ToJSON Data.OpenApi.Internal.SecurityRequirement
instance GHC.Base.Monoid Data.OpenApi.Internal.SecurityRequirement
instance GHC.Base.Semigroup Data.OpenApi.Internal.SecurityRequirement
instance GHC.Show.Show Data.OpenApi.Internal.SecurityRequirement
instance GHC.Read.Read Data.OpenApi.Internal.SecurityRequirement
instance GHC.Classes.Eq Data.OpenApi.Internal.SecurityRequirement
instance Data.Data.Data Data.OpenApi.Internal.Reference
instance GHC.Show.Show Data.OpenApi.Internal.Reference
instance GHC.Classes.Eq Data.OpenApi.Internal.Reference
instance Data.Data.Data a => Data.Data.Data (Data.OpenApi.Internal.Referenced a)
instance GHC.Base.Functor Data.OpenApi.Internal.Referenced
instance GHC.Show.Show a => GHC.Show.Show (Data.OpenApi.Internal.Referenced a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.OpenApi.Internal.Referenced a)
instance Data.Data.Data Data.OpenApi.Internal.URL
instance Data.Aeson.Types.FromJSON.FromJSON Data.OpenApi.Internal.URL
instance Data.Aeson.Types.ToJSON.ToJSON Data.OpenApi.Internal.URL
instance Data.Hashable.Class.Hashable Data.OpenApi.Internal.URL
instance GHC.Show.Show Data.OpenApi.Internal.URL
instance GHC.Classes.Ord Data.OpenApi.Internal.URL
instance GHC.Classes.Eq Data.OpenApi.Internal.URL
instance Data.Data.Data Data.OpenApi.Internal.ExternalDocs
instance GHC.Generics.Generic Data.OpenApi.Internal.ExternalDocs
instance GHC.Show.Show Data.OpenApi.Internal.ExternalDocs
instance GHC.Classes.Ord Data.OpenApi.Internal.ExternalDocs
instance GHC.Classes.Eq Data.OpenApi.Internal.ExternalDocs
instance Data.Data.Data Data.OpenApi.Internal.Tag
instance GHC.Generics.Generic Data.OpenApi.Internal.Tag
instance GHC.Show.Show Data.OpenApi.Internal.Tag
instance GHC.Classes.Ord Data.OpenApi.Internal.Tag
instance GHC.Classes.Eq Data.OpenApi.Internal.Tag
instance Data.Data.Data p => Data.Data.Data (Data.OpenApi.Internal.OAuth2Flow p)
instance GHC.Generics.Generic (Data.OpenApi.Internal.OAuth2Flow p)
instance GHC.Show.Show p => GHC.Show.Show (Data.OpenApi.Internal.OAuth2Flow p)
instance GHC.Classes.Eq p => GHC.Classes.Eq (Data.OpenApi.Internal.OAuth2Flow p)
instance Data.Data.Data Data.OpenApi.Internal.OAuth2Flows
instance GHC.Generics.Generic Data.OpenApi.Internal.OAuth2Flows
instance GHC.Show.Show Data.OpenApi.Internal.OAuth2Flows
instance GHC.Classes.Eq Data.OpenApi.Internal.OAuth2Flows
instance Data.Data.Data Data.OpenApi.Internal.SecuritySchemeType
instance GHC.Generics.Generic Data.OpenApi.Internal.SecuritySchemeType
instance GHC.Show.Show Data.OpenApi.Internal.SecuritySchemeType
instance GHC.Classes.Eq Data.OpenApi.Internal.SecuritySchemeType
instance Data.Data.Data Data.OpenApi.Internal.SecurityScheme
instance GHC.Generics.Generic Data.OpenApi.Internal.SecurityScheme
instance GHC.Show.Show Data.OpenApi.Internal.SecurityScheme
instance GHC.Classes.Eq Data.OpenApi.Internal.SecurityScheme
instance Data.Data.Data Data.OpenApi.Internal.SecurityDefinitions
instance GHC.Generics.Generic Data.OpenApi.Internal.SecurityDefinitions
instance GHC.Show.Show Data.OpenApi.Internal.SecurityDefinitions
instance GHC.Classes.Eq Data.OpenApi.Internal.SecurityDefinitions
instance Data.Data.Data Data.OpenApi.Internal.Example
instance GHC.Generics.Generic Data.OpenApi.Internal.Example
instance GHC.Show.Show Data.OpenApi.Internal.Example
instance GHC.Classes.Eq Data.OpenApi.Internal.Example
instance Data.Data.Data Data.OpenApi.Internal.License
instance GHC.Generics.Generic Data.OpenApi.Internal.License
instance GHC.Show.Show Data.OpenApi.Internal.License
instance GHC.Classes.Eq Data.OpenApi.Internal.License
instance Data.Data.Data Data.OpenApi.Internal.Contact
instance GHC.Generics.Generic Data.OpenApi.Internal.Contact
instance GHC.Show.Show Data.OpenApi.Internal.Contact
instance GHC.Classes.Eq Data.OpenApi.Internal.Contact
instance Data.Data.Data Data.OpenApi.Internal.Info
instance GHC.Generics.Generic Data.OpenApi.Internal.Info
instance GHC.Show.Show Data.OpenApi.Internal.Info
instance GHC.Classes.Eq Data.OpenApi.Internal.Info
instance Data.Data.Data Data.OpenApi.Internal.OpenApiItems
instance GHC.Show.Show Data.OpenApi.Internal.OpenApiItems
instance GHC.Classes.Eq Data.OpenApi.Internal.OpenApiItems
instance Data.Data.Data Data.OpenApi.Internal.Schema
instance GHC.Generics.Generic Data.OpenApi.Internal.Schema
instance GHC.Show.Show Data.OpenApi.Internal.Schema
instance GHC.Classes.Eq Data.OpenApi.Internal.Schema
instance Data.Data.Data Data.OpenApi.Internal.AdditionalProperties
instance GHC.Show.Show Data.OpenApi.Internal.AdditionalProperties
instance GHC.Classes.Eq Data.OpenApi.Internal.AdditionalProperties
instance Data.Data.Data Data.OpenApi.Internal.Header
instance GHC.Generics.Generic Data.OpenApi.Internal.Header
instance GHC.Show.Show Data.OpenApi.Internal.Header
instance GHC.Classes.Eq Data.OpenApi.Internal.Header
instance Data.Data.Data Data.OpenApi.Internal.Encoding
instance GHC.Generics.Generic Data.OpenApi.Internal.Encoding
instance GHC.Show.Show Data.OpenApi.Internal.Encoding
instance GHC.Classes.Eq Data.OpenApi.Internal.Encoding
instance Data.Data.Data Data.OpenApi.Internal.NamedSchema
instance GHC.Generics.Generic Data.OpenApi.Internal.NamedSchema
instance GHC.Show.Show Data.OpenApi.Internal.NamedSchema
instance GHC.Classes.Eq Data.OpenApi.Internal.NamedSchema
instance Data.Data.Data Data.OpenApi.Internal.Param
instance GHC.Generics.Generic Data.OpenApi.Internal.Param
instance GHC.Show.Show Data.OpenApi.Internal.Param
instance GHC.Classes.Eq Data.OpenApi.Internal.Param
instance Data.Data.Data Data.OpenApi.Internal.MediaTypeObject
instance GHC.Generics.Generic Data.OpenApi.Internal.MediaTypeObject
instance GHC.Show.Show Data.OpenApi.Internal.MediaTypeObject
instance GHC.Classes.Eq Data.OpenApi.Internal.MediaTypeObject
instance Data.Data.Data Data.OpenApi.Internal.Response
instance GHC.Generics.Generic Data.OpenApi.Internal.Response
instance GHC.Show.Show Data.OpenApi.Internal.Response
instance GHC.Classes.Eq Data.OpenApi.Internal.Response
instance Data.Data.Data Data.OpenApi.Internal.Responses
instance GHC.Generics.Generic Data.OpenApi.Internal.Responses
instance GHC.Show.Show Data.OpenApi.Internal.Responses
instance GHC.Classes.Eq Data.OpenApi.Internal.Responses
instance Data.Data.Data Data.OpenApi.Internal.RequestBody
instance GHC.Generics.Generic Data.OpenApi.Internal.RequestBody
instance GHC.Show.Show Data.OpenApi.Internal.RequestBody
instance GHC.Classes.Eq Data.OpenApi.Internal.RequestBody
instance Data.Data.Data Data.OpenApi.Internal.PathItem
instance GHC.Generics.Generic Data.OpenApi.Internal.PathItem
instance GHC.Show.Show Data.OpenApi.Internal.PathItem
instance GHC.Classes.Eq Data.OpenApi.Internal.PathItem
instance Data.Data.Data Data.OpenApi.Internal.Callback
instance GHC.Generics.Generic Data.OpenApi.Internal.Callback
instance GHC.Show.Show Data.OpenApi.Internal.Callback
instance GHC.Classes.Eq Data.OpenApi.Internal.Callback
instance Data.Data.Data Data.OpenApi.Internal.Operation
instance GHC.Generics.Generic Data.OpenApi.Internal.Operation
instance GHC.Show.Show Data.OpenApi.Internal.Operation
instance GHC.Classes.Eq Data.OpenApi.Internal.Operation
instance Data.Data.Data Data.OpenApi.Internal.Components
instance GHC.Generics.Generic Data.OpenApi.Internal.Components
instance GHC.Show.Show Data.OpenApi.Internal.Components
instance GHC.Classes.Eq Data.OpenApi.Internal.Components
instance Data.Data.Data Data.OpenApi.Internal.OpenApiSpecVersion
instance GHC.Generics.Generic Data.OpenApi.Internal.OpenApiSpecVersion
instance GHC.Show.Show Data.OpenApi.Internal.OpenApiSpecVersion
instance GHC.Classes.Eq Data.OpenApi.Internal.OpenApiSpecVersion
instance Data.Data.Data Data.OpenApi.Internal.OpenApi
instance GHC.Generics.Generic Data.OpenApi.Internal.OpenApi
instance GHC.Show.Show Data.OpenApi.Internal.OpenApi
instance GHC.Classes.Eq Data.OpenApi.Internal.OpenApi
instance Data.String.IsString Data.OpenApi.Internal.Response
instance Data.String.IsString Data.OpenApi.Internal.License
instance Data.Hashable.Class.Hashable Data.OpenApi.Internal.Tag
instance Data.String.IsString Data.OpenApi.Internal.Tag
instance Data.Hashable.Class.Hashable Data.OpenApi.Internal.ExternalDocs
instance Data.String.IsString a => Data.String.IsString (Data.OpenApi.Internal.Referenced a)
instance Data.Data.Data Data.OpenApi.Internal.MimeList
instance Data.String.IsString Data.OpenApi.Internal.Server
instance Data.Data.Data Network.HTTP.Media.MediaType.Internal.MediaType
instance Data.Hashable.Class.Hashable Network.HTTP.Media.MediaType.Internal.MediaType


-- | Lenses and prisms for Swagger.
module Data.OpenApi.Lens
class HasComponents s a | s -> a
components :: HasComponents s a => Lens' s a
class HasExternalDocs s a | s -> a
externalDocs :: HasExternalDocs s a => Lens' s a
class HasInfo s a | s -> a
info :: HasInfo s a => Lens' s a
class HasOpenapi s a | s -> a
openapi :: HasOpenapi s a => Lens' s a
class HasPaths s a | s -> a
paths :: HasPaths s a => Lens' s a
class HasSecurity s a | s -> a
security :: HasSecurity s a => Lens' s a
class HasServers s a | s -> a
servers :: HasServers s a => Lens' s a
class HasTags s a | s -> a
tags :: HasTags s a => Lens' s a
class HasCallbacks s a | s -> a
callbacks :: HasCallbacks s a => Lens' s a
class HasExamples s a | s -> a
examples :: HasExamples s a => Lens' s a
class HasHeaders s a | s -> a
headers :: HasHeaders s a => Lens' s a
class HasLinks s a | s -> a
links :: HasLinks s a => Lens' s a
class HasParameters s a | s -> a
parameters :: HasParameters s a => Lens' s a
class HasRequestBodies s a | s -> a
requestBodies :: HasRequestBodies s a => Lens' s a
class HasResponses s a | s -> a
responses :: HasResponses s a => Lens' s a
class HasSchemas s a | s -> a
schemas :: HasSchemas s a => Lens' s a
class HasSecuritySchemes s a | s -> a
securitySchemes :: HasSecuritySchemes s a => Lens' s a
class HasDescription s a | s -> a
description :: HasDescription s a => Lens' s a
class HasUrl s a | s -> a
url :: HasUrl s a => Lens' s a
class HasVariables s a | s -> a
variables :: HasVariables s a => Lens' s a
class HasContent s a | s -> a
content :: HasContent s a => Lens' s a
class HasRequired s a | s -> a
required :: HasRequired s a => Lens' s a
class HasEncoding s a | s -> a
encoding :: HasEncoding s a => Lens' s a
class HasExample s a | s -> a
example :: HasExample s a => Lens' s a
class HasSchema s a | s -> a
schema :: HasSchema s a => Lens' s a
class HasContact s a | s -> a
contact :: HasContact s a => Lens' s a
class HasLicense s a | s -> a
license :: HasLicense s a => Lens' s a
class HasTermsOfService s a | s -> a
termsOfService :: HasTermsOfService s a => Lens' s a
class HasTitle s a | s -> a
title :: HasTitle s a => Lens' s a
class HasVersion s a | s -> a
version :: HasVersion s a => Lens' s a
class HasEmail s a | s -> a
email :: HasEmail s a => Lens' s a
class HasName s a | s -> a
name :: HasName s a => Lens' s a
class HasDelete s a | s -> a
delete :: HasDelete s a => Lens' s a
class HasGet s a | s -> a
get :: HasGet s a => Lens' s a
class HasHead s a | s -> a
head_ :: HasHead s a => Lens' s a
class HasOptions s a | s -> a
options :: HasOptions s a => Lens' s a
class HasPatch s a | s -> a
patch :: HasPatch s a => Lens' s a
class HasPost s a | s -> a
post :: HasPost s a => Lens' s a
class HasPut s a | s -> a
put :: HasPut s a => Lens' s a
class HasSummary s a | s -> a
summary :: HasSummary s a => Lens' s a
class HasTrace s a | s -> a
trace :: HasTrace s a => Lens' s a
class HasDeprecated s a | s -> a
deprecated :: HasDeprecated s a => Lens' s a
class HasOperationId s a | s -> a
operationId :: HasOperationId s a => Lens' s a
class HasRequestBody s a | s -> a
requestBody :: HasRequestBody s a => Lens' s a
class HasAllowEmptyValue s a | s -> a
allowEmptyValue :: HasAllowEmptyValue s a => Lens' s a
class HasAllowReserved s a | s -> a
allowReserved :: HasAllowReserved s a => Lens' s a
class HasExplode s a | s -> a
explode :: HasExplode s a => Lens' s a
class HasIn s a | s -> a
in_ :: HasIn s a => Lens' s a
class HasStyle s a | s -> a
style :: HasStyle s a => Lens' s a
class HasAdditionalProperties s a | s -> a
additionalProperties :: HasAdditionalProperties s a => Lens' s a
class HasAllOf s a | s -> a
allOf :: HasAllOf s a => Lens' s a
class HasAnyOf s a | s -> a
anyOf :: HasAnyOf s a => Lens' s a
class HasDefault s a | s -> a
default_ :: HasDefault s a => Lens' s a
class HasDiscriminator s a | s -> a
discriminator :: HasDiscriminator s a => Lens' s a
class HasEnum s a | s -> a
enum_ :: HasEnum s a => Lens' s a
class HasExclusiveMaximum s a | s -> a
exclusiveMaximum :: HasExclusiveMaximum s a => Lens' s a
class HasExclusiveMinimum s a | s -> a
exclusiveMinimum :: HasExclusiveMinimum s a => Lens' s a
class HasFormat s a | s -> a
format :: HasFormat s a => Lens' s a
class HasItems s a | s -> a
items :: HasItems s a => Lens' s a
class HasMaxItems s a | s -> a
maxItems :: HasMaxItems s a => Lens' s a
class HasMaxLength s a | s -> a
maxLength :: HasMaxLength s a => Lens' s a
class HasMaxProperties s a | s -> a
maxProperties :: HasMaxProperties s a => Lens' s a
class HasMaximum s a | s -> a
maximum_ :: HasMaximum s a => Lens' s a
class HasMinItems s a | s -> a
minItems :: HasMinItems s a => Lens' s a
class HasMinLength s a | s -> a
minLength :: HasMinLength s a => Lens' s a
class HasMinProperties s a | s -> a
minProperties :: HasMinProperties s a => Lens' s a
class HasMinimum s a | s -> a
minimum_ :: HasMinimum s a => Lens' s a
class HasMultipleOf s a | s -> a
multipleOf :: HasMultipleOf s a => Lens' s a
class HasNot s a | s -> a
not_ :: HasNot s a => Lens' s a
class HasNullable s a | s -> a
nullable :: HasNullable s a => Lens' s a
class HasOneOf s a | s -> a
oneOf :: HasOneOf s a => Lens' s a
class HasPattern s a | s -> a
pattern :: HasPattern s a => Lens' s a
class HasProperties s a | s -> a
properties :: HasProperties s a => Lens' s a
class HasReadOnly s a | s -> a
readOnly :: HasReadOnly s a => Lens' s a
class HasType s a | s -> a
type_ :: HasType s a => Lens' s a
class HasUniqueItems s a | s -> a
uniqueItems :: HasUniqueItems s a => Lens' s a
class HasWriteOnly s a | s -> a
writeOnly :: HasWriteOnly s a => Lens' s a
class HasXml s a | s -> a
xml :: HasXml s a => Lens' s a
class HasAttribute s a | s -> a
attribute :: HasAttribute s a => Lens' s a
class HasNamespace s a | s -> a
namespace :: HasNamespace s a => Lens' s a
class HasPrefix s a | s -> a
prefix :: HasPrefix s a => Lens' s a
class HasWrapped s a | s -> a
wrapped :: HasWrapped s a => Lens' s a
class HasAuthorizationUrl s a | s -> a
authorizationUrl :: HasAuthorizationUrl s a => Lens' s a
class HasTokenUrl s a | s -> a
tokenUrl :: HasTokenUrl s a => Lens' s a
class HasAuthorizationCode s a | s -> a
authorizationCode :: HasAuthorizationCode s a => Lens' s a
class HasClientCredentials s a | s -> a
clientCredentials :: HasClientCredentials s a => Lens' s a
class HasImplicit s a | s -> a
implicit :: HasImplicit s a => Lens' s a
class HasPassword s a | s -> a
password :: HasPassword s a => Lens' s a
class HasContentType s a | s -> a
contentType :: HasContentType s a => Lens' s a
class HasExternalValue s a | s -> a
externalValue :: HasExternalValue s a => Lens' s a
class HasValue s a | s -> a
value :: HasValue s a => Lens' s a
class HasMapping s a | s -> a
mapping :: HasMapping s a => Lens' s a
class HasPropertyName s a | s -> a
propertyName :: HasPropertyName s a => Lens' s a
class HasOperationRef s a | s -> a
operationRef :: HasOperationRef s a => Lens' s a
class HasServer s a | s -> a
server :: HasServer s a => Lens' s a
_SecuritySchemeOpenIdConnect :: Prism' SecuritySchemeType URL
_SecuritySchemeOAuth2 :: Prism' SecuritySchemeType OAuth2Flows
_SecuritySchemeApiKey :: Prism' SecuritySchemeType ApiKeyParams
_SecuritySchemeHttp :: Prism' SecuritySchemeType HttpSchemeType
_Inline :: forall a_a33td a_i305I. Prism (Referenced a_a33td) (Referenced a_i305I) a_a33td a_i305I
_Ref :: forall a_i305I. Prism' (Referenced a_i305I) Reference
_OpenApiItemsArray :: Review OpenApiItems [Referenced Schema]
_OpenApiItemsObject :: Review OpenApiItems (Referenced Schema)
instance Control.Lens.At.Ixed Data.OpenApi.Internal.Responses
instance Control.Lens.At.At Data.OpenApi.Internal.Responses
instance Control.Lens.At.Ixed Data.OpenApi.Internal.Operation
instance Control.Lens.At.At Data.OpenApi.Internal.Operation
instance Data.OpenApi.Lens.HasType Data.OpenApi.Internal.NamedSchema (GHC.Maybe.Maybe Data.OpenApi.Internal.OpenApiType)
instance Data.OpenApi.Lens.HasSchema s Data.OpenApi.Internal.Schema => Data.OpenApi.Lens.HasFormat s (GHC.Maybe.Maybe Data.OpenApi.Internal.Format)
instance Data.OpenApi.Lens.HasSchema s Data.OpenApi.Internal.Schema => Data.OpenApi.Lens.HasItems s (GHC.Maybe.Maybe Data.OpenApi.Internal.OpenApiItems)
instance Data.OpenApi.Lens.HasSchema s Data.OpenApi.Internal.Schema => Data.OpenApi.Lens.HasMaximum s (GHC.Maybe.Maybe Data.Scientific.Scientific)
instance Data.OpenApi.Lens.HasSchema s Data.OpenApi.Internal.Schema => Data.OpenApi.Lens.HasExclusiveMaximum s (GHC.Maybe.Maybe GHC.Types.Bool)
instance Data.OpenApi.Lens.HasSchema s Data.OpenApi.Internal.Schema => Data.OpenApi.Lens.HasMinimum s (GHC.Maybe.Maybe Data.Scientific.Scientific)
instance Data.OpenApi.Lens.HasSchema s Data.OpenApi.Internal.Schema => Data.OpenApi.Lens.HasExclusiveMinimum s (GHC.Maybe.Maybe GHC.Types.Bool)
instance Data.OpenApi.Lens.HasSchema s Data.OpenApi.Internal.Schema => Data.OpenApi.Lens.HasMaxLength s (GHC.Maybe.Maybe GHC.Num.Integer.Integer)
instance Data.OpenApi.Lens.HasSchema s Data.OpenApi.Internal.Schema => Data.OpenApi.Lens.HasMinLength s (GHC.Maybe.Maybe GHC.Num.Integer.Integer)
instance Data.OpenApi.Lens.HasSchema s Data.OpenApi.Internal.Schema => Data.OpenApi.Lens.HasPattern s (GHC.Maybe.Maybe Data.Text.Internal.Text)
instance Data.OpenApi.Lens.HasSchema s Data.OpenApi.Internal.Schema => Data.OpenApi.Lens.HasMaxItems s (GHC.Maybe.Maybe GHC.Num.Integer.Integer)
instance Data.OpenApi.Lens.HasSchema s Data.OpenApi.Internal.Schema => Data.OpenApi.Lens.HasMinItems s (GHC.Maybe.Maybe GHC.Num.Integer.Integer)
instance Data.OpenApi.Lens.HasSchema s Data.OpenApi.Internal.Schema => Data.OpenApi.Lens.HasUniqueItems s (GHC.Maybe.Maybe GHC.Types.Bool)
instance Data.OpenApi.Lens.HasSchema s Data.OpenApi.Internal.Schema => Data.OpenApi.Lens.HasEnum s (GHC.Maybe.Maybe [Data.Aeson.Types.Internal.Value])
instance Data.OpenApi.Lens.HasSchema s Data.OpenApi.Internal.Schema => Data.OpenApi.Lens.HasMultipleOf s (GHC.Maybe.Maybe Data.Scientific.Scientific)
instance Data.OpenApi.Lens.HasServer Data.OpenApi.Internal.Link (GHC.Maybe.Maybe Data.OpenApi.Internal.Server)
instance Data.OpenApi.Lens.HasOperationRef Data.OpenApi.Internal.Link (GHC.Maybe.Maybe Data.Text.Internal.Text)
instance Data.OpenApi.Lens.HasDescription Data.OpenApi.Internal.Link (GHC.Maybe.Maybe Data.Text.Internal.Text)
instance Data.OpenApi.Lens.HasOperationId Data.OpenApi.Internal.Link (GHC.Maybe.Maybe Data.Text.Internal.Text)
instance Data.OpenApi.Lens.HasParameters Data.OpenApi.Internal.Link (Data.HashMap.Strict.InsOrd.InsOrdHashMap Data.Text.Internal.Text Data.OpenApi.Internal.ExpressionOrValue)
instance Data.OpenApi.Lens.HasRequestBody Data.OpenApi.Internal.Link (GHC.Maybe.Maybe Data.OpenApi.Internal.ExpressionOrValue)
instance Data.OpenApi.Lens.HasPropertyName Data.OpenApi.Internal.Discriminator Data.Text.Internal.Text
instance Data.OpenApi.Lens.HasMapping Data.OpenApi.Internal.Discriminator (Data.HashMap.Strict.InsOrd.InsOrdHashMap Data.Text.Internal.Text Data.Text.Internal.Text)
instance Data.OpenApi.Lens.HasValue Data.OpenApi.Internal.Example (GHC.Maybe.Maybe Data.Aeson.Types.Internal.Value)
instance Data.OpenApi.Lens.HasExternalValue Data.OpenApi.Internal.Example (GHC.Maybe.Maybe Data.OpenApi.Internal.URL)
instance Data.OpenApi.Lens.HasDescription Data.OpenApi.Internal.Example (GHC.Maybe.Maybe Data.Text.Internal.Text)
instance Data.OpenApi.Lens.HasSummary Data.OpenApi.Internal.Example (GHC.Maybe.Maybe Data.Text.Internal.Text)
instance Data.OpenApi.Lens.HasContentType Data.OpenApi.Internal.Encoding (GHC.Maybe.Maybe Network.HTTP.Media.MediaType.Internal.MediaType)
instance Data.OpenApi.Lens.HasAllowReserved Data.OpenApi.Internal.Encoding (GHC.Maybe.Maybe GHC.Types.Bool)
instance Data.OpenApi.Lens.HasExplode Data.OpenApi.Internal.Encoding (GHC.Maybe.Maybe GHC.Types.Bool)
instance Data.OpenApi.Lens.HasHeaders Data.OpenApi.Internal.Encoding (Data.HashMap.Strict.InsOrd.InsOrdHashMap Data.Text.Internal.Text (Data.OpenApi.Internal.Referenced Data.OpenApi.Internal.Header))
instance Data.OpenApi.Lens.HasStyle Data.OpenApi.Internal.Encoding (GHC.Maybe.Maybe Data.OpenApi.Internal.Style)
instance Data.OpenApi.Lens.HasDescription Data.OpenApi.Internal.ExternalDocs (GHC.Maybe.Maybe Data.Text.Internal.Text)
instance Data.OpenApi.Lens.HasUrl Data.OpenApi.Internal.ExternalDocs Data.OpenApi.Internal.URL
instance Data.OpenApi.Lens.HasPassword Data.OpenApi.Internal.OAuth2Flows (GHC.Maybe.Maybe (Data.OpenApi.Internal.OAuth2Flow Data.OpenApi.Internal.OAuth2PasswordFlow))
instance Data.OpenApi.Lens.HasImplicit Data.OpenApi.Internal.OAuth2Flows (GHC.Maybe.Maybe (Data.OpenApi.Internal.OAuth2Flow Data.OpenApi.Internal.OAuth2ImplicitFlow))
instance Data.OpenApi.Lens.HasClientCredentials Data.OpenApi.Internal.OAuth2Flows (GHC.Maybe.Maybe (Data.OpenApi.Internal.OAuth2Flow Data.OpenApi.Internal.OAuth2ClientCredentialsFlow))
instance Data.OpenApi.Lens.HasAuthorizationCode Data.OpenApi.Internal.OAuth2Flows (GHC.Maybe.Maybe (Data.OpenApi.Internal.OAuth2Flow Data.OpenApi.Internal.OAuth2AuthorizationCodeFlow))
instance Data.OpenApi.Lens.HasAuthorizationUrl Data.OpenApi.Internal.OAuth2AuthorizationCodeFlow Data.OpenApi.Internal.AuthorizationURL
instance Data.OpenApi.Lens.HasTokenUrl Data.OpenApi.Internal.OAuth2AuthorizationCodeFlow Data.OpenApi.Internal.TokenURL
instance Data.OpenApi.Lens.HasTokenUrl Data.OpenApi.Internal.OAuth2ClientCredentialsFlow Data.OpenApi.Internal.TokenURL
instance Data.OpenApi.Lens.HasTokenUrl Data.OpenApi.Internal.OAuth2PasswordFlow Data.OpenApi.Internal.TokenURL
instance Data.OpenApi.Lens.HasAuthorizationUrl Data.OpenApi.Internal.OAuth2ImplicitFlow Data.OpenApi.Internal.AuthorizationURL
instance Data.OpenApi.Lens.HasDescription Data.OpenApi.Internal.SecurityScheme (GHC.Maybe.Maybe Data.Text.Internal.Text)
instance Data.OpenApi.Lens.HasType Data.OpenApi.Internal.SecurityScheme Data.OpenApi.Internal.SecuritySchemeType
instance Data.OpenApi.Lens.HasContent Data.OpenApi.Internal.Response (Data.HashMap.Strict.InsOrd.InsOrdHashMap Network.HTTP.Media.MediaType.Internal.MediaType Data.OpenApi.Internal.MediaTypeObject)
instance Data.OpenApi.Lens.HasDescription Data.OpenApi.Internal.Response Data.Text.Internal.Text
instance Data.OpenApi.Lens.HasHeaders Data.OpenApi.Internal.Response (Data.HashMap.Strict.InsOrd.InsOrdHashMap Data.OpenApi.Internal.HeaderName (Data.OpenApi.Internal.Referenced Data.OpenApi.Internal.Header))
instance Data.OpenApi.Lens.HasLinks Data.OpenApi.Internal.Response (Data.HashMap.Strict.InsOrd.InsOrdHashMap Data.Text.Internal.Text (Data.OpenApi.Internal.Referenced Data.OpenApi.Internal.Link))
instance Data.OpenApi.Lens.HasDefault Data.OpenApi.Internal.Responses (GHC.Maybe.Maybe (Data.OpenApi.Internal.Referenced Data.OpenApi.Internal.Response))
instance Data.OpenApi.Lens.HasResponses Data.OpenApi.Internal.Responses (Data.HashMap.Strict.InsOrd.InsOrdHashMap Data.OpenApi.Internal.HttpStatusCode (Data.OpenApi.Internal.Referenced Data.OpenApi.Internal.Response))
instance Data.OpenApi.Lens.HasWrapped Data.OpenApi.Internal.Xml (GHC.Maybe.Maybe GHC.Types.Bool)
instance Data.OpenApi.Lens.HasPrefix Data.OpenApi.Internal.Xml (GHC.Maybe.Maybe Data.Text.Internal.Text)
instance Data.OpenApi.Lens.HasNamespace Data.OpenApi.Internal.Xml (GHC.Maybe.Maybe Data.Text.Internal.Text)
instance Data.OpenApi.Lens.HasAttribute Data.OpenApi.Internal.Xml (GHC.Maybe.Maybe GHC.Types.Bool)
instance Data.OpenApi.Lens.HasName Data.OpenApi.Internal.Xml (GHC.Maybe.Maybe Data.Text.Internal.Text)
instance Data.OpenApi.Lens.HasName Data.OpenApi.Internal.NamedSchema (GHC.Maybe.Maybe Data.Text.Internal.Text)
instance Data.OpenApi.Lens.HasSchema Data.OpenApi.Internal.NamedSchema Data.OpenApi.Internal.Schema
instance Data.OpenApi.Lens.HasXml Data.OpenApi.Internal.Schema (GHC.Maybe.Maybe Data.OpenApi.Internal.Xml)
instance Data.OpenApi.Lens.HasWriteOnly Data.OpenApi.Internal.Schema (GHC.Maybe.Maybe GHC.Types.Bool)
instance Data.OpenApi.Lens.HasUniqueItems Data.OpenApi.Internal.Schema (GHC.Maybe.Maybe GHC.Types.Bool)
instance Data.OpenApi.Lens.HasType Data.OpenApi.Internal.Schema (GHC.Maybe.Maybe Data.OpenApi.Internal.OpenApiType)
instance Data.OpenApi.Lens.HasReadOnly Data.OpenApi.Internal.Schema (GHC.Maybe.Maybe GHC.Types.Bool)
instance Data.OpenApi.Lens.HasProperties Data.OpenApi.Internal.Schema (Data.HashMap.Strict.InsOrd.InsOrdHashMap Data.Text.Internal.Text (Data.OpenApi.Internal.Referenced Data.OpenApi.Internal.Schema))
instance Data.OpenApi.Lens.HasPattern Data.OpenApi.Internal.Schema (GHC.Maybe.Maybe Data.OpenApi.Internal.Pattern)
instance Data.OpenApi.Lens.HasOneOf Data.OpenApi.Internal.Schema (GHC.Maybe.Maybe [Data.OpenApi.Internal.Referenced Data.OpenApi.Internal.Schema])
instance Data.OpenApi.Lens.HasNullable Data.OpenApi.Internal.Schema (GHC.Maybe.Maybe GHC.Types.Bool)
instance Data.OpenApi.Lens.HasNot Data.OpenApi.Internal.Schema (GHC.Maybe.Maybe (Data.OpenApi.Internal.Referenced Data.OpenApi.Internal.Schema))
instance Data.OpenApi.Lens.HasMultipleOf Data.OpenApi.Internal.Schema (GHC.Maybe.Maybe Data.Scientific.Scientific)
instance Data.OpenApi.Lens.HasMinimum Data.OpenApi.Internal.Schema (GHC.Maybe.Maybe Data.Scientific.Scientific)
instance Data.OpenApi.Lens.HasMinProperties Data.OpenApi.Internal.Schema (GHC.Maybe.Maybe GHC.Num.Integer.Integer)
instance Data.OpenApi.Lens.HasMinLength Data.OpenApi.Internal.Schema (GHC.Maybe.Maybe GHC.Num.Integer.Integer)
instance Data.OpenApi.Lens.HasMinItems Data.OpenApi.Internal.Schema (GHC.Maybe.Maybe GHC.Num.Integer.Integer)
instance Data.OpenApi.Lens.HasMaximum Data.OpenApi.Internal.Schema (GHC.Maybe.Maybe Data.Scientific.Scientific)
instance Data.OpenApi.Lens.HasMaxProperties Data.OpenApi.Internal.Schema (GHC.Maybe.Maybe GHC.Num.Integer.Integer)
instance Data.OpenApi.Lens.HasMaxLength Data.OpenApi.Internal.Schema (GHC.Maybe.Maybe GHC.Num.Integer.Integer)
instance Data.OpenApi.Lens.HasMaxItems Data.OpenApi.Internal.Schema (GHC.Maybe.Maybe GHC.Num.Integer.Integer)
instance Data.OpenApi.Lens.HasItems Data.OpenApi.Internal.Schema (GHC.Maybe.Maybe Data.OpenApi.Internal.OpenApiItems)
instance Data.OpenApi.Lens.HasFormat Data.OpenApi.Internal.Schema (GHC.Maybe.Maybe Data.OpenApi.Internal.Format)
instance Data.OpenApi.Lens.HasExclusiveMinimum Data.OpenApi.Internal.Schema (GHC.Maybe.Maybe GHC.Types.Bool)
instance Data.OpenApi.Lens.HasExclusiveMaximum Data.OpenApi.Internal.Schema (GHC.Maybe.Maybe GHC.Types.Bool)
instance Data.OpenApi.Lens.HasEnum Data.OpenApi.Internal.Schema (GHC.Maybe.Maybe [Data.Aeson.Types.Internal.Value])
instance Data.OpenApi.Lens.HasDiscriminator Data.OpenApi.Internal.Schema (GHC.Maybe.Maybe Data.OpenApi.Internal.Discriminator)
instance Data.OpenApi.Lens.HasDefault Data.OpenApi.Internal.Schema (GHC.Maybe.Maybe Data.Aeson.Types.Internal.Value)
instance Data.OpenApi.Lens.HasAnyOf Data.OpenApi.Internal.Schema (GHC.Maybe.Maybe [Data.OpenApi.Internal.Referenced Data.OpenApi.Internal.Schema])
instance Data.OpenApi.Lens.HasAllOf Data.OpenApi.Internal.Schema (GHC.Maybe.Maybe [Data.OpenApi.Internal.Referenced Data.OpenApi.Internal.Schema])
instance Data.OpenApi.Lens.HasAdditionalProperties Data.OpenApi.Internal.Schema (GHC.Maybe.Maybe Data.OpenApi.Internal.AdditionalProperties)
instance Data.OpenApi.Lens.HasDeprecated Data.OpenApi.Internal.Schema (GHC.Maybe.Maybe GHC.Types.Bool)
instance Data.OpenApi.Lens.HasDescription Data.OpenApi.Internal.Schema (GHC.Maybe.Maybe Data.Text.Internal.Text)
instance Data.OpenApi.Lens.HasExample Data.OpenApi.Internal.Schema (GHC.Maybe.Maybe Data.Aeson.Types.Internal.Value)
instance Data.OpenApi.Lens.HasExternalDocs Data.OpenApi.Internal.Schema (GHC.Maybe.Maybe Data.OpenApi.Internal.ExternalDocs)
instance Data.OpenApi.Lens.HasRequired Data.OpenApi.Internal.Schema [Data.OpenApi.Internal.ParamName]
instance Data.OpenApi.Lens.HasTitle Data.OpenApi.Internal.Schema (GHC.Maybe.Maybe Data.Text.Internal.Text)
instance Data.OpenApi.Lens.HasAllowEmptyValue Data.OpenApi.Internal.Header (GHC.Maybe.Maybe GHC.Types.Bool)
instance Data.OpenApi.Lens.HasDeprecated Data.OpenApi.Internal.Header (GHC.Maybe.Maybe GHC.Types.Bool)
instance Data.OpenApi.Lens.HasDescription Data.OpenApi.Internal.Header (GHC.Maybe.Maybe Data.OpenApi.Internal.HeaderName)
instance Data.OpenApi.Lens.HasExample Data.OpenApi.Internal.Header (GHC.Maybe.Maybe Data.Aeson.Types.Internal.Value)
instance Data.OpenApi.Lens.HasExamples Data.OpenApi.Internal.Header (Data.HashMap.Strict.InsOrd.InsOrdHashMap Data.Text.Internal.Text (Data.OpenApi.Internal.Referenced Data.OpenApi.Internal.Example))
instance Data.OpenApi.Lens.HasExplode Data.OpenApi.Internal.Header (GHC.Maybe.Maybe GHC.Types.Bool)
instance Data.OpenApi.Lens.HasRequired Data.OpenApi.Internal.Header (GHC.Maybe.Maybe GHC.Types.Bool)
instance Data.OpenApi.Lens.HasSchema Data.OpenApi.Internal.Header (GHC.Maybe.Maybe (Data.OpenApi.Internal.Referenced Data.OpenApi.Internal.Schema))
instance Data.OpenApi.Lens.HasStyle Data.OpenApi.Internal.Param (GHC.Maybe.Maybe Data.OpenApi.Internal.Style)
instance Data.OpenApi.Lens.HasIn Data.OpenApi.Internal.Param Data.OpenApi.Internal.ParamLocation
instance Data.OpenApi.Lens.HasExplode Data.OpenApi.Internal.Param (GHC.Maybe.Maybe GHC.Types.Bool)
instance Data.OpenApi.Lens.HasAllowReserved Data.OpenApi.Internal.Param (GHC.Maybe.Maybe GHC.Types.Bool)
instance Data.OpenApi.Lens.HasAllowEmptyValue Data.OpenApi.Internal.Param (GHC.Maybe.Maybe GHC.Types.Bool)
instance Data.OpenApi.Lens.HasDeprecated Data.OpenApi.Internal.Param (GHC.Maybe.Maybe GHC.Types.Bool)
instance Data.OpenApi.Lens.HasDescription Data.OpenApi.Internal.Param (GHC.Maybe.Maybe Data.Text.Internal.Text)
instance Data.OpenApi.Lens.HasExample Data.OpenApi.Internal.Param (GHC.Maybe.Maybe Data.Aeson.Types.Internal.Value)
instance Data.OpenApi.Lens.HasExamples Data.OpenApi.Internal.Param (Data.HashMap.Strict.InsOrd.InsOrdHashMap Data.Text.Internal.Text (Data.OpenApi.Internal.Referenced Data.OpenApi.Internal.Example))
instance Data.OpenApi.Lens.HasName Data.OpenApi.Internal.Param Data.Text.Internal.Text
instance Data.OpenApi.Lens.HasRequired Data.OpenApi.Internal.Param (GHC.Maybe.Maybe GHC.Types.Bool)
instance Data.OpenApi.Lens.HasSchema Data.OpenApi.Internal.Param (GHC.Maybe.Maybe (Data.OpenApi.Internal.Referenced Data.OpenApi.Internal.Schema))
instance Data.OpenApi.Lens.HasRequestBody Data.OpenApi.Internal.Operation (GHC.Maybe.Maybe (Data.OpenApi.Internal.Referenced Data.OpenApi.Internal.RequestBody))
instance Data.OpenApi.Lens.HasOperationId Data.OpenApi.Internal.Operation (GHC.Maybe.Maybe Data.Text.Internal.Text)
instance Data.OpenApi.Lens.HasDeprecated Data.OpenApi.Internal.Operation (GHC.Maybe.Maybe GHC.Types.Bool)
instance Data.OpenApi.Lens.HasCallbacks Data.OpenApi.Internal.Operation (Data.HashMap.Strict.InsOrd.InsOrdHashMap Data.Text.Internal.Text (Data.OpenApi.Internal.Referenced Data.OpenApi.Internal.Callback))
instance Data.OpenApi.Lens.HasDescription Data.OpenApi.Internal.Operation (GHC.Maybe.Maybe Data.Text.Internal.Text)
instance Data.OpenApi.Lens.HasExternalDocs Data.OpenApi.Internal.Operation (GHC.Maybe.Maybe Data.OpenApi.Internal.ExternalDocs)
instance Data.OpenApi.Lens.HasParameters Data.OpenApi.Internal.Operation [Data.OpenApi.Internal.Referenced Data.OpenApi.Internal.Param]
instance Data.OpenApi.Lens.HasResponses Data.OpenApi.Internal.Operation Data.OpenApi.Internal.Responses
instance Data.OpenApi.Lens.HasSecurity Data.OpenApi.Internal.Operation [Data.OpenApi.Internal.SecurityRequirement]
instance Data.OpenApi.Lens.HasServers Data.OpenApi.Internal.Operation [Data.OpenApi.Internal.Server]
instance Data.OpenApi.Lens.HasSummary Data.OpenApi.Internal.Operation (GHC.Maybe.Maybe Data.Text.Internal.Text)
instance Data.OpenApi.Lens.HasTags Data.OpenApi.Internal.Operation (Data.HashSet.InsOrd.InsOrdHashSet Data.OpenApi.Internal.TagName)
instance Data.OpenApi.Lens.HasDescription Data.OpenApi.Internal.Tag (GHC.Maybe.Maybe Data.Text.Internal.Text)
instance Data.OpenApi.Lens.HasExternalDocs Data.OpenApi.Internal.Tag (GHC.Maybe.Maybe Data.OpenApi.Internal.ExternalDocs)
instance Data.OpenApi.Lens.HasName Data.OpenApi.Internal.Tag Data.OpenApi.Internal.TagName
instance Data.OpenApi.Lens.HasTrace Data.OpenApi.Internal.PathItem (GHC.Maybe.Maybe Data.OpenApi.Internal.Operation)
instance Data.OpenApi.Lens.HasSummary Data.OpenApi.Internal.PathItem (GHC.Maybe.Maybe Data.Text.Internal.Text)
instance Data.OpenApi.Lens.HasPut Data.OpenApi.Internal.PathItem (GHC.Maybe.Maybe Data.OpenApi.Internal.Operation)
instance Data.OpenApi.Lens.HasPost Data.OpenApi.Internal.PathItem (GHC.Maybe.Maybe Data.OpenApi.Internal.Operation)
instance Data.OpenApi.Lens.HasPatch Data.OpenApi.Internal.PathItem (GHC.Maybe.Maybe Data.OpenApi.Internal.Operation)
instance Data.OpenApi.Lens.HasOptions Data.OpenApi.Internal.PathItem (GHC.Maybe.Maybe Data.OpenApi.Internal.Operation)
instance Data.OpenApi.Lens.HasHead Data.OpenApi.Internal.PathItem (GHC.Maybe.Maybe Data.OpenApi.Internal.Operation)
instance Data.OpenApi.Lens.HasGet Data.OpenApi.Internal.PathItem (GHC.Maybe.Maybe Data.OpenApi.Internal.Operation)
instance Data.OpenApi.Lens.HasDelete Data.OpenApi.Internal.PathItem (GHC.Maybe.Maybe Data.OpenApi.Internal.Operation)
instance Data.OpenApi.Lens.HasDescription Data.OpenApi.Internal.PathItem (GHC.Maybe.Maybe Data.Text.Internal.Text)
instance Data.OpenApi.Lens.HasParameters Data.OpenApi.Internal.PathItem [Data.OpenApi.Internal.Referenced Data.OpenApi.Internal.Param]
instance Data.OpenApi.Lens.HasServers Data.OpenApi.Internal.PathItem [Data.OpenApi.Internal.Server]
instance Data.OpenApi.Lens.HasName Data.OpenApi.Internal.License Data.Text.Internal.Text
instance Data.OpenApi.Lens.HasUrl Data.OpenApi.Internal.License (GHC.Maybe.Maybe Data.OpenApi.Internal.URL)
instance Data.OpenApi.Lens.HasName Data.OpenApi.Internal.Contact (GHC.Maybe.Maybe Data.Text.Internal.Text)
instance Data.OpenApi.Lens.HasEmail Data.OpenApi.Internal.Contact (GHC.Maybe.Maybe Data.Text.Internal.Text)
instance Data.OpenApi.Lens.HasUrl Data.OpenApi.Internal.Contact (GHC.Maybe.Maybe Data.OpenApi.Internal.URL)
instance Data.OpenApi.Lens.HasVersion Data.OpenApi.Internal.Info Data.Text.Internal.Text
instance Data.OpenApi.Lens.HasTitle Data.OpenApi.Internal.Info Data.Text.Internal.Text
instance Data.OpenApi.Lens.HasTermsOfService Data.OpenApi.Internal.Info (GHC.Maybe.Maybe Data.Text.Internal.Text)
instance Data.OpenApi.Lens.HasLicense Data.OpenApi.Internal.Info (GHC.Maybe.Maybe Data.OpenApi.Internal.License)
instance Data.OpenApi.Lens.HasContact Data.OpenApi.Internal.Info (GHC.Maybe.Maybe Data.OpenApi.Internal.Contact)
instance Data.OpenApi.Lens.HasDescription Data.OpenApi.Internal.Info (GHC.Maybe.Maybe Data.Text.Internal.Text)
instance Data.OpenApi.Lens.HasSchema Data.OpenApi.Internal.MediaTypeObject (GHC.Maybe.Maybe (Data.OpenApi.Internal.Referenced Data.OpenApi.Internal.Schema))
instance Data.OpenApi.Lens.HasExample Data.OpenApi.Internal.MediaTypeObject (GHC.Maybe.Maybe Data.Aeson.Types.Internal.Value)
instance Data.OpenApi.Lens.HasEncoding Data.OpenApi.Internal.MediaTypeObject (Data.HashMap.Strict.InsOrd.InsOrdHashMap Data.Text.Internal.Text Data.OpenApi.Internal.Encoding)
instance Data.OpenApi.Lens.HasExamples Data.OpenApi.Internal.MediaTypeObject (Data.HashMap.Strict.InsOrd.InsOrdHashMap Data.Text.Internal.Text (Data.OpenApi.Internal.Referenced Data.OpenApi.Internal.Example))
instance Data.OpenApi.Lens.HasRequired Data.OpenApi.Internal.RequestBody (GHC.Maybe.Maybe GHC.Types.Bool)
instance Data.OpenApi.Lens.HasContent Data.OpenApi.Internal.RequestBody (Data.HashMap.Strict.InsOrd.InsOrdHashMap Network.HTTP.Media.MediaType.Internal.MediaType Data.OpenApi.Internal.MediaTypeObject)
instance Data.OpenApi.Lens.HasDescription Data.OpenApi.Internal.RequestBody (GHC.Maybe.Maybe Data.Text.Internal.Text)
instance Data.OpenApi.Lens.HasVariables Data.OpenApi.Internal.Server (Data.HashMap.Strict.InsOrd.InsOrdHashMap Data.Text.Internal.Text Data.OpenApi.Internal.ServerVariable)
instance Data.OpenApi.Lens.HasUrl Data.OpenApi.Internal.Server Data.Text.Internal.Text
instance Data.OpenApi.Lens.HasDescription Data.OpenApi.Internal.Server (GHC.Maybe.Maybe Data.Text.Internal.Text)
instance Data.OpenApi.Lens.HasSecuritySchemes Data.OpenApi.Internal.Components Data.OpenApi.Internal.SecurityDefinitions
instance Data.OpenApi.Lens.HasSchemas Data.OpenApi.Internal.Components (Data.OpenApi.Internal.Definitions Data.OpenApi.Internal.Schema)
instance Data.OpenApi.Lens.HasResponses Data.OpenApi.Internal.Components (Data.OpenApi.Internal.Definitions Data.OpenApi.Internal.Response)
instance Data.OpenApi.Lens.HasRequestBodies Data.OpenApi.Internal.Components (Data.OpenApi.Internal.Definitions Data.OpenApi.Internal.RequestBody)
instance Data.OpenApi.Lens.HasParameters Data.OpenApi.Internal.Components (Data.OpenApi.Internal.Definitions Data.OpenApi.Internal.Param)
instance Data.OpenApi.Lens.HasLinks Data.OpenApi.Internal.Components (Data.OpenApi.Internal.Definitions Data.OpenApi.Internal.Link)
instance Data.OpenApi.Lens.HasHeaders Data.OpenApi.Internal.Components (Data.OpenApi.Internal.Definitions Data.OpenApi.Internal.Header)
instance Data.OpenApi.Lens.HasExamples Data.OpenApi.Internal.Components (Data.OpenApi.Internal.Definitions Data.OpenApi.Internal.Example)
instance Data.OpenApi.Lens.HasCallbacks Data.OpenApi.Internal.Components (Data.OpenApi.Internal.Definitions Data.OpenApi.Internal.Callback)
instance Data.OpenApi.Lens.HasTags Data.OpenApi.Internal.OpenApi (Data.HashSet.InsOrd.InsOrdHashSet Data.OpenApi.Internal.Tag)
instance Data.OpenApi.Lens.HasServers Data.OpenApi.Internal.OpenApi [Data.OpenApi.Internal.Server]
instance Data.OpenApi.Lens.HasSecurity Data.OpenApi.Internal.OpenApi [Data.OpenApi.Internal.SecurityRequirement]
instance Data.OpenApi.Lens.HasPaths Data.OpenApi.Internal.OpenApi (Data.HashMap.Strict.InsOrd.InsOrdHashMap GHC.IO.FilePath Data.OpenApi.Internal.PathItem)
instance Data.OpenApi.Lens.HasOpenapi Data.OpenApi.Internal.OpenApi Data.OpenApi.Internal.OpenApiSpecVersion
instance Data.OpenApi.Lens.HasInfo Data.OpenApi.Internal.OpenApi Data.OpenApi.Internal.Info
instance Data.OpenApi.Lens.HasExternalDocs Data.OpenApi.Internal.OpenApi (GHC.Maybe.Maybe Data.OpenApi.Internal.ExternalDocs)
instance Data.OpenApi.Lens.HasComponents Data.OpenApi.Internal.OpenApi Data.OpenApi.Internal.Components


-- | Lenses and prisms for the <a>optics</a> library.
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Aeson
--   
--   &gt;&gt;&gt; import Optics.Core
--   
--   &gt;&gt;&gt; :set -XOverloadedLabels
--   
--   &gt;&gt;&gt; import qualified Data.ByteString.Lazy.Char8 as BSL
--   
--   &gt;&gt;&gt; import qualified Data.HashMap.Strict.InsOrd as IOHM
--   </pre>
--   
--   Example from the <a>Data.OpenApi</a> module using <tt>optics</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; :{
--   BSL.putStrLn $ encodePretty $ (mempty :: OpenApi)
--     &amp; #components % #schemas .~ IOHM.fromList [ ("User", mempty &amp; #type ?~ OpenApiString) ]
--     &amp; #paths .~
--       IOHM.fromList [ ("/user", mempty &amp; #get ?~ (mempty
--           &amp; at 200 ?~ ("OK" &amp; #_Inline % #content % at "application/json" ?~ (mempty &amp; #schema ?~ Ref (Reference "User")))
--           &amp; at 404 ?~ "User info not found")) ]
--   :}
--   {
--       "components": {
--           "schemas": {
--               "User": {
--                   "type": "string"
--               }
--           }
--       },
--       "info": {
--           "title": "",
--           "version": ""
--       },
--       "openapi": "3.0.0",
--       "paths": {
--           "/user": {
--               "get": {
--                   "responses": {
--                       "200": {
--                           "content": {
--                               "application/json": {
--                                   "schema": {
--                                       "$ref": "#/components/schemas/User"
--                                   }
--                               }
--                           },
--                           "description": "OK"
--                       },
--                       "404": {
--                           "description": "User info not found"
--                       }
--                   }
--               }
--           }
--       }
--   }
--   </pre>
--   
--   For convenience optics are defined as <i>labels</i>. It means that
--   field accessor names can be overloaded for different types. One such
--   common field is <tt>#description</tt>. Many components of a Swagger
--   specification can have descriptions, and you can use the same name for
--   them:
--   
--   <pre>
--   &gt;&gt;&gt; BSL.putStrLn $ encodePretty $ (mempty :: Response) &amp; #description .~ "No content"
--   {
--       "description": "No content"
--   }
--   
--   &gt;&gt;&gt; :{
--   BSL.putStrLn $ encodePretty $ (mempty :: Schema)
--     &amp; #type        ?~ OpenApiBoolean
--     &amp; #description ?~ "To be or not to be"
--   :}
--   {
--       "description": "To be or not to be",
--       "type": "boolean"
--   }
--   </pre>
--   
--   Additionally, to simplify working with <tt><a>Response</a></tt>, both
--   <tt><a>Operation</a></tt> and <tt><a>Responses</a></tt> have direct
--   access to it via <tt><a>at</a></tt>. Example:
--   
--   <pre>
--   &gt;&gt;&gt; :{
--   BSL.putStrLn $ encodePretty $ (mempty :: Operation)
--     &amp; at 404 ?~ "Not found"
--   :}
--   {
--       "responses": {
--           "404": {
--               "description": "Not found"
--           }
--       }
--   }
--   </pre>
module Data.OpenApi.Optics
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Prism, a1 GHC.Types.~ Data.OpenApi.Internal.Reference, b GHC.Types.~ Data.OpenApi.Internal.Reference) => Optics.Label.LabelOptic "_Ref" k (Data.OpenApi.Internal.Referenced a2) (Data.OpenApi.Internal.Referenced a2) a1 b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Prism, a1 GHC.Types.~ a2, b GHC.Types.~ a3) => Optics.Label.LabelOptic "_Inline" k (Data.OpenApi.Internal.Referenced a2) (Data.OpenApi.Internal.Referenced a3) a1 b
instance (a GHC.Types.~ [Data.OpenApi.Internal.Referenced Data.OpenApi.Internal.Schema], b GHC.Types.~ [Data.OpenApi.Internal.Referenced Data.OpenApi.Internal.Schema]) => Optics.Label.LabelOptic "_OpenApiItemsArray" Optics.Internal.Optic.Types.A_Review Data.OpenApi.Internal.OpenApiItems Data.OpenApi.Internal.OpenApiItems a b
instance (a GHC.Types.~ Data.OpenApi.Internal.Referenced Data.OpenApi.Internal.Schema, b GHC.Types.~ Data.OpenApi.Internal.Referenced Data.OpenApi.Internal.Schema) => Optics.Label.LabelOptic "_OpenApiItemsObject" Optics.Internal.Optic.Types.A_Review Data.OpenApi.Internal.OpenApiItems Data.OpenApi.Internal.OpenApiItems a b
instance Optics.At.Core.Ixed Data.OpenApi.Internal.Responses
instance Optics.At.Core.At Data.OpenApi.Internal.Responses
instance Optics.At.Core.Ixed Data.OpenApi.Internal.Operation
instance Optics.At.Core.At Data.OpenApi.Internal.Operation
instance (a GHC.Types.~ GHC.Maybe.Maybe Data.OpenApi.Internal.OpenApiType, b GHC.Types.~ GHC.Maybe.Maybe Data.OpenApi.Internal.OpenApiType) => Optics.Label.LabelOptic "type" Optics.Internal.Optic.Types.A_Lens Data.OpenApi.Internal.NamedSchema Data.OpenApi.Internal.NamedSchema a b
instance (a GHC.Types.~ GHC.Maybe.Maybe Data.Aeson.Types.Internal.Value, b GHC.Types.~ GHC.Maybe.Maybe Data.Aeson.Types.Internal.Value) => Optics.Label.LabelOptic "default" Optics.Internal.Optic.Types.A_Lens Data.OpenApi.Internal.NamedSchema Data.OpenApi.Internal.NamedSchema a b
instance (a GHC.Types.~ GHC.Maybe.Maybe Data.OpenApi.Internal.Format, b GHC.Types.~ GHC.Maybe.Maybe Data.OpenApi.Internal.Format) => Optics.Label.LabelOptic "format" Optics.Internal.Optic.Types.A_Lens Data.OpenApi.Internal.NamedSchema Data.OpenApi.Internal.NamedSchema a b
instance (a GHC.Types.~ GHC.Maybe.Maybe Data.OpenApi.Internal.OpenApiItems, b GHC.Types.~ GHC.Maybe.Maybe Data.OpenApi.Internal.OpenApiItems) => Optics.Label.LabelOptic "items" Optics.Internal.Optic.Types.A_Lens Data.OpenApi.Internal.NamedSchema Data.OpenApi.Internal.NamedSchema a b
instance (a GHC.Types.~ GHC.Maybe.Maybe Data.Scientific.Scientific, b GHC.Types.~ GHC.Maybe.Maybe Data.Scientific.Scientific) => Optics.Label.LabelOptic "maximum" Optics.Internal.Optic.Types.A_Lens Data.OpenApi.Internal.NamedSchema Data.OpenApi.Internal.NamedSchema a b
instance (a GHC.Types.~ GHC.Maybe.Maybe GHC.Types.Bool, b GHC.Types.~ GHC.Maybe.Maybe GHC.Types.Bool) => Optics.Label.LabelOptic "exclusiveMaximum" Optics.Internal.Optic.Types.A_Lens Data.OpenApi.Internal.NamedSchema Data.OpenApi.Internal.NamedSchema a b
instance (a GHC.Types.~ GHC.Maybe.Maybe Data.Scientific.Scientific, b GHC.Types.~ GHC.Maybe.Maybe Data.Scientific.Scientific) => Optics.Label.LabelOptic "minimum" Optics.Internal.Optic.Types.A_Lens Data.OpenApi.Internal.NamedSchema Data.OpenApi.Internal.NamedSchema a b
instance (a GHC.Types.~ GHC.Maybe.Maybe GHC.Types.Bool, b GHC.Types.~ GHC.Maybe.Maybe GHC.Types.Bool) => Optics.Label.LabelOptic "exclusiveMinimum" Optics.Internal.Optic.Types.A_Lens Data.OpenApi.Internal.NamedSchema Data.OpenApi.Internal.NamedSchema a b
instance (a GHC.Types.~ GHC.Maybe.Maybe GHC.Num.Integer.Integer, b GHC.Types.~ GHC.Maybe.Maybe GHC.Num.Integer.Integer) => Optics.Label.LabelOptic "maxLength" Optics.Internal.Optic.Types.A_Lens Data.OpenApi.Internal.NamedSchema Data.OpenApi.Internal.NamedSchema a b
instance (a GHC.Types.~ GHC.Maybe.Maybe GHC.Num.Integer.Integer, b GHC.Types.~ GHC.Maybe.Maybe GHC.Num.Integer.Integer) => Optics.Label.LabelOptic "minLength" Optics.Internal.Optic.Types.A_Lens Data.OpenApi.Internal.NamedSchema Data.OpenApi.Internal.NamedSchema a b
instance (a GHC.Types.~ GHC.Maybe.Maybe Data.Text.Internal.Text, b GHC.Types.~ GHC.Maybe.Maybe Data.Text.Internal.Text) => Optics.Label.LabelOptic "pattern" Optics.Internal.Optic.Types.A_Lens Data.OpenApi.Internal.NamedSchema Data.OpenApi.Internal.NamedSchema a b
instance (a GHC.Types.~ GHC.Maybe.Maybe GHC.Num.Integer.Integer, b GHC.Types.~ GHC.Maybe.Maybe GHC.Num.Integer.Integer) => Optics.Label.LabelOptic "maxItems" Optics.Internal.Optic.Types.A_Lens Data.OpenApi.Internal.NamedSchema Data.OpenApi.Internal.NamedSchema a b
instance (a GHC.Types.~ GHC.Maybe.Maybe GHC.Num.Integer.Integer, b GHC.Types.~ GHC.Maybe.Maybe GHC.Num.Integer.Integer) => Optics.Label.LabelOptic "minItems" Optics.Internal.Optic.Types.A_Lens Data.OpenApi.Internal.NamedSchema Data.OpenApi.Internal.NamedSchema a b
instance (a GHC.Types.~ GHC.Maybe.Maybe GHC.Types.Bool, b GHC.Types.~ GHC.Maybe.Maybe GHC.Types.Bool) => Optics.Label.LabelOptic "uniqueItems" Optics.Internal.Optic.Types.A_Lens Data.OpenApi.Internal.NamedSchema Data.OpenApi.Internal.NamedSchema a b
instance (a GHC.Types.~ GHC.Maybe.Maybe [Data.Aeson.Types.Internal.Value], b GHC.Types.~ GHC.Maybe.Maybe [Data.Aeson.Types.Internal.Value]) => Optics.Label.LabelOptic "enum" Optics.Internal.Optic.Types.A_Lens Data.OpenApi.Internal.NamedSchema Data.OpenApi.Internal.NamedSchema a b
instance (a GHC.Types.~ GHC.Maybe.Maybe Data.Scientific.Scientific, b GHC.Types.~ GHC.Maybe.Maybe Data.Scientific.Scientific) => Optics.Label.LabelOptic "multipleOf" Optics.Internal.Optic.Types.A_Lens Data.OpenApi.Internal.NamedSchema Data.OpenApi.Internal.NamedSchema a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Prism, a GHC.Types.~ Data.OpenApi.Internal.HttpSchemeType, b GHC.Types.~ Data.OpenApi.Internal.HttpSchemeType) => Optics.Label.LabelOptic "_SecuritySchemeHttp" k Data.OpenApi.Internal.SecuritySchemeType Data.OpenApi.Internal.SecuritySchemeType a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Prism, a GHC.Types.~ Data.OpenApi.Internal.ApiKeyParams, b GHC.Types.~ Data.OpenApi.Internal.ApiKeyParams) => Optics.Label.LabelOptic "_SecuritySchemeApiKey" k Data.OpenApi.Internal.SecuritySchemeType Data.OpenApi.Internal.SecuritySchemeType a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Prism, a GHC.Types.~ Data.OpenApi.Internal.OAuth2Flows, b GHC.Types.~ Data.OpenApi.Internal.OAuth2Flows) => Optics.Label.LabelOptic "_SecuritySchemeOAuth2" k Data.OpenApi.Internal.SecuritySchemeType Data.OpenApi.Internal.SecuritySchemeType a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Prism, a GHC.Types.~ Data.OpenApi.Internal.URL, b GHC.Types.~ Data.OpenApi.Internal.URL) => Optics.Label.LabelOptic "_SecuritySchemeOpenIdConnect" k Data.OpenApi.Internal.SecuritySchemeType Data.OpenApi.Internal.SecuritySchemeType a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Lens, a GHC.Types.~ GHC.Maybe.Maybe Data.Text.Internal.Text, b GHC.Types.~ GHC.Maybe.Maybe Data.Text.Internal.Text) => Optics.Label.LabelOptic "description" k Data.OpenApi.Internal.Link Data.OpenApi.Internal.Link a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Lens, a GHC.Types.~ GHC.Maybe.Maybe Data.Text.Internal.Text, b GHC.Types.~ GHC.Maybe.Maybe Data.Text.Internal.Text) => Optics.Label.LabelOptic "operationId" k Data.OpenApi.Internal.Link Data.OpenApi.Internal.Link a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Lens, a GHC.Types.~ GHC.Maybe.Maybe Data.Text.Internal.Text, b GHC.Types.~ GHC.Maybe.Maybe Data.Text.Internal.Text) => Optics.Label.LabelOptic "operationRef" k Data.OpenApi.Internal.Link Data.OpenApi.Internal.Link a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Lens, a GHC.Types.~ Data.HashMap.Strict.InsOrd.InsOrdHashMap Data.Text.Internal.Text Data.OpenApi.Internal.ExpressionOrValue, b GHC.Types.~ Data.HashMap.Strict.InsOrd.InsOrdHashMap Data.Text.Internal.Text Data.OpenApi.Internal.ExpressionOrValue) => Optics.Label.LabelOptic "parameters" k Data.OpenApi.Internal.Link Data.OpenApi.Internal.Link a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Lens, a GHC.Types.~ GHC.Maybe.Maybe Data.OpenApi.Internal.ExpressionOrValue, b GHC.Types.~ GHC.Maybe.Maybe Data.OpenApi.Internal.ExpressionOrValue) => Optics.Label.LabelOptic "requestBody" k Data.OpenApi.Internal.Link Data.OpenApi.Internal.Link a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Lens, a GHC.Types.~ GHC.Maybe.Maybe Data.OpenApi.Internal.Server, b GHC.Types.~ GHC.Maybe.Maybe Data.OpenApi.Internal.Server) => Optics.Label.LabelOptic "server" k Data.OpenApi.Internal.Link Data.OpenApi.Internal.Link a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Lens, a GHC.Types.~ Data.HashMap.Strict.InsOrd.InsOrdHashMap Data.Text.Internal.Text Data.Text.Internal.Text, b GHC.Types.~ Data.HashMap.Strict.InsOrd.InsOrdHashMap Data.Text.Internal.Text Data.Text.Internal.Text) => Optics.Label.LabelOptic "mapping" k Data.OpenApi.Internal.Discriminator Data.OpenApi.Internal.Discriminator a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Lens, a GHC.Types.~ Data.Text.Internal.Text, b GHC.Types.~ Data.Text.Internal.Text) => Optics.Label.LabelOptic "propertyName" k Data.OpenApi.Internal.Discriminator Data.OpenApi.Internal.Discriminator a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Lens, a GHC.Types.~ GHC.Maybe.Maybe Data.Text.Internal.Text, b GHC.Types.~ GHC.Maybe.Maybe Data.Text.Internal.Text) => Optics.Label.LabelOptic "description" k Data.OpenApi.Internal.Example Data.OpenApi.Internal.Example a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Lens, a GHC.Types.~ GHC.Maybe.Maybe Data.OpenApi.Internal.URL, b GHC.Types.~ GHC.Maybe.Maybe Data.OpenApi.Internal.URL) => Optics.Label.LabelOptic "externalValue" k Data.OpenApi.Internal.Example Data.OpenApi.Internal.Example a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Lens, a GHC.Types.~ GHC.Maybe.Maybe Data.Text.Internal.Text, b GHC.Types.~ GHC.Maybe.Maybe Data.Text.Internal.Text) => Optics.Label.LabelOptic "summary" k Data.OpenApi.Internal.Example Data.OpenApi.Internal.Example a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Lens, a GHC.Types.~ GHC.Maybe.Maybe Data.Aeson.Types.Internal.Value, b GHC.Types.~ GHC.Maybe.Maybe Data.Aeson.Types.Internal.Value) => Optics.Label.LabelOptic "value" k Data.OpenApi.Internal.Example Data.OpenApi.Internal.Example a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Lens, a GHC.Types.~ GHC.Maybe.Maybe GHC.Types.Bool, b GHC.Types.~ GHC.Maybe.Maybe GHC.Types.Bool) => Optics.Label.LabelOptic "allowReserved" k Data.OpenApi.Internal.Encoding Data.OpenApi.Internal.Encoding a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Lens, a GHC.Types.~ GHC.Maybe.Maybe Network.HTTP.Media.MediaType.Internal.MediaType, b GHC.Types.~ GHC.Maybe.Maybe Network.HTTP.Media.MediaType.Internal.MediaType) => Optics.Label.LabelOptic "contentType" k Data.OpenApi.Internal.Encoding Data.OpenApi.Internal.Encoding a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Lens, a GHC.Types.~ GHC.Maybe.Maybe GHC.Types.Bool, b GHC.Types.~ GHC.Maybe.Maybe GHC.Types.Bool) => Optics.Label.LabelOptic "explode" k Data.OpenApi.Internal.Encoding Data.OpenApi.Internal.Encoding a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Lens, a GHC.Types.~ Data.HashMap.Strict.InsOrd.InsOrdHashMap Data.Text.Internal.Text (Data.OpenApi.Internal.Referenced Data.OpenApi.Internal.Header), b GHC.Types.~ Data.HashMap.Strict.InsOrd.InsOrdHashMap Data.Text.Internal.Text (Data.OpenApi.Internal.Referenced Data.OpenApi.Internal.Header)) => Optics.Label.LabelOptic "headers" k Data.OpenApi.Internal.Encoding Data.OpenApi.Internal.Encoding a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Lens, a GHC.Types.~ GHC.Maybe.Maybe Data.OpenApi.Internal.Style, b GHC.Types.~ GHC.Maybe.Maybe Data.OpenApi.Internal.Style) => Optics.Label.LabelOptic "style" k Data.OpenApi.Internal.Encoding Data.OpenApi.Internal.Encoding a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Lens, a GHC.Types.~ GHC.Maybe.Maybe Data.Text.Internal.Text, b GHC.Types.~ GHC.Maybe.Maybe Data.Text.Internal.Text) => Optics.Label.LabelOptic "description" k Data.OpenApi.Internal.ExternalDocs Data.OpenApi.Internal.ExternalDocs a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Lens, a GHC.Types.~ Data.OpenApi.Internal.URL, b GHC.Types.~ Data.OpenApi.Internal.URL) => Optics.Label.LabelOptic "url" k Data.OpenApi.Internal.ExternalDocs Data.OpenApi.Internal.ExternalDocs a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Lens, a GHC.Types.~ GHC.Maybe.Maybe (Data.OpenApi.Internal.OAuth2Flow Data.OpenApi.Internal.OAuth2AuthorizationCodeFlow), b GHC.Types.~ GHC.Maybe.Maybe (Data.OpenApi.Internal.OAuth2Flow Data.OpenApi.Internal.OAuth2AuthorizationCodeFlow)) => Optics.Label.LabelOptic "authorizationCode" k Data.OpenApi.Internal.OAuth2Flows Data.OpenApi.Internal.OAuth2Flows a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Lens, a GHC.Types.~ GHC.Maybe.Maybe (Data.OpenApi.Internal.OAuth2Flow Data.OpenApi.Internal.OAuth2ClientCredentialsFlow), b GHC.Types.~ GHC.Maybe.Maybe (Data.OpenApi.Internal.OAuth2Flow Data.OpenApi.Internal.OAuth2ClientCredentialsFlow)) => Optics.Label.LabelOptic "clientCredentials" k Data.OpenApi.Internal.OAuth2Flows Data.OpenApi.Internal.OAuth2Flows a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Lens, a GHC.Types.~ GHC.Maybe.Maybe (Data.OpenApi.Internal.OAuth2Flow Data.OpenApi.Internal.OAuth2ImplicitFlow), b GHC.Types.~ GHC.Maybe.Maybe (Data.OpenApi.Internal.OAuth2Flow Data.OpenApi.Internal.OAuth2ImplicitFlow)) => Optics.Label.LabelOptic "implicit" k Data.OpenApi.Internal.OAuth2Flows Data.OpenApi.Internal.OAuth2Flows a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Lens, a GHC.Types.~ GHC.Maybe.Maybe (Data.OpenApi.Internal.OAuth2Flow Data.OpenApi.Internal.OAuth2PasswordFlow), b GHC.Types.~ GHC.Maybe.Maybe (Data.OpenApi.Internal.OAuth2Flow Data.OpenApi.Internal.OAuth2PasswordFlow)) => Optics.Label.LabelOptic "password" k Data.OpenApi.Internal.OAuth2Flows Data.OpenApi.Internal.OAuth2Flows a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Lens, a GHC.Types.~ Data.OpenApi.Internal.AuthorizationURL, b GHC.Types.~ Data.OpenApi.Internal.AuthorizationURL) => Optics.Label.LabelOptic "authorizationUrl" k Data.OpenApi.Internal.OAuth2AuthorizationCodeFlow Data.OpenApi.Internal.OAuth2AuthorizationCodeFlow a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Lens, a GHC.Types.~ Data.OpenApi.Internal.TokenURL, b GHC.Types.~ Data.OpenApi.Internal.TokenURL) => Optics.Label.LabelOptic "tokenUrl" k Data.OpenApi.Internal.OAuth2AuthorizationCodeFlow Data.OpenApi.Internal.OAuth2AuthorizationCodeFlow a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.An_Iso, a GHC.Types.~ Data.OpenApi.Internal.TokenURL, b GHC.Types.~ Data.OpenApi.Internal.TokenURL) => Optics.Label.LabelOptic "tokenUrl" k Data.OpenApi.Internal.OAuth2ClientCredentialsFlow Data.OpenApi.Internal.OAuth2ClientCredentialsFlow a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.An_Iso, a GHC.Types.~ Data.OpenApi.Internal.TokenURL, b GHC.Types.~ Data.OpenApi.Internal.TokenURL) => Optics.Label.LabelOptic "tokenUrl" k Data.OpenApi.Internal.OAuth2PasswordFlow Data.OpenApi.Internal.OAuth2PasswordFlow a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.An_Iso, a GHC.Types.~ Data.OpenApi.Internal.AuthorizationURL, b GHC.Types.~ Data.OpenApi.Internal.AuthorizationURL) => Optics.Label.LabelOptic "authorizationUrl" k Data.OpenApi.Internal.OAuth2ImplicitFlow Data.OpenApi.Internal.OAuth2ImplicitFlow a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Lens, a GHC.Types.~ GHC.Maybe.Maybe Data.Text.Internal.Text, b GHC.Types.~ GHC.Maybe.Maybe Data.Text.Internal.Text) => Optics.Label.LabelOptic "description" k Data.OpenApi.Internal.SecurityScheme Data.OpenApi.Internal.SecurityScheme a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Lens, a GHC.Types.~ Data.OpenApi.Internal.SecuritySchemeType, b GHC.Types.~ Data.OpenApi.Internal.SecuritySchemeType) => Optics.Label.LabelOptic "type" k Data.OpenApi.Internal.SecurityScheme Data.OpenApi.Internal.SecurityScheme a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Lens, a GHC.Types.~ Data.HashMap.Strict.InsOrd.InsOrdHashMap Network.HTTP.Media.MediaType.Internal.MediaType Data.OpenApi.Internal.MediaTypeObject, b GHC.Types.~ Data.HashMap.Strict.InsOrd.InsOrdHashMap Network.HTTP.Media.MediaType.Internal.MediaType Data.OpenApi.Internal.MediaTypeObject) => Optics.Label.LabelOptic "content" k Data.OpenApi.Internal.Response Data.OpenApi.Internal.Response a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Lens, a GHC.Types.~ Data.Text.Internal.Text, b GHC.Types.~ Data.Text.Internal.Text) => Optics.Label.LabelOptic "description" k Data.OpenApi.Internal.Response Data.OpenApi.Internal.Response a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Lens, a GHC.Types.~ Data.HashMap.Strict.InsOrd.InsOrdHashMap Data.OpenApi.Internal.HeaderName (Data.OpenApi.Internal.Referenced Data.OpenApi.Internal.Header), b GHC.Types.~ Data.HashMap.Strict.InsOrd.InsOrdHashMap Data.OpenApi.Internal.HeaderName (Data.OpenApi.Internal.Referenced Data.OpenApi.Internal.Header)) => Optics.Label.LabelOptic "headers" k Data.OpenApi.Internal.Response Data.OpenApi.Internal.Response a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Lens, a GHC.Types.~ Data.HashMap.Strict.InsOrd.InsOrdHashMap Data.Text.Internal.Text (Data.OpenApi.Internal.Referenced Data.OpenApi.Internal.Link), b GHC.Types.~ Data.HashMap.Strict.InsOrd.InsOrdHashMap Data.Text.Internal.Text (Data.OpenApi.Internal.Referenced Data.OpenApi.Internal.Link)) => Optics.Label.LabelOptic "links" k Data.OpenApi.Internal.Response Data.OpenApi.Internal.Response a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Lens, a GHC.Types.~ GHC.Maybe.Maybe (Data.OpenApi.Internal.Referenced Data.OpenApi.Internal.Response), b GHC.Types.~ GHC.Maybe.Maybe (Data.OpenApi.Internal.Referenced Data.OpenApi.Internal.Response)) => Optics.Label.LabelOptic "default" k Data.OpenApi.Internal.Responses Data.OpenApi.Internal.Responses a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Lens, a GHC.Types.~ Data.HashMap.Strict.InsOrd.InsOrdHashMap Data.OpenApi.Internal.HttpStatusCode (Data.OpenApi.Internal.Referenced Data.OpenApi.Internal.Response), b GHC.Types.~ Data.HashMap.Strict.InsOrd.InsOrdHashMap Data.OpenApi.Internal.HttpStatusCode (Data.OpenApi.Internal.Referenced Data.OpenApi.Internal.Response)) => Optics.Label.LabelOptic "responses" k Data.OpenApi.Internal.Responses Data.OpenApi.Internal.Responses a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Lens, a GHC.Types.~ GHC.Maybe.Maybe GHC.Types.Bool, b GHC.Types.~ GHC.Maybe.Maybe GHC.Types.Bool) => Optics.Label.LabelOptic "attribute" k Data.OpenApi.Internal.Xml Data.OpenApi.Internal.Xml a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Lens, a GHC.Types.~ GHC.Maybe.Maybe Data.Text.Internal.Text, b GHC.Types.~ GHC.Maybe.Maybe Data.Text.Internal.Text) => Optics.Label.LabelOptic "name" k Data.OpenApi.Internal.Xml Data.OpenApi.Internal.Xml a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Lens, a GHC.Types.~ GHC.Maybe.Maybe Data.Text.Internal.Text, b GHC.Types.~ GHC.Maybe.Maybe Data.Text.Internal.Text) => Optics.Label.LabelOptic "namespace" k Data.OpenApi.Internal.Xml Data.OpenApi.Internal.Xml a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Lens, a GHC.Types.~ GHC.Maybe.Maybe Data.Text.Internal.Text, b GHC.Types.~ GHC.Maybe.Maybe Data.Text.Internal.Text) => Optics.Label.LabelOptic "prefix" k Data.OpenApi.Internal.Xml Data.OpenApi.Internal.Xml a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Lens, a GHC.Types.~ GHC.Maybe.Maybe GHC.Types.Bool, b GHC.Types.~ GHC.Maybe.Maybe GHC.Types.Bool) => Optics.Label.LabelOptic "wrapped" k Data.OpenApi.Internal.Xml Data.OpenApi.Internal.Xml a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Lens, a GHC.Types.~ GHC.Maybe.Maybe Data.Text.Internal.Text, b GHC.Types.~ GHC.Maybe.Maybe Data.Text.Internal.Text) => Optics.Label.LabelOptic "name" k Data.OpenApi.Internal.NamedSchema Data.OpenApi.Internal.NamedSchema a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Lens, a GHC.Types.~ Data.OpenApi.Internal.Schema, b GHC.Types.~ Data.OpenApi.Internal.Schema) => Optics.Label.LabelOptic "schema" k Data.OpenApi.Internal.NamedSchema Data.OpenApi.Internal.NamedSchema a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Lens, a GHC.Types.~ GHC.Maybe.Maybe Data.OpenApi.Internal.AdditionalProperties, b GHC.Types.~ GHC.Maybe.Maybe Data.OpenApi.Internal.AdditionalProperties) => Optics.Label.LabelOptic "additionalProperties" k Data.OpenApi.Internal.Schema Data.OpenApi.Internal.Schema a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Lens, a GHC.Types.~ GHC.Maybe.Maybe [Data.OpenApi.Internal.Referenced Data.OpenApi.Internal.Schema], b GHC.Types.~ GHC.Maybe.Maybe [Data.OpenApi.Internal.Referenced Data.OpenApi.Internal.Schema]) => Optics.Label.LabelOptic "allOf" k Data.OpenApi.Internal.Schema Data.OpenApi.Internal.Schema a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Lens, a GHC.Types.~ GHC.Maybe.Maybe [Data.OpenApi.Internal.Referenced Data.OpenApi.Internal.Schema], b GHC.Types.~ GHC.Maybe.Maybe [Data.OpenApi.Internal.Referenced Data.OpenApi.Internal.Schema]) => Optics.Label.LabelOptic "anyOf" k Data.OpenApi.Internal.Schema Data.OpenApi.Internal.Schema a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Lens, a GHC.Types.~ GHC.Maybe.Maybe Data.Aeson.Types.Internal.Value, b GHC.Types.~ GHC.Maybe.Maybe Data.Aeson.Types.Internal.Value) => Optics.Label.LabelOptic "default" k Data.OpenApi.Internal.Schema Data.OpenApi.Internal.Schema a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Lens, a GHC.Types.~ GHC.Maybe.Maybe GHC.Types.Bool, b GHC.Types.~ GHC.Maybe.Maybe GHC.Types.Bool) => Optics.Label.LabelOptic "deprecated" k Data.OpenApi.Internal.Schema Data.OpenApi.Internal.Schema a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Lens, a GHC.Types.~ GHC.Maybe.Maybe Data.Text.Internal.Text, b GHC.Types.~ GHC.Maybe.Maybe Data.Text.Internal.Text) => Optics.Label.LabelOptic "description" k Data.OpenApi.Internal.Schema Data.OpenApi.Internal.Schema a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Lens, a GHC.Types.~ GHC.Maybe.Maybe Data.OpenApi.Internal.Discriminator, b GHC.Types.~ GHC.Maybe.Maybe Data.OpenApi.Internal.Discriminator) => Optics.Label.LabelOptic "discriminator" k Data.OpenApi.Internal.Schema Data.OpenApi.Internal.Schema a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Lens, a GHC.Types.~ GHC.Maybe.Maybe [Data.Aeson.Types.Internal.Value], b GHC.Types.~ GHC.Maybe.Maybe [Data.Aeson.Types.Internal.Value]) => Optics.Label.LabelOptic "enum" k Data.OpenApi.Internal.Schema Data.OpenApi.Internal.Schema a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Lens, a GHC.Types.~ GHC.Maybe.Maybe Data.Aeson.Types.Internal.Value, b GHC.Types.~ GHC.Maybe.Maybe Data.Aeson.Types.Internal.Value) => Optics.Label.LabelOptic "example" k Data.OpenApi.Internal.Schema Data.OpenApi.Internal.Schema a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Lens, a GHC.Types.~ GHC.Maybe.Maybe GHC.Types.Bool, b GHC.Types.~ GHC.Maybe.Maybe GHC.Types.Bool) => Optics.Label.LabelOptic "exclusiveMaximum" k Data.OpenApi.Internal.Schema Data.OpenApi.Internal.Schema a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Lens, a GHC.Types.~ GHC.Maybe.Maybe GHC.Types.Bool, b GHC.Types.~ GHC.Maybe.Maybe GHC.Types.Bool) => Optics.Label.LabelOptic "exclusiveMinimum" k Data.OpenApi.Internal.Schema Data.OpenApi.Internal.Schema a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Lens, a GHC.Types.~ GHC.Maybe.Maybe Data.OpenApi.Internal.ExternalDocs, b GHC.Types.~ GHC.Maybe.Maybe Data.OpenApi.Internal.ExternalDocs) => Optics.Label.LabelOptic "externalDocs" k Data.OpenApi.Internal.Schema Data.OpenApi.Internal.Schema a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Lens, a GHC.Types.~ GHC.Maybe.Maybe Data.OpenApi.Internal.Format, b GHC.Types.~ GHC.Maybe.Maybe Data.OpenApi.Internal.Format) => Optics.Label.LabelOptic "format" k Data.OpenApi.Internal.Schema Data.OpenApi.Internal.Schema a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Lens, a GHC.Types.~ GHC.Maybe.Maybe Data.OpenApi.Internal.OpenApiItems, b GHC.Types.~ GHC.Maybe.Maybe Data.OpenApi.Internal.OpenApiItems) => Optics.Label.LabelOptic "items" k Data.OpenApi.Internal.Schema Data.OpenApi.Internal.Schema a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Lens, a GHC.Types.~ GHC.Maybe.Maybe GHC.Num.Integer.Integer, b GHC.Types.~ GHC.Maybe.Maybe GHC.Num.Integer.Integer) => Optics.Label.LabelOptic "maxItems" k Data.OpenApi.Internal.Schema Data.OpenApi.Internal.Schema a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Lens, a GHC.Types.~ GHC.Maybe.Maybe GHC.Num.Integer.Integer, b GHC.Types.~ GHC.Maybe.Maybe GHC.Num.Integer.Integer) => Optics.Label.LabelOptic "maxLength" k Data.OpenApi.Internal.Schema Data.OpenApi.Internal.Schema a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Lens, a GHC.Types.~ GHC.Maybe.Maybe GHC.Num.Integer.Integer, b GHC.Types.~ GHC.Maybe.Maybe GHC.Num.Integer.Integer) => Optics.Label.LabelOptic "maxProperties" k Data.OpenApi.Internal.Schema Data.OpenApi.Internal.Schema a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Lens, a GHC.Types.~ GHC.Maybe.Maybe Data.Scientific.Scientific, b GHC.Types.~ GHC.Maybe.Maybe Data.Scientific.Scientific) => Optics.Label.LabelOptic "maximum" k Data.OpenApi.Internal.Schema Data.OpenApi.Internal.Schema a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Lens, a GHC.Types.~ GHC.Maybe.Maybe GHC.Num.Integer.Integer, b GHC.Types.~ GHC.Maybe.Maybe GHC.Num.Integer.Integer) => Optics.Label.LabelOptic "minItems" k Data.OpenApi.Internal.Schema Data.OpenApi.Internal.Schema a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Lens, a GHC.Types.~ GHC.Maybe.Maybe GHC.Num.Integer.Integer, b GHC.Types.~ GHC.Maybe.Maybe GHC.Num.Integer.Integer) => Optics.Label.LabelOptic "minLength" k Data.OpenApi.Internal.Schema Data.OpenApi.Internal.Schema a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Lens, a GHC.Types.~ GHC.Maybe.Maybe GHC.Num.Integer.Integer, b GHC.Types.~ GHC.Maybe.Maybe GHC.Num.Integer.Integer) => Optics.Label.LabelOptic "minProperties" k Data.OpenApi.Internal.Schema Data.OpenApi.Internal.Schema a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Lens, a GHC.Types.~ GHC.Maybe.Maybe Data.Scientific.Scientific, b GHC.Types.~ GHC.Maybe.Maybe Data.Scientific.Scientific) => Optics.Label.LabelOptic "minimum" k Data.OpenApi.Internal.Schema Data.OpenApi.Internal.Schema a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Lens, a GHC.Types.~ GHC.Maybe.Maybe Data.Scientific.Scientific, b GHC.Types.~ GHC.Maybe.Maybe Data.Scientific.Scientific) => Optics.Label.LabelOptic "multipleOf" k Data.OpenApi.Internal.Schema Data.OpenApi.Internal.Schema a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Lens, a GHC.Types.~ GHC.Maybe.Maybe (Data.OpenApi.Internal.Referenced Data.OpenApi.Internal.Schema), b GHC.Types.~ GHC.Maybe.Maybe (Data.OpenApi.Internal.Referenced Data.OpenApi.Internal.Schema)) => Optics.Label.LabelOptic "not" k Data.OpenApi.Internal.Schema Data.OpenApi.Internal.Schema a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Lens, a GHC.Types.~ GHC.Maybe.Maybe GHC.Types.Bool, b GHC.Types.~ GHC.Maybe.Maybe GHC.Types.Bool) => Optics.Label.LabelOptic "nullable" k Data.OpenApi.Internal.Schema Data.OpenApi.Internal.Schema a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Lens, a GHC.Types.~ GHC.Maybe.Maybe [Data.OpenApi.Internal.Referenced Data.OpenApi.Internal.Schema], b GHC.Types.~ GHC.Maybe.Maybe [Data.OpenApi.Internal.Referenced Data.OpenApi.Internal.Schema]) => Optics.Label.LabelOptic "oneOf" k Data.OpenApi.Internal.Schema Data.OpenApi.Internal.Schema a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Lens, a GHC.Types.~ GHC.Maybe.Maybe Data.OpenApi.Internal.Pattern, b GHC.Types.~ GHC.Maybe.Maybe Data.OpenApi.Internal.Pattern) => Optics.Label.LabelOptic "pattern" k Data.OpenApi.Internal.Schema Data.OpenApi.Internal.Schema a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Lens, a GHC.Types.~ Data.HashMap.Strict.InsOrd.InsOrdHashMap Data.Text.Internal.Text (Data.OpenApi.Internal.Referenced Data.OpenApi.Internal.Schema), b GHC.Types.~ Data.HashMap.Strict.InsOrd.InsOrdHashMap Data.Text.Internal.Text (Data.OpenApi.Internal.Referenced Data.OpenApi.Internal.Schema)) => Optics.Label.LabelOptic "properties" k Data.OpenApi.Internal.Schema Data.OpenApi.Internal.Schema a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Lens, a GHC.Types.~ GHC.Maybe.Maybe GHC.Types.Bool, b GHC.Types.~ GHC.Maybe.Maybe GHC.Types.Bool) => Optics.Label.LabelOptic "readOnly" k Data.OpenApi.Internal.Schema Data.OpenApi.Internal.Schema a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Lens, a GHC.Types.~ [Data.OpenApi.Internal.ParamName], b GHC.Types.~ [Data.OpenApi.Internal.ParamName]) => Optics.Label.LabelOptic "required" k Data.OpenApi.Internal.Schema Data.OpenApi.Internal.Schema a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Lens, a GHC.Types.~ GHC.Maybe.Maybe Data.Text.Internal.Text, b GHC.Types.~ GHC.Maybe.Maybe Data.Text.Internal.Text) => Optics.Label.LabelOptic "title" k Data.OpenApi.Internal.Schema Data.OpenApi.Internal.Schema a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Lens, a GHC.Types.~ GHC.Maybe.Maybe Data.OpenApi.Internal.OpenApiType, b GHC.Types.~ GHC.Maybe.Maybe Data.OpenApi.Internal.OpenApiType) => Optics.Label.LabelOptic "type" k Data.OpenApi.Internal.Schema Data.OpenApi.Internal.Schema a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Lens, a GHC.Types.~ GHC.Maybe.Maybe GHC.Types.Bool, b GHC.Types.~ GHC.Maybe.Maybe GHC.Types.Bool) => Optics.Label.LabelOptic "uniqueItems" k Data.OpenApi.Internal.Schema Data.OpenApi.Internal.Schema a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Lens, a GHC.Types.~ GHC.Maybe.Maybe GHC.Types.Bool, b GHC.Types.~ GHC.Maybe.Maybe GHC.Types.Bool) => Optics.Label.LabelOptic "writeOnly" k Data.OpenApi.Internal.Schema Data.OpenApi.Internal.Schema a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Lens, a GHC.Types.~ GHC.Maybe.Maybe Data.OpenApi.Internal.Xml, b GHC.Types.~ GHC.Maybe.Maybe Data.OpenApi.Internal.Xml) => Optics.Label.LabelOptic "xml" k Data.OpenApi.Internal.Schema Data.OpenApi.Internal.Schema a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Lens, a GHC.Types.~ GHC.Maybe.Maybe GHC.Types.Bool, b GHC.Types.~ GHC.Maybe.Maybe GHC.Types.Bool) => Optics.Label.LabelOptic "allowEmptyValue" k Data.OpenApi.Internal.Header Data.OpenApi.Internal.Header a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Lens, a GHC.Types.~ GHC.Maybe.Maybe GHC.Types.Bool, b GHC.Types.~ GHC.Maybe.Maybe GHC.Types.Bool) => Optics.Label.LabelOptic "deprecated" k Data.OpenApi.Internal.Header Data.OpenApi.Internal.Header a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Lens, a GHC.Types.~ GHC.Maybe.Maybe Data.OpenApi.Internal.HeaderName, b GHC.Types.~ GHC.Maybe.Maybe Data.OpenApi.Internal.HeaderName) => Optics.Label.LabelOptic "description" k Data.OpenApi.Internal.Header Data.OpenApi.Internal.Header a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Lens, a GHC.Types.~ GHC.Maybe.Maybe Data.Aeson.Types.Internal.Value, b GHC.Types.~ GHC.Maybe.Maybe Data.Aeson.Types.Internal.Value) => Optics.Label.LabelOptic "example" k Data.OpenApi.Internal.Header Data.OpenApi.Internal.Header a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Lens, a GHC.Types.~ Data.HashMap.Strict.InsOrd.InsOrdHashMap Data.Text.Internal.Text (Data.OpenApi.Internal.Referenced Data.OpenApi.Internal.Example), b GHC.Types.~ Data.HashMap.Strict.InsOrd.InsOrdHashMap Data.Text.Internal.Text (Data.OpenApi.Internal.Referenced Data.OpenApi.Internal.Example)) => Optics.Label.LabelOptic "examples" k Data.OpenApi.Internal.Header Data.OpenApi.Internal.Header a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Lens, a GHC.Types.~ GHC.Maybe.Maybe GHC.Types.Bool, b GHC.Types.~ GHC.Maybe.Maybe GHC.Types.Bool) => Optics.Label.LabelOptic "explode" k Data.OpenApi.Internal.Header Data.OpenApi.Internal.Header a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Lens, a GHC.Types.~ GHC.Maybe.Maybe GHC.Types.Bool, b GHC.Types.~ GHC.Maybe.Maybe GHC.Types.Bool) => Optics.Label.LabelOptic "required" k Data.OpenApi.Internal.Header Data.OpenApi.Internal.Header a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Lens, a GHC.Types.~ GHC.Maybe.Maybe (Data.OpenApi.Internal.Referenced Data.OpenApi.Internal.Schema), b GHC.Types.~ GHC.Maybe.Maybe (Data.OpenApi.Internal.Referenced Data.OpenApi.Internal.Schema)) => Optics.Label.LabelOptic "schema" k Data.OpenApi.Internal.Header Data.OpenApi.Internal.Header a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Lens, a GHC.Types.~ GHC.Maybe.Maybe GHC.Types.Bool, b GHC.Types.~ GHC.Maybe.Maybe GHC.Types.Bool) => Optics.Label.LabelOptic "allowEmptyValue" k Data.OpenApi.Internal.Param Data.OpenApi.Internal.Param a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Lens, a GHC.Types.~ GHC.Maybe.Maybe GHC.Types.Bool, b GHC.Types.~ GHC.Maybe.Maybe GHC.Types.Bool) => Optics.Label.LabelOptic "allowReserved" k Data.OpenApi.Internal.Param Data.OpenApi.Internal.Param a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Lens, a GHC.Types.~ GHC.Maybe.Maybe GHC.Types.Bool, b GHC.Types.~ GHC.Maybe.Maybe GHC.Types.Bool) => Optics.Label.LabelOptic "deprecated" k Data.OpenApi.Internal.Param Data.OpenApi.Internal.Param a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Lens, a GHC.Types.~ GHC.Maybe.Maybe Data.Text.Internal.Text, b GHC.Types.~ GHC.Maybe.Maybe Data.Text.Internal.Text) => Optics.Label.LabelOptic "description" k Data.OpenApi.Internal.Param Data.OpenApi.Internal.Param a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Lens, a GHC.Types.~ GHC.Maybe.Maybe Data.Aeson.Types.Internal.Value, b GHC.Types.~ GHC.Maybe.Maybe Data.Aeson.Types.Internal.Value) => Optics.Label.LabelOptic "example" k Data.OpenApi.Internal.Param Data.OpenApi.Internal.Param a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Lens, a GHC.Types.~ Data.HashMap.Strict.InsOrd.InsOrdHashMap Data.Text.Internal.Text (Data.OpenApi.Internal.Referenced Data.OpenApi.Internal.Example), b GHC.Types.~ Data.HashMap.Strict.InsOrd.InsOrdHashMap Data.Text.Internal.Text (Data.OpenApi.Internal.Referenced Data.OpenApi.Internal.Example)) => Optics.Label.LabelOptic "examples" k Data.OpenApi.Internal.Param Data.OpenApi.Internal.Param a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Lens, a GHC.Types.~ GHC.Maybe.Maybe GHC.Types.Bool, b GHC.Types.~ GHC.Maybe.Maybe GHC.Types.Bool) => Optics.Label.LabelOptic "explode" k Data.OpenApi.Internal.Param Data.OpenApi.Internal.Param a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Lens, a GHC.Types.~ Data.OpenApi.Internal.ParamLocation, b GHC.Types.~ Data.OpenApi.Internal.ParamLocation) => Optics.Label.LabelOptic "in" k Data.OpenApi.Internal.Param Data.OpenApi.Internal.Param a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Lens, a GHC.Types.~ Data.Text.Internal.Text, b GHC.Types.~ Data.Text.Internal.Text) => Optics.Label.LabelOptic "name" k Data.OpenApi.Internal.Param Data.OpenApi.Internal.Param a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Lens, a GHC.Types.~ GHC.Maybe.Maybe GHC.Types.Bool, b GHC.Types.~ GHC.Maybe.Maybe GHC.Types.Bool) => Optics.Label.LabelOptic "required" k Data.OpenApi.Internal.Param Data.OpenApi.Internal.Param a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Lens, a GHC.Types.~ GHC.Maybe.Maybe (Data.OpenApi.Internal.Referenced Data.OpenApi.Internal.Schema), b GHC.Types.~ GHC.Maybe.Maybe (Data.OpenApi.Internal.Referenced Data.OpenApi.Internal.Schema)) => Optics.Label.LabelOptic "schema" k Data.OpenApi.Internal.Param Data.OpenApi.Internal.Param a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Lens, a GHC.Types.~ GHC.Maybe.Maybe Data.OpenApi.Internal.Style, b GHC.Types.~ GHC.Maybe.Maybe Data.OpenApi.Internal.Style) => Optics.Label.LabelOptic "style" k Data.OpenApi.Internal.Param Data.OpenApi.Internal.Param a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Lens, a GHC.Types.~ Data.HashMap.Strict.InsOrd.InsOrdHashMap Data.Text.Internal.Text (Data.OpenApi.Internal.Referenced Data.OpenApi.Internal.Callback), b GHC.Types.~ Data.HashMap.Strict.InsOrd.InsOrdHashMap Data.Text.Internal.Text (Data.OpenApi.Internal.Referenced Data.OpenApi.Internal.Callback)) => Optics.Label.LabelOptic "callbacks" k Data.OpenApi.Internal.Operation Data.OpenApi.Internal.Operation a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Lens, a GHC.Types.~ GHC.Maybe.Maybe GHC.Types.Bool, b GHC.Types.~ GHC.Maybe.Maybe GHC.Types.Bool) => Optics.Label.LabelOptic "deprecated" k Data.OpenApi.Internal.Operation Data.OpenApi.Internal.Operation a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Lens, a GHC.Types.~ GHC.Maybe.Maybe Data.Text.Internal.Text, b GHC.Types.~ GHC.Maybe.Maybe Data.Text.Internal.Text) => Optics.Label.LabelOptic "description" k Data.OpenApi.Internal.Operation Data.OpenApi.Internal.Operation a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Lens, a GHC.Types.~ GHC.Maybe.Maybe Data.OpenApi.Internal.ExternalDocs, b GHC.Types.~ GHC.Maybe.Maybe Data.OpenApi.Internal.ExternalDocs) => Optics.Label.LabelOptic "externalDocs" k Data.OpenApi.Internal.Operation Data.OpenApi.Internal.Operation a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Lens, a GHC.Types.~ GHC.Maybe.Maybe Data.Text.Internal.Text, b GHC.Types.~ GHC.Maybe.Maybe Data.Text.Internal.Text) => Optics.Label.LabelOptic "operationId" k Data.OpenApi.Internal.Operation Data.OpenApi.Internal.Operation a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Lens, a GHC.Types.~ [Data.OpenApi.Internal.Referenced Data.OpenApi.Internal.Param], b GHC.Types.~ [Data.OpenApi.Internal.Referenced Data.OpenApi.Internal.Param]) => Optics.Label.LabelOptic "parameters" k Data.OpenApi.Internal.Operation Data.OpenApi.Internal.Operation a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Lens, a GHC.Types.~ GHC.Maybe.Maybe (Data.OpenApi.Internal.Referenced Data.OpenApi.Internal.RequestBody), b GHC.Types.~ GHC.Maybe.Maybe (Data.OpenApi.Internal.Referenced Data.OpenApi.Internal.RequestBody)) => Optics.Label.LabelOptic "requestBody" k Data.OpenApi.Internal.Operation Data.OpenApi.Internal.Operation a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Lens, a GHC.Types.~ Data.OpenApi.Internal.Responses, b GHC.Types.~ Data.OpenApi.Internal.Responses) => Optics.Label.LabelOptic "responses" k Data.OpenApi.Internal.Operation Data.OpenApi.Internal.Operation a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Lens, a GHC.Types.~ [Data.OpenApi.Internal.SecurityRequirement], b GHC.Types.~ [Data.OpenApi.Internal.SecurityRequirement]) => Optics.Label.LabelOptic "security" k Data.OpenApi.Internal.Operation Data.OpenApi.Internal.Operation a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Lens, a GHC.Types.~ [Data.OpenApi.Internal.Server], b GHC.Types.~ [Data.OpenApi.Internal.Server]) => Optics.Label.LabelOptic "servers" k Data.OpenApi.Internal.Operation Data.OpenApi.Internal.Operation a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Lens, a GHC.Types.~ GHC.Maybe.Maybe Data.Text.Internal.Text, b GHC.Types.~ GHC.Maybe.Maybe Data.Text.Internal.Text) => Optics.Label.LabelOptic "summary" k Data.OpenApi.Internal.Operation Data.OpenApi.Internal.Operation a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Lens, a GHC.Types.~ Data.HashSet.InsOrd.InsOrdHashSet Data.OpenApi.Internal.TagName, b GHC.Types.~ Data.HashSet.InsOrd.InsOrdHashSet Data.OpenApi.Internal.TagName) => Optics.Label.LabelOptic "tags" k Data.OpenApi.Internal.Operation Data.OpenApi.Internal.Operation a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Lens, a GHC.Types.~ GHC.Maybe.Maybe Data.Text.Internal.Text, b GHC.Types.~ GHC.Maybe.Maybe Data.Text.Internal.Text) => Optics.Label.LabelOptic "description" k Data.OpenApi.Internal.Tag Data.OpenApi.Internal.Tag a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Lens, a GHC.Types.~ GHC.Maybe.Maybe Data.OpenApi.Internal.ExternalDocs, b GHC.Types.~ GHC.Maybe.Maybe Data.OpenApi.Internal.ExternalDocs) => Optics.Label.LabelOptic "externalDocs" k Data.OpenApi.Internal.Tag Data.OpenApi.Internal.Tag a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Lens, a GHC.Types.~ Data.OpenApi.Internal.TagName, b GHC.Types.~ Data.OpenApi.Internal.TagName) => Optics.Label.LabelOptic "name" k Data.OpenApi.Internal.Tag Data.OpenApi.Internal.Tag a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Lens, a GHC.Types.~ GHC.Maybe.Maybe Data.OpenApi.Internal.Operation, b GHC.Types.~ GHC.Maybe.Maybe Data.OpenApi.Internal.Operation) => Optics.Label.LabelOptic "delete" k Data.OpenApi.Internal.PathItem Data.OpenApi.Internal.PathItem a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Lens, a GHC.Types.~ GHC.Maybe.Maybe Data.Text.Internal.Text, b GHC.Types.~ GHC.Maybe.Maybe Data.Text.Internal.Text) => Optics.Label.LabelOptic "description" k Data.OpenApi.Internal.PathItem Data.OpenApi.Internal.PathItem a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Lens, a GHC.Types.~ GHC.Maybe.Maybe Data.OpenApi.Internal.Operation, b GHC.Types.~ GHC.Maybe.Maybe Data.OpenApi.Internal.Operation) => Optics.Label.LabelOptic "get" k Data.OpenApi.Internal.PathItem Data.OpenApi.Internal.PathItem a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Lens, a GHC.Types.~ GHC.Maybe.Maybe Data.OpenApi.Internal.Operation, b GHC.Types.~ GHC.Maybe.Maybe Data.OpenApi.Internal.Operation) => Optics.Label.LabelOptic "head" k Data.OpenApi.Internal.PathItem Data.OpenApi.Internal.PathItem a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Lens, a GHC.Types.~ GHC.Maybe.Maybe Data.OpenApi.Internal.Operation, b GHC.Types.~ GHC.Maybe.Maybe Data.OpenApi.Internal.Operation) => Optics.Label.LabelOptic "options" k Data.OpenApi.Internal.PathItem Data.OpenApi.Internal.PathItem a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Lens, a GHC.Types.~ [Data.OpenApi.Internal.Referenced Data.OpenApi.Internal.Param], b GHC.Types.~ [Data.OpenApi.Internal.Referenced Data.OpenApi.Internal.Param]) => Optics.Label.LabelOptic "parameters" k Data.OpenApi.Internal.PathItem Data.OpenApi.Internal.PathItem a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Lens, a GHC.Types.~ GHC.Maybe.Maybe Data.OpenApi.Internal.Operation, b GHC.Types.~ GHC.Maybe.Maybe Data.OpenApi.Internal.Operation) => Optics.Label.LabelOptic "patch" k Data.OpenApi.Internal.PathItem Data.OpenApi.Internal.PathItem a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Lens, a GHC.Types.~ GHC.Maybe.Maybe Data.OpenApi.Internal.Operation, b GHC.Types.~ GHC.Maybe.Maybe Data.OpenApi.Internal.Operation) => Optics.Label.LabelOptic "post" k Data.OpenApi.Internal.PathItem Data.OpenApi.Internal.PathItem a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Lens, a GHC.Types.~ GHC.Maybe.Maybe Data.OpenApi.Internal.Operation, b GHC.Types.~ GHC.Maybe.Maybe Data.OpenApi.Internal.Operation) => Optics.Label.LabelOptic "put" k Data.OpenApi.Internal.PathItem Data.OpenApi.Internal.PathItem a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Lens, a GHC.Types.~ [Data.OpenApi.Internal.Server], b GHC.Types.~ [Data.OpenApi.Internal.Server]) => Optics.Label.LabelOptic "servers" k Data.OpenApi.Internal.PathItem Data.OpenApi.Internal.PathItem a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Lens, a GHC.Types.~ GHC.Maybe.Maybe Data.Text.Internal.Text, b GHC.Types.~ GHC.Maybe.Maybe Data.Text.Internal.Text) => Optics.Label.LabelOptic "summary" k Data.OpenApi.Internal.PathItem Data.OpenApi.Internal.PathItem a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Lens, a GHC.Types.~ GHC.Maybe.Maybe Data.OpenApi.Internal.Operation, b GHC.Types.~ GHC.Maybe.Maybe Data.OpenApi.Internal.Operation) => Optics.Label.LabelOptic "trace" k Data.OpenApi.Internal.PathItem Data.OpenApi.Internal.PathItem a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Lens, a GHC.Types.~ Data.Text.Internal.Text, b GHC.Types.~ Data.Text.Internal.Text) => Optics.Label.LabelOptic "name" k Data.OpenApi.Internal.License Data.OpenApi.Internal.License a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Lens, a GHC.Types.~ GHC.Maybe.Maybe Data.OpenApi.Internal.URL, b GHC.Types.~ GHC.Maybe.Maybe Data.OpenApi.Internal.URL) => Optics.Label.LabelOptic "url" k Data.OpenApi.Internal.License Data.OpenApi.Internal.License a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Lens, a GHC.Types.~ GHC.Maybe.Maybe Data.Text.Internal.Text, b GHC.Types.~ GHC.Maybe.Maybe Data.Text.Internal.Text) => Optics.Label.LabelOptic "email" k Data.OpenApi.Internal.Contact Data.OpenApi.Internal.Contact a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Lens, a GHC.Types.~ GHC.Maybe.Maybe Data.Text.Internal.Text, b GHC.Types.~ GHC.Maybe.Maybe Data.Text.Internal.Text) => Optics.Label.LabelOptic "name" k Data.OpenApi.Internal.Contact Data.OpenApi.Internal.Contact a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Lens, a GHC.Types.~ GHC.Maybe.Maybe Data.OpenApi.Internal.URL, b GHC.Types.~ GHC.Maybe.Maybe Data.OpenApi.Internal.URL) => Optics.Label.LabelOptic "url" k Data.OpenApi.Internal.Contact Data.OpenApi.Internal.Contact a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Lens, a GHC.Types.~ GHC.Maybe.Maybe Data.OpenApi.Internal.Contact, b GHC.Types.~ GHC.Maybe.Maybe Data.OpenApi.Internal.Contact) => Optics.Label.LabelOptic "contact" k Data.OpenApi.Internal.Info Data.OpenApi.Internal.Info a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Lens, a GHC.Types.~ GHC.Maybe.Maybe Data.Text.Internal.Text, b GHC.Types.~ GHC.Maybe.Maybe Data.Text.Internal.Text) => Optics.Label.LabelOptic "description" k Data.OpenApi.Internal.Info Data.OpenApi.Internal.Info a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Lens, a GHC.Types.~ GHC.Maybe.Maybe Data.OpenApi.Internal.License, b GHC.Types.~ GHC.Maybe.Maybe Data.OpenApi.Internal.License) => Optics.Label.LabelOptic "license" k Data.OpenApi.Internal.Info Data.OpenApi.Internal.Info a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Lens, a GHC.Types.~ GHC.Maybe.Maybe Data.Text.Internal.Text, b GHC.Types.~ GHC.Maybe.Maybe Data.Text.Internal.Text) => Optics.Label.LabelOptic "termsOfService" k Data.OpenApi.Internal.Info Data.OpenApi.Internal.Info a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Lens, a GHC.Types.~ Data.Text.Internal.Text, b GHC.Types.~ Data.Text.Internal.Text) => Optics.Label.LabelOptic "title" k Data.OpenApi.Internal.Info Data.OpenApi.Internal.Info a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Lens, a GHC.Types.~ Data.Text.Internal.Text, b GHC.Types.~ Data.Text.Internal.Text) => Optics.Label.LabelOptic "version" k Data.OpenApi.Internal.Info Data.OpenApi.Internal.Info a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Lens, a GHC.Types.~ Data.HashMap.Strict.InsOrd.InsOrdHashMap Data.Text.Internal.Text Data.OpenApi.Internal.Encoding, b GHC.Types.~ Data.HashMap.Strict.InsOrd.InsOrdHashMap Data.Text.Internal.Text Data.OpenApi.Internal.Encoding) => Optics.Label.LabelOptic "encoding" k Data.OpenApi.Internal.MediaTypeObject Data.OpenApi.Internal.MediaTypeObject a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Lens, a GHC.Types.~ GHC.Maybe.Maybe Data.Aeson.Types.Internal.Value, b GHC.Types.~ GHC.Maybe.Maybe Data.Aeson.Types.Internal.Value) => Optics.Label.LabelOptic "example" k Data.OpenApi.Internal.MediaTypeObject Data.OpenApi.Internal.MediaTypeObject a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Lens, a GHC.Types.~ Data.HashMap.Strict.InsOrd.InsOrdHashMap Data.Text.Internal.Text (Data.OpenApi.Internal.Referenced Data.OpenApi.Internal.Example), b GHC.Types.~ Data.HashMap.Strict.InsOrd.InsOrdHashMap Data.Text.Internal.Text (Data.OpenApi.Internal.Referenced Data.OpenApi.Internal.Example)) => Optics.Label.LabelOptic "examples" k Data.OpenApi.Internal.MediaTypeObject Data.OpenApi.Internal.MediaTypeObject a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Lens, a GHC.Types.~ GHC.Maybe.Maybe (Data.OpenApi.Internal.Referenced Data.OpenApi.Internal.Schema), b GHC.Types.~ GHC.Maybe.Maybe (Data.OpenApi.Internal.Referenced Data.OpenApi.Internal.Schema)) => Optics.Label.LabelOptic "schema" k Data.OpenApi.Internal.MediaTypeObject Data.OpenApi.Internal.MediaTypeObject a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Lens, a GHC.Types.~ Data.HashMap.Strict.InsOrd.InsOrdHashMap Network.HTTP.Media.MediaType.Internal.MediaType Data.OpenApi.Internal.MediaTypeObject, b GHC.Types.~ Data.HashMap.Strict.InsOrd.InsOrdHashMap Network.HTTP.Media.MediaType.Internal.MediaType Data.OpenApi.Internal.MediaTypeObject) => Optics.Label.LabelOptic "content" k Data.OpenApi.Internal.RequestBody Data.OpenApi.Internal.RequestBody a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Lens, a GHC.Types.~ GHC.Maybe.Maybe Data.Text.Internal.Text, b GHC.Types.~ GHC.Maybe.Maybe Data.Text.Internal.Text) => Optics.Label.LabelOptic "description" k Data.OpenApi.Internal.RequestBody Data.OpenApi.Internal.RequestBody a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Lens, a GHC.Types.~ GHC.Maybe.Maybe GHC.Types.Bool, b GHC.Types.~ GHC.Maybe.Maybe GHC.Types.Bool) => Optics.Label.LabelOptic "required" k Data.OpenApi.Internal.RequestBody Data.OpenApi.Internal.RequestBody a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Lens, a GHC.Types.~ Data.Text.Internal.Text, b GHC.Types.~ Data.Text.Internal.Text) => Optics.Label.LabelOptic "default" k Data.OpenApi.Internal.ServerVariable Data.OpenApi.Internal.ServerVariable a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Lens, a GHC.Types.~ GHC.Maybe.Maybe Data.Text.Internal.Text, b GHC.Types.~ GHC.Maybe.Maybe Data.Text.Internal.Text) => Optics.Label.LabelOptic "description" k Data.OpenApi.Internal.ServerVariable Data.OpenApi.Internal.ServerVariable a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Lens, a GHC.Types.~ GHC.Maybe.Maybe (Data.HashSet.InsOrd.InsOrdHashSet Data.Text.Internal.Text), b GHC.Types.~ GHC.Maybe.Maybe (Data.HashSet.InsOrd.InsOrdHashSet Data.Text.Internal.Text)) => Optics.Label.LabelOptic "enum" k Data.OpenApi.Internal.ServerVariable Data.OpenApi.Internal.ServerVariable a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Lens, a GHC.Types.~ GHC.Maybe.Maybe Data.Text.Internal.Text, b GHC.Types.~ GHC.Maybe.Maybe Data.Text.Internal.Text) => Optics.Label.LabelOptic "description" k Data.OpenApi.Internal.Server Data.OpenApi.Internal.Server a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Lens, a GHC.Types.~ Data.Text.Internal.Text, b GHC.Types.~ Data.Text.Internal.Text) => Optics.Label.LabelOptic "url" k Data.OpenApi.Internal.Server Data.OpenApi.Internal.Server a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Lens, a GHC.Types.~ Data.HashMap.Strict.InsOrd.InsOrdHashMap Data.Text.Internal.Text Data.OpenApi.Internal.ServerVariable, b GHC.Types.~ Data.HashMap.Strict.InsOrd.InsOrdHashMap Data.Text.Internal.Text Data.OpenApi.Internal.ServerVariable) => Optics.Label.LabelOptic "variables" k Data.OpenApi.Internal.Server Data.OpenApi.Internal.Server a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Lens, a GHC.Types.~ Data.OpenApi.Internal.Definitions Data.OpenApi.Internal.Callback, b GHC.Types.~ Data.OpenApi.Internal.Definitions Data.OpenApi.Internal.Callback) => Optics.Label.LabelOptic "callbacks" k Data.OpenApi.Internal.Components Data.OpenApi.Internal.Components a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Lens, a GHC.Types.~ Data.OpenApi.Internal.Definitions Data.OpenApi.Internal.Example, b GHC.Types.~ Data.OpenApi.Internal.Definitions Data.OpenApi.Internal.Example) => Optics.Label.LabelOptic "examples" k Data.OpenApi.Internal.Components Data.OpenApi.Internal.Components a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Lens, a GHC.Types.~ Data.OpenApi.Internal.Definitions Data.OpenApi.Internal.Header, b GHC.Types.~ Data.OpenApi.Internal.Definitions Data.OpenApi.Internal.Header) => Optics.Label.LabelOptic "headers" k Data.OpenApi.Internal.Components Data.OpenApi.Internal.Components a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Lens, a GHC.Types.~ Data.OpenApi.Internal.Definitions Data.OpenApi.Internal.Link, b GHC.Types.~ Data.OpenApi.Internal.Definitions Data.OpenApi.Internal.Link) => Optics.Label.LabelOptic "links" k Data.OpenApi.Internal.Components Data.OpenApi.Internal.Components a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Lens, a GHC.Types.~ Data.OpenApi.Internal.Definitions Data.OpenApi.Internal.Param, b GHC.Types.~ Data.OpenApi.Internal.Definitions Data.OpenApi.Internal.Param) => Optics.Label.LabelOptic "parameters" k Data.OpenApi.Internal.Components Data.OpenApi.Internal.Components a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Lens, a GHC.Types.~ Data.OpenApi.Internal.Definitions Data.OpenApi.Internal.RequestBody, b GHC.Types.~ Data.OpenApi.Internal.Definitions Data.OpenApi.Internal.RequestBody) => Optics.Label.LabelOptic "requestBodies" k Data.OpenApi.Internal.Components Data.OpenApi.Internal.Components a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Lens, a GHC.Types.~ Data.OpenApi.Internal.Definitions Data.OpenApi.Internal.Response, b GHC.Types.~ Data.OpenApi.Internal.Definitions Data.OpenApi.Internal.Response) => Optics.Label.LabelOptic "responses" k Data.OpenApi.Internal.Components Data.OpenApi.Internal.Components a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Lens, a GHC.Types.~ Data.OpenApi.Internal.Definitions Data.OpenApi.Internal.Schema, b GHC.Types.~ Data.OpenApi.Internal.Definitions Data.OpenApi.Internal.Schema) => Optics.Label.LabelOptic "schemas" k Data.OpenApi.Internal.Components Data.OpenApi.Internal.Components a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Lens, a GHC.Types.~ Data.OpenApi.Internal.SecurityDefinitions, b GHC.Types.~ Data.OpenApi.Internal.SecurityDefinitions) => Optics.Label.LabelOptic "securitySchemes" k Data.OpenApi.Internal.Components Data.OpenApi.Internal.Components a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Lens, a GHC.Types.~ Data.OpenApi.Internal.Components, b GHC.Types.~ Data.OpenApi.Internal.Components) => Optics.Label.LabelOptic "components" k Data.OpenApi.Internal.OpenApi Data.OpenApi.Internal.OpenApi a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Lens, a GHC.Types.~ GHC.Maybe.Maybe Data.OpenApi.Internal.ExternalDocs, b GHC.Types.~ GHC.Maybe.Maybe Data.OpenApi.Internal.ExternalDocs) => Optics.Label.LabelOptic "externalDocs" k Data.OpenApi.Internal.OpenApi Data.OpenApi.Internal.OpenApi a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Lens, a GHC.Types.~ Data.OpenApi.Internal.Info, b GHC.Types.~ Data.OpenApi.Internal.Info) => Optics.Label.LabelOptic "info" k Data.OpenApi.Internal.OpenApi Data.OpenApi.Internal.OpenApi a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Lens, a GHC.Types.~ Data.OpenApi.Internal.OpenApiSpecVersion, b GHC.Types.~ Data.OpenApi.Internal.OpenApiSpecVersion) => Optics.Label.LabelOptic "openapi" k Data.OpenApi.Internal.OpenApi Data.OpenApi.Internal.OpenApi a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Lens, a GHC.Types.~ Data.HashMap.Strict.InsOrd.InsOrdHashMap GHC.IO.FilePath Data.OpenApi.Internal.PathItem, b GHC.Types.~ Data.HashMap.Strict.InsOrd.InsOrdHashMap GHC.IO.FilePath Data.OpenApi.Internal.PathItem) => Optics.Label.LabelOptic "paths" k Data.OpenApi.Internal.OpenApi Data.OpenApi.Internal.OpenApi a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Lens, a GHC.Types.~ [Data.OpenApi.Internal.SecurityRequirement], b GHC.Types.~ [Data.OpenApi.Internal.SecurityRequirement]) => Optics.Label.LabelOptic "security" k Data.OpenApi.Internal.OpenApi Data.OpenApi.Internal.OpenApi a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Lens, a GHC.Types.~ [Data.OpenApi.Internal.Server], b GHC.Types.~ [Data.OpenApi.Internal.Server]) => Optics.Label.LabelOptic "servers" k Data.OpenApi.Internal.OpenApi Data.OpenApi.Internal.OpenApi a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Lens, a GHC.Types.~ Data.HashSet.InsOrd.InsOrdHashSet Data.OpenApi.Internal.Tag, b GHC.Types.~ Data.HashSet.InsOrd.InsOrdHashSet Data.OpenApi.Internal.Tag) => Optics.Label.LabelOptic "tags" k Data.OpenApi.Internal.OpenApi Data.OpenApi.Internal.OpenApi a b


-- | Generic deriving options for <tt><tt>ToParamSchema</tt></tt> and
--   <tt><tt>ToSchema</tt></tt>.
module Data.OpenApi.SchemaOptions

-- | Options that specify how to encode your type to Swagger schema.
data SchemaOptions
SchemaOptions :: (String -> String) -> (String -> String) -> (String -> String) -> Bool -> Bool -> SumEncoding -> SchemaOptions

-- | Function applied to field labels. Handy for removing common record
--   prefixes for example.
[fieldLabelModifier] :: SchemaOptions -> String -> String

-- | Function applied to constructor tags which could be handy for
--   lower-casing them for example.
[constructorTagModifier] :: SchemaOptions -> String -> String

-- | Function applied to datatype name.
[datatypeNameModifier] :: SchemaOptions -> String -> String

-- | If <tt><a>True</a></tt> the constructors of a datatype, with all
--   nullary constructors, will be encoded to a string enumeration schema
--   with the constructor tags as possible values.
[allNullaryToStringTag] :: SchemaOptions -> Bool

-- | Hide the field name when a record constructor has only one field, like
--   a newtype.
[unwrapUnaryRecords] :: SchemaOptions -> Bool

-- | Specifies how to encode constructors of a sum datatype.
[sumEncoding] :: SchemaOptions -> SumEncoding

-- | Default encoding <tt><a>SchemaOptions</a></tt>.
--   
--   <pre>
--   <a>SchemaOptions</a>
--   { <a>fieldLabelModifier</a>     = id
--   , <a>constructorTagModifier</a> = id
--   , <a>datatypeNameModifier</a>   = id
--   , <a>allNullaryToStringTag</a>  = True
--   , <a>unwrapUnaryRecords</a>     = False
--   , <a>sumEncoding</a>            = <a>defaultTaggedObject</a>
--   }
--   </pre>
defaultSchemaOptions :: SchemaOptions

-- | Convert <a>Options</a> to <a>SchemaOptions</a>.
--   
--   Specifically the following fields get copied:
--   
--   <ul>
--   <li><a>fieldLabelModifier</a></li>
--   <li><a>constructorTagModifier</a></li>
--   <li><a>allNullaryToStringTag</a></li>
--   <li><a>unwrapUnaryRecords</a></li>
--   </ul>
--   
--   Note that these fields have no effect on <a>SchemaOptions</a>:
--   
--   <ul>
--   <li><a>omitNothingFields</a></li>
--   <li><a>tagSingleConstructors</a></li>
--   </ul>
--   
--   The rest is defined as in <a>defaultSchemaOptions</a>.
fromAesonOptions :: Options -> SchemaOptions

module Data.OpenApi.Internal.ParamSchema

-- | Default schema for binary data (any sequence of octets).
binarySchema :: Schema

-- | Default schema for binary data (base64 encoded).
byteSchema :: Schema

-- | Default schema for password string. <tt>"password"</tt> format is used
--   to hint UIs the input needs to be obscured.
passwordSchema :: Schema

-- | Convert a type into a plain <tt><a>Schema</a></tt>.
--   
--   In previous versions of the package there was a separate type called
--   <tt>ParamSchema</tt>, which was included in a greater <a>Schema</a>.
--   Now this is a single class, but distinction for schema generators for
--   "simple" types is preserved.
--   
--   <a>ToParamSchema</a> is suited only for primitive-like types without
--   nested fields and such.
--   
--   An example type and instance:
--   
--   <pre>
--   {-# LANGUAGE OverloadedStrings #-}   -- allows to write <a>Text</a> literals
--   
--   import Control.Lens
--   
--   data Direction = Up | Down
--   
--   instance ToParamSchema Direction where
--     toParamSchema _ = mempty
--        &amp; type_ ?~ OpenApiString
--        &amp; enum_ ?~ [ "Up", "Down" ]
--   </pre>
--   
--   Instead of manually writing your <tt><a>ToParamSchema</a></tt>
--   instance you can use a default generic implementation of
--   <tt><a>toParamSchema</a></tt>.
--   
--   To do that, simply add <tt>deriving <a>FPFormat</a></tt> clause to
--   your datatype and declare a <tt><a>ToParamSchema</a></tt> instance for
--   your datatype without giving definition for
--   <tt><a>toParamSchema</a></tt>.
--   
--   For instance, the previous example can be simplified into this:
--   
--   <pre>
--   {-# LANGUAGE DeriveGeneric #-}
--   
--   import GHC.Generics (Generic)
--   
--   data Direction = Up | Down deriving Generic
--   
--   instance ToParamSchema Direction
--   </pre>
class ToParamSchema a

-- | Convert a type into a plain parameter schema.
--   
--   <pre>
--   &gt;&gt;&gt; BSL.putStrLn $ encodePretty $ toParamSchema (Proxy :: Proxy Integer)
--   {
--       "type": "integer"
--   }
--   </pre>
toParamSchema :: ToParamSchema a => Proxy a -> Schema

-- | Convert a type into a plain parameter schema.
--   
--   <pre>
--   &gt;&gt;&gt; BSL.putStrLn $ encodePretty $ toParamSchema (Proxy :: Proxy Integer)
--   {
--       "type": "integer"
--   }
--   </pre>
toParamSchema :: (ToParamSchema a, Generic a, GToParamSchema (Rep a)) => Proxy a -> Schema

-- | Default plain schema for <tt><a>Bounded</a></tt>,
--   <tt><a>Integral</a></tt> types.
--   
--   <pre>
--   &gt;&gt;&gt; BSL.putStrLn $ encodePretty $ toParamSchemaBoundedIntegral (Proxy :: Proxy Int8)
--   {
--       "maximum": 127,
--       "minimum": -128,
--       "type": "integer"
--   }
--   </pre>
toParamSchemaBoundedIntegral :: forall a t. (Bounded a, Integral a) => Proxy a -> Schema
timeParamSchema :: String -> Schema
type family ToParamSchemaByteStringError bs

-- | A configurable generic <tt><a>Schema</a></tt> creator.
--   
--   <pre>
--   &gt;&gt;&gt; :set -XDeriveGeneric
--   
--   &gt;&gt;&gt; data Color = Red | Blue deriving Generic
--   
--   &gt;&gt;&gt; BSL.putStrLn $ encodePretty $ genericToParamSchema defaultSchemaOptions (Proxy :: Proxy Color)
--   {
--       "enum": [
--           "Red",
--           "Blue"
--       ],
--       "type": "string"
--   }
--   </pre>
genericToParamSchema :: forall a t. (Generic a, GToParamSchema (Rep a)) => SchemaOptions -> Proxy a -> Schema
class GToParamSchema (f :: * -> *)
gtoParamSchema :: GToParamSchema f => SchemaOptions -> Proxy f -> Schema -> Schema
class GEnumParamSchema (f :: * -> *)
genumParamSchema :: GEnumParamSchema f => SchemaOptions -> Proxy f -> Schema -> Schema
data Proxy3 a b c
Proxy3 :: Proxy3 a b c
instance GHC.Generics.Constructor c => Data.OpenApi.Internal.ParamSchema.GEnumParamSchema (GHC.Generics.C1 c GHC.Generics.U1)
instance GHC.Generics.Constructor c => Data.OpenApi.Internal.ParamSchema.GToParamSchema (GHC.Generics.C1 c GHC.Generics.U1)
instance (Data.OpenApi.Internal.ParamSchema.GEnumParamSchema f, Data.OpenApi.Internal.ParamSchema.GEnumParamSchema g) => Data.OpenApi.Internal.ParamSchema.GToParamSchema (f GHC.Generics.:+: g)
instance (Data.OpenApi.Internal.ParamSchema.GEnumParamSchema f, Data.OpenApi.Internal.ParamSchema.GEnumParamSchema g) => Data.OpenApi.Internal.ParamSchema.GEnumParamSchema (f GHC.Generics.:+: g)
instance Data.OpenApi.Internal.ParamSchema.ToParamSchemaByteStringError Data.ByteString.Internal.Type.ByteString => Data.OpenApi.Internal.ParamSchema.ToParamSchema Data.ByteString.Internal.Type.ByteString
instance Data.OpenApi.Internal.ParamSchema.ToParamSchemaByteStringError Data.ByteString.Lazy.Internal.ByteString => Data.OpenApi.Internal.ParamSchema.ToParamSchema Data.ByteString.Lazy.Internal.ByteString
instance Data.OpenApi.Internal.ParamSchema.ToParamSchema GHC.Base.String
instance Data.OpenApi.Internal.ParamSchema.ToParamSchema GHC.Types.Bool
instance Data.OpenApi.Internal.ParamSchema.ToParamSchema GHC.Num.Integer.Integer
instance Data.OpenApi.Internal.ParamSchema.ToParamSchema GHC.Num.Natural.Natural
instance Data.OpenApi.Internal.ParamSchema.ToParamSchema GHC.Types.Int
instance Data.OpenApi.Internal.ParamSchema.ToParamSchema GHC.Int.Int8
instance Data.OpenApi.Internal.ParamSchema.ToParamSchema GHC.Int.Int16
instance Data.OpenApi.Internal.ParamSchema.ToParamSchema GHC.Int.Int32
instance Data.OpenApi.Internal.ParamSchema.ToParamSchema GHC.Int.Int64
instance Data.OpenApi.Internal.ParamSchema.ToParamSchema GHC.Types.Word
instance Data.OpenApi.Internal.ParamSchema.ToParamSchema GHC.Word.Word8
instance Data.OpenApi.Internal.ParamSchema.ToParamSchema GHC.Word.Word16
instance Data.OpenApi.Internal.ParamSchema.ToParamSchema GHC.Word.Word32
instance Data.OpenApi.Internal.ParamSchema.ToParamSchema GHC.Word.Word64
instance Data.OpenApi.Internal.ParamSchema.ToParamSchema GHC.Types.Char
instance Data.OpenApi.Internal.ParamSchema.ToParamSchema Data.Scientific.Scientific
instance forall k (a :: k). Data.Fixed.HasResolution a => Data.OpenApi.Internal.ParamSchema.ToParamSchema (Data.Fixed.Fixed a)
instance Data.OpenApi.Internal.ParamSchema.ToParamSchema GHC.Types.Double
instance Data.OpenApi.Internal.ParamSchema.ToParamSchema GHC.Types.Float
instance Data.OpenApi.Internal.ParamSchema.ToParamSchema Data.Time.Calendar.Days.Day
instance Data.OpenApi.Internal.ParamSchema.ToParamSchema Data.Time.LocalTime.Internal.TimeOfDay.TimeOfDay
instance Data.OpenApi.Internal.ParamSchema.ToParamSchema Data.Time.LocalTime.Internal.LocalTime.LocalTime
instance Data.OpenApi.Internal.ParamSchema.ToParamSchema Data.Time.LocalTime.Internal.ZonedTime.ZonedTime
instance Data.OpenApi.Internal.ParamSchema.ToParamSchema Data.Time.Clock.Internal.UTCTime.UTCTime
instance Data.OpenApi.Internal.ParamSchema.ToParamSchema Data.Time.Clock.Internal.NominalDiffTime.NominalDiffTime
instance Data.OpenApi.Internal.ParamSchema.ToParamSchema Data.Text.Internal.Text
instance Data.OpenApi.Internal.ParamSchema.ToParamSchema Data.Text.Internal.Lazy.Text
instance Data.OpenApi.Internal.ParamSchema.ToParamSchema Data.Version.Version
instance Data.OpenApi.Internal.ParamSchema.ToParamSchema Web.Cookie.SetCookie
instance Data.OpenApi.Internal.ParamSchema.ToParamSchema Data.Semigroup.Internal.All
instance Data.OpenApi.Internal.ParamSchema.ToParamSchema Data.Semigroup.Internal.Any
instance Data.OpenApi.Internal.ParamSchema.ToParamSchema a => Data.OpenApi.Internal.ParamSchema.ToParamSchema (Data.Semigroup.Internal.Sum a)
instance Data.OpenApi.Internal.ParamSchema.ToParamSchema a => Data.OpenApi.Internal.ParamSchema.ToParamSchema (Data.Semigroup.Internal.Product a)
instance Data.OpenApi.Internal.ParamSchema.ToParamSchema a => Data.OpenApi.Internal.ParamSchema.ToParamSchema (Data.Monoid.First a)
instance Data.OpenApi.Internal.ParamSchema.ToParamSchema a => Data.OpenApi.Internal.ParamSchema.ToParamSchema (Data.Monoid.Last a)
instance Data.OpenApi.Internal.ParamSchema.ToParamSchema a => Data.OpenApi.Internal.ParamSchema.ToParamSchema (Data.Semigroup.Internal.Dual a)
instance Data.OpenApi.Internal.ParamSchema.ToParamSchema a => Data.OpenApi.Internal.ParamSchema.ToParamSchema (Data.Functor.Identity.Identity a)
instance Data.OpenApi.Internal.ParamSchema.ToParamSchema a => Data.OpenApi.Internal.ParamSchema.ToParamSchema [a]
instance Data.OpenApi.Internal.ParamSchema.ToParamSchema a => Data.OpenApi.Internal.ParamSchema.ToParamSchema (Data.Vector.Vector a)
instance Data.OpenApi.Internal.ParamSchema.ToParamSchema a => Data.OpenApi.Internal.ParamSchema.ToParamSchema (Data.Vector.Primitive.Vector a)
instance Data.OpenApi.Internal.ParamSchema.ToParamSchema a => Data.OpenApi.Internal.ParamSchema.ToParamSchema (Data.Vector.Storable.Vector a)
instance Data.OpenApi.Internal.ParamSchema.ToParamSchema a => Data.OpenApi.Internal.ParamSchema.ToParamSchema (Data.Vector.Unboxed.Base.Vector a)
instance Data.OpenApi.Internal.ParamSchema.ToParamSchema a => Data.OpenApi.Internal.ParamSchema.ToParamSchema (Data.Set.Internal.Set a)
instance Data.OpenApi.Internal.ParamSchema.ToParamSchema a => Data.OpenApi.Internal.ParamSchema.ToParamSchema (Data.HashSet.Internal.HashSet a)
instance Data.OpenApi.Internal.ParamSchema.ToParamSchema ()
instance Data.OpenApi.Internal.ParamSchema.ToParamSchema Data.UUID.Types.Internal.UUID
instance Data.OpenApi.Internal.ParamSchema.ToParamSchema c => Data.OpenApi.Internal.ParamSchema.GToParamSchema (GHC.Generics.K1 i c)
instance Data.OpenApi.Internal.ParamSchema.GToParamSchema f => Data.OpenApi.Internal.ParamSchema.GToParamSchema (GHC.Generics.D1 d f)
instance Data.OpenApi.Internal.ParamSchema.GToParamSchema f => Data.OpenApi.Internal.ParamSchema.GToParamSchema (GHC.Generics.C1 c (GHC.Generics.S1 s f))


-- | Types and functions for working with Swagger parameter schema.
module Data.OpenApi.ParamSchema

-- | Convert a type into a plain <tt><a>Schema</a></tt>.
--   
--   In previous versions of the package there was a separate type called
--   <tt>ParamSchema</tt>, which was included in a greater <a>Schema</a>.
--   Now this is a single class, but distinction for schema generators for
--   "simple" types is preserved.
--   
--   <a>ToParamSchema</a> is suited only for primitive-like types without
--   nested fields and such.
--   
--   An example type and instance:
--   
--   <pre>
--   {-# LANGUAGE OverloadedStrings #-}   -- allows to write <a>Text</a> literals
--   
--   import Control.Lens
--   
--   data Direction = Up | Down
--   
--   instance ToParamSchema Direction where
--     toParamSchema _ = mempty
--        &amp; type_ ?~ OpenApiString
--        &amp; enum_ ?~ [ "Up", "Down" ]
--   </pre>
--   
--   Instead of manually writing your <tt><a>ToParamSchema</a></tt>
--   instance you can use a default generic implementation of
--   <tt><a>toParamSchema</a></tt>.
--   
--   To do that, simply add <tt>deriving <a>FPFormat</a></tt> clause to
--   your datatype and declare a <tt><a>ToParamSchema</a></tt> instance for
--   your datatype without giving definition for
--   <tt><a>toParamSchema</a></tt>.
--   
--   For instance, the previous example can be simplified into this:
--   
--   <pre>
--   {-# LANGUAGE DeriveGeneric #-}
--   
--   import GHC.Generics (Generic)
--   
--   data Direction = Up | Down deriving Generic
--   
--   instance ToParamSchema Direction
--   </pre>
class ToParamSchema a

-- | Convert a type into a plain parameter schema.
--   
--   <pre>
--   &gt;&gt;&gt; BSL.putStrLn $ encodePretty $ toParamSchema (Proxy :: Proxy Integer)
--   {
--       "type": "integer"
--   }
--   </pre>
toParamSchema :: ToParamSchema a => Proxy a -> Schema

-- | Convert a type into a plain parameter schema.
--   
--   <pre>
--   &gt;&gt;&gt; BSL.putStrLn $ encodePretty $ toParamSchema (Proxy :: Proxy Integer)
--   {
--       "type": "integer"
--   }
--   </pre>
toParamSchema :: (ToParamSchema a, Generic a, GToParamSchema (Rep a)) => Proxy a -> Schema

-- | A configurable generic <tt><a>Schema</a></tt> creator.
--   
--   <pre>
--   &gt;&gt;&gt; :set -XDeriveGeneric
--   
--   &gt;&gt;&gt; data Color = Red | Blue deriving Generic
--   
--   &gt;&gt;&gt; BSL.putStrLn $ encodePretty $ genericToParamSchema defaultSchemaOptions (Proxy :: Proxy Color)
--   {
--       "enum": [
--           "Red",
--           "Blue"
--       ],
--       "type": "string"
--   }
--   </pre>
genericToParamSchema :: forall a t. (Generic a, GToParamSchema (Rep a)) => SchemaOptions -> Proxy a -> Schema

-- | Default plain schema for <tt><a>Bounded</a></tt>,
--   <tt><a>Integral</a></tt> types.
--   
--   <pre>
--   &gt;&gt;&gt; BSL.putStrLn $ encodePretty $ toParamSchemaBoundedIntegral (Proxy :: Proxy Int8)
--   {
--       "maximum": 127,
--       "minimum": -128,
--       "type": "integer"
--   }
--   </pre>
toParamSchemaBoundedIntegral :: forall a t. (Bounded a, Integral a) => Proxy a -> Schema

-- | Default schema for password string. <tt>"password"</tt> format is used
--   to hint UIs the input needs to be obscured.
passwordSchema :: Schema

-- | Default schema for binary data (any sequence of octets).
binarySchema :: Schema

-- | Default schema for binary data (base64 encoded).
byteSchema :: Schema

-- | Options that specify how to encode your type to Swagger schema.
data SchemaOptions
SchemaOptions :: (String -> String) -> (String -> String) -> (String -> String) -> Bool -> Bool -> SumEncoding -> SchemaOptions

-- | Function applied to field labels. Handy for removing common record
--   prefixes for example.
[fieldLabelModifier] :: SchemaOptions -> String -> String

-- | Function applied to constructor tags which could be handy for
--   lower-casing them for example.
[constructorTagModifier] :: SchemaOptions -> String -> String

-- | Function applied to datatype name.
[datatypeNameModifier] :: SchemaOptions -> String -> String

-- | If <tt><a>True</a></tt> the constructors of a datatype, with all
--   nullary constructors, will be encoded to a string enumeration schema
--   with the constructor tags as possible values.
[allNullaryToStringTag] :: SchemaOptions -> Bool

-- | Hide the field name when a record constructor has only one field, like
--   a newtype.
[unwrapUnaryRecords] :: SchemaOptions -> Bool

-- | Specifies how to encode constructors of a sum datatype.
[sumEncoding] :: SchemaOptions -> SumEncoding

-- | Default encoding <tt><a>SchemaOptions</a></tt>.
--   
--   <pre>
--   <a>SchemaOptions</a>
--   { <a>fieldLabelModifier</a>     = id
--   , <a>constructorTagModifier</a> = id
--   , <a>datatypeNameModifier</a>   = id
--   , <a>allNullaryToStringTag</a>  = True
--   , <a>unwrapUnaryRecords</a>     = False
--   , <a>sumEncoding</a>            = <a>defaultTaggedObject</a>
--   }
--   </pre>
defaultSchemaOptions :: SchemaOptions

module Data.OpenApi.Internal.Schema
unnamed :: Schema -> NamedSchema
named :: Text -> Schema -> NamedSchema
plain :: Schema -> Declare (Definitions Schema) NamedSchema
unname :: NamedSchema -> NamedSchema
rename :: Maybe Text -> NamedSchema -> NamedSchema

-- | Convert a type into <tt><a>Schema</a></tt>.
--   
--   An example type and instance:
--   
--   <pre>
--   {-# LANGUAGE OverloadedStrings #-}   -- allows to write <a>Text</a> literals
--   {-# LANGUAGE OverloadedLists #-}     -- allows to write <a>Map</a> and <a>HashMap</a> as lists
--   
--   import Control.Lens
--   import Data.Proxy
--   import Data.OpenApi
--   
--   data Coord = Coord { x :: Double, y :: Double }
--   
--   instance ToSchema Coord where
--     declareNamedSchema _ = do
--       doubleSchema &lt;- declareSchemaRef (Proxy :: Proxy Double)
--       return $ NamedSchema (Just "Coord") $ mempty
--         &amp; type_ ?~ OpenApiObject
--         &amp; properties .~
--             [ ("x", doubleSchema)
--             , ("y", doubleSchema)
--             ]
--         &amp; required .~ [ "x", "y" ]
--   </pre>
--   
--   Instead of manually writing your <tt><a>ToSchema</a></tt> instance you
--   can use a default generic implementation of
--   <tt><a>declareNamedSchema</a></tt>.
--   
--   To do that, simply add <tt>deriving <a>Generic</a></tt> clause to your
--   datatype and declare a <tt><a>ToSchema</a></tt> instance for your
--   datatype without giving definition for
--   <tt><a>declareNamedSchema</a></tt>.
--   
--   For instance, the previous example can be simplified into this:
--   
--   <pre>
--   {-# LANGUAGE DeriveGeneric #-}
--   
--   import GHC.Generics (Generic)
--   
--   data Coord = Coord { x :: Double, y :: Double } deriving Generic
--   
--   instance ToSchema Coord
--   </pre>
class Typeable a => ToSchema a

-- | Convert a type into an optionally named schema together with all used
--   definitions. Note that the schema itself is included in definitions
--   only if it is recursive (and thus needs its definition in scope).
declareNamedSchema :: ToSchema a => Proxy a -> Declare (Definitions Schema) NamedSchema

-- | Convert a type into an optionally named schema together with all used
--   definitions. Note that the schema itself is included in definitions
--   only if it is recursive (and thus needs its definition in scope).
declareNamedSchema :: (ToSchema a, Generic a, GToSchema (Rep a)) => Proxy a -> Declare (Definitions Schema) NamedSchema

-- | Convert a type into a schema and declare all used schema definitions.
declareSchema :: ToSchema a => Proxy a -> Declare (Definitions Schema) Schema

-- | Convert a type into an optionally named schema.
--   
--   <pre>
--   &gt;&gt;&gt; toNamedSchema (Proxy :: Proxy String) ^. name
--   Nothing
--   
--   &gt;&gt;&gt; BSL.putStrLn $ encodePretty (toNamedSchema (Proxy :: Proxy String) ^. schema)
--   {
--       "type": "string"
--   }
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; toNamedSchema (Proxy :: Proxy Day) ^. name
--   Just "Day"
--   
--   &gt;&gt;&gt; BSL.putStrLn $ encodePretty (toNamedSchema (Proxy :: Proxy Day) ^. schema)
--   {
--       "example": "2016-07-22",
--       "format": "date",
--       "type": "string"
--   }
--   </pre>
toNamedSchema :: ToSchema a => Proxy a -> NamedSchema

-- | Get type's schema name according to its <tt><a>ToSchema</a></tt>
--   instance.
--   
--   <pre>
--   &gt;&gt;&gt; schemaName (Proxy :: Proxy Int)
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; schemaName (Proxy :: Proxy UTCTime)
--   Just "UTCTime"
--   </pre>
schemaName :: ToSchema a => Proxy a -> Maybe Text

-- | Convert a type into a schema.
--   
--   <pre>
--   &gt;&gt;&gt; BSL.putStrLn $ encodePretty $ toSchema (Proxy :: Proxy Int8)
--   {
--       "maximum": 127,
--       "minimum": -128,
--       "type": "integer"
--   }
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; BSL.putStrLn $ encodePretty $ toSchema (Proxy :: Proxy [Day])
--   {
--       "items": {
--           "$ref": "#/components/schemas/Day"
--       },
--       "type": "array"
--   }
--   </pre>
toSchema :: ToSchema a => Proxy a -> Schema

-- | Convert a type into a referenced schema if possible. Only named
--   schemas can be referenced, nameless schemas are inlined.
--   
--   <pre>
--   &gt;&gt;&gt; BSL.putStrLn $ encodePretty $ toSchemaRef (Proxy :: Proxy Integer)
--   {
--       "type": "integer"
--   }
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; BSL.putStrLn $ encodePretty $ toSchemaRef (Proxy :: Proxy Day)
--   {
--       "$ref": "#/components/schemas/Day"
--   }
--   </pre>
toSchemaRef :: ToSchema a => Proxy a -> Referenced Schema

-- | Convert a type into a referenced schema if possible and declare all
--   used schema definitions. Only named schemas can be referenced,
--   nameless schemas are inlined.
--   
--   Schema definitions are typically declared for every referenced schema.
--   If <tt><a>declareSchemaRef</a></tt> returns a reference, a
--   corresponding schema will be declared (regardless of whether it is
--   recusive or not).
declareSchemaRef :: ToSchema a => Proxy a -> Declare (Definitions Schema) (Referenced Schema)

-- | Inline any referenced schema if its name satisfies given predicate.
--   
--   <i>NOTE:</i> if a referenced schema is not found in definitions the
--   predicate is ignored and schema stays referenced.
--   
--   <b>WARNING:</b> <tt><a>inlineSchemasWhen</a></tt> will produce
--   infinite schemas when inlining recursive schemas.
inlineSchemasWhen :: Data s => (Text -> Bool) -> Definitions Schema -> s -> s

-- | Inline any referenced schema if its name is in the given list.
--   
--   <i>NOTE:</i> if a referenced schema is not found in definitions it
--   stays referenced even if it appears in the list of names.
--   
--   <b>WARNING:</b> <tt><a>inlineSchemas</a></tt> will produce infinite
--   schemas when inlining recursive schemas.
inlineSchemas :: Data s => [Text] -> Definitions Schema -> s -> s

-- | Inline all schema references for which the definition can be found in
--   <tt><a>Definitions</a></tt>.
--   
--   <b>WARNING:</b> <tt><a>inlineAllSchemas</a></tt> will produce infinite
--   schemas when inlining recursive schemas.
inlineAllSchemas :: Data s => Definitions Schema -> s -> s

-- | Convert a type into a schema without references.
--   
--   <pre>
--   &gt;&gt;&gt; BSL.putStrLn $ encodePretty $ toInlinedSchema (Proxy :: Proxy [Day])
--   {
--       "items": {
--           "example": "2016-07-22",
--           "format": "date",
--           "type": "string"
--       },
--       "type": "array"
--   }
--   </pre>
--   
--   <b>WARNING:</b> <tt><a>toInlinedSchema</a></tt> will produce infinite
--   schema when inlining recursive schemas.
toInlinedSchema :: ToSchema a => Proxy a -> Schema

-- | Inline all <i>non-recursive</i> schemas for which the definition can
--   be found in <tt><a>Definitions</a></tt>.
inlineNonRecursiveSchemas :: Data s => Definitions Schema -> s -> s

-- | Make an unrestrictive sketch of a <tt><a>Schema</a></tt> based on a
--   <tt><a>ToJSON</a></tt> instance. Produced schema can be used for
--   further refinement.
--   
--   <pre>
--   &gt;&gt;&gt; BSL.putStrLn $ encodePretty $ sketchSchema "hello"
--   {
--       "example": "hello",
--       "type": "string"
--   }
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; BSL.putStrLn $ encodePretty $ sketchSchema (1, 2, 3)
--   {
--       "example": [
--           1,
--           2,
--           3
--       ],
--       "items": {
--           "type": "number"
--       },
--       "type": "array"
--   }
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; BSL.putStrLn $ encodePretty $ sketchSchema ("Jack", 25)
--   {
--       "example": [
--           "Jack",
--           25
--       ],
--       "items": [
--           {
--               "type": "string"
--           },
--           {
--               "type": "number"
--           }
--       ],
--       "type": "array"
--   }
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; data Person = Person { name :: String, age :: Int } deriving (Generic)
--   
--   &gt;&gt;&gt; instance ToJSON Person
--   
--   &gt;&gt;&gt; BSL.putStrLn $ encodePretty $ sketchSchema (Person "Jack" 25)
--   {
--       "example": {
--           "age": 25,
--           "name": "Jack"
--       },
--       "properties": {
--           "age": {
--               "type": "number"
--           },
--           "name": {
--               "type": "string"
--           }
--       },
--       "required": [
--           "age",
--           "name"
--       ],
--       "type": "object"
--   }
--   </pre>
sketchSchema :: ToJSON a => a -> Schema

-- | Make a restrictive sketch of a <tt><a>Schema</a></tt> based on a
--   <tt><a>ToJSON</a></tt> instance. Produced schema uses as much
--   constraints as possible.
--   
--   <pre>
--   &gt;&gt;&gt; BSL.putStrLn $ encodePretty $ sketchStrictSchema "hello"
--   {
--       "enum": [
--           "hello"
--       ],
--       "maxLength": 5,
--       "minLength": 5,
--       "pattern": "hello",
--       "type": "string"
--   }
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; BSL.putStrLn $ encodePretty $ sketchStrictSchema (1, 2, 3)
--   {
--       "enum": [
--           [
--               1,
--               2,
--               3
--           ]
--       ],
--       "items": [
--           {
--               "enum": [
--                   1
--               ],
--               "maximum": 1,
--               "minimum": 1,
--               "multipleOf": 1,
--               "type": "number"
--           },
--           {
--               "enum": [
--                   2
--               ],
--               "maximum": 2,
--               "minimum": 2,
--               "multipleOf": 2,
--               "type": "number"
--           },
--           {
--               "enum": [
--                   3
--               ],
--               "maximum": 3,
--               "minimum": 3,
--               "multipleOf": 3,
--               "type": "number"
--           }
--       ],
--       "maxItems": 3,
--       "minItems": 3,
--       "type": "array",
--       "uniqueItems": true
--   }
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; BSL.putStrLn $ encodePretty $ sketchStrictSchema ("Jack", 25)
--   {
--       "enum": [
--           [
--               "Jack",
--               25
--           ]
--       ],
--       "items": [
--           {
--               "enum": [
--                   "Jack"
--               ],
--               "maxLength": 4,
--               "minLength": 4,
--               "pattern": "Jack",
--               "type": "string"
--           },
--           {
--               "enum": [
--                   25
--               ],
--               "maximum": 25,
--               "minimum": 25,
--               "multipleOf": 25,
--               "type": "number"
--           }
--       ],
--       "maxItems": 2,
--       "minItems": 2,
--       "type": "array",
--       "uniqueItems": true
--   }
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; data Person = Person { name :: String, age :: Int } deriving (Generic)
--   
--   &gt;&gt;&gt; instance ToJSON Person
--   
--   &gt;&gt;&gt; BSL.putStrLn $ encodePretty $ sketchStrictSchema (Person "Jack" 25)
--   {
--       "enum": [
--           {
--               "age": 25,
--               "name": "Jack"
--           }
--       ],
--       "maxProperties": 2,
--       "minProperties": 2,
--       "properties": {
--           "age": {
--               "enum": [
--                   25
--               ],
--               "maximum": 25,
--               "minimum": 25,
--               "multipleOf": 25,
--               "type": "number"
--           },
--           "name": {
--               "enum": [
--                   "Jack"
--               ],
--               "maxLength": 4,
--               "minLength": 4,
--               "pattern": "Jack",
--               "type": "string"
--           }
--       },
--       "required": [
--           "age",
--           "name"
--       ],
--       "type": "object"
--   }
--   </pre>
sketchStrictSchema :: ToJSON a => a -> Schema
class GToSchema (f :: * -> *)
gdeclareNamedSchema :: GToSchema f => SchemaOptions -> Proxy f -> Schema -> Declare (Definitions Schema) NamedSchema
timeSchema :: Text -> Schema
type family ToSchemaByteStringError bs

-- | Default schema for <tt><a>Bounded</a></tt>, <tt><a>Integral</a></tt>
--   types.
--   
--   <pre>
--   &gt;&gt;&gt; BSL.putStrLn $ encodePretty $ toSchemaBoundedIntegral (Proxy :: Proxy Int16)
--   {
--       "maximum": 32767,
--       "minimum": -32768,
--       "type": "integer"
--   }
--   </pre>
toSchemaBoundedIntegral :: forall a. (Bounded a, Integral a) => Proxy a -> Schema

-- | Default generic named schema for <tt><a>Bounded</a></tt>,
--   <tt><a>Integral</a></tt> types.
genericToNamedSchemaBoundedIntegral :: forall a d f. (Bounded a, Integral a, Generic a, Rep a ~ D1 d f, Datatype d) => SchemaOptions -> Proxy a -> NamedSchema

-- | Declare a named schema for a <tt>newtype</tt> wrapper.
genericDeclareNamedSchemaNewtype :: forall a d c s i inner. (Generic a, Datatype d, Rep a ~ D1 d (C1 c (S1 s (K1 i inner)))) => SchemaOptions -> (Proxy inner -> Declare (Definitions Schema) Schema) -> Proxy a -> Declare (Definitions Schema) NamedSchema

-- | Declare <a>Schema</a> for a mapping with <a>Bounded</a> <a>Enum</a>
--   keys. This makes a much more useful schema when there aren't many
--   options for key values.
--   
--   <pre>
--   &gt;&gt;&gt; data ButtonState = Neutral | Focus | Active | Hover | Disabled deriving (Show, Bounded, Enum, Generic)
--   
--   &gt;&gt;&gt; instance ToJSON ButtonState
--   
--   &gt;&gt;&gt; instance ToSchema ButtonState
--   
--   &gt;&gt;&gt; instance ToJSONKey ButtonState where toJSONKey = toJSONKeyText (T.pack . show)
--   
--   &gt;&gt;&gt; type ImageUrl = T.Text
--   
--   &gt;&gt;&gt; BSL.putStrLn $ encodePretty $ toSchemaBoundedEnumKeyMapping (Proxy :: Proxy (Map ButtonState ImageUrl))
--   {
--       "properties": {
--           "Active": {
--               "type": "string"
--           },
--           "Disabled": {
--               "type": "string"
--           },
--           "Focus": {
--               "type": "string"
--           },
--           "Hover": {
--               "type": "string"
--           },
--           "Neutral": {
--               "type": "string"
--           }
--       },
--       "type": "object"
--   }
--   </pre>
--   
--   Note: this is only useful when <tt>key</tt> is encoded with
--   <a>ToJSONKeyText</a>. If it is encoded with <a>ToJSONKeyValue</a> then
--   a regular schema for <tt>[(key, value)]</tt> is used.
declareSchemaBoundedEnumKeyMapping :: forall map key value. (Bounded key, Enum key, ToJSONKey key, ToSchema key, ToSchema value) => Proxy (map key value) -> Declare (Definitions Schema) Schema

-- | A <a>Schema</a> for a mapping with <a>Bounded</a> <a>Enum</a> keys.
--   This makes a much more useful schema when there aren't many options
--   for key values.
--   
--   <pre>
--   &gt;&gt;&gt; data ButtonState = Neutral | Focus | Active | Hover | Disabled deriving (Show, Bounded, Enum, Generic)
--   
--   &gt;&gt;&gt; instance ToJSON ButtonState
--   
--   &gt;&gt;&gt; instance ToSchema ButtonState
--   
--   &gt;&gt;&gt; instance ToJSONKey ButtonState where toJSONKey = toJSONKeyText (T.pack . show)
--   
--   &gt;&gt;&gt; type ImageUrl = T.Text
--   
--   &gt;&gt;&gt; BSL.putStrLn $ encodePretty $ toSchemaBoundedEnumKeyMapping (Proxy :: Proxy (Map ButtonState ImageUrl))
--   {
--       "properties": {
--           "Active": {
--               "type": "string"
--           },
--           "Disabled": {
--               "type": "string"
--           },
--           "Focus": {
--               "type": "string"
--           },
--           "Hover": {
--               "type": "string"
--           },
--           "Neutral": {
--               "type": "string"
--           }
--       },
--       "type": "object"
--   }
--   </pre>
--   
--   Note: this is only useful when <tt>key</tt> is encoded with
--   <a>ToJSONKeyText</a>. If it is encoded with <a>ToJSONKeyValue</a> then
--   a regular schema for <tt>[(key, value)]</tt> is used.
toSchemaBoundedEnumKeyMapping :: forall map key value. (Bounded key, Enum key, ToJSONKey key, ToSchema key, ToSchema value) => Proxy (map key value) -> Schema

-- | A configurable generic <tt><a>Schema</a></tt> creator.
genericDeclareSchema :: (Generic a, GToSchema (Rep a), Typeable a) => SchemaOptions -> Proxy a -> Declare (Definitions Schema) Schema

-- | A configurable generic <tt><a>NamedSchema</a></tt> creator. This
--   function applied to <tt><a>defaultSchemaOptions</a></tt> is used as
--   the default for <tt><a>declareNamedSchema</a></tt> when the type is an
--   instance of <tt><a>Generic</a></tt>.
--   
--   Default implementation will use the name from <a>Typeable</a>
--   instance, including concrete instantioations of type variables.
--   
--   For example:
--   
--   <pre>
--   &gt;&gt;&gt; _namedSchemaName $ undeclare $ genericDeclareNamedSchema defaultSchemaOptions (Proxy :: Proxy (Either Int Bool))
--   Just "Either_Int_Bool"
--   </pre>
genericDeclareNamedSchema :: forall a. (Generic a, GToSchema (Rep a), Typeable a) => SchemaOptions -> Proxy a -> Declare (Definitions Schema) NamedSchema

-- | Derive a <a>Generic</a>-based name for a datatype and assign it to a
--   given <a>Schema</a>.
genericNameSchema :: forall a d f. (Generic a, Rep a ~ D1 d f, Datatype d) => SchemaOptions -> Proxy a -> Schema -> NamedSchema
gdatatypeSchemaName :: forall d. Datatype d => SchemaOptions -> Proxy d -> Maybe Text

-- | Construct <a>NamedSchema</a> usinng <a>ToParamSchema</a>.
paramSchemaToNamedSchema :: (ToParamSchema a, Generic a, Rep a ~ D1 d f, Datatype d) => SchemaOptions -> Proxy a -> NamedSchema

-- | Construct <a>Schema</a> usinng <a>ToParamSchema</a>.
paramSchemaToSchema :: ToParamSchema a => Proxy a -> Schema
nullarySchema :: Schema
gtoNamedSchema :: GToSchema f => SchemaOptions -> Proxy f -> NamedSchema
gdeclareSchema :: GToSchema f => SchemaOptions -> Proxy f -> Declare (Definitions Schema) Schema
gdeclareSchemaRef :: GToSchema a => SchemaOptions -> Proxy a -> Declare (Definitions Schema) (Referenced Schema)
appendItem :: Referenced Schema -> Maybe OpenApiItems -> Maybe OpenApiItems
withFieldSchema :: forall proxy s f. (Selector s, GToSchema f) => SchemaOptions -> proxy s f -> Bool -> Schema -> Declare (Definitions Schema) Schema
gdeclareNamedSumSchema :: GSumToSchema f => SchemaOptions -> Proxy f -> Schema -> Declare (Definitions Schema) NamedSchema
type AllNullary = All
class GSumToSchema (f :: * -> *)
gsumToSchema :: GSumToSchema f => SchemaOptions -> Proxy f -> WriterT AllNullary (Declare (Definitions Schema)) [(Text, Referenced Schema)]

-- | Convert one component of the sum to schema, to be later combined with
--   <tt>oneOf</tt>.
gsumConToSchemaWith :: forall c f. (GToSchema (C1 c f), Constructor c) => Maybe (Referenced Schema) -> SchemaOptions -> Proxy (C1 c f) -> (Text, Referenced Schema)
gsumConToSchema :: (GToSchema (C1 c f), Constructor c) => SchemaOptions -> Proxy (C1 c f) -> Declare (Definitions Schema) [(Text, Referenced Schema)]
data Proxy2 a b
Proxy2 :: Proxy2 a b
data Proxy3 a b c
Proxy3 :: Proxy3 a b c
instance (GHC.Generics.Selector s, Data.OpenApi.Internal.Schema.ToSchema c) => Data.OpenApi.Internal.Schema.GToSchema (GHC.Generics.S1 s (GHC.Generics.K1 i (GHC.Maybe.Maybe c)))
instance (GHC.Generics.Selector s, Data.OpenApi.Internal.Schema.GToSchema f) => Data.OpenApi.Internal.Schema.GToSchema (GHC.Generics.S1 s f)
instance (Data.OpenApi.Internal.Schema.GSumToSchema f, Data.OpenApi.Internal.Schema.GSumToSchema g) => Data.OpenApi.Internal.Schema.GToSchema (f GHC.Generics.:+: g)
instance (Data.OpenApi.Internal.Schema.GSumToSchema f, Data.OpenApi.Internal.Schema.GSumToSchema g) => Data.OpenApi.Internal.Schema.GSumToSchema (f GHC.Generics.:+: g)
instance (GHC.Generics.Constructor c, Data.OpenApi.Internal.Schema.GToSchema f) => Data.OpenApi.Internal.Schema.GSumToSchema (GHC.Generics.C1 c f)
instance (GHC.Generics.Constructor c, GHC.Generics.Selector s, Data.OpenApi.Internal.Schema.GToSchema f) => Data.OpenApi.Internal.Schema.GSumToSchema (GHC.Generics.C1 c (GHC.Generics.S1 s f))
instance GHC.Generics.Constructor c => Data.OpenApi.Internal.Schema.GSumToSchema (GHC.Generics.C1 c GHC.Generics.U1)
instance Data.OpenApi.Internal.Schema.ToSchemaByteStringError Data.ByteString.Internal.Type.ByteString => Data.OpenApi.Internal.Schema.ToSchema Data.ByteString.Internal.Type.ByteString
instance Data.OpenApi.Internal.Schema.ToSchemaByteStringError Data.ByteString.Lazy.Internal.ByteString => Data.OpenApi.Internal.Schema.ToSchema Data.ByteString.Lazy.Internal.ByteString
instance Data.OpenApi.Internal.Schema.ToSchema Data.Time.LocalTime.Internal.TimeOfDay.TimeOfDay
instance Data.OpenApi.Internal.Schema.ToSchema a => Data.OpenApi.Internal.Schema.ToSchema [a]
instance Data.OpenApi.Internal.Schema.ToSchema GHC.Base.String
instance Data.OpenApi.Internal.Schema.ToSchema GHC.Types.Bool
instance Data.OpenApi.Internal.Schema.ToSchema GHC.Num.Integer.Integer
instance Data.OpenApi.Internal.Schema.ToSchema GHC.Num.Natural.Natural
instance Data.OpenApi.Internal.Schema.ToSchema GHC.Types.Int
instance Data.OpenApi.Internal.Schema.ToSchema GHC.Int.Int8
instance Data.OpenApi.Internal.Schema.ToSchema GHC.Int.Int16
instance Data.OpenApi.Internal.Schema.ToSchema GHC.Int.Int32
instance Data.OpenApi.Internal.Schema.ToSchema GHC.Int.Int64
instance Data.OpenApi.Internal.Schema.ToSchema GHC.Types.Word
instance Data.OpenApi.Internal.Schema.ToSchema GHC.Word.Word8
instance Data.OpenApi.Internal.Schema.ToSchema GHC.Word.Word16
instance Data.OpenApi.Internal.Schema.ToSchema GHC.Word.Word32
instance Data.OpenApi.Internal.Schema.ToSchema GHC.Word.Word64
instance Data.OpenApi.Internal.Schema.ToSchema GHC.Types.Char
instance Data.OpenApi.Internal.Schema.ToSchema Data.Scientific.Scientific
instance Data.OpenApi.Internal.Schema.ToSchema GHC.Types.Double
instance Data.OpenApi.Internal.Schema.ToSchema GHC.Types.Float
instance forall k (a :: k). (Data.Typeable.Internal.Typeable (Data.Fixed.Fixed a), Data.Fixed.HasResolution a) => Data.OpenApi.Internal.Schema.ToSchema (Data.Fixed.Fixed a)
instance Data.OpenApi.Internal.Schema.ToSchema a => Data.OpenApi.Internal.Schema.ToSchema (GHC.Maybe.Maybe a)
instance (Data.OpenApi.Internal.Schema.ToSchema a, Data.OpenApi.Internal.Schema.ToSchema b) => Data.OpenApi.Internal.Schema.ToSchema (Data.Either.Either a b)
instance Data.OpenApi.Internal.Schema.ToSchema ()
instance Data.OpenApi.Internal.Schema.ToSchema Data.UUID.Types.Internal.UUID
instance (Data.OpenApi.Internal.Schema.ToSchema a, Data.OpenApi.Internal.Schema.ToSchema b) => Data.OpenApi.Internal.Schema.ToSchema (a, b)
instance (Data.OpenApi.Internal.Schema.ToSchema a, Data.OpenApi.Internal.Schema.ToSchema b, Data.OpenApi.Internal.Schema.ToSchema c) => Data.OpenApi.Internal.Schema.ToSchema (a, b, c)
instance (Data.OpenApi.Internal.Schema.ToSchema a, Data.OpenApi.Internal.Schema.ToSchema b, Data.OpenApi.Internal.Schema.ToSchema c, Data.OpenApi.Internal.Schema.ToSchema d) => Data.OpenApi.Internal.Schema.ToSchema (a, b, c, d)
instance (Data.OpenApi.Internal.Schema.ToSchema a, Data.OpenApi.Internal.Schema.ToSchema b, Data.OpenApi.Internal.Schema.ToSchema c, Data.OpenApi.Internal.Schema.ToSchema d, Data.OpenApi.Internal.Schema.ToSchema e) => Data.OpenApi.Internal.Schema.ToSchema (a, b, c, d, e)
instance (Data.OpenApi.Internal.Schema.ToSchema a, Data.OpenApi.Internal.Schema.ToSchema b, Data.OpenApi.Internal.Schema.ToSchema c, Data.OpenApi.Internal.Schema.ToSchema d, Data.OpenApi.Internal.Schema.ToSchema e, Data.OpenApi.Internal.Schema.ToSchema f) => Data.OpenApi.Internal.Schema.ToSchema (a, b, c, d, e, f)
instance (Data.OpenApi.Internal.Schema.ToSchema a, Data.OpenApi.Internal.Schema.ToSchema b, Data.OpenApi.Internal.Schema.ToSchema c, Data.OpenApi.Internal.Schema.ToSchema d, Data.OpenApi.Internal.Schema.ToSchema e, Data.OpenApi.Internal.Schema.ToSchema f, Data.OpenApi.Internal.Schema.ToSchema g) => Data.OpenApi.Internal.Schema.ToSchema (a, b, c, d, e, f, g)
instance Data.OpenApi.Internal.Schema.ToSchema Data.Time.Calendar.Days.Day
instance Data.OpenApi.Internal.Schema.ToSchema Data.Time.LocalTime.Internal.LocalTime.LocalTime
instance Data.OpenApi.Internal.Schema.ToSchema Data.Time.LocalTime.Internal.ZonedTime.ZonedTime
instance Data.OpenApi.Internal.Schema.ToSchema Data.Time.Clock.Internal.NominalDiffTime.NominalDiffTime
instance Data.OpenApi.Internal.Schema.ToSchema Data.Time.Clock.Internal.UTCTime.UTCTime
instance Data.OpenApi.Internal.Schema.ToSchema Data.Text.Internal.Text
instance Data.OpenApi.Internal.Schema.ToSchema Data.Text.Internal.Lazy.Text
instance Data.OpenApi.Internal.Schema.ToSchema Data.Version.Version
instance Data.OpenApi.Internal.Schema.ToSchema Data.IntSet.Internal.IntSet
instance Data.OpenApi.Internal.Schema.ToSchema a => Data.OpenApi.Internal.Schema.ToSchema (Data.IntMap.Internal.IntMap a)
instance (Data.Aeson.Types.ToJSON.ToJSONKey k, Data.OpenApi.Internal.Schema.ToSchema k, Data.OpenApi.Internal.Schema.ToSchema v) => Data.OpenApi.Internal.Schema.ToSchema (Data.Map.Internal.Map k v)
instance (Data.Aeson.Types.ToJSON.ToJSONKey k, Data.OpenApi.Internal.Schema.ToSchema k, Data.OpenApi.Internal.Schema.ToSchema v) => Data.OpenApi.Internal.Schema.ToSchema (Data.HashMap.Internal.HashMap k v)
instance Data.OpenApi.Internal.Schema.ToSchema Data.Aeson.Types.Internal.Object
instance Data.OpenApi.Internal.Schema.ToSchema a => Data.OpenApi.Internal.Schema.ToSchema (Data.Vector.Vector a)
instance Data.OpenApi.Internal.Schema.ToSchema a => Data.OpenApi.Internal.Schema.ToSchema (Data.Vector.Unboxed.Base.Vector a)
instance Data.OpenApi.Internal.Schema.ToSchema a => Data.OpenApi.Internal.Schema.ToSchema (Data.Vector.Storable.Vector a)
instance Data.OpenApi.Internal.Schema.ToSchema a => Data.OpenApi.Internal.Schema.ToSchema (Data.Vector.Primitive.Vector a)
instance Data.OpenApi.Internal.Schema.ToSchema a => Data.OpenApi.Internal.Schema.ToSchema (Data.Set.Internal.Set a)
instance Data.OpenApi.Internal.Schema.ToSchema a => Data.OpenApi.Internal.Schema.ToSchema (Data.HashSet.Internal.HashSet a)
instance Data.OpenApi.Internal.Schema.ToSchema a => Data.OpenApi.Internal.Schema.ToSchema (GHC.Base.NonEmpty a)
instance Data.OpenApi.Internal.Schema.ToSchema Data.Semigroup.Internal.All
instance Data.OpenApi.Internal.Schema.ToSchema Data.Semigroup.Internal.Any
instance Data.OpenApi.Internal.Schema.ToSchema a => Data.OpenApi.Internal.Schema.ToSchema (Data.Semigroup.Internal.Sum a)
instance Data.OpenApi.Internal.Schema.ToSchema a => Data.OpenApi.Internal.Schema.ToSchema (Data.Semigroup.Internal.Product a)
instance Data.OpenApi.Internal.Schema.ToSchema a => Data.OpenApi.Internal.Schema.ToSchema (Data.Semigroup.First a)
instance Data.OpenApi.Internal.Schema.ToSchema a => Data.OpenApi.Internal.Schema.ToSchema (Data.Semigroup.Last a)
instance Data.OpenApi.Internal.Schema.ToSchema a => Data.OpenApi.Internal.Schema.ToSchema (Data.Semigroup.Internal.Dual a)
instance Data.OpenApi.Internal.Schema.ToSchema a => Data.OpenApi.Internal.Schema.ToSchema (Data.Functor.Identity.Identity a)
instance Data.OpenApi.Internal.Schema.ToSchema c => Data.OpenApi.Internal.Schema.GToSchema (GHC.Generics.K1 i (GHC.Maybe.Maybe c))
instance Data.OpenApi.Internal.Schema.ToSchema c => Data.OpenApi.Internal.Schema.GToSchema (GHC.Generics.K1 i c)
instance (Data.OpenApi.Internal.Schema.GToSchema f, Data.OpenApi.Internal.Schema.GToSchema g) => Data.OpenApi.Internal.Schema.GToSchema (f GHC.Generics.:*: g)
instance (GHC.Generics.Datatype d, Data.OpenApi.Internal.Schema.GToSchema f) => Data.OpenApi.Internal.Schema.GToSchema (GHC.Generics.D1 d f)
instance Data.OpenApi.Internal.Schema.GToSchema f => Data.OpenApi.Internal.Schema.GToSchema (GHC.Generics.C1 c f)
instance GHC.Generics.Constructor c => Data.OpenApi.Internal.Schema.GToSchema (GHC.Generics.C1 c GHC.Generics.U1)
instance (GHC.Generics.Selector s, Data.OpenApi.Internal.Schema.GToSchema f, Data.OpenApi.Internal.Schema.GToSchema (GHC.Generics.S1 s f)) => Data.OpenApi.Internal.Schema.GToSchema (GHC.Generics.C1 c (GHC.Generics.S1 s f))


-- | Types and functions for working with Swagger schema.
module Data.OpenApi.Schema

-- | Convert a type into <tt><a>Schema</a></tt>.
--   
--   An example type and instance:
--   
--   <pre>
--   {-# LANGUAGE OverloadedStrings #-}   -- allows to write <a>Text</a> literals
--   {-# LANGUAGE OverloadedLists #-}     -- allows to write <a>Map</a> and <a>HashMap</a> as lists
--   
--   import Control.Lens
--   import Data.Proxy
--   import Data.OpenApi
--   
--   data Coord = Coord { x :: Double, y :: Double }
--   
--   instance ToSchema Coord where
--     declareNamedSchema _ = do
--       doubleSchema &lt;- declareSchemaRef (Proxy :: Proxy Double)
--       return $ NamedSchema (Just "Coord") $ mempty
--         &amp; type_ ?~ OpenApiObject
--         &amp; properties .~
--             [ ("x", doubleSchema)
--             , ("y", doubleSchema)
--             ]
--         &amp; required .~ [ "x", "y" ]
--   </pre>
--   
--   Instead of manually writing your <tt><a>ToSchema</a></tt> instance you
--   can use a default generic implementation of
--   <tt><a>declareNamedSchema</a></tt>.
--   
--   To do that, simply add <tt>deriving <a>Generic</a></tt> clause to your
--   datatype and declare a <tt><a>ToSchema</a></tt> instance for your
--   datatype without giving definition for
--   <tt><a>declareNamedSchema</a></tt>.
--   
--   For instance, the previous example can be simplified into this:
--   
--   <pre>
--   {-# LANGUAGE DeriveGeneric #-}
--   
--   import GHC.Generics (Generic)
--   
--   data Coord = Coord { x :: Double, y :: Double } deriving Generic
--   
--   instance ToSchema Coord
--   </pre>
class Typeable a => ToSchema a

-- | Convert a type into an optionally named schema together with all used
--   definitions. Note that the schema itself is included in definitions
--   only if it is recursive (and thus needs its definition in scope).
declareNamedSchema :: ToSchema a => Proxy a -> Declare (Definitions Schema) NamedSchema

-- | Convert a type into an optionally named schema together with all used
--   definitions. Note that the schema itself is included in definitions
--   only if it is recursive (and thus needs its definition in scope).
declareNamedSchema :: (ToSchema a, Generic a, GToSchema (Rep a)) => Proxy a -> Declare (Definitions Schema) NamedSchema

-- | Convert a type into a schema and declare all used schema definitions.
declareSchema :: ToSchema a => Proxy a -> Declare (Definitions Schema) Schema

-- | Convert a type into a referenced schema if possible and declare all
--   used schema definitions. Only named schemas can be referenced,
--   nameless schemas are inlined.
--   
--   Schema definitions are typically declared for every referenced schema.
--   If <tt><a>declareSchemaRef</a></tt> returns a reference, a
--   corresponding schema will be declared (regardless of whether it is
--   recusive or not).
declareSchemaRef :: ToSchema a => Proxy a -> Declare (Definitions Schema) (Referenced Schema)

-- | Convert a type into a schema.
--   
--   <pre>
--   &gt;&gt;&gt; BSL.putStrLn $ encodePretty $ toSchema (Proxy :: Proxy Int8)
--   {
--       "maximum": 127,
--       "minimum": -128,
--       "type": "integer"
--   }
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; BSL.putStrLn $ encodePretty $ toSchema (Proxy :: Proxy [Day])
--   {
--       "items": {
--           "$ref": "#/components/schemas/Day"
--       },
--       "type": "array"
--   }
--   </pre>
toSchema :: ToSchema a => Proxy a -> Schema

-- | Convert a type into a referenced schema if possible. Only named
--   schemas can be referenced, nameless schemas are inlined.
--   
--   <pre>
--   &gt;&gt;&gt; BSL.putStrLn $ encodePretty $ toSchemaRef (Proxy :: Proxy Integer)
--   {
--       "type": "integer"
--   }
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; BSL.putStrLn $ encodePretty $ toSchemaRef (Proxy :: Proxy Day)
--   {
--       "$ref": "#/components/schemas/Day"
--   }
--   </pre>
toSchemaRef :: ToSchema a => Proxy a -> Referenced Schema

-- | Get type's schema name according to its <tt><a>ToSchema</a></tt>
--   instance.
--   
--   <pre>
--   &gt;&gt;&gt; schemaName (Proxy :: Proxy Int)
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; schemaName (Proxy :: Proxy UTCTime)
--   Just "UTCTime"
--   </pre>
schemaName :: ToSchema a => Proxy a -> Maybe Text

-- | Convert a type into a schema without references.
--   
--   <pre>
--   &gt;&gt;&gt; BSL.putStrLn $ encodePretty $ toInlinedSchema (Proxy :: Proxy [Day])
--   {
--       "items": {
--           "example": "2016-07-22",
--           "format": "date",
--           "type": "string"
--       },
--       "type": "array"
--   }
--   </pre>
--   
--   <b>WARNING:</b> <tt><a>toInlinedSchema</a></tt> will produce infinite
--   schema when inlining recursive schemas.
toInlinedSchema :: ToSchema a => Proxy a -> Schema

-- | A configurable generic <tt><a>NamedSchema</a></tt> creator. This
--   function applied to <tt><a>defaultSchemaOptions</a></tt> is used as
--   the default for <tt><a>declareNamedSchema</a></tt> when the type is an
--   instance of <tt><a>Generic</a></tt>.
--   
--   Default implementation will use the name from <a>Typeable</a>
--   instance, including concrete instantioations of type variables.
--   
--   For example:
--   
--   <pre>
--   &gt;&gt;&gt; _namedSchemaName $ undeclare $ genericDeclareNamedSchema defaultSchemaOptions (Proxy :: Proxy (Either Int Bool))
--   Just "Either_Int_Bool"
--   </pre>
genericDeclareNamedSchema :: forall a. (Generic a, GToSchema (Rep a), Typeable a) => SchemaOptions -> Proxy a -> Declare (Definitions Schema) NamedSchema

-- | A configurable generic <tt><a>Schema</a></tt> creator.
genericDeclareSchema :: (Generic a, GToSchema (Rep a), Typeable a) => SchemaOptions -> Proxy a -> Declare (Definitions Schema) Schema

-- | Declare a named schema for a <tt>newtype</tt> wrapper.
genericDeclareNamedSchemaNewtype :: forall a d c s i inner. (Generic a, Datatype d, Rep a ~ D1 d (C1 c (S1 s (K1 i inner)))) => SchemaOptions -> (Proxy inner -> Declare (Definitions Schema) Schema) -> Proxy a -> Declare (Definitions Schema) NamedSchema

-- | Derive a <a>Generic</a>-based name for a datatype and assign it to a
--   given <a>Schema</a>.
genericNameSchema :: forall a d f. (Generic a, Rep a ~ D1 d f, Datatype d) => SchemaOptions -> Proxy a -> Schema -> NamedSchema

-- | Default generic named schema for <tt><a>Bounded</a></tt>,
--   <tt><a>Integral</a></tt> types.
genericToNamedSchemaBoundedIntegral :: forall a d f. (Bounded a, Integral a, Generic a, Rep a ~ D1 d f, Datatype d) => SchemaOptions -> Proxy a -> NamedSchema

-- | Default schema for <tt><a>Bounded</a></tt>, <tt><a>Integral</a></tt>
--   types.
--   
--   <pre>
--   &gt;&gt;&gt; BSL.putStrLn $ encodePretty $ toSchemaBoundedIntegral (Proxy :: Proxy Int16)
--   {
--       "maximum": 32767,
--       "minimum": -32768,
--       "type": "integer"
--   }
--   </pre>
toSchemaBoundedIntegral :: forall a. (Bounded a, Integral a) => Proxy a -> Schema

-- | Declare <a>Schema</a> for a mapping with <a>Bounded</a> <a>Enum</a>
--   keys. This makes a much more useful schema when there aren't many
--   options for key values.
--   
--   <pre>
--   &gt;&gt;&gt; data ButtonState = Neutral | Focus | Active | Hover | Disabled deriving (Show, Bounded, Enum, Generic)
--   
--   &gt;&gt;&gt; instance ToJSON ButtonState
--   
--   &gt;&gt;&gt; instance ToSchema ButtonState
--   
--   &gt;&gt;&gt; instance ToJSONKey ButtonState where toJSONKey = toJSONKeyText (T.pack . show)
--   
--   &gt;&gt;&gt; type ImageUrl = T.Text
--   
--   &gt;&gt;&gt; BSL.putStrLn $ encodePretty $ toSchemaBoundedEnumKeyMapping (Proxy :: Proxy (Map ButtonState ImageUrl))
--   {
--       "properties": {
--           "Active": {
--               "type": "string"
--           },
--           "Disabled": {
--               "type": "string"
--           },
--           "Focus": {
--               "type": "string"
--           },
--           "Hover": {
--               "type": "string"
--           },
--           "Neutral": {
--               "type": "string"
--           }
--       },
--       "type": "object"
--   }
--   </pre>
--   
--   Note: this is only useful when <tt>key</tt> is encoded with
--   <a>ToJSONKeyText</a>. If it is encoded with <a>ToJSONKeyValue</a> then
--   a regular schema for <tt>[(key, value)]</tt> is used.
declareSchemaBoundedEnumKeyMapping :: forall map key value. (Bounded key, Enum key, ToJSONKey key, ToSchema key, ToSchema value) => Proxy (map key value) -> Declare (Definitions Schema) Schema

-- | A <a>Schema</a> for a mapping with <a>Bounded</a> <a>Enum</a> keys.
--   This makes a much more useful schema when there aren't many options
--   for key values.
--   
--   <pre>
--   &gt;&gt;&gt; data ButtonState = Neutral | Focus | Active | Hover | Disabled deriving (Show, Bounded, Enum, Generic)
--   
--   &gt;&gt;&gt; instance ToJSON ButtonState
--   
--   &gt;&gt;&gt; instance ToSchema ButtonState
--   
--   &gt;&gt;&gt; instance ToJSONKey ButtonState where toJSONKey = toJSONKeyText (T.pack . show)
--   
--   &gt;&gt;&gt; type ImageUrl = T.Text
--   
--   &gt;&gt;&gt; BSL.putStrLn $ encodePretty $ toSchemaBoundedEnumKeyMapping (Proxy :: Proxy (Map ButtonState ImageUrl))
--   {
--       "properties": {
--           "Active": {
--               "type": "string"
--           },
--           "Disabled": {
--               "type": "string"
--           },
--           "Focus": {
--               "type": "string"
--           },
--           "Hover": {
--               "type": "string"
--           },
--           "Neutral": {
--               "type": "string"
--           }
--       },
--       "type": "object"
--   }
--   </pre>
--   
--   Note: this is only useful when <tt>key</tt> is encoded with
--   <a>ToJSONKeyText</a>. If it is encoded with <a>ToJSONKeyValue</a> then
--   a regular schema for <tt>[(key, value)]</tt> is used.
toSchemaBoundedEnumKeyMapping :: forall map key value. (Bounded key, Enum key, ToJSONKey key, ToSchema key, ToSchema value) => Proxy (map key value) -> Schema

-- | Construct <a>NamedSchema</a> usinng <a>ToParamSchema</a>.
paramSchemaToNamedSchema :: (ToParamSchema a, Generic a, Rep a ~ D1 d f, Datatype d) => SchemaOptions -> Proxy a -> NamedSchema

-- | Construct <a>Schema</a> usinng <a>ToParamSchema</a>.
paramSchemaToSchema :: ToParamSchema a => Proxy a -> Schema

-- | Make an unrestrictive sketch of a <tt><a>Schema</a></tt> based on a
--   <tt><a>ToJSON</a></tt> instance. Produced schema can be used for
--   further refinement.
--   
--   <pre>
--   &gt;&gt;&gt; BSL.putStrLn $ encodePretty $ sketchSchema "hello"
--   {
--       "example": "hello",
--       "type": "string"
--   }
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; BSL.putStrLn $ encodePretty $ sketchSchema (1, 2, 3)
--   {
--       "example": [
--           1,
--           2,
--           3
--       ],
--       "items": {
--           "type": "number"
--       },
--       "type": "array"
--   }
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; BSL.putStrLn $ encodePretty $ sketchSchema ("Jack", 25)
--   {
--       "example": [
--           "Jack",
--           25
--       ],
--       "items": [
--           {
--               "type": "string"
--           },
--           {
--               "type": "number"
--           }
--       ],
--       "type": "array"
--   }
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; data Person = Person { name :: String, age :: Int } deriving (Generic)
--   
--   &gt;&gt;&gt; instance ToJSON Person
--   
--   &gt;&gt;&gt; BSL.putStrLn $ encodePretty $ sketchSchema (Person "Jack" 25)
--   {
--       "example": {
--           "age": 25,
--           "name": "Jack"
--       },
--       "properties": {
--           "age": {
--               "type": "number"
--           },
--           "name": {
--               "type": "string"
--           }
--       },
--       "required": [
--           "age",
--           "name"
--       ],
--       "type": "object"
--   }
--   </pre>
sketchSchema :: ToJSON a => a -> Schema

-- | Make a restrictive sketch of a <tt><a>Schema</a></tt> based on a
--   <tt><a>ToJSON</a></tt> instance. Produced schema uses as much
--   constraints as possible.
--   
--   <pre>
--   &gt;&gt;&gt; BSL.putStrLn $ encodePretty $ sketchStrictSchema "hello"
--   {
--       "enum": [
--           "hello"
--       ],
--       "maxLength": 5,
--       "minLength": 5,
--       "pattern": "hello",
--       "type": "string"
--   }
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; BSL.putStrLn $ encodePretty $ sketchStrictSchema (1, 2, 3)
--   {
--       "enum": [
--           [
--               1,
--               2,
--               3
--           ]
--       ],
--       "items": [
--           {
--               "enum": [
--                   1
--               ],
--               "maximum": 1,
--               "minimum": 1,
--               "multipleOf": 1,
--               "type": "number"
--           },
--           {
--               "enum": [
--                   2
--               ],
--               "maximum": 2,
--               "minimum": 2,
--               "multipleOf": 2,
--               "type": "number"
--           },
--           {
--               "enum": [
--                   3
--               ],
--               "maximum": 3,
--               "minimum": 3,
--               "multipleOf": 3,
--               "type": "number"
--           }
--       ],
--       "maxItems": 3,
--       "minItems": 3,
--       "type": "array",
--       "uniqueItems": true
--   }
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; BSL.putStrLn $ encodePretty $ sketchStrictSchema ("Jack", 25)
--   {
--       "enum": [
--           [
--               "Jack",
--               25
--           ]
--       ],
--       "items": [
--           {
--               "enum": [
--                   "Jack"
--               ],
--               "maxLength": 4,
--               "minLength": 4,
--               "pattern": "Jack",
--               "type": "string"
--           },
--           {
--               "enum": [
--                   25
--               ],
--               "maximum": 25,
--               "minimum": 25,
--               "multipleOf": 25,
--               "type": "number"
--           }
--       ],
--       "maxItems": 2,
--       "minItems": 2,
--       "type": "array",
--       "uniqueItems": true
--   }
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; data Person = Person { name :: String, age :: Int } deriving (Generic)
--   
--   &gt;&gt;&gt; instance ToJSON Person
--   
--   &gt;&gt;&gt; BSL.putStrLn $ encodePretty $ sketchStrictSchema (Person "Jack" 25)
--   {
--       "enum": [
--           {
--               "age": 25,
--               "name": "Jack"
--           }
--       ],
--       "maxProperties": 2,
--       "minProperties": 2,
--       "properties": {
--           "age": {
--               "enum": [
--                   25
--               ],
--               "maximum": 25,
--               "minimum": 25,
--               "multipleOf": 25,
--               "type": "number"
--           },
--           "name": {
--               "enum": [
--                   "Jack"
--               ],
--               "maxLength": 4,
--               "minLength": 4,
--               "pattern": "Jack",
--               "type": "string"
--           }
--       },
--       "required": [
--           "age",
--           "name"
--       ],
--       "type": "object"
--   }
--   </pre>
sketchStrictSchema :: ToJSON a => a -> Schema

-- | Inline all <i>non-recursive</i> schemas for which the definition can
--   be found in <tt><a>Definitions</a></tt>.
inlineNonRecursiveSchemas :: Data s => Definitions Schema -> s -> s

-- | Inline all schema references for which the definition can be found in
--   <tt><a>Definitions</a></tt>.
--   
--   <b>WARNING:</b> <tt><a>inlineAllSchemas</a></tt> will produce infinite
--   schemas when inlining recursive schemas.
inlineAllSchemas :: Data s => Definitions Schema -> s -> s

-- | Inline any referenced schema if its name is in the given list.
--   
--   <i>NOTE:</i> if a referenced schema is not found in definitions it
--   stays referenced even if it appears in the list of names.
--   
--   <b>WARNING:</b> <tt><a>inlineSchemas</a></tt> will produce infinite
--   schemas when inlining recursive schemas.
inlineSchemas :: Data s => [Text] -> Definitions Schema -> s -> s

-- | Inline any referenced schema if its name satisfies given predicate.
--   
--   <i>NOTE:</i> if a referenced schema is not found in definitions the
--   predicate is ignored and schema stays referenced.
--   
--   <b>WARNING:</b> <tt><a>inlineSchemasWhen</a></tt> will produce
--   infinite schemas when inlining recursive schemas.
inlineSchemasWhen :: Data s => (Text -> Bool) -> Definitions Schema -> s -> s

-- | Options that specify how to encode your type to Swagger schema.
data SchemaOptions
SchemaOptions :: (String -> String) -> (String -> String) -> (String -> String) -> Bool -> Bool -> SumEncoding -> SchemaOptions

-- | Function applied to field labels. Handy for removing common record
--   prefixes for example.
[fieldLabelModifier] :: SchemaOptions -> String -> String

-- | Function applied to constructor tags which could be handy for
--   lower-casing them for example.
[constructorTagModifier] :: SchemaOptions -> String -> String

-- | Function applied to datatype name.
[datatypeNameModifier] :: SchemaOptions -> String -> String

-- | If <tt><a>True</a></tt> the constructors of a datatype, with all
--   nullary constructors, will be encoded to a string enumeration schema
--   with the constructor tags as possible values.
[allNullaryToStringTag] :: SchemaOptions -> Bool

-- | Hide the field name when a record constructor has only one field, like
--   a newtype.
[unwrapUnaryRecords] :: SchemaOptions -> Bool

-- | Specifies how to encode constructors of a sum datatype.
[sumEncoding] :: SchemaOptions -> SumEncoding

-- | Default encoding <tt><a>SchemaOptions</a></tt>.
--   
--   <pre>
--   <a>SchemaOptions</a>
--   { <a>fieldLabelModifier</a>     = id
--   , <a>constructorTagModifier</a> = id
--   , <a>datatypeNameModifier</a>   = id
--   , <a>allNullaryToStringTag</a>  = True
--   , <a>unwrapUnaryRecords</a>     = False
--   , <a>sumEncoding</a>            = <a>defaultTaggedObject</a>
--   }
--   </pre>
defaultSchemaOptions :: SchemaOptions

-- | Convert <a>Options</a> to <a>SchemaOptions</a>.
--   
--   Specifically the following fields get copied:
--   
--   <ul>
--   <li><a>fieldLabelModifier</a></li>
--   <li><a>constructorTagModifier</a></li>
--   <li><a>allNullaryToStringTag</a></li>
--   <li><a>unwrapUnaryRecords</a></li>
--   </ul>
--   
--   Note that these fields have no effect on <a>SchemaOptions</a>:
--   
--   <ul>
--   <li><a>omitNothingFields</a></li>
--   <li><a>tagSingleConstructors</a></li>
--   </ul>
--   
--   The rest is defined as in <a>defaultSchemaOptions</a>.
fromAesonOptions :: Options -> SchemaOptions


-- | Helper traversals and functions for Swagger operations manipulations.
--   These might be useful when you already have Swagger specification
--   generated by something else.
module Data.OpenApi.Operation

-- | All operations of a Swagger spec.
allOperations :: Traversal' OpenApi Operation

-- | <tt><a>operationsOf</a> sub</tt> will traverse only those operations
--   that are present in <tt>sub</tt>. Note that <tt><a>Operation</a></tt>
--   is determined by both path and method.
--   
--   <pre>
--   &gt;&gt;&gt; let ok = (mempty :: Operation) &amp; at 200 ?~ "OK"
--   
--   &gt;&gt;&gt; let api = (mempty :: OpenApi) &amp; paths .~ IOHM.fromList [("/user", mempty &amp; get ?~ ok &amp; post ?~ ok)]
--   
--   &gt;&gt;&gt; let sub = (mempty :: OpenApi) &amp; paths .~ IOHM.fromList [("/user", mempty &amp; get ?~ mempty)]
--   
--   &gt;&gt;&gt; BSL.putStrLn $ encodePretty api
--   {
--       "components": {},
--       "info": {
--           "title": "",
--           "version": ""
--       },
--       "openapi": "3.0.0",
--       "paths": {
--           "/user": {
--               "get": {
--                   "responses": {
--                       "200": {
--                           "description": "OK"
--                       }
--                   }
--               },
--               "post": {
--                   "responses": {
--                       "200": {
--                           "description": "OK"
--                       }
--                   }
--               }
--           }
--       }
--   }
--   
--   &gt;&gt;&gt; BSL.putStrLn $ encodePretty $ api &amp; operationsOf sub . at 404 ?~ "Not found"
--   {
--       "components": {},
--       "info": {
--           "title": "",
--           "version": ""
--       },
--       "openapi": "3.0.0",
--       "paths": {
--           "/user": {
--               "get": {
--                   "responses": {
--                       "200": {
--                           "description": "OK"
--                       },
--                       "404": {
--                           "description": "Not found"
--                       }
--                   }
--               },
--               "post": {
--                   "responses": {
--                       "200": {
--                           "description": "OK"
--                       }
--                   }
--               }
--           }
--       }
--   }
--   </pre>
operationsOf :: OpenApi -> Traversal' OpenApi Operation

-- | Apply tags to all operations and update the global list of tags.
--   
--   <pre>
--   <a>applyTags</a> = <a>applyTagsFor</a> <a>allOperations</a>
--   </pre>
applyTags :: [Tag] -> OpenApi -> OpenApi

-- | Apply tags to a part of Swagger spec and update the global list of
--   tags.
applyTagsFor :: Traversal' OpenApi Operation -> [Tag] -> OpenApi -> OpenApi

-- | Set response for all operations. This will also update global schema
--   definitions.
--   
--   If the response already exists it will be overwritten.
--   
--   <pre>
--   <a>setResponse</a> = <a>setResponseFor</a> <a>allOperations</a>
--   </pre>
--   
--   Example:
--   
--   <pre>
--   &gt;&gt;&gt; let api = (mempty :: OpenApi) &amp; paths .~ IOHM.fromList [("/user", mempty &amp; get ?~ mempty)]
--   
--   &gt;&gt;&gt; let res = declareResponse "application/json" (Proxy :: Proxy Day)
--   
--   &gt;&gt;&gt; BSL.putStrLn $ encodePretty $ api &amp; setResponse 200 res
--   {
--       "components": {
--           "schemas": {
--               "Day": {
--                   "example": "2016-07-22",
--                   "format": "date",
--                   "type": "string"
--               }
--           }
--       },
--       "info": {
--           "title": "",
--           "version": ""
--       },
--       "openapi": "3.0.0",
--       "paths": {
--           "/user": {
--               "get": {
--                   "responses": {
--                       "200": {
--                           "content": {
--                               "application/json": {
--                                   "schema": {
--                                       "$ref": "#/components/schemas/Day"
--                                   }
--                               }
--                           },
--                           "description": ""
--                       }
--                   }
--               }
--           }
--       }
--   }
--   </pre>
--   
--   See also <tt><a>setResponseWith</a></tt>.
setResponse :: HttpStatusCode -> Declare (Definitions Schema) Response -> OpenApi -> OpenApi

-- | Set or update response for all operations. This will also update
--   global schema definitions.
--   
--   If the response already exists, but it can't be dereferenced (invalid
--   <tt>$ref</tt>), then just the new response is used.
--   
--   <pre>
--   <a>setResponseWith</a> = <a>setResponseForWith</a> <a>allOperations</a>
--   </pre>
--   
--   See also <tt><a>setResponse</a></tt>.
setResponseWith :: (Response -> Response -> Response) -> HttpStatusCode -> Declare (Definitions Schema) Response -> OpenApi -> OpenApi

-- | Set response for specified operations. This will also update global
--   schema definitions.
--   
--   If the response already exists it will be overwritten.
--   
--   See also <tt><a>setResponseForWith</a></tt>.
setResponseFor :: Traversal' OpenApi Operation -> HttpStatusCode -> Declare (Definitions Schema) Response -> OpenApi -> OpenApi

-- | Set or update response for specified operations. This will also update
--   global schema definitions.
--   
--   If the response already exists, but it can't be dereferenced (invalid
--   <tt>$ref</tt>), then just the new response is used.
--   
--   See also <tt><a>setResponseFor</a></tt>.
setResponseForWith :: Traversal' OpenApi Operation -> (Response -> Response -> Response) -> HttpStatusCode -> Declare (Definitions Schema) Response -> OpenApi -> OpenApi

-- | Prepend path piece to all operations of the spec. Leading and trailing
--   slashes are trimmed/added automatically.
--   
--   <pre>
--   &gt;&gt;&gt; let api = (mempty :: OpenApi) &amp; paths .~ IOHM.fromList [("/info", mempty)]
--   
--   &gt;&gt;&gt; BSL.putStrLn $ encodePretty $ prependPath "user/{user_id}" api ^. paths
--   {
--       "/user/{user_id}/info": {}
--   }
--   </pre>
prependPath :: FilePath -> OpenApi -> OpenApi

-- | Construct a response with <tt><a>Schema</a></tt> while declaring all
--   necessary schema definitions.
--   
--   FIXME doc
--   
--   <pre>
--   &gt;&gt;&gt; BSL.putStrLn $ encodePretty $ runDeclare (declareResponse "application/json" (Proxy :: Proxy Day)) mempty
--   [
--       {
--           "Day": {
--               "example": "2016-07-22",
--               "format": "date",
--               "type": "string"
--           }
--       },
--       {
--           "content": {
--               "application/json": {
--                   "schema": {
--                       "$ref": "#/components/schemas/Day"
--                   }
--               }
--           },
--           "description": ""
--       }
--   ]
--   </pre>
declareResponse :: ToSchema a => MediaType -> Proxy a -> Declare (Definitions Schema) Response


-- | Validate JSON values with Swagger Schema.
module Data.OpenApi.Internal.Schema.Validation

-- | Validate <tt><a>ToJSON</a></tt> instance matches
--   <tt><a>ToSchema</a></tt> for a given value. This can be used with
--   QuickCheck to ensure those instances are coherent:
--   
--   <pre>
--   validateToJSON (x :: Int) == []
--   </pre>
--   
--   <i>NOTE:</i> <tt><a>validateToJSON</a></tt> does not perform string
--   pattern validation. See
--   <tt><a>validateToJSONWithPatternChecker</a></tt>.
--   
--   See <a>renderValidationErrors</a> on how the output is structured.
validatePrettyToJSON :: forall a. (ToJSON a, ToSchema a) => a -> Maybe String

-- | Variant of <a>validatePrettyToJSON</a> with typed output.
validateToJSON :: forall a. (ToJSON a, ToSchema a) => a -> [ValidationError]

-- | Validate <tt><a>ToJSON</a></tt> instance matches
--   <tt><a>ToSchema</a></tt> for a given value and pattern checker. This
--   can be used with QuickCheck to ensure those instances are coherent.
--   
--   For validation without patterns see <tt><a>validateToJSON</a></tt>.
--   See also: <a>renderValidationErrors</a>.
validateToJSONWithPatternChecker :: forall a. (ToJSON a, ToSchema a) => (Pattern -> Text -> Bool) -> a -> [ValidationError]

-- | Pretty print validation errors together with actual JSON and Swagger
--   Schema (using <a>encodePretty</a>).
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Aeson as Aeson
--   
--   &gt;&gt;&gt; import Data.Foldable (traverse_)
--   
--   &gt;&gt;&gt; import GHC.Generics
--   
--   &gt;&gt;&gt; data Phone = Phone { value :: String } deriving (Generic)
--   
--   &gt;&gt;&gt; data Person = Person { name :: String, phone :: Phone } deriving (Generic)
--   
--   &gt;&gt;&gt; instance ToJSON Person where toJSON p = object [ "name" Aeson..= name p ]
--   
--   &gt;&gt;&gt; instance ToSchema Phone
--   
--   &gt;&gt;&gt; instance ToSchema Person
--   
--   &gt;&gt;&gt; let person = Person { name = "John", phone = Phone "123456" }
--   
--   &gt;&gt;&gt; traverse_ putStrLn $ renderValidationErrors validateToJSON person
--   Validation against the schema fails:
--     * property "phone" is required, but not found in "{\"name\":\"John\"}"
--   
--   JSON value:
--   {
--       "name": "John"
--   }
--   
--   Swagger Schema:
--   {
--       "properties": {
--           "name": {
--               "type": "string"
--           },
--           "phone": {
--               "$ref": "#/components/schemas/Phone"
--           }
--       },
--       "required": [
--           "name",
--           "phone"
--       ],
--       "type": "object"
--   }
--   
--   Swagger Description Context:
--   {
--       "Phone": {
--           "properties": {
--               "value": {
--                   "type": "string"
--               }
--           },
--           "required": [
--               "value"
--           ],
--           "type": "object"
--       }
--   }
--   </pre>
renderValidationErrors :: forall a. (ToJSON a, ToSchema a) => (a -> [ValidationError]) -> a -> Maybe String

-- | Validate JSON <tt><a>ExpressionOrValue</a></tt> against Swagger
--   <tt><a>Schema</a></tt>.
--   
--   <pre>
--   validateJSON mempty (toSchema (Proxy :: Proxy Int)) (toJSON (x :: Int)) == []
--   </pre>
--   
--   <i>NOTE:</i> <tt><a>validateJSON</a></tt> does not perform string
--   pattern validation. See
--   <tt><a>validateJSONWithPatternChecker</a></tt>.
validateJSON :: Definitions Schema -> Schema -> Value -> [ValidationError]

-- | Validate JSON <tt><a>ExpressionOrValue</a></tt> agains Swagger
--   <tt><a>ToSchema</a></tt> for a given value and pattern checker.
--   
--   For validation without patterns see <tt><a>validateJSON</a></tt>.
validateJSONWithPatternChecker :: (Pattern -> Text -> Bool) -> Definitions Schema -> Schema -> Value -> [ValidationError]

-- | Validation error message.
type ValidationError = String

-- | Validation result type.
data Result a

-- | Validation failed with a list of error messages.
Failed :: [ValidationError] -> Result a

-- | Validation passed.
Passed :: a -> Result a

-- | Validation configuration.
data Config
Config :: (Pattern -> Text -> Bool) -> Definitions Schema -> Config

-- | Pattern checker for <tt><a>_schemaPattern</a></tt> validation.
[configPatternChecker] :: Config -> Pattern -> Text -> Bool

-- | Schema definitions in scope to resolve references.
[configDefinitions] :: Config -> Definitions Schema

-- | Default <tt><a>Config</a></tt>:
--   
--   <pre>
--   defaultConfig = <a>Config</a>
--     { <a>configPatternChecker</a> = \_pattern _str -&gt; True
--     , <a>configDefinitions</a>    = mempty
--     }
--   </pre>
defaultConfig :: Config

-- | Value validation.
newtype Validation s a
Validation :: (Config -> s -> Result a) -> Validation s a
[runValidation] :: Validation s a -> Config -> s -> Result a
withConfig :: (Config -> Validation s a) -> Validation s a
withSchema :: (s -> Validation s a) -> Validation s a

-- | Issue an error message.
invalid :: String -> Validation schema a

-- | Validation passed.
valid :: Validation schema ()

-- | Validate schema's property given a lens into that property and
--   property checker.
checkMissing :: Validation s () -> Lens' s (Maybe a) -> (a -> Validation s ()) -> Validation s ()

-- | Validate schema's property given a lens into that property and
--   property checker. If property is missing in schema, consider it valid.
check :: Lens' s (Maybe a) -> (a -> Validation s ()) -> Validation s ()

-- | Validate same value with different schema.
sub :: t -> Validation t a -> Validation s a

-- | Validate same value with a part of the original schema.
sub_ :: Getting a s a -> Validation a r -> Validation s r

-- | Validate value against a schema given schema reference and validation
--   function.
withRef :: Reference -> (Schema -> Validation s a) -> Validation s a
validateWithSchemaRef :: Referenced Schema -> Value -> Validation s ()

-- | Validate JSON <tt><a>ExpressionOrValue</a></tt> with Swagger
--   <tt><a>Schema</a></tt>.
validateWithSchema :: Value -> Validation Schema ()
validateInteger :: Scientific -> Validation Schema ()
validateNumber :: Scientific -> Validation Schema ()
validateString :: Text -> Validation Schema ()
validateArray :: Vector Value -> Validation Schema ()
validateObject :: KeyMap Value -> Validation Schema ()
validateEnum :: Value -> Validation Schema ()

-- | Infer schema type based on used properties.
--   
--   This is like <a>inferParamSchemaTypes</a>, but also works for objects:
--   
--   <pre>
--   &gt;&gt;&gt; inferSchemaTypes &lt;$&gt; decode "{\"minProperties\": 1}"
--   Just [OpenApiObject]
--   </pre>
inferSchemaTypes :: Schema -> [OpenApiType]

-- | Infer schema type based on used properties.
--   
--   <pre>
--   &gt;&gt;&gt; inferSchemaTypes &lt;$&gt; decode "{\"minLength\": 2}"
--   Just [OpenApiString]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; inferSchemaTypes &lt;$&gt; decode "{\"maxItems\": 0}"
--   Just [OpenApiArray]
--   </pre>
--   
--   From numeric properties <a>OpenApiInteger</a> type is inferred. If you
--   want <a>OpenApiNumber</a> instead, you must specify it explicitly.
--   
--   <pre>
--   &gt;&gt;&gt; inferSchemaTypes &lt;$&gt; decode "{\"minimum\": 1}"
--   Just [OpenApiInteger]
--   </pre>
inferParamSchemaTypes :: Schema -> [OpenApiType]
validateSchemaType :: Value -> Validation Schema ()
validateParamSchemaType :: Value -> Validation Schema ()
showType :: (Maybe OpenApiType, Value) -> String
instance GHC.Base.Functor Data.OpenApi.Internal.Schema.Validation.Result
instance GHC.Show.Show a => GHC.Show.Show (Data.OpenApi.Internal.Schema.Validation.Result a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.OpenApi.Internal.Schema.Validation.Result a)
instance GHC.Base.Functor (Data.OpenApi.Internal.Schema.Validation.Validation s)
instance GHC.Base.Applicative (Data.OpenApi.Internal.Schema.Validation.Validation schema)
instance GHC.Base.Alternative (Data.OpenApi.Internal.Schema.Validation.Validation schema)
instance Data.Profunctor.Unsafe.Profunctor Data.OpenApi.Internal.Schema.Validation.Validation
instance Data.Profunctor.Choice.Choice Data.OpenApi.Internal.Schema.Validation.Validation
instance GHC.Base.Monad (Data.OpenApi.Internal.Schema.Validation.Validation s)
instance GHC.Base.Applicative Data.OpenApi.Internal.Schema.Validation.Result
instance GHC.Base.Alternative Data.OpenApi.Internal.Schema.Validation.Result
instance GHC.Base.Monad Data.OpenApi.Internal.Schema.Validation.Result


-- | Validate JSON values with Swagger Schema.
module Data.OpenApi.Schema.Validation

-- | Validation error message.
type ValidationError = String

-- | Validate <tt><a>ToJSON</a></tt> instance matches
--   <tt><a>ToSchema</a></tt> for a given value. This can be used with
--   QuickCheck to ensure those instances are coherent:
--   
--   <pre>
--   validateToJSON (x :: Int) == []
--   </pre>
--   
--   <i>NOTE:</i> <tt><a>validateToJSON</a></tt> does not perform string
--   pattern validation. See
--   <tt><a>validateToJSONWithPatternChecker</a></tt>.
--   
--   See <a>renderValidationErrors</a> on how the output is structured.
validatePrettyToJSON :: forall a. (ToJSON a, ToSchema a) => a -> Maybe String

-- | Variant of <a>validatePrettyToJSON</a> with typed output.
validateToJSON :: forall a. (ToJSON a, ToSchema a) => a -> [ValidationError]

-- | Validate <tt><a>ToJSON</a></tt> instance matches
--   <tt><a>ToSchema</a></tt> for a given value and pattern checker. This
--   can be used with QuickCheck to ensure those instances are coherent.
--   
--   For validation without patterns see <tt><a>validateToJSON</a></tt>.
--   See also: <a>renderValidationErrors</a>.
validateToJSONWithPatternChecker :: forall a. (ToJSON a, ToSchema a) => (Pattern -> Text -> Bool) -> a -> [ValidationError]

-- | Pretty print validation errors together with actual JSON and Swagger
--   Schema (using <a>encodePretty</a>).
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Aeson as Aeson
--   
--   &gt;&gt;&gt; import Data.Foldable (traverse_)
--   
--   &gt;&gt;&gt; import GHC.Generics
--   
--   &gt;&gt;&gt; data Phone = Phone { value :: String } deriving (Generic)
--   
--   &gt;&gt;&gt; data Person = Person { name :: String, phone :: Phone } deriving (Generic)
--   
--   &gt;&gt;&gt; instance ToJSON Person where toJSON p = object [ "name" Aeson..= name p ]
--   
--   &gt;&gt;&gt; instance ToSchema Phone
--   
--   &gt;&gt;&gt; instance ToSchema Person
--   
--   &gt;&gt;&gt; let person = Person { name = "John", phone = Phone "123456" }
--   
--   &gt;&gt;&gt; traverse_ putStrLn $ renderValidationErrors validateToJSON person
--   Validation against the schema fails:
--     * property "phone" is required, but not found in "{\"name\":\"John\"}"
--   
--   JSON value:
--   {
--       "name": "John"
--   }
--   
--   Swagger Schema:
--   {
--       "properties": {
--           "name": {
--               "type": "string"
--           },
--           "phone": {
--               "$ref": "#/components/schemas/Phone"
--           }
--       },
--       "required": [
--           "name",
--           "phone"
--       ],
--       "type": "object"
--   }
--   
--   Swagger Description Context:
--   {
--       "Phone": {
--           "properties": {
--               "value": {
--                   "type": "string"
--               }
--           },
--           "required": [
--               "value"
--           ],
--           "type": "object"
--       }
--   }
--   </pre>
renderValidationErrors :: forall a. (ToJSON a, ToSchema a) => (a -> [ValidationError]) -> a -> Maybe String

-- | Validate JSON <tt><a>ExpressionOrValue</a></tt> against Swagger
--   <tt><a>Schema</a></tt>.
--   
--   <pre>
--   validateJSON mempty (toSchema (Proxy :: Proxy Int)) (toJSON (x :: Int)) == []
--   </pre>
--   
--   <i>NOTE:</i> <tt><a>validateJSON</a></tt> does not perform string
--   pattern validation. See
--   <tt><a>validateJSONWithPatternChecker</a></tt>.
validateJSON :: Definitions Schema -> Schema -> Value -> [ValidationError]

-- | Validate JSON <tt><a>ExpressionOrValue</a></tt> agains Swagger
--   <tt><a>ToSchema</a></tt> for a given value and pattern checker.
--   
--   For validation without patterns see <tt><a>validateJSON</a></tt>.
validateJSONWithPatternChecker :: (Pattern -> Text -> Bool) -> Definitions Schema -> Schema -> Value -> [ValidationError]


-- | Swagger™ is a project used to describe and document RESTful APIs.
--   
--   The Swagger specification defines a set of files required to describe
--   such an API. These files can then be used by the Swagger-UI project to
--   display the API and Swagger-Codegen to generate clients in various
--   languages. Additional utilities can also take advantage of the
--   resulting files, such as testing tools.
module Data.OpenApi

-- | This is the root document object for the API specification.
data OpenApi
OpenApi :: Info -> [Server] -> InsOrdHashMap FilePath PathItem -> Components -> [SecurityRequirement] -> InsOrdHashSet Tag -> Maybe ExternalDocs -> OpenApiSpecVersion -> OpenApi

-- | Provides metadata about the API. The metadata can be used by the
--   clients if needed.
[_openApiInfo] :: OpenApi -> Info

-- | An array of Server Objects, which provide connectivity information to
--   a target server. If the servers property is not provided, or is an
--   empty array, the default value would be a <a>Server</a> object with a
--   url value of <tt>/</tt>.
[_openApiServers] :: OpenApi -> [Server]

-- | The available paths and operations for the API.
[_openApiPaths] :: OpenApi -> InsOrdHashMap FilePath PathItem

-- | An element to hold various schemas for the specification.
[_openApiComponents] :: OpenApi -> Components

-- | A declaration of which security mechanisms can be used across the API.
--   The list of values includes alternative security requirement objects
--   that can be used. Only one of the security requirement objects need to
--   be satisfied to authorize a request. Individual operations can
--   override this definition. To make security optional, an empty security
--   requirement can be included in the array.
[_openApiSecurity] :: OpenApi -> [SecurityRequirement]

-- | A list of tags used by the specification with additional metadata. The
--   order of the tags can be used to reflect on their order by the parsing
--   tools. Not all tags that are used by the <a>Operation</a> Object must
--   be declared. The tags that are not declared MAY be organized randomly
--   or based on the tools' logic. Each tag name in the list MUST be
--   unique.
[_openApiTags] :: OpenApi -> InsOrdHashSet Tag

-- | Additional external documentation.
[_openApiExternalDocs] :: OpenApi -> Maybe ExternalDocs

-- | The spec of OpenApi this spec adheres to. Must be between
--   <a>lowerOpenApiSpecVersion</a> and <a>upperOpenApiSpecVersion</a>
[_openApiOpenapi] :: OpenApi -> OpenApiSpecVersion

-- | An object representing a Server.
data Server
Server :: Text -> Maybe Text -> InsOrdHashMap Text ServerVariable -> Server

-- | A URL to the target host. This URL supports Server Variables and MAY
--   be relative, to indicate that the host location is relative to the
--   location where the OpenAPI document is being served. Variable
--   substitutions will be made when a variable is named in
--   <tt>{brackets}</tt>.
[_serverUrl] :: Server -> Text

-- | An optional string describing the host designated by the URL.
--   <a>CommonMark syntax</a> MAY be used for rich text representation.
[_serverDescription] :: Server -> Maybe Text

-- | A map between a variable name and its value. The value is used for
--   substitution in the server's URL template.
[_serverVariables] :: Server -> InsOrdHashMap Text ServerVariable
data ServerVariable
ServerVariable :: Maybe (InsOrdHashSet Text) -> Text -> Maybe Text -> ServerVariable

-- | An enumeration of string values to be used if the substitution options
--   are from a limited set. The array SHOULD NOT be empty.
[_serverVariableEnum] :: ServerVariable -> Maybe (InsOrdHashSet Text)

-- | The default value to use for substitution, which SHALL be sent if an
--   alternate value is not supplied. Note this behavior is different than
--   the 'Schema Object's treatment of default values, because in those
--   cases parameter values are optional. If the <a>_serverVariableEnum</a>
--   is defined, the value SHOULD exist in the enum's values.
[_serverVariableDefault] :: ServerVariable -> Text

-- | An optional description for the server variable. <a>CommonMark
--   syntax</a> MAY be used for rich text representation.
[_serverVariableDescription] :: ServerVariable -> Maybe Text

-- | Holds a set of reusable objects for different aspects of the OAS. All
--   objects defined within the components object will have no effect on
--   the API unless they are explicitly referenced from properties outside
--   the components object.
data Components
Components :: Definitions Schema -> Definitions Response -> Definitions Param -> Definitions Example -> Definitions RequestBody -> Definitions Header -> SecurityDefinitions -> Definitions Link -> Definitions Callback -> Components
[_componentsSchemas] :: Components -> Definitions Schema
[_componentsResponses] :: Components -> Definitions Response
[_componentsParameters] :: Components -> Definitions Param
[_componentsExamples] :: Components -> Definitions Example
[_componentsRequestBodies] :: Components -> Definitions RequestBody
[_componentsHeaders] :: Components -> Definitions Header
[_componentsSecuritySchemes] :: Components -> SecurityDefinitions
[_componentsLinks] :: Components -> Definitions Link
[_componentsCallbacks] :: Components -> Definitions Callback

-- | The object provides metadata about the API. The metadata MAY be used
--   by the clients if needed, and MAY be presented in editing or
--   documentation generation tools for convenience.
data Info
Info :: Text -> Maybe Text -> Maybe Text -> Maybe Contact -> Maybe License -> Text -> Info

-- | The title of the API.
[_infoTitle] :: Info -> Text

-- | A short description of the API. <a>CommonMark syntax</a> MAY be used
--   for rich text representation.
[_infoDescription] :: Info -> Maybe Text

-- | A URL to the Terms of Service for the API. MUST be in the format of a
--   URL.
[_infoTermsOfService] :: Info -> Maybe Text

-- | The contact information for the exposed API.
[_infoContact] :: Info -> Maybe Contact

-- | The license information for the exposed API.
[_infoLicense] :: Info -> Maybe License

-- | The version of the OpenAPI document (which is distinct from the
--   OpenAPI Specification version or the API implementation version).
[_infoVersion] :: Info -> Text

-- | Contact information for the exposed API.
data Contact
Contact :: Maybe Text -> Maybe URL -> Maybe Text -> Contact

-- | The identifying name of the contact person/organization.
[_contactName] :: Contact -> Maybe Text

-- | The URL pointing to the contact information.
[_contactUrl] :: Contact -> Maybe URL

-- | The email address of the contact person/organization.
[_contactEmail] :: Contact -> Maybe Text

-- | License information for the exposed API.
data License
License :: Text -> Maybe URL -> License

-- | The license name used for the API.
[_licenseName] :: License -> Text

-- | A URL to the license used for the API.
[_licenseUrl] :: License -> Maybe URL

-- | Describes the operations available on a single path. A
--   <tt><a>PathItem</a></tt> may be empty, due to ACL constraints. The
--   path itself is still exposed to the documentation viewer but they will
--   not know which operations and parameters are available.
data PathItem
PathItem :: Maybe Text -> Maybe Text -> Maybe Operation -> Maybe Operation -> Maybe Operation -> Maybe Operation -> Maybe Operation -> Maybe Operation -> Maybe Operation -> Maybe Operation -> [Server] -> [Referenced Param] -> PathItem

-- | An optional, string summary, intended to apply to all operations in
--   this path.
[_pathItemSummary] :: PathItem -> Maybe Text

-- | An optional, string description, intended to apply to all operations
--   in this path. <a>CommonMark syntax</a> MAY be used for rich text
--   representation.
[_pathItemDescription] :: PathItem -> Maybe Text

-- | A definition of a GET operation on this path.
[_pathItemGet] :: PathItem -> Maybe Operation

-- | A definition of a PUT operation on this path.
[_pathItemPut] :: PathItem -> Maybe Operation

-- | A definition of a POST operation on this path.
[_pathItemPost] :: PathItem -> Maybe Operation

-- | A definition of a DELETE operation on this path.
[_pathItemDelete] :: PathItem -> Maybe Operation

-- | A definition of a OPTIONS operation on this path.
[_pathItemOptions] :: PathItem -> Maybe Operation

-- | A definition of a HEAD operation on this path.
[_pathItemHead] :: PathItem -> Maybe Operation

-- | A definition of a PATCH operation on this path.
[_pathItemPatch] :: PathItem -> Maybe Operation

-- | A definition of a TRACE operation on this path.
[_pathItemTrace] :: PathItem -> Maybe Operation

-- | An alternative server array to service all operations in this path.
[_pathItemServers] :: PathItem -> [Server]

-- | A list of parameters that are applicable for all the operations
--   described under this path. These parameters can be overridden at the
--   operation level, but cannot be removed there. The list MUST NOT
--   include duplicated parameters. A unique parameter is defined by a
--   combination of a name and location.
[_pathItemParameters] :: PathItem -> [Referenced Param]

-- | Describes a single API operation on a path.
data Operation
Operation :: InsOrdHashSet TagName -> Maybe Text -> Maybe Text -> Maybe ExternalDocs -> Maybe Text -> [Referenced Param] -> Maybe (Referenced RequestBody) -> Responses -> InsOrdHashMap Text (Referenced Callback) -> Maybe Bool -> [SecurityRequirement] -> [Server] -> Operation

-- | A list of tags for API documentation control. Tags can be used for
--   logical grouping of operations by resources or any other qualifier.
[_operationTags] :: Operation -> InsOrdHashSet TagName

-- | A short summary of what the operation does. For maximum readability in
--   the swagger-ui, this field SHOULD be less than 120 characters.
[_operationSummary] :: Operation -> Maybe Text

-- | A verbose explanation of the operation behavior. <a>CommonMark
--   syntax</a> can be used for rich text representation.
[_operationDescription] :: Operation -> Maybe Text

-- | Additional external documentation for this operation.
[_operationExternalDocs] :: Operation -> Maybe ExternalDocs

-- | Unique string used to identify the operation. The id MUST be unique
--   among all operations described in the API. The operationId value is
--   **case-sensitive**. Tools and libraries MAY use the operationId to
--   uniquely identify an operation, therefore, it is RECOMMENDED to follow
--   common programming naming conventions.
[_operationOperationId] :: Operation -> Maybe Text

-- | A list of parameters that are applicable for this operation. If a
--   parameter is already defined at the <tt><a>PathItem</a></tt>, the new
--   definition will override it, but can never remove it. The list MUST
--   NOT include duplicated parameters. A unique parameter is defined by a
--   combination of a name and location.
[_operationParameters] :: Operation -> [Referenced Param]

-- | The request body applicable for this operation. The requestBody is
--   only supported in HTTP methods where the HTTP 1.1 specification
--   <a>RFC7231</a> has explicitly defined semantics for request bodies. In
--   other cases where the HTTP spec is vague, requestBody SHALL be ignored
--   by consumers.
[_operationRequestBody] :: Operation -> Maybe (Referenced RequestBody)

-- | The list of possible responses as they are returned from executing
--   this operation.
[_operationResponses] :: Operation -> Responses

-- | A map of possible out-of band callbacks related to the parent
--   operation. The key is a unique identifier for the <a>Callback</a>
--   Object. Each value in the map is a <a>Callback</a> Object that
--   describes a request that may be initiated by the API provider and the
--   expected responses.
[_operationCallbacks] :: Operation -> InsOrdHashMap Text (Referenced Callback)

-- | Declares this operation to be deprecated. Usage of the declared
--   operation should be refrained. Default value is <tt>False</tt>.
[_operationDeprecated] :: Operation -> Maybe Bool

-- | A declaration of which security schemes are applied for this
--   operation. The list of values describes alternative security schemes
--   that can be used (that is, there is a logical OR between the security
--   requirements). This definition overrides any declared top-level
--   security. To remove a top-level security declaration, <tt>Just []</tt>
--   can be used.
[_operationSecurity] :: Operation -> [SecurityRequirement]

-- | An alternative server array to service this operation. If an
--   alternative server object is specified at the <a>PathItem</a> Object
--   or Root level, it will be overridden by this value.
[_operationServers] :: Operation -> [Server]

-- | Allows adding meta data to a single tag that is used by
--   <tt>Operation</tt>. It is not mandatory to have a <tt>Tag</tt> per tag
--   used there.
data Tag
Tag :: TagName -> Maybe Text -> Maybe ExternalDocs -> Tag

-- | The name of the tag.
[_tagName] :: Tag -> TagName

-- | A short description for the tag. <a>CommonMark syntax</a> MAY be used
--   for rich text representation.
[_tagDescription] :: Tag -> Maybe Text

-- | Additional external documentation for this tag.
[_tagExternalDocs] :: Tag -> Maybe ExternalDocs

-- | Tag name.
type TagName = Text
data OpenApiType
[OpenApiString] :: OpenApiType
[OpenApiNumber] :: OpenApiType
[OpenApiInteger] :: OpenApiType
[OpenApiBoolean] :: OpenApiType
[OpenApiArray] :: OpenApiType
[OpenApiNull] :: OpenApiType
[OpenApiObject] :: OpenApiType
type Format = Text

-- | A list of definitions that can be used in references.
type Definitions = InsOrdHashMap Text

-- | In order to support common ways of serializing simple parameters, a
--   set of style values are defined.
data Style

-- | Path-style parameters defined by <a>RFC6570</a>.
StyleMatrix :: Style

-- | Label style parameters defined by <a>RFC6570</a>.
StyleLabel :: Style

-- | Form style parameters defined by <a>RFC6570</a>. This option replaces
--   <tt>collectionFormat</tt> with a <tt>csv</tt> (when <tt>explode</tt>
--   is false) or <tt>multi</tt> (when explode is true) value from OpenAPI
--   2.0.
StyleForm :: Style

-- | Simple style parameters defined by <a>RFC6570</a>. This option
--   replaces <tt>collectionFormat</tt> with a <tt>csv</tt> value from
--   OpenAPI 2.0.
StyleSimple :: Style

-- | Space separated array values. This option replaces
--   <tt>collectionFormat</tt> equal to <tt>ssv</tt> from OpenAPI 2.0.
StyleSpaceDelimited :: Style

-- | Pipe separated array values. This option replaces
--   <tt>collectionFormat</tt> equal to <tt>pipes</tt> from OpenAPI 2.0.
StylePipeDelimited :: Style

-- | Provides a simple way of rendering nested objects using form
--   parameters.
StyleDeepObject :: Style

-- | Describes a single operation parameter. A unique parameter is defined
--   by a combination of a name and location.
data Param
Param :: Text -> Maybe Text -> Maybe Bool -> Maybe Bool -> ParamLocation -> Maybe Bool -> Maybe Bool -> Maybe (Referenced Schema) -> Maybe Style -> Maybe Bool -> Maybe Value -> InsOrdHashMap Text (Referenced Example) -> Param

-- | The name of the parameter. Parameter names are case sensitive.
[_paramName] :: Param -> Text

-- | A brief description of the parameter. This could contain examples of
--   use. CommonMark syntax MAY be used for rich text representation.
[_paramDescription] :: Param -> Maybe Text

-- | Determines whether this parameter is mandatory. If the parameter is in
--   "path", this property is required and its value MUST be true.
--   Otherwise, the property MAY be included and its default value is
--   <tt>False</tt>.
[_paramRequired] :: Param -> Maybe Bool

-- | Specifies that a parameter is deprecated and SHOULD be transitioned
--   out of usage. Default value is <tt>false</tt>.
[_paramDeprecated] :: Param -> Maybe Bool

-- | The location of the parameter.
[_paramIn] :: Param -> ParamLocation

-- | Sets the ability to pass empty-valued parameters. This is valid only
--   for <a>ParamQuery</a> parameters and allows sending a parameter with
--   an empty value. Default value is <tt>false</tt>.
[_paramAllowEmptyValue] :: Param -> Maybe Bool

-- | Determines whether the parameter value SHOULD allow reserved
--   characters, as defined by <a>RFC3986</a>
--   <tt>:/?#[]</tt>!$&amp;'()*+,;=@ to be included without
--   percent-encoding. This property only applies to parameters with an
--   <a>_paramIn</a> value of <a>ParamQuery</a>. The default value is
--   <a>False</a>.
[_paramAllowReserved] :: Param -> Maybe Bool

-- | Parameter schema.
[_paramSchema] :: Param -> Maybe (Referenced Schema)

-- | Describes how the parameter value will be serialized depending on the
--   type of the parameter value. Default values (based on value of
--   <a>_paramIn</a>): for <a>ParamQuery</a> - <a>StyleForm</a>; for
--   <a>ParamPath</a> - <a>StyleSimple</a>; for <a>ParamHeader</a> -
--   <a>StyleSimple</a>; for <a>ParamCookie</a> - <a>StyleForm</a>.
[_paramStyle] :: Param -> Maybe Style

-- | When this is true, parameter values of type <tt>array</tt> or
--   <tt>object</tt> generate separate parameters for each value of the
--   array or key-value pair of the map. For other types of parameters this
--   property has no effect. When style is <tt>form</tt>, the default value
--   is true. For all other styles, the default value is false.
[_paramExplode] :: Param -> Maybe Bool

-- | Example of the parameter's potential value. The example SHOULD match
--   the specified schema and encoding properties if present. The
--   <a>_paramExample</a> field is mutually exclusive of the
--   <a>_paramExamples</a> field. Furthermore, if referencing a schema that
--   contains an example, the example value SHALL override the example
--   provided by the schema. To represent examples of media types that
--   cannot naturally be represented in JSON or YAML, a string value can
--   contain the example with escaping where necessary.
[_paramExample] :: Param -> Maybe Value

-- | Examples of the parameter's potential value. Each example SHOULD
--   contain a value in the correct format as specified in the parameter
--   encoding. The <a>_paramExamples</a> field is mutually exclusive of the
--   <a>_paramExample</a> field. Furthermore, if referencing a schema that
--   contains an example, the examples value SHALL override the example
--   provided by the schema.
[_paramExamples] :: Param -> InsOrdHashMap Text (Referenced Example)
data ParamLocation

-- | Parameters that are appended to the URL. For example, in
--   <tt>/items?id=###</tt>, the query parameter is <tt>id</tt>.
ParamQuery :: ParamLocation

-- | Custom headers that are expected as part of the request.
ParamHeader :: ParamLocation

-- | Used together with Path Templating, where the parameter value is
--   actually part of the operation's URL. This does not include the host
--   or base path of the API. For example, in
--   <tt><i>items</i>{itemId}</tt>, the path parameter is <tt>itemId</tt>.
ParamPath :: ParamLocation

-- | Used to pass a specific cookie value to the API.
ParamCookie :: ParamLocation
type ParamName = Text

-- | Header fields have the same meaning as for <a>Param</a>.
--   
--   Style is always treated as <a>StyleSimple</a>, as it is the only value
--   allowed for headers.
data Header
Header :: Maybe HeaderName -> Maybe Bool -> Maybe Bool -> Maybe Bool -> Maybe Bool -> Maybe Value -> InsOrdHashMap Text (Referenced Example) -> Maybe (Referenced Schema) -> Header

-- | A short description of the header.
[_headerDescription] :: Header -> Maybe HeaderName
[_headerRequired] :: Header -> Maybe Bool
[_headerDeprecated] :: Header -> Maybe Bool
[_headerAllowEmptyValue] :: Header -> Maybe Bool
[_headerExplode] :: Header -> Maybe Bool
[_headerExample] :: Header -> Maybe Value
[_headerExamples] :: Header -> InsOrdHashMap Text (Referenced Example)
[_headerSchema] :: Header -> Maybe (Referenced Schema)
type HeaderName = Text
data Example
Example :: Maybe Text -> Maybe Text -> Maybe Value -> Maybe URL -> Example

-- | Short description for the example.
[_exampleSummary] :: Example -> Maybe Text

-- | Long description for the example. CommonMark syntax MAY be used for
--   rich text representation.
[_exampleDescription] :: Example -> Maybe Text

-- | Embedded literal example. The <a>_exampleValue</a> field and
--   <a>_exampleExternalValue</a> field are mutually exclusive.
--   
--   To represent examples of media types that cannot naturally represented
--   in JSON or YAML, use a string value to contain the example, escaping
--   where necessary.
[_exampleValue] :: Example -> Maybe Value

-- | A URL that points to the literal example. This provides the capability
--   to reference examples that cannot easily be included in JSON or YAML
--   documents. The <a>_exampleValue</a> field and
--   <a>_exampleExternalValue</a> field are mutually exclusive.
[_exampleExternalValue] :: Example -> Maybe URL

-- | Describes a single request body.
data RequestBody
RequestBody :: Maybe Text -> InsOrdHashMap MediaType MediaTypeObject -> Maybe Bool -> RequestBody

-- | A brief description of the request body. This could contain examples
--   of use. <a>CommonMark syntax</a> MAY be used for rich text
--   representation.
[_requestBodyDescription] :: RequestBody -> Maybe Text

-- | The content of the request body. The key is a media type or media type
--   range and the value describes it. For requests that match multiple
--   keys, only the most specific key is applicable. e.g.
--   <tt>text/plain</tt> overrides <tt>text/*</tt>
[_requestBodyContent] :: RequestBody -> InsOrdHashMap MediaType MediaTypeObject

-- | Determines if the request body is required in the request. Defaults to
--   <a>False</a>.
[_requestBodyRequired] :: RequestBody -> Maybe Bool

-- | Each Media Type Object provides schema and examples for the media type
--   identified by its key.
data MediaTypeObject
MediaTypeObject :: Maybe (Referenced Schema) -> Maybe Value -> InsOrdHashMap Text (Referenced Example) -> InsOrdHashMap Text Encoding -> MediaTypeObject
[_mediaTypeObjectSchema] :: MediaTypeObject -> Maybe (Referenced Schema)

-- | Example of the media type. The example object SHOULD be in the correct
--   format as specified by the media type.
[_mediaTypeObjectExample] :: MediaTypeObject -> Maybe Value

-- | Examples of the media type. Each example object SHOULD match the media
--   type and specified schema if present.
[_mediaTypeObjectExamples] :: MediaTypeObject -> InsOrdHashMap Text (Referenced Example)

-- | A map between a property name and its encoding information. The key,
--   being the property name, MUST exist in the schema as a property. The
--   encoding object SHALL only apply to <a>RequestBody</a> objects when
--   the media type is <tt>multipart</tt> or
--   <tt>application/x-www-form-urlencoded</tt>.
[_mediaTypeObjectEncoding] :: MediaTypeObject -> InsOrdHashMap Text Encoding
data Encoding
Encoding :: Maybe MediaType -> InsOrdHashMap Text (Referenced Header) -> Maybe Style -> Maybe Bool -> Maybe Bool -> Encoding

-- | The Content-Type for encoding a specific property. Default value
--   depends on the property type: for <tt>string</tt> with format being
--   <tt>binary</tt> – <tt>application/octet-stream</tt>; for other
--   primitive types – <tt>text/plain</tt>; for object -
--   <tt>application/json</tt>; for array – the default is defined based on
--   the inner type. The value can be a specific media type (e.g.
--   <tt>application/json</tt>), a wildcard media type (e.g.
--   <tt>image/*</tt>), or a comma-separated list of the two types.
[_encodingContentType] :: Encoding -> Maybe MediaType

-- | A map allowing additional information to be provided as headers, for
--   example <tt>Content-Disposition</tt>. <tt>Content-Type</tt> is
--   described separately and SHALL be ignored in this section. This
--   property SHALL be ignored if the request body media type is not a
--   <tt>multipart</tt>.
[_encodingHeaders] :: Encoding -> InsOrdHashMap Text (Referenced Header)

-- | Describes how a specific property value will be serialized depending
--   on its type. See <a>Param</a> Object for details on the style
--   property. The behavior follows the same values as query parameters,
--   including default values. This property SHALL be ignored if the
--   request body media type is not
--   <tt>application/x-www-form-urlencoded</tt>.
[_encodingStyle] :: Encoding -> Maybe Style

-- | When this is true, property values of type <tt>array</tt> or
--   <tt>object</tt> generate separate parameters for each value of the
--   array, or key-value-pair of the map. For other types of properties
--   this property has no effect. When style is form, the default value is
--   <tt>true</tt>. For all other styles, the default value is
--   <tt>false</tt>. This property SHALL be ignored if the request body
--   media type is not <tt>application/x-www-form-urlencoded</tt>.
[_encodingExplode] :: Encoding -> Maybe Bool

-- | Determines whether the parameter value SHOULD allow reserved
--   characters, as defined by <a>RFC3986</a>
--   <tt>:/?#[]</tt>!$&amp;'()*+,;=<tt> to be included without
--   percent-encoding. The default value is </tt>false<tt>. This property
--   SHALL be ignored if the request body media type is not
--   </tt>application/x-www-form-urlencoded@.
[_encodingAllowReserved] :: Encoding -> Maybe Bool
data Schema
Schema :: Maybe Text -> Maybe Text -> [ParamName] -> Maybe Bool -> Maybe [Referenced Schema] -> Maybe [Referenced Schema] -> Maybe (Referenced Schema) -> Maybe [Referenced Schema] -> InsOrdHashMap Text (Referenced Schema) -> Maybe AdditionalProperties -> Maybe Discriminator -> Maybe Bool -> Maybe Bool -> Maybe Xml -> Maybe ExternalDocs -> Maybe Value -> Maybe Bool -> Maybe Integer -> Maybe Integer -> Maybe Value -> Maybe OpenApiType -> Maybe Format -> Maybe OpenApiItems -> Maybe Scientific -> Maybe Bool -> Maybe Scientific -> Maybe Bool -> Maybe Integer -> Maybe Integer -> Maybe Pattern -> Maybe Integer -> Maybe Integer -> Maybe Bool -> Maybe [Value] -> Maybe Scientific -> Schema
[_schemaTitle] :: Schema -> Maybe Text
[_schemaDescription] :: Schema -> Maybe Text
[_schemaRequired] :: Schema -> [ParamName]
[_schemaNullable] :: Schema -> Maybe Bool
[_schemaAllOf] :: Schema -> Maybe [Referenced Schema]
[_schemaOneOf] :: Schema -> Maybe [Referenced Schema]
[_schemaNot] :: Schema -> Maybe (Referenced Schema)
[_schemaAnyOf] :: Schema -> Maybe [Referenced Schema]
[_schemaProperties] :: Schema -> InsOrdHashMap Text (Referenced Schema)
[_schemaAdditionalProperties] :: Schema -> Maybe AdditionalProperties
[_schemaDiscriminator] :: Schema -> Maybe Discriminator
[_schemaReadOnly] :: Schema -> Maybe Bool
[_schemaWriteOnly] :: Schema -> Maybe Bool
[_schemaXml] :: Schema -> Maybe Xml
[_schemaExternalDocs] :: Schema -> Maybe ExternalDocs
[_schemaExample] :: Schema -> Maybe Value
[_schemaDeprecated] :: Schema -> Maybe Bool
[_schemaMaxProperties] :: Schema -> Maybe Integer
[_schemaMinProperties] :: Schema -> Maybe Integer

-- | Declares the value of the parameter that the server will use if none
--   is provided, for example a <tt>"count"</tt> to control the number of
--   results per page might default to <tt>100</tt> if not supplied by the
--   client in the request. (Note: "default" has no meaning for required
--   parameters.) Unlike JSON Schema this value MUST conform to the defined
--   type for this parameter.
[_schemaDefault] :: Schema -> Maybe Value
[_schemaType] :: Schema -> Maybe OpenApiType
[_schemaFormat] :: Schema -> Maybe Format
[_schemaItems] :: Schema -> Maybe OpenApiItems
[_schemaMaximum] :: Schema -> Maybe Scientific
[_schemaExclusiveMaximum] :: Schema -> Maybe Bool
[_schemaMinimum] :: Schema -> Maybe Scientific
[_schemaExclusiveMinimum] :: Schema -> Maybe Bool
[_schemaMaxLength] :: Schema -> Maybe Integer
[_schemaMinLength] :: Schema -> Maybe Integer
[_schemaPattern] :: Schema -> Maybe Pattern
[_schemaMaxItems] :: Schema -> Maybe Integer
[_schemaMinItems] :: Schema -> Maybe Integer
[_schemaUniqueItems] :: Schema -> Maybe Bool
[_schemaEnum] :: Schema -> Maybe [Value]
[_schemaMultipleOf] :: Schema -> Maybe Scientific

-- | A <tt><a>Schema</a></tt> with an optional name. This name can be used
--   in references.
data NamedSchema
NamedSchema :: Maybe Text -> Schema -> NamedSchema
[_namedSchemaName] :: NamedSchema -> Maybe Text
[_namedSchemaSchema] :: NamedSchema -> Schema

-- | Items for <tt><a>OpenApiArray</a></tt> schemas.
--   
--   <b>Warning</b>: OpenAPI 3.0 does not support tuple arrays. However,
--   OpenAPI 3.1 will, as it will incorporate Json Schema mostly verbatim.
--   
--   <tt><a>OpenApiItemsObject</a></tt> should be used to specify
--   homogenous array <tt><a>Schema</a></tt>s.
--   
--   <tt><a>OpenApiItemsArray</a></tt> should be used to specify tuple
--   <tt><a>Schema</a></tt>s.
data OpenApiItems
[OpenApiItemsObject] :: Referenced Schema -> OpenApiItems
[OpenApiItemsArray] :: [Referenced Schema] -> OpenApiItems
data Xml
Xml :: Maybe Text -> Maybe Text -> Maybe Text -> Maybe Bool -> Maybe Bool -> Xml

-- | Replaces the name of the element/attribute used for the described
--   schema property. When defined within the <tt><a>OpenApiItems</a></tt>
--   (items), it will affect the name of the individual XML elements within
--   the list. When defined alongside type being array (outside the items),
--   it will affect the wrapping element and only if wrapped is true. If
--   wrapped is false, it will be ignored.
[_xmlName] :: Xml -> Maybe Text

-- | The URL of the namespace definition. Value SHOULD be in the form of a
--   URL.
[_xmlNamespace] :: Xml -> Maybe Text

-- | The prefix to be used for the name.
[_xmlPrefix] :: Xml -> Maybe Text

-- | Declares whether the property definition translates to an attribute
--   instead of an element. Default value is <tt>False</tt>.
[_xmlAttribute] :: Xml -> Maybe Bool

-- | MAY be used only for an array definition. Signifies whether the array
--   is wrapped (for example,
--   <tt>&lt;books&gt;&lt;book<i>&gt;&lt;book</i>&gt;&lt;/books&gt;</tt>)
--   or unwrapped (<tt>&lt;book<i>&gt;&lt;book</i>&gt;</tt>). Default value
--   is <tt>False</tt>. The definition takes effect only when defined
--   alongside type being array (outside the items).
[_xmlWrapped] :: Xml -> Maybe Bool

-- | Regex pattern for <tt>string</tt> type.
type Pattern = Text
data AdditionalProperties
AdditionalPropertiesAllowed :: Bool -> AdditionalProperties
AdditionalPropertiesSchema :: Referenced Schema -> AdditionalProperties
data Discriminator
Discriminator :: Text -> InsOrdHashMap Text Text -> Discriminator

-- | The name of the property in the payload that will hold the
--   discriminator value.
[_discriminatorPropertyName] :: Discriminator -> Text

-- | An object to hold mappings between payload values and schema names or
--   references.
[_discriminatorMapping] :: Discriminator -> InsOrdHashMap Text Text

-- | A container for the expected responses of an operation. The container
--   maps a HTTP response code to the expected response. It is not expected
--   from the documentation to necessarily cover all possible HTTP response
--   codes, since they may not be known in advance. However, it is expected
--   from the documentation to cover a successful operation response and
--   any known errors.
data Responses
Responses :: Maybe (Referenced Response) -> InsOrdHashMap HttpStatusCode (Referenced Response) -> Responses

-- | The documentation of responses other than the ones declared for
--   specific HTTP response codes. It can be used to cover undeclared
--   responses.
[_responsesDefault] :: Responses -> Maybe (Referenced Response)

-- | Any HTTP status code can be used as the property name (one property
--   per HTTP status code). Describes the expected response for those HTTP
--   status codes.
[_responsesResponses] :: Responses -> InsOrdHashMap HttpStatusCode (Referenced Response)

-- | Describes a single response from an API Operation.
data Response
Response :: Text -> InsOrdHashMap MediaType MediaTypeObject -> InsOrdHashMap HeaderName (Referenced Header) -> InsOrdHashMap Text (Referenced Link) -> Response

-- | A short description of the response. <a>CommonMark syntax</a> can be
--   used for rich text representation.
[_responseDescription] :: Response -> Text

-- | A map containing descriptions of potential response payloads. The key
--   is a media type or media type range and the value describes it. For
--   responses that match multiple keys, only the most specific key is
--   applicable. e.g. <tt>text/plain</tt> overrides <tt>text/*</tt>.
[_responseContent] :: Response -> InsOrdHashMap MediaType MediaTypeObject

-- | Maps a header name to its definition.
[_responseHeaders] :: Response -> InsOrdHashMap HeaderName (Referenced Header)

-- | A map of operations links that can be followed from the response. The
--   key of the map is a short name for the link, following the naming
--   constraints of the names for <tt>Component</tt> Objects.
[_responseLinks] :: Response -> InsOrdHashMap Text (Referenced Link)
type HttpStatusCode = Int

-- | The Link object represents a possible design-time link for a response.
--   The presence of a link does not guarantee the caller's ability to
--   successfully invoke it, rather it provides a known relationship and
--   traversal mechanism between responses and other operations.
data Link
Link :: Maybe Text -> Maybe Text -> InsOrdHashMap Text ExpressionOrValue -> Maybe ExpressionOrValue -> Maybe Text -> Maybe Server -> Link

-- | A relative or absolute URI reference to an OAS operation. This field
--   is mutually exclusive of the <a>_linkOperationId</a> field, and MUST
--   point to an <a>Operation</a> Object. Relative <a>_linkOperationRef</a>
--   values MAY be used to locate an existing <a>Operation</a> Object in
--   the OpenAPI definition.
[_linkOperationRef] :: Link -> Maybe Text

-- | The name of an <i>existing</i>, resolvable OAS operation, as defined
--   with a unique <a>_operationOperationId</a>. This field is mutually
--   exclusive of the <a>_linkOperationRef</a> field.
[_linkOperationId] :: Link -> Maybe Text

-- | A map representing parameters to pass to an operation as specified
--   with <a>_linkOperationId</a> or identified via
--   <a>_linkOperationRef</a>. The key is the parameter name to be used,
--   whereas the value can be a constant or an expression to be evaluated
--   and passed to the linked operation. The parameter name can be
--   qualified using the parameter location <tt>[{in}.]{name}</tt> for
--   operations that use the same parameter name in different locations
--   (e.g. path.id).
[_linkParameters] :: Link -> InsOrdHashMap Text ExpressionOrValue

-- | A literal value or <tt>{expression}</tt> to use as a request body when
--   calling the target operation.
[_linkRequestBody] :: Link -> Maybe ExpressionOrValue

-- | A description of the link.
[_linkDescription] :: Link -> Maybe Text

-- | A server object to be used by the target operation.
[_linkServer] :: Link -> Maybe Server

-- | A map of possible out-of band callbacks related to the parent
--   operation. Each value in the map is a <a>PathItem</a> Object that
--   describes a set of requests that may be initiated by the API provider
--   and the expected responses. The key value used to identify the path
--   item object is an expression, evaluated at runtime, that identifies a
--   URL to use for the callback operation.
newtype Callback
Callback :: InsOrdHashMap Text PathItem -> Callback
data SecurityScheme
SecurityScheme :: SecuritySchemeType -> Maybe Text -> SecurityScheme

-- | The type of the security scheme.
[_securitySchemeType] :: SecurityScheme -> SecuritySchemeType

-- | A short description for security scheme.
[_securitySchemeDescription] :: SecurityScheme -> Maybe Text

-- | <pre>
--   &gt;&gt;&gt; BSL.putStrLn $ encodePretty (SecuritySchemeHttp (HttpSchemeBearer Nothing))
--   {
--       "scheme": "bearer",
--       "type": "http"
--   }
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; BSL.putStrLn $ encodePretty (SecuritySchemeHttp (HttpSchemeBearer (Just "jwt")))
--   {
--       "bearerFormat": "jwt",
--       "scheme": "bearer",
--       "type": "http"
--   }
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; BSL.putStrLn $ encodePretty (SecuritySchemeHttp HttpSchemeBasic)
--   {
--       "scheme": "basic",
--       "type": "http"
--   }
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; BSL.putStrLn $ encodePretty (SecuritySchemeHttp (HttpSchemeCustom "CANARY"))
--   {
--       "scheme": "CANARY",
--       "type": "http"
--   }
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; BSL.putStrLn $ encodePretty (SecuritySchemeApiKey (ApiKeyParams "id" ApiKeyCookie))
--   {
--       "in": "cookie",
--       "name": "id",
--       "type": "apiKey"
--   }
--   </pre>
data SecuritySchemeType
SecuritySchemeHttp :: HttpSchemeType -> SecuritySchemeType
SecuritySchemeApiKey :: ApiKeyParams -> SecuritySchemeType
SecuritySchemeOAuth2 :: OAuth2Flows -> SecuritySchemeType
SecuritySchemeOpenIdConnect :: URL -> SecuritySchemeType
data HttpSchemeType
HttpSchemeBearer :: Maybe BearerFormat -> HttpSchemeType
HttpSchemeBasic :: HttpSchemeType
HttpSchemeCustom :: Text -> HttpSchemeType
newtype SecurityDefinitions
SecurityDefinitions :: Definitions SecurityScheme -> SecurityDefinitions

-- | Lists the required security schemes to execute this operation. The
--   object can have multiple security schemes declared in it which are all
--   required (that is, there is a logical AND between the schemes).
newtype SecurityRequirement
SecurityRequirement :: InsOrdHashMap Text [Text] -> SecurityRequirement
[getSecurityRequirement] :: SecurityRequirement -> InsOrdHashMap Text [Text]
data ApiKeyParams
ApiKeyParams :: Text -> ApiKeyLocation -> ApiKeyParams

-- | The name of the header or query parameter to be used.
[_apiKeyName] :: ApiKeyParams -> Text

-- | The location of the API key.
[_apiKeyIn] :: ApiKeyParams -> ApiKeyLocation

-- | The location of the API key.
data ApiKeyLocation
ApiKeyQuery :: ApiKeyLocation
ApiKeyHeader :: ApiKeyLocation
ApiKeyCookie :: ApiKeyLocation
data OAuth2Flows
OAuth2Flows :: Maybe (OAuth2Flow OAuth2ImplicitFlow) -> Maybe (OAuth2Flow OAuth2PasswordFlow) -> Maybe (OAuth2Flow OAuth2ClientCredentialsFlow) -> Maybe (OAuth2Flow OAuth2AuthorizationCodeFlow) -> OAuth2Flows

-- | Configuration for the OAuth Implicit flow
[_oAuth2FlowsImplicit] :: OAuth2Flows -> Maybe (OAuth2Flow OAuth2ImplicitFlow)

-- | Configuration for the OAuth Resource Owner Password flow
[_oAuth2FlowsPassword] :: OAuth2Flows -> Maybe (OAuth2Flow OAuth2PasswordFlow)

-- | Configuration for the OAuth Client Credentials flow
[_oAuth2FlowsClientCredentials] :: OAuth2Flows -> Maybe (OAuth2Flow OAuth2ClientCredentialsFlow)

-- | Configuration for the OAuth Authorization Code flow
[_oAuth2FlowsAuthorizationCode] :: OAuth2Flows -> Maybe (OAuth2Flow OAuth2AuthorizationCodeFlow)
data OAuth2Flow p
OAuth2Flow :: p -> Maybe URL -> InsOrdHashMap Text Text -> OAuth2Flow p
[_oAuth2Params] :: OAuth2Flow p -> p

-- | The URL to be used for obtaining refresh tokens.
[_oAath2RefreshUrl] :: OAuth2Flow p -> Maybe URL

-- | The available scopes for the OAuth2 security scheme. A map between the
--   scope name and a short description for it. The map MAY be empty.
[_oAuth2Scopes] :: OAuth2Flow p -> InsOrdHashMap Text Text
newtype OAuth2ImplicitFlow
OAuth2ImplicitFlow :: AuthorizationURL -> OAuth2ImplicitFlow
[_oAuth2ImplicitFlowAuthorizationUrl] :: OAuth2ImplicitFlow -> AuthorizationURL
newtype OAuth2PasswordFlow
OAuth2PasswordFlow :: TokenURL -> OAuth2PasswordFlow
[_oAuth2PasswordFlowTokenUrl] :: OAuth2PasswordFlow -> TokenURL
newtype OAuth2ClientCredentialsFlow
OAuth2ClientCredentialsFlow :: TokenURL -> OAuth2ClientCredentialsFlow
[_oAuth2ClientCredentialsFlowTokenUrl] :: OAuth2ClientCredentialsFlow -> TokenURL
data OAuth2AuthorizationCodeFlow
OAuth2AuthorizationCodeFlow :: AuthorizationURL -> TokenURL -> OAuth2AuthorizationCodeFlow
[_oAuth2AuthorizationCodeFlowAuthorizationUrl] :: OAuth2AuthorizationCodeFlow -> AuthorizationURL
[_oAuth2AuthorizationCodeFlowTokenUrl] :: OAuth2AuthorizationCodeFlow -> TokenURL

-- | The authorization URL to be used for OAuth2 flow. This SHOULD be in
--   the form of a URL.
type AuthorizationURL = Text

-- | The token URL to be used for OAuth2 flow. This SHOULD be in the form
--   of a URL.
type TokenURL = Text

-- | Allows referencing an external resource for extended documentation.
data ExternalDocs
ExternalDocs :: Maybe Text -> URL -> ExternalDocs

-- | A short description of the target documentation. <a>CommonMark
--   syntax</a> MAY be used for rich text representation.
[_externalDocsDescription] :: ExternalDocs -> Maybe Text

-- | The URL for the target documentation.
[_externalDocsUrl] :: ExternalDocs -> URL

-- | A simple object to allow referencing other definitions in the
--   specification. It can be used to reference parameters and responses
--   that are defined at the top level for reuse.
newtype Reference
Reference :: Text -> Reference
[getReference] :: Reference -> Text
data Referenced a
Ref :: Reference -> Referenced a
Inline :: a -> Referenced a
newtype MimeList
MimeList :: [MediaType] -> MimeList
[getMimeList] :: MimeList -> [MediaType]
newtype URL
URL :: Text -> URL
[getUrl] :: URL -> Text

module Data.OpenApi.Schema.Generator

-- | Note: <a>schemaGen</a> may <a>error</a>, if schema type is not
--   specified, and cannot be inferred.
schemaGen :: Definitions Schema -> Schema -> Gen Value
dereference :: Definitions a -> Referenced a -> a
genValue :: ToSchema a => Proxy a -> Gen Value
validateFromJSON :: forall a. (ToSchema a, FromJSON a) => Proxy a -> Property
