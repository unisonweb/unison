-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


@package unison-hashing-v2
@version 0.0.0


-- | This module exports:
--   
--   <ul>
--   <li>Data types with <a>ContentAddressable</a> instances that
--   correspond to v2 of the Unison hash function.</li>
--   <li>Miscellaneous helper functions related to hashing.</li>
--   </ul>
module Unison.Hashing.V2
data Branch
Branch :: Map NameSegment (Map Referent MdValues) -> Map NameSegment (Map Reference MdValues) -> Map NameSegment Hash -> Map NameSegment Hash -> Branch
[terms] :: Branch -> Map NameSegment (Map Referent MdValues)
[types] :: Branch -> Map NameSegment (Map Reference MdValues)
[patches] :: Branch -> Map NameSegment Hash
[children] :: Branch -> Map NameSegment Hash
data Causal
Causal :: Hash -> Set Hash -> Causal
[branchHash] :: Causal -> Hash
[parents] :: Causal -> Set Hash
data DataDeclaration v a
DataDeclaration :: Modifier -> a -> [v] -> [(a, v, Type v a)] -> DataDeclaration v a
[modifier] :: DataDeclaration v a -> Modifier
[annotation] :: DataDeclaration v a -> a
[bound] :: DataDeclaration v a -> [v]
[constructors'] :: DataDeclaration v a -> [(a, v, Type v a)]
type Decl v a = Either (EffectDeclaration v a) (DataDeclaration v a)
newtype EffectDeclaration v a
EffectDeclaration :: DataDeclaration v a -> EffectDeclaration v a
[toDataDecl] :: EffectDeclaration v a -> DataDeclaration v a
data Kind
KindStar :: Kind
KindArrow :: Kind -> Kind -> Kind
data MatchCase loc a
MatchCase :: Pattern loc -> Maybe a -> a -> MatchCase loc a
newtype MdValues
MdValues :: Set MetadataValue -> MdValues
data Modifier
Structural :: Modifier
Unique :: Text -> Modifier

-- | A name segment.
newtype NameSegment
NameSegment :: Text -> NameSegment
data Patch
Patch :: Map Referent (Set TermEdit) -> Map Reference (Set TypeEdit) -> Patch
[termEdits] :: Patch -> Map Referent (Set TermEdit)
[typeEdits] :: Patch -> Map Reference (Set TypeEdit)
data Pattern loc
PatternUnbound :: loc -> Pattern loc
PatternVar :: loc -> Pattern loc
PatternBoolean :: loc -> !Bool -> Pattern loc
PatternInt :: loc -> !Int64 -> Pattern loc
PatternNat :: loc -> !Word64 -> Pattern loc
PatternFloat :: loc -> !Double -> Pattern loc
PatternText :: loc -> !Text -> Pattern loc
PatternChar :: loc -> !Char -> Pattern loc
PatternConstructor :: loc -> !Reference -> !ConstructorId -> [Pattern loc] -> Pattern loc
PatternAs :: loc -> Pattern loc -> Pattern loc
PatternEffectPure :: loc -> Pattern loc -> Pattern loc
PatternEffectBind :: loc -> !Reference -> !ConstructorId -> [Pattern loc] -> Pattern loc -> Pattern loc
PatternSequenceLiteral :: loc -> [Pattern loc] -> Pattern loc
PatternSequenceOp :: loc -> Pattern loc -> !SeqOp -> Pattern loc -> Pattern loc

-- | Either a builtin or a user defined (hashed) top-level declaration.
--   
--   Used for both terms and types. Doesn't distinguish between them.
--   
--   Other used defined things like local variables don't get
--   <tt>Reference</tt>s.
data Reference
ReferenceBuiltin :: Text -> Reference
ReferenceDerivedId :: ReferenceId -> Reference
pattern ReferenceDerived :: Hash -> Pos -> Reference

-- | <tt>Pos</tt> is a position into a cycle of size <tt>Size</tt>, as
--   cycles are hashed together.
data ReferenceId
ReferenceId :: Hash -> Pos -> ReferenceId
data Referent
ReferentRef :: Reference -> Referent
ReferentCon :: Reference -> ConstructorId -> Referent
data SeqOp
Cons :: SeqOp
Snoc :: SeqOp
Concat :: SeqOp

-- | Like `Term v`, but with an annotation of type <tt>a</tt> at every
--   level in the tree
type Term v a = Term2 v a a v a
data TermEdit
TermEditReplace :: Referent -> TermEdit
TermEditDeprecate :: TermEdit

-- | Base functor for terms in the Unison language We need <tt>typeVar</tt>
--   because the term and type variables may differ.
data TermF typeVar typeAnn patternAnn a
TermInt :: Int64 -> TermF typeVar typeAnn patternAnn a
TermNat :: Word64 -> TermF typeVar typeAnn patternAnn a
TermFloat :: Double -> TermF typeVar typeAnn patternAnn a
TermBoolean :: Bool -> TermF typeVar typeAnn patternAnn a
TermText :: Text -> TermF typeVar typeAnn patternAnn a
TermChar :: Char -> TermF typeVar typeAnn patternAnn a
TermBlank :: Blank typeAnn -> TermF typeVar typeAnn patternAnn a
TermRef :: Reference -> TermF typeVar typeAnn patternAnn a
TermConstructor :: Reference -> ConstructorId -> TermF typeVar typeAnn patternAnn a
TermRequest :: Reference -> ConstructorId -> TermF typeVar typeAnn patternAnn a
TermHandle :: a -> a -> TermF typeVar typeAnn patternAnn a
TermApp :: a -> a -> TermF typeVar typeAnn patternAnn a
TermAnn :: a -> Type typeVar typeAnn -> TermF typeVar typeAnn patternAnn a
TermList :: Seq a -> TermF typeVar typeAnn patternAnn a
TermIf :: a -> a -> a -> TermF typeVar typeAnn patternAnn a
TermAnd :: a -> a -> TermF typeVar typeAnn patternAnn a
TermOr :: a -> a -> TermF typeVar typeAnn patternAnn a
TermLam :: a -> TermF typeVar typeAnn patternAnn a
TermLetRec :: [a] -> a -> TermF typeVar typeAnn patternAnn a
TermLet :: a -> a -> TermF typeVar typeAnn patternAnn a
TermMatch :: a -> [MatchCase patternAnn a] -> TermF typeVar typeAnn patternAnn a
TermTermLink :: Referent -> TermF typeVar typeAnn patternAnn a
TermTypeLink :: Reference -> TermF typeVar typeAnn patternAnn a

-- | Types are represented as ABTs over the base functor F, with variables
--   in <tt>v</tt>
type Type v a = Term TypeF v a
data TypeEdit
TypeEditReplace :: Reference -> TypeEdit
TypeEditDeprecate :: TypeEdit

-- | Base functor for types in the Unison language
data TypeF a
TypeRef :: Reference -> TypeF a
TypeArrow :: a -> a -> TypeF a
TypeAnn :: a -> Kind -> TypeF a
TypeApp :: a -> a -> TypeF a
TypeEffect :: a -> a -> TypeF a
TypeEffects :: [a] -> TypeF a
TypeForall :: a -> TypeF a
TypeIntroOuter :: a -> TypeF a
hashClosedTerm :: Var v => Term v a -> ReferenceId

-- | compute the hashes of these user defined types and update any free
--   vars corresponding to these decls with the resulting hashes
--   
--   data List a = Nil | Cons a (List a) becomes something like (List,
--   #xyz, [forall a. #xyz a, forall a. a -&gt; (#xyz a) -&gt; (#xyz a)])
--   
--   NOTE: technical limitation, this implementation gives diff results if
--   ctors have the same FQN as one of the types. TODO: assert this and
--   bomb if not satisfied, or else do local mangling and unmangling to
--   ensure this doesn't affect the hash.
hashDecls :: (Eq v, Var v, Show v) => (v -> Name) -> Map v (DataDeclaration v a) -> ResolutionResult a [(v, ReferenceId, DataDeclaration v a)]
hashTermComponents :: forall v a extra. Var v => Map v (Term v a, Type v a, extra) -> Map v (ReferenceId, Term v a, Type v a, extra)
hashTermComponentsWithoutTypes :: Var v => Map v (Term v a) -> Map v (ReferenceId, Term v a)
typeToReference :: (Ord v, Show v) => Type v a -> Reference
typeToReferenceMentions :: (Ord v, Show v) => Type v a -> Set Reference

-- | A type class that is inhabited by types that can compute a hash of
--   their content.
--   
--   The base instances of this class should only live in dedicated
--   "hashing packages" such as <tt>unison-hashing-v2</tt>, whose types and
--   implementations should never change.
--   
--   Trivial wrapper instances can be written around these, but note these
--   pipelines from <tt>MyType ==&gt; SomeHashingType ==&gt; Hash</tt> must
--   take care not to change the <tt>MyType ==&gt; SomeHashingType</tt>
--   conversion, once written.
--   
--   For example, we might have a representation of some namespace in
--   memory
--   
--   <pre>
--   data Namespace = Namespace Terms Types OtherStuff CachesAndWhatnot
--   </pre>
--   
--   with a somewhat equivalent "hashing" type in some "hashing package",
--   with a ContentAddressable instance
--   
--   <pre>
--   data HashingNamespace = Namespace Terms Types
--   </pre>
--   
--   We can of course make our own convenience instance
--   
--   <pre>
--   instance ContentAddressable Namespace where
--     contentHash = contentHash . namespaceToHashingNamespace
--   </pre>
--   
--   But we must make sure that the implementation of
--   <tt>namespaceToHashingNamespace</tt> never changes the fields in the
--   corresponding <tt>HashingNamespace</tt>, even as features are added to
--   or removed from <tt>Namespace</tt>.
class () => ContentAddressable a
contentHash :: ContentAddressable a => a -> Hash
