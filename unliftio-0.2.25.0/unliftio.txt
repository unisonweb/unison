-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | The MonadUnliftIO typeclass for unlifting monads to IO (batteries included)
--   
--   Please see the documentation and README at
--   <a>https://www.stackage.org/package/unliftio</a>
@package unliftio
@version 0.2.25.0


-- | Lifted <a>Control.Concurrent.Chan</a>.
module UnliftIO.Chan

-- | <a>Chan</a> is an abstract type representing an unbounded FIFO
--   channel.
data () => Chan a

-- | Lifted <a>newChan</a>.
newChan :: MonadIO m => m (Chan a)

-- | Lifted <a>writeChan</a>.
writeChan :: MonadIO m => Chan a -> a -> m ()

-- | Lifted <a>readChan</a>.
readChan :: MonadIO m => Chan a -> m a

-- | Lifted <a>dupChan</a>.
dupChan :: MonadIO m => Chan a -> m (Chan a)

-- | Lifted <a>getChanContents</a>.
getChanContents :: MonadIO m => Chan a -> m [a]

-- | Lifted <a>writeList2Chan</a>.
writeList2Chan :: MonadIO m => Chan a -> [a] -> m ()


-- | Unlifted <a>System.Directory</a>.
module UnliftIO.Directory

-- | Lifted <a>createDirectory</a>.
createDirectory :: MonadIO m => FilePath -> m ()

-- | Lifted <a>createDirectoryIfMissing</a>.
createDirectoryIfMissing :: MonadIO m => Bool -> FilePath -> m ()

-- | Lifted <a>createFileLink</a>. directory package version should be
--   &gt;= 1.3.1. @since 0.2.16.0
createFileLink :: MonadIO m => FilePath -> FilePath -> m ()

-- | Lifted <a>createDirectoryLink</a>.
createDirectoryLink :: MonadIO m => FilePath -> FilePath -> m ()

-- | Lifted <a>removeDirectoryLink</a>.
removeDirectoryLink :: MonadIO m => FilePath -> m ()

-- | Lifted <a>getSymbolicLinkTarget</a>.
getSymbolicLinkTarget :: MonadIO m => FilePath -> m FilePath

-- | Lifted <a>removeDirectory</a>.
removeDirectory :: MonadIO m => FilePath -> m ()

-- | Lifted <a>removeDirectoryRecursive</a>.
removeDirectoryRecursive :: MonadIO m => FilePath -> m ()

-- | Lifted <a>removePathForcibly</a>.
removePathForcibly :: MonadIO m => FilePath -> m ()

-- | Lifted <a>renameDirectory</a>.
renameDirectory :: MonadIO m => FilePath -> FilePath -> m ()

-- | Lifted <a>listDirectory</a>.
listDirectory :: MonadIO m => FilePath -> m [FilePath]

-- | Lifted <a>getDirectoryContents</a>.
getDirectoryContents :: MonadIO m => FilePath -> m [FilePath]

-- | Lifted <a>getCurrentDirectory</a>.
getCurrentDirectory :: MonadIO m => m FilePath

-- | Lifted <a>setCurrentDirectory</a>.
setCurrentDirectory :: MonadIO m => FilePath -> m ()

-- | Unlifted <a>withCurrentDirectory</a>.
withCurrentDirectory :: MonadUnliftIO m => FilePath -> m a -> m a

-- | Lifted <a>getHomeDirectory</a>.
getHomeDirectory :: MonadIO m => m FilePath

-- | Special directories for storing user-specific application data,
--   configuration, and cache files, as specified by the <a>XDG Base
--   Directory Specification</a>.
--   
--   Note: On Windows, <a>XdgData</a> and <a>XdgConfig</a> usually map to
--   the same directory.
data () => XdgDirectory

-- | For data files (e.g. images). It uses the <tt>XDG_DATA_HOME</tt>
--   environment variable. On non-Windows systems, the default is
--   <tt>~/.local/share</tt>. On Windows, the default is <tt>%APPDATA%</tt>
--   (e.g. <tt>C:/Users/<i>&lt;user&gt;</i>/AppData/Roaming</tt>). Can be
--   considered as the user-specific equivalent of <tt>/usr/share</tt>.
XdgData :: XdgDirectory

-- | For configuration files. It uses the <tt>XDG_CONFIG_HOME</tt>
--   environment variable. On non-Windows systems, the default is
--   <tt>~/.config</tt>. On Windows, the default is <tt>%APPDATA%</tt>
--   (e.g. <tt>C:/Users/<i>&lt;user&gt;</i>/AppData/Roaming</tt>). Can be
--   considered as the user-specific equivalent of <tt>/etc</tt>.
XdgConfig :: XdgDirectory

-- | For non-essential files (e.g. cache). It uses the
--   <tt>XDG_CACHE_HOME</tt> environment variable. On non-Windows systems,
--   the default is <tt>~/.cache</tt>. On Windows, the default is
--   <tt>%LOCALAPPDATA%</tt> (e.g.
--   <tt>C:/Users/<i>&lt;user&gt;</i>/AppData/Local</tt>). Can be
--   considered as the user-specific equivalent of <tt>/var/cache</tt>.
XdgCache :: XdgDirectory

-- | For data that should persist between (application) restarts, but that
--   is not important or portable enough to the user that it should be
--   stored in <a>XdgData</a>. It uses the <tt>XDG_STATE_HOME</tt>
--   environment variable. On non-Windows sytems, the default is
--   <tt>~/.local/state</tt>. On Windows, the default is
--   <tt>%LOCALAPPDATA%</tt> (e.g.
--   <tt>C:/Users/<i>&lt;user&gt;</i>/AppData/Local</tt>).
XdgState :: XdgDirectory

-- | Lifted <a>getXdgDirectory</a>.
getXdgDirectory :: MonadIO m => XdgDirectory -> FilePath -> m FilePath

-- | Search paths for various application data, as specified by the <a>XDG
--   Base Directory Specification</a>.
--   
--   The list of paths is split using <a>searchPathSeparator</a>, which on
--   Windows is a semicolon.
--   
--   Note: On Windows, <a>XdgDataDirs</a> and <a>XdgConfigDirs</a> usually
--   yield the same result.
data () => XdgDirectoryList

-- | For data files (e.g. images). It uses the <tt>XDG_DATA_DIRS</tt>
--   environment variable. On non-Windows systems, the default is
--   <tt>/usr/local/share/</tt> and <tt>/usr/share/</tt>. On Windows, the
--   default is <tt>%PROGRAMDATA%</tt> or <tt>%ALLUSERSPROFILE%</tt> (e.g.
--   <tt>C:/ProgramData</tt>).
XdgDataDirs :: XdgDirectoryList

-- | For configuration files. It uses the <tt>XDG_CONFIG_DIRS</tt>
--   environment variable. On non-Windows systems, the default is
--   <tt>/etc/xdg</tt>. On Windows, the default is <tt>%PROGRAMDATA%</tt>
--   or <tt>%ALLUSERSPROFILE%</tt> (e.g. <tt>C:/ProgramData</tt>).
XdgConfigDirs :: XdgDirectoryList

-- | Lifted <a>getXdgDirectoryList</a>.
getXdgDirectoryList :: MonadIO m => XdgDirectoryList -> m [FilePath]

-- | Lifted <a>getAppUserDataDirectory</a>.
getAppUserDataDirectory :: MonadIO m => FilePath -> m FilePath

-- | Lifted <a>getUserDocumentsDirectory</a>.
getUserDocumentsDirectory :: MonadIO m => m FilePath

-- | Lifted <a>getTemporaryDirectory</a>.
getTemporaryDirectory :: MonadIO m => m FilePath

-- | Lifted <a>removeFile</a>.
removeFile :: MonadIO m => FilePath -> m ()

-- | Lifted <a>renameFile</a>.
renameFile :: MonadIO m => FilePath -> FilePath -> m ()

-- | Lifted <a>renamePath</a>.
renamePath :: MonadIO m => FilePath -> FilePath -> m ()

-- | Lifted <a>copyFile</a>.
copyFile :: MonadIO m => FilePath -> FilePath -> m ()

-- | Lifted <a>copyFileWithMetadata</a>.
copyFileWithMetadata :: MonadIO m => FilePath -> FilePath -> m ()

-- | Lifted <a>canonicalizePath</a>.
canonicalizePath :: MonadIO m => FilePath -> m FilePath

-- | Lifted <a>makeAbsolute</a>.
makeAbsolute :: MonadIO m => FilePath -> m FilePath

-- | Lifted <a>makeRelativeToCurrentDirectory</a>.
makeRelativeToCurrentDirectory :: MonadIO m => FilePath -> m FilePath

-- | Lifted <a>findExecutable</a>.
findExecutable :: MonadIO m => String -> m (Maybe FilePath)

-- | Lifted <a>findExecutables</a>.
findExecutables :: MonadIO m => String -> m [FilePath]

-- | Lifted <a>findExecutablesInDirectories</a>.
findExecutablesInDirectories :: MonadIO m => [FilePath] -> String -> m [FilePath]

-- | Lifted <a>findFile</a>.
findFile :: MonadIO m => [FilePath] -> String -> m (Maybe FilePath)

-- | Lifted <a>findFiles</a>.
findFiles :: MonadIO m => [FilePath] -> String -> m [FilePath]

-- | Unlifted <a>findFileWith</a>.
findFileWith :: MonadUnliftIO m => (FilePath -> m Bool) -> [FilePath] -> String -> m (Maybe FilePath)

-- | Unlifted <a>findFilesWith</a>.
findFilesWith :: MonadUnliftIO m => (FilePath -> m Bool) -> [FilePath] -> String -> m [FilePath]

-- | Filename extension for executable files (including the dot if any)
--   (usually <tt>""</tt> on POSIX systems and <tt>".exe"</tt> on Windows
--   or OS/2).
exeExtension :: String

-- | Lifted <a>getFileSize</a>.
getFileSize :: MonadIO m => FilePath -> m Integer

-- | Lifted <a>doesPathExist</a>.
doesPathExist :: MonadIO m => FilePath -> m Bool

-- | Lifted <a>doesFileExist</a>.
doesFileExist :: MonadIO m => FilePath -> m Bool

-- | Lifted <a>doesDirectoryExist</a>.
doesDirectoryExist :: MonadIO m => FilePath -> m Bool

-- | Lifted <a>pathIsSymbolicLink</a>.
pathIsSymbolicLink :: MonadIO m => FilePath -> m Bool
data () => Permissions
emptyPermissions :: Permissions
readable :: Permissions -> Bool
writable :: Permissions -> Bool
executable :: Permissions -> Bool
searchable :: Permissions -> Bool
setOwnerReadable :: Bool -> Permissions -> Permissions
setOwnerWritable :: Bool -> Permissions -> Permissions
setOwnerExecutable :: Bool -> Permissions -> Permissions
setOwnerSearchable :: Bool -> Permissions -> Permissions

-- | Lifted <a>getPermissions</a>.
getPermissions :: MonadIO m => FilePath -> m Permissions

-- | Lifted <a>setPermissions</a>.
setPermissions :: MonadIO m => FilePath -> Permissions -> m ()

-- | Lifted <a>copyPermissions</a>.
copyPermissions :: MonadIO m => FilePath -> FilePath -> m ()

-- | Lifted <a>getAccessTime</a>.
getAccessTime :: MonadIO m => FilePath -> m UTCTime

-- | Lifted <a>getModificationTime</a>.
getModificationTime :: MonadIO m => FilePath -> m UTCTime

-- | Lifted <a>setAccessTime</a>.
setAccessTime :: MonadIO m => FilePath -> UTCTime -> m ()

-- | Lifted <a>setModificationTime</a>.
setModificationTime :: MonadIO m => FilePath -> UTCTime -> m ()


-- | Unlifted <a>System.Environment</a>.
module UnliftIO.Environment

-- | Lifted <a>getArgs</a>.
getArgs :: MonadIO m => m [String]

-- | Lifted <a>getProgName</a>.
getProgName :: MonadIO m => m String

-- | Lifted <a>getExecutablePath</a>.
getExecutablePath :: MonadIO m => m FilePath

-- | Lifted <a>getEnv</a>.
getEnv :: MonadIO m => String -> m String

-- | Lifted <a>lookupEnv</a>.
lookupEnv :: MonadIO m => String -> m (Maybe String)

-- | Lifted <a>setEnv</a>.
setEnv :: MonadIO m => String -> String -> m ()

-- | Lifted <a>unsetEnv</a>.
unsetEnv :: MonadIO m => String -> m ()

-- | Unlifted <a>withArgs</a>.
withArgs :: MonadUnliftIO m => [String] -> m a -> m a

-- | Unlifted <a>withProgName</a>.
withProgName :: MonadUnliftIO m => String -> m a -> m a

-- | Lifted <a>getEnvironment</a>.
getEnvironment :: MonadIO m => m [(String, String)]


-- | Unlifted <a>Control.Exception</a>, with extra async exception safety
--   and more helper functions.
--   
--   This module works best when your cleanup functions adhere to certain
--   expectations around exception safety and interruptible actions. For
--   more details, see <a>this exception safety tutorial</a>.
module UnliftIO.Exception

-- | Synchronously throw the given exception.
--   
--   Note that, if you provide an exception value which is of an
--   asynchronous type, it will be wrapped up in
--   <tt>SyncExceptionWrapper</tt>. See <a>toSyncException</a>.
throwIO :: (MonadIO m, Exception e) => e -> m a

-- | A convenience function for throwing a user error. This is useful for
--   cases where it would be too high a burden to define your own exception
--   type.
--   
--   This throws an exception of type <a>StringException</a>. When GHC
--   supports it (base 4.9 and GHC 8.0 and onward), it includes a call
--   stack.
throwString :: (MonadIO m, HasCallStack) => String -> m a

-- | Exception type thrown by <a>throwString</a>.
--   
--   Note that the second field of the data constructor depends on GHC/base
--   version. For base 4.9 and GHC 8.0 and later, the second field is a
--   call stack. Previous versions of GHC and base do not support call
--   stacks, and the field is simply unit (provided to make pattern
--   matching across GHC versions easier).
data StringException
StringException :: String -> CallStack -> StringException

-- | Smart constructor for a <a>StringException</a> that deals with the
--   call stack.
stringException :: HasCallStack => String -> StringException

-- | Throw an asynchronous exception to another thread.
--   
--   Synchronously typed exceptions will be wrapped into an
--   <tt>AsyncExceptionWrapper</tt>, see
--   <a>https://github.com/fpco/safe-exceptions#determining-sync-vs-async</a>.
--   
--   It's usually a better idea to use the <a>UnliftIO.Async</a> module,
--   see <a>https://github.com/fpco/safe-exceptions#quickstart</a>.
throwTo :: (Exception e, MonadIO m) => ThreadId -> e -> m ()

-- | Generate a pure value which, when forced, will synchronously throw the
--   given exception.
--   
--   Generally it's better to avoid using this function and instead use
--   <a>throwIO</a>, see
--   <a>https://github.com/fpco/safe-exceptions#quickstart</a>.
impureThrow :: Exception e => e -> a

-- | Unwrap an <a>Either</a> value, throwing its <a>Left</a> value as a
--   runtime exception via <a>throwIO</a> if present.
fromEither :: (Exception e, MonadIO m) => Either e a -> m a

-- | Same as <a>fromEither</a>, but works on an <a>IO</a>-wrapped
--   <a>Either</a>.
fromEitherIO :: (Exception e, MonadIO m) => IO (Either e a) -> m a

-- | Same as <a>fromEither</a>, but works on an <tt>m</tt>-wrapped
--   <a>Either</a>.
fromEitherM :: (Exception e, MonadIO m) => m (Either e a) -> m a

-- | Same as <a>mapException</a>, except works in a monadic context.
mapExceptionM :: (Exception e1, Exception e2, MonadUnliftIO m) => (e1 -> e2) -> m a -> m a

-- | Catch a synchronous (but not asynchronous) exception and recover from
--   it.
--   
--   This is parameterized on the exception type. To catch all synchronous
--   exceptions, use <a>catchAny</a>.
catch :: (MonadUnliftIO m, Exception e) => m a -> (e -> m a) -> m a

-- | <a>catch</a> specialized to only catching <a>IOException</a>s.
catchIO :: MonadUnliftIO m => m a -> (IOException -> m a) -> m a

-- | <a>catch</a> specialized to catch all synchronous exceptions.
catchAny :: MonadUnliftIO m => m a -> (SomeException -> m a) -> m a

-- | Same as <a>catch</a>, but fully force evaluation of the result value
--   to find all impure exceptions.
catchDeep :: (MonadUnliftIO m, Exception e, NFData a) => m a -> (e -> m a) -> m a

-- | <a>catchDeep</a> specialized to catch all synchronous exception.
catchAnyDeep :: (NFData a, MonadUnliftIO m) => m a -> (SomeException -> m a) -> m a

-- | <a>catchJust</a> is like <a>catch</a> but it takes an extra argument
--   which is an exception predicate, a function which selects which type
--   of exceptions we're interested in.
catchJust :: (MonadUnliftIO m, Exception e) => (e -> Maybe b) -> m a -> (b -> m a) -> m a

-- | Flipped version of <a>catch</a>.
handle :: (MonadUnliftIO m, Exception e) => (e -> m a) -> m a -> m a

-- | <a>handle</a> specialized to only catching <a>IOException</a>s.
handleIO :: MonadUnliftIO m => (IOException -> m a) -> m a -> m a

-- | Flipped version of <a>catchAny</a>.
handleAny :: MonadUnliftIO m => (SomeException -> m a) -> m a -> m a

-- | Flipped version of <a>catchDeep</a>.
handleDeep :: (MonadUnliftIO m, Exception e, NFData a) => (e -> m a) -> m a -> m a

-- | Flipped version of <a>catchAnyDeep</a>.
handleAnyDeep :: (MonadUnliftIO m, NFData a) => (SomeException -> m a) -> m a -> m a

-- | Flipped <a>catchJust</a>.
handleJust :: (MonadUnliftIO m, Exception e) => (e -> Maybe b) -> (b -> m a) -> m a -> m a

-- | Run the given action and catch any synchronous exceptions as a
--   <a>Left</a> value.
--   
--   This is parameterized on the exception type. To catch all synchronous
--   exceptions, use <a>tryAny</a>.
try :: (MonadUnliftIO m, Exception e) => m a -> m (Either e a)

-- | <a>try</a> specialized to only catching <a>IOException</a>s.
tryIO :: MonadUnliftIO m => m a -> m (Either IOException a)

-- | <a>try</a> specialized to catch all synchronous exceptions.
tryAny :: MonadUnliftIO m => m a -> m (Either SomeException a)

-- | Same as <a>try</a>, but fully force evaluation of the result value to
--   find all impure exceptions.
tryDeep :: (MonadUnliftIO m, Exception e, NFData a) => m a -> m (Either e a)

-- | <a>tryDeep</a> specialized to catch all synchronous exceptions.
tryAnyDeep :: (MonadUnliftIO m, NFData a) => m a -> m (Either SomeException a)

-- | A variant of <a>try</a> that takes an exception predicate to select
--   which exceptions are caught.
tryJust :: (MonadUnliftIO m, Exception e) => (e -> Maybe b) -> m a -> m (Either b a)

-- | Evaluate the value to WHNF and catch any synchronous exceptions.
--   
--   The expression may still have bottom values within it; you may instead
--   want to use <a>pureTryDeep</a>.
pureTry :: a -> Either SomeException a

-- | Evaluate the value to NF and catch any synchronous exceptions.
pureTryDeep :: NFData a => a -> Either SomeException a

-- | Generalized version of <a>Handler</a>
data () => Handler (m :: Type -> Type) a
Handler :: (e -> m a) -> Handler (m :: Type -> Type) a

-- | Similar to <a>catch</a>, but provides multiple different handler
--   functions.
--   
--   For more information on motivation, see <tt>base</tt>'s
--   <a>catches</a>. Note that, unlike that function, this function will
--   not catch asynchronous exceptions.
catches :: MonadUnliftIO m => m a -> [Handler m a] -> m a

-- | Same as <a>catches</a>, but fully force evaluation of the result value
--   to find all impure exceptions.
catchesDeep :: (MonadUnliftIO m, NFData a) => m a -> [Handler m a] -> m a

-- | A variant of <a>catch</a> that catches both synchronous and
--   asynchronous exceptions.
--   
--   WARNING: This function (and other <tt>*SyncOrAsync</tt> functions) is
--   for advanced users. Most of the time, you probably want to use the
--   non-<tt>SyncOrAsync</tt> versions.
--   
--   Before attempting to use this function, be familiar with the "Rules
--   for async safe handling" section in <a>this blog post</a>.
catchSyncOrAsync :: (MonadUnliftIO m, Exception e) => m a -> (e -> m a) -> m a

-- | A variant of <a>handle</a> that catches both synchronous and
--   asynchronous exceptions.
--   
--   See <a>catchSyncOrAsync</a>.
handleSyncOrAsync :: (MonadUnliftIO m, Exception e) => (e -> m a) -> m a -> m a

-- | A variant of <a>try</a> that catches both synchronous and asynchronous
--   exceptions.
--   
--   See <a>catchSyncOrAsync</a>.
trySyncOrAsync :: (MonadUnliftIO m, Exception e) => m a -> m (Either e a)

-- | Like <a>finally</a>, but only call <tt>after</tt> if an exception
--   occurs.
onException :: MonadUnliftIO m => m a -> m b -> m a

-- | Allocate and clean up a resource safely.
--   
--   For more information on motivation and usage of this function, see
--   <tt>base</tt>'s <a>bracket</a>. This function has two differences from
--   the one in <tt>base</tt>. The first, and more obvious, is that it
--   works on any <tt>MonadUnliftIO</tt> instance, not just <tt>IO</tt>.
--   
--   The more subtle difference is that this function will use
--   uninterruptible masking for its cleanup handler. This is a subtle
--   distinction, but at a high level, means that resource cleanup has more
--   guarantees to complete. This comes at the cost that an incorrectly
--   written cleanup function cannot be interrupted.
--   
--   For more information, please see
--   <a>https://github.com/fpco/safe-exceptions/issues/3</a>.
bracket :: MonadUnliftIO m => m a -> (a -> m b) -> (a -> m c) -> m c

-- | Same as <a>bracket</a>, but does not pass the acquired resource to
--   cleanup and use functions.
--   
--   For more information, see <tt>base</tt>'s <a>bracket_</a>.
bracket_ :: MonadUnliftIO m => m a -> m b -> m c -> m c

-- | Perform <tt>thing</tt>, guaranteeing that <tt>after</tt> will run
--   after, even if an exception occurs.
--   
--   Same interruptible vs uninterrupible points apply as with
--   <a>bracket</a>. See <tt>base</tt>'s <a>finally</a> for more
--   information.
finally :: MonadUnliftIO m => m a -> m b -> m a

-- | Like <a>onException</a>, but provides the handler the thrown
--   exception.
withException :: (MonadUnliftIO m, Exception e) => m a -> (e -> m b) -> m a

-- | Same as <a>bracket</a>, but only perform the cleanup if an exception
--   is thrown.
bracketOnError :: MonadUnliftIO m => m a -> (a -> m b) -> (a -> m c) -> m c

-- | A variant of <a>bracketOnError</a> where the return value from the
--   first computation is not required.
bracketOnError_ :: MonadUnliftIO m => m a -> m b -> m c -> m c

-- | Wrap up an asynchronous exception to be treated as a synchronous
--   exception
--   
--   This is intended to be created via <a>toSyncException</a>
data () => SyncExceptionWrapper
SyncExceptionWrapper :: e -> SyncExceptionWrapper

-- | Convert an exception into a synchronous exception.
--   
--   For synchronous exceptions, this is the same as <a>toException</a>.
--   For asynchronous exceptions, this will wrap up the exception with
--   <tt>SyncExceptionWrapper</tt>.
toSyncException :: Exception e => e -> SomeException

-- | Wrap up a synchronous exception to be treated as an asynchronous
--   exception
--   
--   This is intended to be created via <a>toAsyncException</a>
data () => AsyncExceptionWrapper
AsyncExceptionWrapper :: e -> AsyncExceptionWrapper

-- | Convert an exception into an asynchronous exception.
--   
--   For asynchronous exceptions, this is the same as <a>toException</a>.
--   For synchronous exceptions, this will wrap up the exception with
--   <tt>AsyncExceptionWrapper</tt>.
toAsyncException :: Exception e => e -> SomeException

-- | Convert from a possibly wrapped exception.
--   
--   The inverse of <a>toAsyncException</a> and <a>toSyncException</a>.
--   When using those functions (or functions that use them, like
--   <a>throwTo</a> or <a>throwIO</a>), <a>fromException</a> might not be
--   sufficient because the exception might be wrapped within
--   <tt>SyncExceptionWrapper</tt> or <tt>AsyncExceptionWrapper</tt>.
fromExceptionUnwrap :: Exception e => SomeException -> Maybe e

-- | Check if the given exception is synchronous.
isSyncException :: Exception e => e -> Bool

-- | Check if the given exception is asynchronous.
isAsyncException :: Exception e => e -> Bool

-- | Unlifted version of <a>mask</a>.
mask :: MonadUnliftIO m => ((forall a. m a -> m a) -> m b) -> m b

-- | Unlifted version of <a>uninterruptibleMask</a>.
uninterruptibleMask :: MonadUnliftIO m => ((forall a. m a -> m a) -> m b) -> m b

-- | Unlifted version of <a>mask_</a>.
mask_ :: MonadUnliftIO m => m a -> m a

-- | Unlifted version of <a>uninterruptibleMask_</a>.
uninterruptibleMask_ :: MonadUnliftIO m => m a -> m a

-- | Lifted version of <a>evaluate</a>.
evaluate :: MonadIO m => a -> m a

-- | Deeply evaluate a value using <a>evaluate</a> and <a>NFData</a>.
evaluateDeep :: (MonadIO m, NFData a) => a -> m a

-- | Any type that you wish to throw or catch as an exception must be an
--   instance of the <tt>Exception</tt> class. The simplest case is a new
--   exception type directly below the root:
--   
--   <pre>
--   data MyException = ThisException | ThatException
--       deriving Show
--   
--   instance Exception MyException
--   </pre>
--   
--   The default method definitions in the <tt>Exception</tt> class do what
--   we need in this case. You can now throw and catch
--   <tt>ThisException</tt> and <tt>ThatException</tt> as exceptions:
--   
--   <pre>
--   *Main&gt; throw ThisException `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: MyException))
--   Caught ThisException
--   </pre>
--   
--   In more complicated examples, you may wish to define a whole hierarchy
--   of exceptions:
--   
--   <pre>
--   ---------------------------------------------------------------------
--   -- Make the root exception type for all the exceptions in a compiler
--   
--   data SomeCompilerException = forall e . Exception e =&gt; SomeCompilerException e
--   
--   instance Show SomeCompilerException where
--       show (SomeCompilerException e) = show e
--   
--   instance Exception SomeCompilerException
--   
--   compilerExceptionToException :: Exception e =&gt; e -&gt; SomeException
--   compilerExceptionToException = toException . SomeCompilerException
--   
--   compilerExceptionFromException :: Exception e =&gt; SomeException -&gt; Maybe e
--   compilerExceptionFromException x = do
--       SomeCompilerException a &lt;- fromException x
--       cast a
--   
--   ---------------------------------------------------------------------
--   -- Make a subhierarchy for exceptions in the frontend of the compiler
--   
--   data SomeFrontendException = forall e . Exception e =&gt; SomeFrontendException e
--   
--   instance Show SomeFrontendException where
--       show (SomeFrontendException e) = show e
--   
--   instance Exception SomeFrontendException where
--       toException = compilerExceptionToException
--       fromException = compilerExceptionFromException
--   
--   frontendExceptionToException :: Exception e =&gt; e -&gt; SomeException
--   frontendExceptionToException = toException . SomeFrontendException
--   
--   frontendExceptionFromException :: Exception e =&gt; SomeException -&gt; Maybe e
--   frontendExceptionFromException x = do
--       SomeFrontendException a &lt;- fromException x
--       cast a
--   
--   ---------------------------------------------------------------------
--   -- Make an exception type for a particular frontend compiler exception
--   
--   data MismatchedParentheses = MismatchedParentheses
--       deriving Show
--   
--   instance Exception MismatchedParentheses where
--       toException   = frontendExceptionToException
--       fromException = frontendExceptionFromException
--   </pre>
--   
--   We can now catch a <tt>MismatchedParentheses</tt> exception as
--   <tt>MismatchedParentheses</tt>, <tt>SomeFrontendException</tt> or
--   <tt>SomeCompilerException</tt>, but not other types, e.g.
--   <tt>IOException</tt>:
--   
--   <pre>
--   *Main&gt; throw MismatchedParentheses `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: MismatchedParentheses))
--   Caught MismatchedParentheses
--   *Main&gt; throw MismatchedParentheses `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: SomeFrontendException))
--   Caught MismatchedParentheses
--   *Main&gt; throw MismatchedParentheses `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: SomeCompilerException))
--   Caught MismatchedParentheses
--   *Main&gt; throw MismatchedParentheses `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: IOException))
--   *** Exception: MismatchedParentheses
--   </pre>
class (Typeable e, Show e) => Exception e
toException :: Exception e => e -> SomeException
fromException :: Exception e => SomeException -> Maybe e

-- | Render this exception value in a human-friendly manner.
--   
--   Default implementation: <tt><a>show</a></tt>.
displayException :: Exception e => e -> String

-- | The class <a>Typeable</a> allows a concrete representation of a type
--   to be calculated.
class () => Typeable (a :: k)

-- | The <tt>SomeException</tt> type is the root of the exception type
--   hierarchy. When an exception of type <tt>e</tt> is thrown, behind the
--   scenes it is encapsulated in a <tt>SomeException</tt>.
data () => SomeException
SomeException :: e -> SomeException

-- | Superclass for asynchronous exceptions.
data () => SomeAsyncException
SomeAsyncException :: e -> SomeAsyncException

-- | Exceptions that occur in the <tt>IO</tt> monad. An
--   <tt>IOException</tt> records a more specific error type, a descriptive
--   string and maybe the handle that was used when the error was flagged.
data () => IOException

-- | If the first argument evaluates to <a>True</a>, then the result is the
--   second argument. Otherwise an <a>AssertionFailed</a> exception is
--   raised, containing a <a>String</a> with the source file and line
--   number of the call to <a>assert</a>.
--   
--   Assertions can normally be turned on or off with a compiler flag (for
--   GHC, assertions are normally on unless optimisation is turned on with
--   <tt>-O</tt> or the <tt>-fignore-asserts</tt> option is given). When
--   assertions are turned off, the first argument to <a>assert</a> is
--   ignored, and the second argument is returned as the result.
assert :: Bool -> a -> a

asyncExceptionToException :: Exception e => e -> SomeException

asyncExceptionFromException :: Exception e => SomeException -> Maybe e
instance GHC.Show.Show UnliftIO.Exception.StringException
instance GHC.Classes.Eq UnliftIO.Exception.StringException
instance GHC.Exception.Type.Exception UnliftIO.Exception.StringException


-- | Functions from <a>Control.Exception.Lens</a>, but using
--   <a>MonadUnliftIO</a>, not <tt>MonadCatch</tt>
module UnliftIO.Exception.Lens

-- | <a>catching</a> using <a>MonadUnliftIO</a>
catching :: MonadUnliftIO m => Getting (First a) SomeException a -> m r -> (a -> m r) -> m r

-- | <a>catching_</a> using <a>MonadUnliftIO</a>
catching_ :: MonadUnliftIO m => Getting (First a) SomeException a -> m r -> m r -> m r

-- | <a>handling</a> using <a>MonadUnliftIO</a>
handling :: MonadUnliftIO m => Getting (First a) SomeException a -> (a -> m r) -> m r -> m r

-- | <a>handling_</a> using <a>MonadUnliftIO</a>
handling_ :: MonadUnliftIO m => Getting (First a) SomeException a -> m r -> m r -> m r

-- | <a>trying</a> using <a>MonadUnliftIO</a>
trying :: MonadUnliftIO m => Getting (First a) SomeException a -> m r -> m (Either a r)

-- | <a>trying_</a> using <a>MonadUnliftIO</a>
trying_ :: MonadUnliftIO m => Getting (First a) SomeException a -> m r -> m (Maybe r)


-- | Unlifted <a>Foreign</a>.
module UnliftIO.Foreign

-- | A C string is a reference to an array of C characters terminated by
--   NUL.
type CString = Ptr CChar

-- | A string with explicit length information in bytes instead of a
--   terminating NUL (allowing NUL characters in the middle of the string).
type CStringLen = (Ptr CChar, Int)

-- | Lifted <a>peekCString</a>.
peekCString :: MonadIO m => CString -> m String

-- | Lifted <a>peekCStringLen</a>.
peekCStringLen :: MonadIO m => CStringLen -> m String

-- | Lifted <a>newCString</a>.
newCString :: MonadIO m => String -> m CString

-- | Lifted <a>newCStringLen</a>.
newCStringLen :: MonadIO m => String -> m CStringLen

-- | Unlifted <a>withCString</a>.
withCString :: MonadUnliftIO m => String -> (CString -> m a) -> m a

-- | Unlifted <a>withCStringLen</a>.
withCStringLen :: MonadUnliftIO m => String -> (CStringLen -> m a) -> m a
charIsRepresentable :: Char -> IO Bool

-- | Convert a Haskell character to a C character. This function is only
--   safe on the first 256 characters.
castCharToCChar :: Char -> CChar

-- | Convert a C byte, representing a Latin-1 character, to the
--   corresponding Haskell character.
castCCharToChar :: CChar -> Char

-- | Convert a Haskell character to a C <tt>unsigned char</tt>. This
--   function is only safe on the first 256 characters.
castCharToCUChar :: Char -> CUChar

-- | Convert a C <tt>unsigned char</tt>, representing a Latin-1 character,
--   to the corresponding Haskell character.
castCUCharToChar :: CUChar -> Char

-- | Convert a Haskell character to a C <tt>signed char</tt>. This function
--   is only safe on the first 256 characters.
castCharToCSChar :: Char -> CSChar

-- | Convert a C <tt>signed char</tt>, representing a Latin-1 character, to
--   the corresponding Haskell character.
castCSCharToChar :: CSChar -> Char

-- | Lifted <a>peekCAString</a>.
peekCAString :: MonadIO m => CString -> m String

-- | Lifted <a>peekCAStringLen</a>.
peekCAStringLen :: MonadIO m => CStringLen -> m String

-- | Lifted <a>newCAString</a>.
newCAString :: MonadIO m => String -> m CString

-- | Lifted <a>newCAStringLen</a>.
newCAStringLen :: MonadIO m => String -> m CStringLen

-- | Unlifted <a>withCAString</a>.
withCAString :: MonadUnliftIO m => String -> (CString -> m a) -> m a

-- | Unlifted <a>withCAStringLen</a>.
withCAStringLen :: MonadUnliftIO m => String -> (CStringLen -> m a) -> m a

-- | A C wide string is a reference to an array of C wide characters
--   terminated by NUL.
type CWString = Ptr CWchar

-- | A wide character string with explicit length information in
--   <a>CWchar</a>s instead of a terminating NUL (allowing NUL characters
--   in the middle of the string).
type CWStringLen = (Ptr CWchar, Int)

-- | Lifted <a>peekCWString</a>.
peekCWString :: MonadIO m => CWString -> m String

-- | Lifted <a>peekCWStringLen</a>.
peekCWStringLen :: MonadIO m => CWStringLen -> m String

-- | Lifted <a>newCWString</a>.
newCWString :: MonadIO m => String -> m CWString

-- | Lifted <a>newCWStringLen</a>.
newCWStringLen :: MonadIO m => String -> m CWStringLen

-- | Unlifted <a>withCWString</a>.
withCWString :: MonadUnliftIO m => String -> (CWString -> m a) -> m a

-- | Unlifted <a>withCWStringLen</a>.
withCWStringLen :: MonadUnliftIO m => String -> (CWStringLen -> m a) -> m a

-- | Haskell representation for <tt>errno</tt> values. The implementation
--   is deliberately exposed, to allow users to add their own definitions
--   of <a>Errno</a> values.
newtype () => Errno
Errno :: CInt -> Errno
eOK :: Errno
e2BIG :: Errno
eACCES :: Errno
eADDRINUSE :: Errno
eADDRNOTAVAIL :: Errno
eADV :: Errno
eAFNOSUPPORT :: Errno
eAGAIN :: Errno
eALREADY :: Errno
eBADF :: Errno
eBADMSG :: Errno
eBADRPC :: Errno
eBUSY :: Errno
eCHILD :: Errno
eCOMM :: Errno
eCONNABORTED :: Errno
eCONNREFUSED :: Errno
eCONNRESET :: Errno
eDEADLK :: Errno
eDESTADDRREQ :: Errno
eDIRTY :: Errno
eDOM :: Errno
eDQUOT :: Errno
eEXIST :: Errno
eFAULT :: Errno
eFBIG :: Errno
eFTYPE :: Errno
eHOSTDOWN :: Errno
eHOSTUNREACH :: Errno
eIDRM :: Errno
eILSEQ :: Errno
eINPROGRESS :: Errno
eINTR :: Errno
eINVAL :: Errno
eIO :: Errno
eISCONN :: Errno
eISDIR :: Errno
eLOOP :: Errno
eMFILE :: Errno
eMLINK :: Errno
eMSGSIZE :: Errno
eMULTIHOP :: Errno
eNAMETOOLONG :: Errno
eNETDOWN :: Errno
eNETRESET :: Errno
eNETUNREACH :: Errno
eNFILE :: Errno
eNOBUFS :: Errno
eNODATA :: Errno
eNODEV :: Errno
eNOENT :: Errno
eNOEXEC :: Errno
eNOLCK :: Errno
eNOLINK :: Errno
eNOMEM :: Errno
eNOMSG :: Errno
eNONET :: Errno
eNOPROTOOPT :: Errno
eNOSPC :: Errno
eNOSR :: Errno
eNOSTR :: Errno
eNOSYS :: Errno
eNOTBLK :: Errno
eNOTCONN :: Errno
eNOTDIR :: Errno
eNOTEMPTY :: Errno
eNOTSOCK :: Errno

eNOTSUP :: Errno
eNOTTY :: Errno
eNXIO :: Errno
eOPNOTSUPP :: Errno
ePERM :: Errno
ePFNOSUPPORT :: Errno
ePIPE :: Errno
ePROCLIM :: Errno
ePROCUNAVAIL :: Errno
ePROGMISMATCH :: Errno
ePROGUNAVAIL :: Errno
ePROTO :: Errno
ePROTONOSUPPORT :: Errno
ePROTOTYPE :: Errno
eRANGE :: Errno
eREMCHG :: Errno
eREMOTE :: Errno
eROFS :: Errno
eRPCMISMATCH :: Errno
eRREMOTE :: Errno
eSHUTDOWN :: Errno
eSOCKTNOSUPPORT :: Errno
eSPIPE :: Errno
eSRCH :: Errno
eSRMNT :: Errno
eSTALE :: Errno
eTIME :: Errno
eTIMEDOUT :: Errno
eTOOMANYREFS :: Errno
eTXTBSY :: Errno
eUSERS :: Errno
eWOULDBLOCK :: Errno
eXDEV :: Errno

-- | Yield <a>True</a> if the given <a>Errno</a> value is valid on the
--   system. This implies that the <a>Eq</a> instance of <a>Errno</a> is
--   also system dependent as it is only defined for valid values of
--   <a>Errno</a>.
isValidErrno :: Errno -> Bool

-- | Lifted <a>getErrno</a>.
getErrno :: MonadIO m => m Errno

-- | Lifted <a>resetErrno</a>.
resetErrno :: MonadIO m => m ()

-- | Construct an <a>IOException</a> based on the given <a>Errno</a> value.
--   The optional information can be used to improve the accuracy of error
--   messages.
errnoToIOError :: String -> Errno -> Maybe Handle -> Maybe String -> IOError

-- | Lifted <a>throwErrno</a>.
throwErrno :: MonadIO m => String -> m a

-- | Unlifted <a>throwErrnoIf</a>.
throwErrnoIf :: MonadUnliftIO m => (a -> Bool) -> String -> m a -> m a

-- | Unlifted <a>throwErrnoIf_</a>.
throwErrnoIf_ :: MonadUnliftIO m => (a -> Bool) -> String -> m a -> m ()

-- | Unlifted <a>throwErrnoIfRetry</a>.
throwErrnoIfRetry :: MonadUnliftIO m => (a -> Bool) -> String -> m a -> m a

-- | Unlifted <a>throwErrnoIfRetry_</a>.
throwErrnoIfRetry_ :: MonadUnliftIO m => (a -> Bool) -> String -> m a -> m ()

-- | Unlifted <a>throwErrnoIfMinus1</a>.
throwErrnoIfMinus1 :: (MonadUnliftIO m, Eq a, Num a) => String -> m a -> m a

-- | Unlifted <a>throwErrnoIfMinus1_</a>
throwErrnoIfMinus1_ :: (MonadUnliftIO m, Eq a, Num a) => String -> m a -> m ()

-- | Unlifted <a>throwErrnoIfMinus1Retry</a>.
throwErrnoIfMinus1Retry :: (MonadUnliftIO m, Eq a, Num a) => String -> m a -> m a

-- | Unlifted <a>throwErrnoIfMinus1Retry_</a>.
throwErrnoIfMinus1Retry_ :: (MonadUnliftIO m, Eq a, Num a) => String -> m a -> m ()

-- | Unlifted <a>throwErrnoIfNull</a>.
throwErrnoIfNull :: MonadUnliftIO m => String -> m (Ptr a) -> m (Ptr a)

-- | Unlifted <a>throwErrnoIfNullRetry</a>.
throwErrnoIfNullRetry :: MonadUnliftIO m => String -> m (Ptr a) -> m (Ptr a)

-- | Unlifted <a>throwErrnoIfRetryMayBlock</a>.
throwErrnoIfRetryMayBlock :: MonadUnliftIO m => (a -> Bool) -> String -> m a -> m b -> m a

-- | Unlifted <a>throwErrnoIfRetryMayBlock_</a>.
throwErrnoIfRetryMayBlock_ :: MonadUnliftIO m => (a -> Bool) -> String -> m a -> m b -> m ()

-- | Unlifted <a>throwErrnoIfMinus1RetryMayBlock</a>.
throwErrnoIfMinus1RetryMayBlock :: (MonadUnliftIO m, Eq a, Num a) => String -> m a -> m b -> m a

-- | Unlifted <a>throwErrnoIfMinus1RetryMayBlock_</a>
throwErrnoIfMinus1RetryMayBlock_ :: (MonadUnliftIO m, Eq a, Num a) => String -> m a -> m b -> m ()

-- | Unlifted <a>throwErrnoIfNullRetryMayBlock</a>.
throwErrnoIfNullRetryMayBlock :: MonadUnliftIO m => String -> m (Ptr a) -> m b -> m (Ptr a)

-- | Lifted <a>throwErrnoPath</a>.
throwErrnoPath :: MonadIO m => String -> FilePath -> m a

-- | Unlifted <a>throwErrnoPathIf</a>.
throwErrnoPathIf :: MonadUnliftIO m => (a -> Bool) -> String -> FilePath -> m a -> m a

-- | Unlifted <a>throwErrnoPathIf_</a>.
throwErrnoPathIf_ :: MonadUnliftIO m => (a -> Bool) -> String -> FilePath -> m a -> m ()

-- | Unlifted <a>throwErrnoPathIfNull</a>.
throwErrnoPathIfNull :: MonadUnliftIO m => String -> FilePath -> m (Ptr a) -> m (Ptr a)

-- | Unlifted <a>throwErrnoPathIfMinus1</a>.
throwErrnoPathIfMinus1 :: (MonadUnliftIO m, Eq a, Num a) => String -> FilePath -> m a -> m a

-- | Unlifted <a>throwErrnoPathIfMinus1_</a>.
throwErrnoPathIfMinus1_ :: (MonadUnliftIO m, Eq a, Num a) => String -> FilePath -> m a -> m ()

-- | A value of type <tt><a>Ptr</a> a</tt> represents a pointer to an
--   object, or an array of objects, which may be marshalled to or from
--   Haskell values of type <tt>a</tt>.
--   
--   The type <tt>a</tt> will often be an instance of class <a>Storable</a>
--   which provides the marshalling operations. However this is not
--   essential, and you can provide your own operations to access the
--   pointer. For example you might write small foreign functions to get or
--   set the fields of a C <tt>struct</tt>.
data () => Ptr a

-- | The constant <a>nullPtr</a> contains a distinguished value of
--   <a>Ptr</a> that is not associated with a valid memory location.
nullPtr :: Ptr a

-- | The <a>castPtr</a> function casts a pointer from one type to another.
castPtr :: Ptr a -> Ptr b

-- | Advances the given address by the given offset in bytes.
plusPtr :: Ptr a -> Int -> Ptr b

-- | Given an arbitrary address and an alignment constraint,
--   <a>alignPtr</a> yields the next higher address that fulfills the
--   alignment constraint. An alignment constraint <tt>x</tt> is fulfilled
--   by any address divisible by <tt>x</tt>. This operation is idempotent.
alignPtr :: Ptr a -> Int -> Ptr a

-- | Computes the offset required to get from the second to the first
--   argument. We have
--   
--   <pre>
--   p2 == p1 `plusPtr` (p2 `minusPtr` p1)
--   </pre>
minusPtr :: Ptr a -> Ptr b -> Int

-- | A value of type <tt><a>FunPtr</a> a</tt> is a pointer to a function
--   callable from foreign code. The type <tt>a</tt> will normally be a
--   <i>foreign type</i>, a function type with zero or more arguments where
--   
--   <ul>
--   <li>the argument types are <i>marshallable foreign types</i>, i.e.
--   <a>Char</a>, <a>Int</a>, <a>Double</a>, <a>Float</a>, <a>Bool</a>,
--   <a>Int8</a>, <a>Int16</a>, <a>Int32</a>, <a>Int64</a>, <a>Word8</a>,
--   <a>Word16</a>, <a>Word32</a>, <a>Word64</a>, <tt><a>Ptr</a> a</tt>,
--   <tt><a>FunPtr</a> a</tt>, <tt><a>StablePtr</a> a</tt> or a renaming of
--   any of these using <tt>newtype</tt>.</li>
--   <li>the return type is either a marshallable foreign type or has the
--   form <tt><a>IO</a> t</tt> where <tt>t</tt> is a marshallable foreign
--   type or <tt>()</tt>.</li>
--   </ul>
--   
--   A value of type <tt><a>FunPtr</a> a</tt> may be a pointer to a foreign
--   function, either returned by another foreign function or imported with
--   a a static address import like
--   
--   <pre>
--   foreign import ccall "stdlib.h &amp;free"
--     p_free :: FunPtr (Ptr a -&gt; IO ())
--   </pre>
--   
--   or a pointer to a Haskell function created using a <i>wrapper</i> stub
--   declared to produce a <a>FunPtr</a> of the correct type. For example:
--   
--   <pre>
--   type Compare = Int -&gt; Int -&gt; Bool
--   foreign import ccall "wrapper"
--     mkCompare :: Compare -&gt; IO (FunPtr Compare)
--   </pre>
--   
--   Calls to wrapper stubs like <tt>mkCompare</tt> allocate storage, which
--   should be released with <a>freeHaskellFunPtr</a> when no longer
--   required.
--   
--   To convert <a>FunPtr</a> values to corresponding Haskell functions,
--   one can define a <i>dynamic</i> stub for the specific foreign type,
--   e.g.
--   
--   <pre>
--   type IntFunction = CInt -&gt; IO ()
--   foreign import ccall "dynamic"
--     mkFun :: FunPtr IntFunction -&gt; IntFunction
--   </pre>
data () => FunPtr a

-- | The constant <a>nullFunPtr</a> contains a distinguished value of
--   <a>FunPtr</a> that is not associated with a valid memory location.
nullFunPtr :: FunPtr a

-- | Casts a <a>FunPtr</a> to a <a>FunPtr</a> of a different type.
castFunPtr :: FunPtr a -> FunPtr b

-- | Casts a <a>FunPtr</a> to a <a>Ptr</a>.
--   
--   <i>Note:</i> this is valid only on architectures where data and
--   function pointers range over the same set of addresses, and should
--   only be used for bindings to external libraries whose interface
--   already relies on this assumption.
castFunPtrToPtr :: FunPtr a -> Ptr b

-- | Casts a <a>Ptr</a> to a <a>FunPtr</a>.
--   
--   <i>Note:</i> this is valid only on architectures where data and
--   function pointers range over the same set of addresses, and should
--   only be used for bindings to external libraries whose interface
--   already relies on this assumption.
castPtrToFunPtr :: Ptr a -> FunPtr b

-- | Lifted <a>freeHaskellFunPtr</a>.
freeHaskellFunPtr :: MonadIO m => FunPtr a -> m ()

-- | A signed integral type that can be losslessly converted to and from
--   <tt>Ptr</tt>. This type is also compatible with the C99 type
--   <tt>intptr_t</tt>, and can be marshalled to and from that type safely.
newtype () => IntPtr
IntPtr :: Int -> IntPtr

-- | casts a <tt>Ptr</tt> to an <tt>IntPtr</tt>
ptrToIntPtr :: Ptr a -> IntPtr

-- | casts an <tt>IntPtr</tt> to a <tt>Ptr</tt>
intPtrToPtr :: IntPtr -> Ptr a

-- | An unsigned integral type that can be losslessly converted to and from
--   <tt>Ptr</tt>. This type is also compatible with the C99 type
--   <tt>uintptr_t</tt>, and can be marshalled to and from that type
--   safely.
newtype () => WordPtr
WordPtr :: Word -> WordPtr

-- | casts a <tt>Ptr</tt> to a <tt>WordPtr</tt>
ptrToWordPtr :: Ptr a -> WordPtr

-- | casts a <tt>WordPtr</tt> to a <tt>Ptr</tt>
wordPtrToPtr :: WordPtr -> Ptr a

-- | The type <a>ForeignPtr</a> represents references to objects that are
--   maintained in a foreign language, i.e., that are not part of the data
--   structures usually managed by the Haskell storage manager. The
--   essential difference between <a>ForeignPtr</a>s and vanilla memory
--   references of type <tt>Ptr a</tt> is that the former may be associated
--   with <i>finalizers</i>. A finalizer is a routine that is invoked when
--   the Haskell storage manager detects that - within the Haskell heap and
--   stack - there are no more references left that are pointing to the
--   <a>ForeignPtr</a>. Typically, the finalizer will, then, invoke
--   routines in the foreign language that free the resources bound by the
--   foreign object.
--   
--   The <a>ForeignPtr</a> is parameterised in the same way as <a>Ptr</a>.
--   The type argument of <a>ForeignPtr</a> should normally be an instance
--   of class <a>Storable</a>.
data () => ForeignPtr a

-- | A finalizer is represented as a pointer to a foreign function that, at
--   finalisation time, gets as an argument a plain pointer variant of the
--   foreign pointer that the finalizer is associated with.
--   
--   Note that the foreign function <i>must</i> use the <tt>ccall</tt>
--   calling convention.
type FinalizerPtr a = FunPtr Ptr a -> IO ()
type FinalizerEnvPtr env a = FunPtr Ptr env -> Ptr a -> IO ()

-- | Lifted <a>newForeignPtr</a>.
newForeignPtr :: MonadIO m => FinalizerPtr a -> Ptr a -> m (ForeignPtr a)

-- | Lifted <a>newForeignPtr_</a>.
newForeignPtr_ :: MonadIO m => Ptr a -> m (ForeignPtr a)

-- | Lifted <a>addForeignPtrFinalizer</a>.
addForeignPtrFinalizer :: MonadIO m => FinalizerPtr a -> ForeignPtr a -> m ()

-- | Lifted <a>newForeignPtrEnv</a>.
newForeignPtrEnv :: MonadIO m => FinalizerEnvPtr env a -> Ptr env -> Ptr a -> m (ForeignPtr a)

-- | Lifted <a>addForeignPtrFinalizerEnv</a>.
addForeignPtrFinalizerEnv :: MonadIO m => FinalizerEnvPtr env a -> Ptr env -> ForeignPtr a -> m ()

-- | Unlifted <a>withForeignPtr</a>.
withForeignPtr :: MonadUnliftIO m => ForeignPtr a -> (Ptr a -> m b) -> m b

-- | Lifted <a>finalizeForeignPtr</a>.
finalizeForeignPtr :: MonadIO m => ForeignPtr a -> m ()

-- | Lifted <a>touchForeignPtr</a>.
touchForeignPtr :: MonadIO m => ForeignPtr a -> m ()

-- | This function casts a <a>ForeignPtr</a> parameterised by one type into
--   another type.
castForeignPtr :: ForeignPtr a -> ForeignPtr b

-- | Advances the given address by the given offset in bytes.
--   
--   The new <a>ForeignPtr</a> shares the finalizer of the original,
--   equivalent from a finalization standpoint to just creating another
--   reference to the original. That is, the finalizer will not be called
--   before the new <a>ForeignPtr</a> is unreachable, nor will it be called
--   an additional time due to this call, and the finalizer will be called
--   with the same address that it would have had this call not happened,
--   *not* the new address.
plusForeignPtr :: ForeignPtr a -> Int -> ForeignPtr b

-- | Lifted <a>mallocForeignPtr</a>.
mallocForeignPtr :: (MonadIO m, Storable a) => m (ForeignPtr a)

-- | Lifted <a>mallocForeignPtrBytes</a>.
mallocForeignPtrBytes :: MonadIO m => Int -> m (ForeignPtr a)

-- | Lifted <a>mallocForeignPtrArray</a>.
mallocForeignPtrArray :: (MonadIO m, Storable a) => Int -> m (ForeignPtr a)

-- | Lifted <a>mallocForeignPtrArray0</a>.
mallocForeignPtrArray0 :: (MonadIO m, Storable a) => Int -> m (ForeignPtr a)

-- | Unlifted <a>newForeignPtr</a>.
newGHCForeignPtr :: MonadUnliftIO m => Ptr a -> m () -> m (ForeignPtr a)

-- | Unlifted <a>addForeignPtrFinalizer</a>.
addGHCForeignPtrFinalizer :: MonadUnliftIO m => ForeignPtr a -> m () -> m ()

-- | This function extracts the pointer component of a foreign pointer.
--   This is a potentially dangerous operations, as if the argument to
--   <a>unsafeForeignPtrToPtr</a> is the last usage occurrence of the given
--   foreign pointer, then its finalizer(s) will be run, which potentially
--   invalidates the plain pointer just obtained. Hence,
--   <a>touchForeignPtr</a> must be used wherever it has to be guaranteed
--   that the pointer lives on - i.e., has another usage occurrence.
--   
--   To avoid subtle coding errors, hand written marshalling code should
--   preferably use <a>withForeignPtr</a> rather than combinations of
--   <a>unsafeForeignPtrToPtr</a> and <a>touchForeignPtr</a>. However, the
--   latter routines are occasionally preferred in tool generated
--   marshalling code.
unsafeForeignPtrToPtr :: ForeignPtr a -> Ptr a

-- | A <i>stable pointer</i> is a reference to a Haskell expression that is
--   guaranteed not to be affected by garbage collection, i.e., it will
--   neither be deallocated nor will the value of the stable pointer itself
--   change during garbage collection (ordinary references may be relocated
--   during garbage collection). Consequently, stable pointers can be
--   passed to foreign code, which can treat it as an opaque reference to a
--   Haskell value.
--   
--   The <tt>StablePtr</tt> 0 is reserved for representing NULL in foreign
--   code.
--   
--   A value of type <tt>StablePtr a</tt> is a stable pointer to a Haskell
--   expression of type <tt>a</tt>.
data () => StablePtr a

-- | Lifted <a>newStablePtr</a>.
newStablePtr :: MonadIO m => a -> m (StablePtr a)

-- | Lifted <a>deRefStablePtr</a>.
deRefStablePtr :: MonadIO m => StablePtr a -> m a

-- | Lifted <a>freeStablePtr</a>.
freeStablePtr :: MonadIO m => StablePtr a -> m ()

-- | Coerce a stable pointer to an address. No guarantees are made about
--   the resulting value, except that the original stable pointer can be
--   recovered by <a>castPtrToStablePtr</a>. In particular, the address
--   might not refer to an accessible memory location and any attempt to
--   pass it to the member functions of the class <a>Storable</a> leads to
--   undefined behaviour.
castStablePtrToPtr :: StablePtr a -> Ptr ()

-- | The inverse of <a>castStablePtrToPtr</a>, i.e., we have the identity
--   
--   <pre>
--   sp == castPtrToStablePtr (castStablePtrToPtr sp)
--   </pre>
--   
--   for any stable pointer <tt>sp</tt> on which <a>freeStablePtr</a> has
--   not been executed yet. Moreover, <a>castPtrToStablePtr</a> may only be
--   applied to pointers that have been produced by
--   <a>castStablePtrToPtr</a>.
castPtrToStablePtr :: Ptr () -> StablePtr a

-- | The member functions of this class facilitate writing values of
--   primitive types to raw memory (which may have been allocated with the
--   above mentioned routines) and reading values from blocks of raw
--   memory. The class, furthermore, includes support for computing the
--   storage requirements and alignment restrictions of storable types.
--   
--   Memory addresses are represented as values of type <tt><a>Ptr</a>
--   a</tt>, for some <tt>a</tt> which is an instance of class
--   <a>Storable</a>. The type argument to <a>Ptr</a> helps provide some
--   valuable type safety in FFI code (you can't mix pointers of different
--   types without an explicit cast), while helping the Haskell type system
--   figure out which marshalling method is needed for a given pointer.
--   
--   All marshalling between Haskell and a foreign language ultimately
--   boils down to translating Haskell data structures into the binary
--   representation of a corresponding data structure of the foreign
--   language and vice versa. To code this marshalling in Haskell, it is
--   necessary to manipulate primitive data types stored in unstructured
--   memory blocks. The class <a>Storable</a> facilitates this manipulation
--   on all types for which it is instantiated, which are the standard
--   basic types of Haskell, the fixed size <tt>Int</tt> types
--   (<a>Int8</a>, <a>Int16</a>, <a>Int32</a>, <a>Int64</a>), the fixed
--   size <tt>Word</tt> types (<a>Word8</a>, <a>Word16</a>, <a>Word32</a>,
--   <a>Word64</a>), <a>StablePtr</a>, all types from
--   <a>Foreign.C.Types</a>, as well as <a>Ptr</a>.
class () => Storable a

-- | Computes the storage requirements (in bytes) of the argument. The
--   value of the argument is not used.
sizeOf :: Storable a => a -> Int

-- | Computes the alignment constraint of the argument. An alignment
--   constraint <tt>x</tt> is fulfilled by any address divisible by
--   <tt>x</tt>. The alignment must be a power of two if this instance is
--   to be used with <tt>alloca</tt> or <tt>allocaArray</tt>. The value of
--   the argument is not used.
alignment :: Storable a => a -> Int

-- | Read a value from a memory area regarded as an array of values of the
--   same kind. The first argument specifies the start address of the array
--   and the second the index into the array (the first element of the
--   array has index <tt>0</tt>). The following equality holds,
--   
--   <pre>
--   peekElemOff addr idx = IOExts.fixIO $ \result -&gt;
--     peek (addr `plusPtr` (idx * sizeOf result))
--   </pre>
--   
--   Note that this is only a specification, not necessarily the concrete
--   implementation of the function.
peekElemOff :: Storable a => Ptr a -> Int -> IO a

-- | Write a value to a memory area regarded as an array of values of the
--   same kind. The following equality holds:
--   
--   <pre>
--   pokeElemOff addr idx x = 
--     poke (addr `plusPtr` (idx * sizeOf x)) x
--   </pre>
pokeElemOff :: Storable a => Ptr a -> Int -> a -> IO ()

-- | Read a value from a memory location given by a base address and
--   offset. The following equality holds:
--   
--   <pre>
--   peekByteOff addr off = peek (addr `plusPtr` off)
--   </pre>
peekByteOff :: Storable a => Ptr b -> Int -> IO a

-- | Write a value to a memory location given by a base address and offset.
--   The following equality holds:
--   
--   <pre>
--   pokeByteOff addr off x = poke (addr `plusPtr` off) x
--   </pre>
pokeByteOff :: Storable a => Ptr b -> Int -> a -> IO ()

-- | Read a value from the given memory location.
--   
--   Note that the peek and poke functions might require properly aligned
--   addresses to function correctly. This is architecture dependent; thus,
--   portable code should ensure that when peeking or poking values of some
--   type <tt>a</tt>, the alignment constraint for <tt>a</tt>, as given by
--   the function <a>alignment</a> is fulfilled.
peek :: Storable a => Ptr a -> IO a

-- | Write the given value to the given memory location. Alignment
--   restrictions might apply; see <a>peek</a>.
poke :: Storable a => Ptr a -> a -> IO ()

-- | Unlifted <a>alloca</a>.
alloca :: (MonadUnliftIO m, Storable a) => (Ptr a -> m b) -> m b

-- | Unlifted <a>allocaBytes</a>.
allocaBytes :: MonadUnliftIO m => Int -> (Ptr a -> m b) -> m b

-- | Unlifted <a>allocaBytesAligned</a>.
allocaBytesAligned :: MonadUnliftIO m => Int -> Int -> (Ptr a -> m b) -> m b

-- | Lifted <a>malloc</a>.
malloc :: (MonadIO m, Storable a) => m (Ptr a)

-- | Lifted <a>mallocBytes</a>.
mallocBytes :: MonadIO m => Int -> m (Ptr a)

-- | Lifted <a>calloc</a>.
calloc :: (MonadIO m, Storable a) => m (Ptr a)

-- | Lifted <a>callocBytes</a>.
callocBytes :: MonadIO m => Int -> m (Ptr a)

-- | Lifted <a>realloc</a>.
realloc :: (MonadIO m, Storable b) => Ptr a -> m (Ptr b)

-- | Lifted <a>reallocBytes</a>.
reallocBytes :: MonadIO m => Ptr a -> Int -> m (Ptr a)

-- | Lifted <a>free</a>.
free :: MonadIO m => Ptr a -> m ()

-- | A pointer to a foreign function equivalent to <a>free</a>, which may
--   be used as a finalizer (cf <a>ForeignPtr</a>) for storage allocated
--   with <a>malloc</a>, <a>mallocBytes</a>, <a>realloc</a> or
--   <a>reallocBytes</a>.
finalizerFree :: FinalizerPtr a

-- | Lifted <a>mallocArray</a>.
mallocArray :: (MonadIO m, Storable a) => Int -> m (Ptr a)

-- | Lifted <a>mallocArray0</a>.
mallocArray0 :: (MonadIO m, Storable a) => Int -> m (Ptr a)

-- | Unlifted <a>allocaArray</a>.
allocaArray :: (MonadUnliftIO m, Storable a) => Int -> (Ptr a -> m b) -> m b

-- | Unlifted <a>allocaArray0</a>.
allocaArray0 :: (MonadUnliftIO m, Storable a) => Int -> (Ptr a -> m b) -> m b

-- | Lifted <a>reallocArray</a>.
reallocArray :: (MonadIO m, Storable a) => Ptr a -> Int -> m (Ptr a)

-- | Lifted <a>reallocArray0</a>.
reallocArray0 :: (MonadIO m, Storable a) => Ptr a -> Int -> m (Ptr a)

-- | Lifted <a>callocArray</a>.
callocArray :: (MonadIO m, Storable a) => Int -> m (Ptr a)

-- | Lifted <a>callocArray0</a>.
callocArray0 :: (MonadIO m, Storable a) => Int -> m (Ptr a)

-- | Lifted <a>peekArray</a>.
peekArray :: (MonadIO m, Storable a) => Int -> Ptr a -> m [a]

-- | Lifted <a>peekArray0</a>.
peekArray0 :: (MonadIO m, Storable a, Eq a) => a -> Ptr a -> m [a]

-- | Lifted <a>pokeArray</a>.
pokeArray :: (MonadIO m, Storable a) => Ptr a -> [a] -> m ()

-- | Lifted <a>pokeArray0</a>.
pokeArray0 :: (MonadIO m, Storable a) => a -> Ptr a -> [a] -> m ()

-- | Lifted <a>newArray</a>.
newArray :: (MonadIO m, Storable a) => [a] -> m (Ptr a)

-- | Lifted <a>newArray0</a>
newArray0 :: (MonadIO m, Storable a) => a -> [a] -> m (Ptr a)

-- | Unlifted <a>withArray</a>.
withArray :: (MonadUnliftIO m, Storable a) => [a] -> (Ptr a -> m b) -> m b

-- | Unlifted <a>withArray0</a>.
withArray0 :: (MonadUnliftIO m, Storable a) => a -> [a] -> (Ptr a -> m b) -> m b

-- | Unlifted <a>withArrayLen</a>.
withArrayLen :: (MonadUnliftIO m, Storable a) => [a] -> (Int -> Ptr a -> m b) -> m b

-- | Unlifted <a>withArrayLen0</a>.
withArrayLen0 :: (MonadUnliftIO m, Storable a) => a -> [a] -> (Int -> Ptr a -> m b) -> m b

-- | Lifted <a>copyArray</a>.
copyArray :: (MonadIO m, Storable a) => Ptr a -> Ptr a -> Int -> m ()

-- | Lifted <a>moveArray</a>.
moveArray :: (MonadIO m, Storable a) => Ptr a -> Ptr a -> Int -> m ()

-- | Lifted <a>lengthArray0</a>.
lengthArray0 :: (MonadIO m, Storable a, Eq a) => a -> Ptr a -> m Int

-- | Advance a pointer into an array by the given number of elements
advancePtr :: Storable a => Ptr a -> Int -> Ptr a

-- | Unlifted <a>throwIf</a>.
throwIf :: MonadUnliftIO m => (a -> Bool) -> (a -> String) -> m a -> m a

-- | Unlifted <a>throwIf_</a>.
throwIf_ :: MonadUnliftIO m => (a -> Bool) -> (a -> String) -> m a -> m ()

-- | Unlifted <a>throwIfNeg</a>.
throwIfNeg :: (MonadUnliftIO m, Ord a, Num a) => (a -> String) -> m a -> m a

-- | Unlifted <a>throwIfNeg_</a>.
throwIfNeg_ :: (MonadUnliftIO m, Ord a, Num a) => (a -> String) -> m a -> m ()

-- | Unlifted <a>throwIfNull</a>.
throwIfNull :: MonadUnliftIO m => String -> m (Ptr a) -> m (Ptr a)

-- | A memory pool.
data () => Pool

-- | Lifted <a>newPool</a>.
newPool :: MonadIO m => m Pool

-- | Lifted <a>freePool</a>.
freePool :: MonadIO m => Pool -> m ()

-- | Unlifted <a>withPool</a>.
withPool :: MonadUnliftIO m => (Pool -> m b) -> m b

-- | Lifted <a>pooledMalloc</a>.
pooledMalloc :: (MonadIO m, Storable a) => Pool -> m (Ptr a)

-- | Lifted <a>pooledMallocBytes</a>.
pooledMallocBytes :: MonadIO m => Pool -> Int -> m (Ptr a)

-- | Lifted <a>pooledRealloc</a>.
pooledRealloc :: (MonadIO m, Storable a) => Pool -> Ptr a -> m (Ptr a)

-- | Lifted <a>pooledReallocBytes</a>.
pooledReallocBytes :: MonadIO m => Pool -> Ptr a -> Int -> m (Ptr a)

-- | Lifted <a>pooledMallocArray</a>.
pooledMallocArray :: (MonadIO m, Storable a) => Pool -> Int -> m (Ptr a)

-- | Lifted <a>pooledMallocArray0</a>.
pooledMallocArray0 :: (MonadIO m, Storable a) => Pool -> Int -> m (Ptr a)

-- | Lifted <a>pooledReallocArray</a>.
pooledReallocArray :: (MonadIO m, Storable a) => Pool -> Ptr a -> Int -> m (Ptr a)

-- | Lifted <a>pooledReallocArray0</a>.
pooledReallocArray0 :: (MonadIO m, Storable a) => Pool -> Ptr a -> Int -> m (Ptr a)

-- | Lifted <a>pooledNew</a>.
pooledNew :: (MonadIO m, Storable a) => Pool -> a -> m (Ptr a)

-- | Lifted <a>pooledNewArray</a>.
pooledNewArray :: (MonadIO m, Storable a) => Pool -> [a] -> m (Ptr a)

-- | Lifted <a>pooledNewArray0</a>.
pooledNewArray0 :: (MonadIO m, Storable a) => Pool -> a -> [a] -> m (Ptr a)

-- | Unlifted <a>with</a>.
with :: (MonadUnliftIO m, Storable a) => a -> (Ptr a -> m b) -> m b

-- | Lifted <a>new</a>.
new :: (MonadIO m, Storable a) => a -> m (Ptr a)

-- | Convert a Haskell <a>Bool</a> to its numeric representation
fromBool :: Num a => Bool -> a

-- | Convert a Boolean in numeric representation to a Haskell value
toBool :: (Eq a, Num a) => a -> Bool

-- | Lifted <a>maybeNew</a>.
maybeNew :: MonadIO m => (a -> m (Ptr b)) -> Maybe a -> m (Ptr b)

-- | Lifted <a>maybeWith</a>.
maybeWith :: MonadIO m => (a -> (Ptr b -> m c) -> m c) -> Maybe a -> (Ptr b -> m c) -> m c

-- | Unlifted <a>maybePeek</a>.
maybePeek :: MonadUnliftIO m => (Ptr a -> m b) -> Ptr a -> m (Maybe b)

-- | Replicates a <tt>withXXX</tt> combinator over a list of objects,
--   yielding a list of marshalled objects
withMany :: (a -> (b -> res) -> res) -> [a] -> ([b] -> res) -> res

-- | Lifted <a>copyBytes</a>.
copyBytes :: MonadIO m => Ptr a -> Ptr a -> Int -> m ()

-- | Lifted <a>moveBytes</a>.
moveBytes :: MonadIO m => Ptr a -> Ptr a -> Int -> m ()

-- | Lifted <a>fillBytes</a>.
fillBytes :: MonadIO m => Ptr a -> Word8 -> Int -> m ()


-- | Unlifted <a>System.IO</a>.
module UnliftIO.IO

-- | See <a>openFile</a>
data () => IOMode
ReadMode :: IOMode
WriteMode :: IOMode
AppendMode :: IOMode
ReadWriteMode :: IOMode

-- | Haskell defines operations to read and write characters from and to
--   files, represented by values of type <tt>Handle</tt>. Each value of
--   this type is a <i>handle</i>: a record used by the Haskell run-time
--   system to <i>manage</i> I/O with file system objects. A handle has at
--   least the following properties:
--   
--   <ul>
--   <li>whether it manages input or output or both;</li>
--   <li>whether it is <i>open</i>, <i>closed</i> or
--   <i>semi-closed</i>;</li>
--   <li>whether the object is seekable;</li>
--   <li>whether buffering is disabled, or enabled on a line or block
--   basis;</li>
--   <li>a buffer (whose length may be zero).</li>
--   </ul>
--   
--   Most handles will also have a current I/O position indicating where
--   the next input or output operation will occur. A handle is
--   <i>readable</i> if it manages only input or both input and output;
--   likewise, it is <i>writable</i> if it manages only output or both
--   input and output. A handle is <i>open</i> when first allocated. Once
--   it is closed it can no longer be used for either input or output,
--   though an implementation cannot re-use its storage while references
--   remain to it. Handles are in the <a>Show</a> and <a>Eq</a> classes.
--   The string produced by showing a handle is system dependent; it should
--   include enough information to identify the handle for debugging. A
--   handle is equal according to <a>==</a> only to itself; no attempt is
--   made to compare the internal state of different handles for equality.
data () => Handle
stdin :: Handle
stdout :: Handle
stderr :: Handle

-- | Unlifted version of <a>withFile</a>.
withFile :: MonadUnliftIO m => FilePath -> IOMode -> (Handle -> m a) -> m a

-- | Unlifted version of <a>withBinaryFile</a>.
withBinaryFile :: MonadUnliftIO m => FilePath -> IOMode -> (Handle -> m a) -> m a

-- | Lifted version of <a>openFile</a>
openFile :: MonadIO m => FilePath -> IOMode -> m Handle

-- | Lifted version of <a>hClose</a>
hClose :: MonadIO m => Handle -> m ()

-- | Lifted version of <a>hFlush</a>
hFlush :: MonadIO m => Handle -> m ()

-- | Lifted version of <a>hFileSize</a>
hFileSize :: MonadIO m => Handle -> m Integer

-- | Lifted version of <a>hSetFileSize</a>
hSetFileSize :: MonadIO m => Handle -> Integer -> m ()

-- | Lifted version of <a>hIsEOF</a>
hIsEOF :: MonadIO m => Handle -> m Bool

-- | Three kinds of buffering are supported: line-buffering,
--   block-buffering or no-buffering. These modes have the following
--   effects. For output, items are written out, or <i>flushed</i>, from
--   the internal buffer according to the buffer mode:
--   
--   <ul>
--   <li><i>line-buffering</i>: the entire output buffer is flushed
--   whenever a newline is output, the buffer overflows, a <a>hFlush</a> is
--   issued, or the handle is closed.</li>
--   <li><i>block-buffering</i>: the entire buffer is written out whenever
--   it overflows, a <a>hFlush</a> is issued, or the handle is closed.</li>
--   <li><i>no-buffering</i>: output is written immediately, and never
--   stored in the buffer.</li>
--   </ul>
--   
--   An implementation is free to flush the buffer more frequently, but not
--   less frequently, than specified above. The output buffer is emptied as
--   soon as it has been written out.
--   
--   Similarly, input occurs according to the buffer mode for the handle:
--   
--   <ul>
--   <li><i>line-buffering</i>: when the buffer for the handle is not
--   empty, the next item is obtained from the buffer; otherwise, when the
--   buffer is empty, characters up to and including the next newline
--   character are read into the buffer. No characters are available until
--   the newline character is available or the buffer is full.</li>
--   <li><i>block-buffering</i>: when the buffer for the handle becomes
--   empty, the next block of data is read into the buffer.</li>
--   <li><i>no-buffering</i>: the next input item is read and returned. The
--   <a>hLookAhead</a> operation implies that even a no-buffered handle may
--   require a one-character buffer.</li>
--   </ul>
--   
--   The default buffering mode when a handle is opened is
--   implementation-dependent and may depend on the file system object
--   which is attached to that handle. For most implementations, physical
--   files will normally be block-buffered and terminals will normally be
--   line-buffered.
data () => BufferMode

-- | buffering is disabled if possible.
NoBuffering :: BufferMode

-- | line-buffering should be enabled if possible.
LineBuffering :: BufferMode

-- | block-buffering should be enabled if possible. The size of the buffer
--   is <tt>n</tt> items if the argument is <a>Just</a> <tt>n</tt> and is
--   otherwise implementation-dependent.
BlockBuffering :: Maybe Int -> BufferMode

-- | Lifted version of <a>hSetBuffering</a>
hSetBuffering :: MonadIO m => Handle -> BufferMode -> m ()

-- | Lifted version of <a>hGetBuffering</a>
hGetBuffering :: MonadIO m => Handle -> m BufferMode

-- | Lifted version of <a>hSeek</a>
hSeek :: MonadIO m => Handle -> SeekMode -> Integer -> m ()

-- | A mode that determines the effect of <a>hSeek</a> <tt>hdl mode i</tt>.
data () => SeekMode

-- | the position of <tt>hdl</tt> is set to <tt>i</tt>.
AbsoluteSeek :: SeekMode

-- | the position of <tt>hdl</tt> is set to offset <tt>i</tt> from the
--   current position.
RelativeSeek :: SeekMode

-- | the position of <tt>hdl</tt> is set to offset <tt>i</tt> from the end
--   of the file.
SeekFromEnd :: SeekMode

-- | Lifted version of <a>hTell</a>
hTell :: MonadIO m => Handle -> m Integer

-- | Lifted version of <a>hIsOpen</a>
hIsOpen :: MonadIO m => Handle -> m Bool

-- | Lifted version of <a>hIsClosed</a>
hIsClosed :: MonadIO m => Handle -> m Bool

-- | Lifted version of <a>hIsReadable</a>
hIsReadable :: MonadIO m => Handle -> m Bool

-- | Lifted version of <a>hIsWritable</a>
hIsWritable :: MonadIO m => Handle -> m Bool

-- | Lifted version of <a>hIsSeekable</a>
hIsSeekable :: MonadIO m => Handle -> m Bool

-- | Lifted version of <a>hIsTerminalDevice</a>
hIsTerminalDevice :: MonadIO m => Handle -> m Bool

-- | Lifted version of <a>hSetEcho</a>
hSetEcho :: MonadIO m => Handle -> Bool -> m ()

-- | Lifted version of <a>hGetEcho</a>
hGetEcho :: MonadIO m => Handle -> m Bool

-- | Lifted version of <a>hWaitForInput</a>
hWaitForInput :: MonadIO m => Handle -> Int -> m Bool

-- | Lifted version of <a>hReady</a>
hReady :: MonadIO m => Handle -> m Bool

-- | Get the number of seconds which have passed since an arbitrary
--   starting time, useful for calculating runtime in a program.
getMonotonicTime :: MonadIO m => m Double


-- | Unlifted <a>Data.IORef</a>.
module UnliftIO.IORef

-- | A mutable variable in the <a>IO</a> monad.
--   
--   <pre>
--   &gt;&gt;&gt; import Data.IORef
--   
--   &gt;&gt;&gt; r &lt;- newIORef 0
--   
--   &gt;&gt;&gt; readIORef r
--   0
--   
--   &gt;&gt;&gt; writeIORef r 1
--   
--   &gt;&gt;&gt; readIORef r
--   1
--   
--   &gt;&gt;&gt; atomicWriteIORef r 2
--   
--   &gt;&gt;&gt; readIORef r
--   2
--   
--   &gt;&gt;&gt; modifyIORef' r (+ 1)
--   
--   &gt;&gt;&gt; readIORef r
--   3
--   
--   &gt;&gt;&gt; atomicModifyIORef' r (\a -&gt; (a + 1, ()))
--   
--   &gt;&gt;&gt; readIORef r
--   4
--   </pre>
--   
--   See also <a>STRef</a> and <a>MVar</a>.
data () => IORef a

-- | Lifted <a>newIORef</a>.
newIORef :: MonadIO m => a -> m (IORef a)

-- | Lifted <a>readIORef</a>.
readIORef :: MonadIO m => IORef a -> m a

-- | Lifted <a>writeIORef</a>.
writeIORef :: MonadIO m => IORef a -> a -> m ()

-- | Lifted <a>modifyIORef</a>.
modifyIORef :: MonadIO m => IORef a -> (a -> a) -> m ()

-- | Lifted <a>modifyIORef'</a>.
modifyIORef' :: MonadIO m => IORef a -> (a -> a) -> m ()

-- | Lifted <a>atomicModifyIORef</a>.
atomicModifyIORef :: MonadIO m => IORef a -> (a -> (a, b)) -> m b

-- | Lifted <a>atomicModifyIORef'</a>.
atomicModifyIORef' :: MonadIO m => IORef a -> (a -> (a, b)) -> m b

-- | Lifted <a>atomicWriteIORef</a>.
atomicWriteIORef :: MonadIO m => IORef a -> a -> m ()

-- | Unlifted <a>mkWeakIORef</a>.
mkWeakIORef :: MonadUnliftIO m => IORef a -> m () -> m (Weak (IORef a))

module UnliftIO.Internals.Async

-- | Unlifted <a>async</a>.
async :: MonadUnliftIO m => m a -> m (Async a)

-- | Unlifted <a>asyncBound</a>.
asyncBound :: MonadUnliftIO m => m a -> m (Async a)

-- | Unlifted <a>asyncOn</a>.
asyncOn :: MonadUnliftIO m => Int -> m a -> m (Async a)

-- | Unlifted <a>asyncWithUnmask</a>.
asyncWithUnmask :: MonadUnliftIO m => ((forall b. m b -> m b) -> m a) -> m (Async a)

-- | Unlifted <a>asyncOnWithUnmask</a>.
asyncOnWithUnmask :: MonadUnliftIO m => Int -> ((forall b. m b -> m b) -> m a) -> m (Async a)

-- | Unlifted <a>withAsync</a>.
withAsync :: MonadUnliftIO m => m a -> (Async a -> m b) -> m b

-- | Unlifted <a>withAsyncBound</a>.
withAsyncBound :: MonadUnliftIO m => m a -> (Async a -> m b) -> m b

-- | Unlifted <a>withAsyncOn</a>.
withAsyncOn :: MonadUnliftIO m => Int -> m a -> (Async a -> m b) -> m b

-- | Unlifted <a>withAsyncWithUnmask</a>.
withAsyncWithUnmask :: MonadUnliftIO m => ((forall c. m c -> m c) -> m a) -> (Async a -> m b) -> m b

-- | Unlifted <a>withAsyncOnWithMask</a>.
withAsyncOnWithUnmask :: MonadUnliftIO m => Int -> ((forall c. m c -> m c) -> m a) -> (Async a -> m b) -> m b

-- | Lifted <a>wait</a>.
wait :: MonadIO m => Async a -> m a

-- | Lifted <a>poll</a>.
poll :: MonadIO m => Async a -> m (Maybe (Either SomeException a))

-- | Lifted <a>waitCatch</a>.
waitCatch :: MonadIO m => Async a -> m (Either SomeException a)

-- | Lifted <a>cancel</a>.
cancel :: MonadIO m => Async a -> m ()

-- | Lifted <a>uninterruptibleCancel</a>.
uninterruptibleCancel :: MonadIO m => Async a -> m ()

-- | Lifted <a>cancelWith</a>. Additionally uses <a>toAsyncException</a> to
--   ensure async exception safety.
cancelWith :: (Exception e, MonadIO m) => Async a -> e -> m ()

-- | Lifted <a>waitAny</a>.
waitAny :: MonadIO m => [Async a] -> m (Async a, a)

-- | Lifted <a>waitAnyCatch</a>.
waitAnyCatch :: MonadIO m => [Async a] -> m (Async a, Either SomeException a)

-- | Lifted <a>waitAnyCancel</a>.
waitAnyCancel :: MonadIO m => [Async a] -> m (Async a, a)

-- | Lifted <a>waitAnyCatchCancel</a>.
waitAnyCatchCancel :: MonadIO m => [Async a] -> m (Async a, Either SomeException a)

-- | Lifted <a>waitEither</a>.
waitEither :: MonadIO m => Async a -> Async b -> m (Either a b)

-- | Lifted <a>waitEitherCatch</a>.
waitEitherCatch :: MonadIO m => Async a -> Async b -> m (Either (Either SomeException a) (Either SomeException b))

-- | Lifted <a>waitEitherCancel</a>.
waitEitherCancel :: MonadIO m => Async a -> Async b -> m (Either a b)

-- | Lifted <a>waitEitherCatchCancel</a>.
waitEitherCatchCancel :: MonadIO m => Async a -> Async b -> m (Either (Either SomeException a) (Either SomeException b))

-- | Lifted <a>waitEither_</a>.
waitEither_ :: MonadIO m => Async a -> Async b -> m ()

-- | Lifted <a>waitBoth</a>.
waitBoth :: MonadIO m => Async a -> Async b -> m (a, b)

-- | Lifted <a>link</a>.
link :: MonadIO m => Async a -> m ()

-- | Lifted <a>link2</a>.
link2 :: MonadIO m => Async a -> Async b -> m ()

-- | Unlifted <a>race</a>.
race :: MonadUnliftIO m => m a -> m b -> m (Either a b)

-- | Unlifted <a>race_</a>.
race_ :: MonadUnliftIO m => m a -> m b -> m ()

-- | Unlifted <a>concurrently</a>.
concurrently :: MonadUnliftIO m => m a -> m b -> m (a, b)

-- | Unlifted <a>concurrently_</a>.
concurrently_ :: MonadUnliftIO m => m a -> m b -> m ()

-- | Unlifted <a>Concurrently</a>.
newtype Concurrently m a
Concurrently :: m a -> Concurrently m a
[runConcurrently] :: Concurrently m a -> m a

-- | Similar to <a>mapConcurrently</a> but with arguments flipped
forConcurrently :: MonadUnliftIO m => Traversable t => t a -> (a -> m b) -> m (t b)

-- | Similar to <a>mapConcurrently_</a> but with arguments flipped
forConcurrently_ :: MonadUnliftIO m => Foldable f => f a -> (a -> m b) -> m ()

-- | Unlifted <a>replicateConcurrently</a>.
replicateConcurrently :: MonadUnliftIO f => Int -> f a -> f [a]

-- | Unlifted <a>replicateConcurrently_</a>.
replicateConcurrently_ :: (Applicative m, MonadUnliftIO m) => Int -> m a -> m ()

-- | Executes a <a>Traversable</a> container of items concurrently, it uses
--   the <a>Flat</a> type internally.
mapConcurrently :: MonadUnliftIO m => Traversable t => (a -> m b) -> t a -> m (t b)

-- | Executes a <a>Traversable</a> container of items concurrently, it uses
--   the <a>Flat</a> type internally. This function ignores the results.
mapConcurrently_ :: MonadUnliftIO m => Foldable f => (a -> m b) -> f a -> m ()

-- | A more efficient alternative to <a>Concurrently</a>, which reduces the
--   number of threads that need to be forked. For more information, see
--   <a>this blog post</a>. This is provided as a separate type to
--   <tt>Concurrently</tt> as it has a slightly different API.
--   
--   Use the <a>conc</a> function to construct values of type <a>Conc</a>,
--   and <a>runConc</a> to execute the composed actions. You can use the
--   <tt>Applicative</tt> instance to run different actions and wait for
--   all of them to complete, or the <tt>Alternative</tt> instance to wait
--   for the first thread to complete.
--   
--   In the event of a runtime exception thrown by any of the children
--   threads, or an asynchronous exception received in the parent thread,
--   all threads will be killed with an <a>AsyncCancelled</a> exception and
--   the original exception rethrown. If multiple exceptions are generated
--   by different threads, there are no guarantees on which exception will
--   end up getting rethrown.
--   
--   For many common use cases, you may prefer using helper functions in
--   this module like <a>mapConcurrently</a>.
--   
--   There are some intentional differences in behavior to
--   <tt>Concurrently</tt>:
--   
--   <ul>
--   <li>Children threads are always launched in an unmasked state, not the
--   inherited state of the parent thread.</li>
--   </ul>
--   
--   Note that it is a programmer error to use the <tt>Alternative</tt>
--   instance in such a way that there are no alternatives to an empty,
--   e.g. <tt>runConc (empty <a>|</a> empty)</tt>. In such a case, a
--   <a>ConcException</a> will be thrown. If there was an
--   <tt>Alternative</tt> in the standard libraries without <tt>empty</tt>,
--   this library would use it instead.
data Conc m a
[Action] :: m a -> Conc m a
[Apply] :: Conc m (v -> a) -> Conc m v -> Conc m a
[LiftA2] :: (x -> y -> a) -> Conc m x -> Conc m y -> Conc m a
[Pure] :: a -> Conc m a
[Alt] :: Conc m a -> Conc m a -> Conc m a
[Empty] :: Conc m a

-- | Construct a value of type <a>Conc</a> from an action. Compose these
--   values using the typeclass instances (most commonly <a>Applicative</a>
--   and <a>Alternative</a>) and then run with <a>runConc</a>.
conc :: m a -> Conc m a

-- | Run a <a>Conc</a> value on multiple threads.
runConc :: MonadUnliftIO m => Conc m a -> m a

-- | Flattened structure, either Applicative or Alternative
data Flat a
FlatApp :: !FlatApp a -> Flat a

-- | Flattened Alternative. Has at least 2 entries, which must be FlatApp
--   (no nesting of FlatAlts).
FlatAlt :: !FlatApp a -> !FlatApp a -> ![FlatApp a] -> Flat a

-- | Flattened Applicative. No Alternative stuff directly in here, but may
--   be in the children. Notice this type doesn't have a type parameter for
--   monadic contexts, it hardwires the base monad to IO given concurrency
--   relies eventually on that.
data FlatApp a
[FlatPure] :: a -> FlatApp a
[FlatAction] :: IO a -> FlatApp a
[FlatApply] :: Flat (v -> a) -> Flat v -> FlatApp a
[FlatLiftA2] :: (x -> y -> a) -> Flat x -> Flat y -> FlatApp a

-- | Things that can go wrong in the structure of a <a>Conc</a>. These are
--   <i>programmer errors</i>.
data ConcException
EmptyWithNoAlternative :: ConcException

-- | Simple difference list, for nicer types below
type DList a = [a] -> [a]
dlistConcat :: DList a -> DList a -> DList a
dlistCons :: a -> DList a -> DList a
dlistConcatAll :: [DList a] -> DList a
dlistToList :: DList a -> [a]
dlistSingleton :: a -> DList a
dlistEmpty :: DList a

-- | Turn a <a>Conc</a> into a <a>Flat</a>. Note that thanks to the
--   ugliness of <a>empty</a>, this may fail, e.g. <tt>flatten Empty</tt>.
flatten :: forall m a. MonadUnliftIO m => Conc m a -> m (Flat a)

-- | Run a <tt>Flat a</tt> on multiple threads.
runFlat :: Flat a -> IO a

-- | Like <a>mapConcurrently</a> from async, but instead of one thread per
--   element, it does pooling from a set of threads. This is useful in
--   scenarios where resource consumption is bounded and for use cases
--   where too many concurrent tasks aren't allowed.
--   
--   <h3><b>Example usage</b></h3>
--   
--   <pre>
--   import Say
--   
--   action :: Int -&gt; IO Int
--   action n = do
--     tid &lt;- myThreadId
--     sayString $ show tid
--     threadDelay (2 * 10^6) -- 2 seconds
--     return n
--   
--   main :: IO ()
--   main = do
--     yx &lt;- pooledMapConcurrentlyN 5 (\x -&gt; action x) [1..5]
--     print yx
--   </pre>
--   
--   On executing you can see that five threads have been spawned:
--   
--   <pre>
--   $ ./pool
--   ThreadId 36
--   ThreadId 38
--   ThreadId 40
--   ThreadId 42
--   ThreadId 44
--   [1,2,3,4,5]
--   </pre>
--   
--   Let's modify the above program such that there are less threads than
--   the number of items in the list:
--   
--   <pre>
--   import Say
--   
--   action :: Int -&gt; IO Int
--   action n = do
--     tid &lt;- myThreadId
--     sayString $ show tid
--     threadDelay (2 * 10^6) -- 2 seconds
--     return n
--   
--   main :: IO ()
--   main = do
--     yx &lt;- pooledMapConcurrentlyN 3 (\x -&gt; action x) [1..5]
--     print yx
--   </pre>
--   
--   On executing you can see that only three threads are active totally:
--   
--   <pre>
--   $ ./pool
--   ThreadId 35
--   ThreadId 37
--   ThreadId 39
--   ThreadId 35
--   ThreadId 39
--   [1,2,3,4,5]
--   </pre>
pooledMapConcurrentlyN :: (MonadUnliftIO m, Traversable t) => Int -> (a -> m b) -> t a -> m (t b)

-- | Similar to <a>pooledMapConcurrentlyN</a> but with number of threads
--   set from <a>getNumCapabilities</a>. Usually this is useful for CPU
--   bound tasks.
pooledMapConcurrently :: (MonadUnliftIO m, Traversable t) => (a -> m b) -> t a -> m (t b)

-- | Similar to <a>pooledMapConcurrentlyN</a> but with flipped arguments.
pooledForConcurrentlyN :: (MonadUnliftIO m, Traversable t) => Int -> t a -> (a -> m b) -> m (t b)

-- | Similar to <a>pooledForConcurrentlyN</a> but with number of threads
--   set from <a>getNumCapabilities</a>. Usually this is useful for CPU
--   bound tasks.
pooledForConcurrently :: (MonadUnliftIO m, Traversable t) => t a -> (a -> m b) -> m (t b)
pooledMapConcurrentlyIO :: Traversable t => Int -> (a -> IO b) -> t a -> IO (t b)

-- | Performs the actual pooling for the tasks. This function will continue
--   execution until the task queue becomes empty. When one of the pooled
--   thread finishes it's task, it will pickup the next task from the queue
--   if an job is available.
pooledConcurrently :: Int -> IORef [a] -> (a -> IO ()) -> IO ()
pooledMapConcurrentlyIO' :: Traversable t => Int -> (a -> IO b) -> t a -> IO (t b)
pooledMapConcurrentlyIO_' :: Foldable t => Int -> (a -> IO ()) -> t a -> IO ()
pooledMapConcurrentlyIO_ :: Foldable t => Int -> (a -> IO b) -> t a -> IO ()

-- | Like <a>pooledMapConcurrentlyN</a> but with the return value
--   discarded.
pooledMapConcurrentlyN_ :: (MonadUnliftIO m, Foldable f) => Int -> (a -> m b) -> f a -> m ()

-- | Like <a>pooledMapConcurrently</a> but with the return value discarded.
pooledMapConcurrently_ :: (MonadUnliftIO m, Foldable f) => (a -> m b) -> f a -> m ()

-- | Like <a>pooledMapConcurrently_</a> but with flipped arguments.
pooledForConcurrently_ :: (MonadUnliftIO m, Foldable f) => f a -> (a -> m b) -> m ()

-- | Like <a>pooledMapConcurrentlyN_</a> but with flipped arguments.
pooledForConcurrentlyN_ :: (MonadUnliftIO m, Foldable t) => Int -> t a -> (a -> m b) -> m ()

-- | Pooled version of <a>replicateConcurrently</a>. Performs the action in
--   the pooled threads.
pooledReplicateConcurrentlyN :: MonadUnliftIO m => Int -> Int -> m a -> m [a]

-- | Similar to <a>pooledReplicateConcurrentlyN</a> but with number of
--   threads set from <a>getNumCapabilities</a>. Usually this is useful for
--   CPU bound tasks.
pooledReplicateConcurrently :: MonadUnliftIO m => Int -> m a -> m [a]

-- | Pooled version of <a>replicateConcurrently_</a>. Performs the action
--   in the pooled threads.
pooledReplicateConcurrentlyN_ :: MonadUnliftIO m => Int -> Int -> m a -> m ()

-- | Similar to <a>pooledReplicateConcurrently_</a> but with number of
--   threads set from <a>getNumCapabilities</a>. Usually this is useful for
--   CPU bound tasks.
pooledReplicateConcurrently_ :: MonadUnliftIO m => Int -> m a -> m ()
instance GHC.Classes.Ord UnliftIO.Internals.Async.ConcException
instance GHC.Classes.Eq UnliftIO.Internals.Async.ConcException
instance GHC.Show.Show UnliftIO.Internals.Async.ConcException
instance GHC.Generics.Generic UnliftIO.Internals.Async.ConcException
instance GHC.Base.Functor m => GHC.Base.Functor (UnliftIO.Internals.Async.Conc m)
instance GHC.Base.Functor UnliftIO.Internals.Async.Flat
instance GHC.Base.Functor UnliftIO.Internals.Async.FlatApp
instance GHC.Exception.Type.Exception UnliftIO.Internals.Async.ConcException
instance GHC.Base.Applicative UnliftIO.Internals.Async.Flat
instance GHC.Base.Applicative UnliftIO.Internals.Async.FlatApp
instance Control.Monad.IO.Unlift.MonadUnliftIO m => GHC.Base.Applicative (UnliftIO.Internals.Async.Conc m)
instance Control.Monad.IO.Unlift.MonadUnliftIO m => GHC.Base.Alternative (UnliftIO.Internals.Async.Conc m)
instance (Control.Monad.IO.Unlift.MonadUnliftIO m, GHC.Base.Semigroup a) => GHC.Base.Semigroup (UnliftIO.Internals.Async.Conc m a)
instance (GHC.Base.Monoid a, Control.Monad.IO.Unlift.MonadUnliftIO m) => GHC.Base.Monoid (UnliftIO.Internals.Async.Conc m a)
instance GHC.Base.Monad m => GHC.Base.Functor (UnliftIO.Internals.Async.Concurrently m)
instance Control.Monad.IO.Unlift.MonadUnliftIO m => GHC.Base.Applicative (UnliftIO.Internals.Async.Concurrently m)
instance Control.Monad.IO.Unlift.MonadUnliftIO m => GHC.Base.Alternative (UnliftIO.Internals.Async.Concurrently m)
instance (Control.Monad.IO.Unlift.MonadUnliftIO m, GHC.Base.Semigroup a) => GHC.Base.Semigroup (UnliftIO.Internals.Async.Concurrently m a)
instance (GHC.Base.Semigroup a, GHC.Base.Monoid a, Control.Monad.IO.Unlift.MonadUnliftIO m) => GHC.Base.Monoid (UnliftIO.Internals.Async.Concurrently m a)


-- | Unlifted <a>Control.Concurrent.Async</a>.
module UnliftIO.Async

-- | An asynchronous action spawned by <a>async</a> or <a>withAsync</a>.
--   Asynchronous actions are executed in a separate thread, and operations
--   are provided for waiting for asynchronous actions to complete and
--   obtaining their results (see e.g. <a>wait</a>).
data () => Async a

-- | Unlifted <a>async</a>.
async :: MonadUnliftIO m => m a -> m (Async a)

-- | Unlifted <a>asyncBound</a>.
asyncBound :: MonadUnliftIO m => m a -> m (Async a)

-- | Unlifted <a>asyncOn</a>.
asyncOn :: MonadUnliftIO m => Int -> m a -> m (Async a)

-- | Unlifted <a>asyncWithUnmask</a>.
asyncWithUnmask :: MonadUnliftIO m => ((forall b. m b -> m b) -> m a) -> m (Async a)

-- | Unlifted <a>asyncOnWithUnmask</a>.
asyncOnWithUnmask :: MonadUnliftIO m => Int -> ((forall b. m b -> m b) -> m a) -> m (Async a)

-- | Unlifted <a>withAsync</a>.
withAsync :: MonadUnliftIO m => m a -> (Async a -> m b) -> m b

-- | Unlifted <a>withAsyncBound</a>.
withAsyncBound :: MonadUnliftIO m => m a -> (Async a -> m b) -> m b

-- | Unlifted <a>withAsyncOn</a>.
withAsyncOn :: MonadUnliftIO m => Int -> m a -> (Async a -> m b) -> m b

-- | Unlifted <a>withAsyncWithUnmask</a>.
withAsyncWithUnmask :: MonadUnliftIO m => ((forall c. m c -> m c) -> m a) -> (Async a -> m b) -> m b

-- | Unlifted <a>withAsyncOnWithMask</a>.
withAsyncOnWithUnmask :: MonadUnliftIO m => Int -> ((forall c. m c -> m c) -> m a) -> (Async a -> m b) -> m b

-- | Lifted <a>wait</a>.
wait :: MonadIO m => Async a -> m a

-- | Lifted <a>poll</a>.
poll :: MonadIO m => Async a -> m (Maybe (Either SomeException a))

-- | Lifted <a>waitCatch</a>.
waitCatch :: MonadIO m => Async a -> m (Either SomeException a)

-- | Lifted <a>cancel</a>.
cancel :: MonadIO m => Async a -> m ()

-- | Lifted <a>uninterruptibleCancel</a>.
uninterruptibleCancel :: MonadIO m => Async a -> m ()

-- | Lifted <a>cancelWith</a>. Additionally uses <a>toAsyncException</a> to
--   ensure async exception safety.
cancelWith :: (Exception e, MonadIO m) => Async a -> e -> m ()

-- | Returns the <a>ThreadId</a> of the thread running the given
--   <a>Async</a>.
asyncThreadId :: Async a -> ThreadId

-- | A version of <a>wait</a> that can be used inside an STM transaction.
waitSTM :: Async a -> STM a

-- | A version of <a>poll</a> that can be used inside an STM transaction.
pollSTM :: Async a -> STM (Maybe (Either SomeException a))

-- | A version of <a>waitCatch</a> that can be used inside an STM
--   transaction.
waitCatchSTM :: Async a -> STM (Either SomeException a)

-- | Lifted <a>waitAny</a>.
waitAny :: MonadIO m => [Async a] -> m (Async a, a)

-- | Lifted <a>waitAnyCatch</a>.
waitAnyCatch :: MonadIO m => [Async a] -> m (Async a, Either SomeException a)

-- | Lifted <a>waitAnyCancel</a>.
waitAnyCancel :: MonadIO m => [Async a] -> m (Async a, a)

-- | Lifted <a>waitAnyCatchCancel</a>.
waitAnyCatchCancel :: MonadIO m => [Async a] -> m (Async a, Either SomeException a)

-- | Lifted <a>waitEither</a>.
waitEither :: MonadIO m => Async a -> Async b -> m (Either a b)

-- | Lifted <a>waitEitherCatch</a>.
waitEitherCatch :: MonadIO m => Async a -> Async b -> m (Either (Either SomeException a) (Either SomeException b))

-- | Lifted <a>waitEitherCancel</a>.
waitEitherCancel :: MonadIO m => Async a -> Async b -> m (Either a b)

-- | Lifted <a>waitEitherCatchCancel</a>.
waitEitherCatchCancel :: MonadIO m => Async a -> Async b -> m (Either (Either SomeException a) (Either SomeException b))

-- | Lifted <a>waitEither_</a>.
waitEither_ :: MonadIO m => Async a -> Async b -> m ()

-- | Lifted <a>waitBoth</a>.
waitBoth :: MonadIO m => Async a -> Async b -> m (a, b)

-- | A version of <a>waitAny</a> that can be used inside an STM
--   transaction.
waitAnySTM :: [Async a] -> STM (Async a, a)

-- | A version of <a>waitAnyCatch</a> that can be used inside an STM
--   transaction.
waitAnyCatchSTM :: [Async a] -> STM (Async a, Either SomeException a)

-- | A version of <a>waitEither</a> that can be used inside an STM
--   transaction.
waitEitherSTM :: Async a -> Async b -> STM (Either a b)

-- | A version of <a>waitEitherCatch</a> that can be used inside an STM
--   transaction.
waitEitherCatchSTM :: Async a -> Async b -> STM (Either (Either SomeException a) (Either SomeException b))

-- | A version of <a>waitEither_</a> that can be used inside an STM
--   transaction.
waitEitherSTM_ :: Async a -> Async b -> STM ()

-- | A version of <a>waitBoth</a> that can be used inside an STM
--   transaction.
waitBothSTM :: Async a -> Async b -> STM (a, b)

-- | Lifted <a>link</a>.
link :: MonadIO m => Async a -> m ()

-- | Lifted <a>link2</a>.
link2 :: MonadIO m => Async a -> Async b -> m ()

-- | Like <a>mapConcurrently</a> from async, but instead of one thread per
--   element, it does pooling from a set of threads. This is useful in
--   scenarios where resource consumption is bounded and for use cases
--   where too many concurrent tasks aren't allowed.
--   
--   <h3><b>Example usage</b></h3>
--   
--   <pre>
--   import Say
--   
--   action :: Int -&gt; IO Int
--   action n = do
--     tid &lt;- myThreadId
--     sayString $ show tid
--     threadDelay (2 * 10^6) -- 2 seconds
--     return n
--   
--   main :: IO ()
--   main = do
--     yx &lt;- pooledMapConcurrentlyN 5 (\x -&gt; action x) [1..5]
--     print yx
--   </pre>
--   
--   On executing you can see that five threads have been spawned:
--   
--   <pre>
--   $ ./pool
--   ThreadId 36
--   ThreadId 38
--   ThreadId 40
--   ThreadId 42
--   ThreadId 44
--   [1,2,3,4,5]
--   </pre>
--   
--   Let's modify the above program such that there are less threads than
--   the number of items in the list:
--   
--   <pre>
--   import Say
--   
--   action :: Int -&gt; IO Int
--   action n = do
--     tid &lt;- myThreadId
--     sayString $ show tid
--     threadDelay (2 * 10^6) -- 2 seconds
--     return n
--   
--   main :: IO ()
--   main = do
--     yx &lt;- pooledMapConcurrentlyN 3 (\x -&gt; action x) [1..5]
--     print yx
--   </pre>
--   
--   On executing you can see that only three threads are active totally:
--   
--   <pre>
--   $ ./pool
--   ThreadId 35
--   ThreadId 37
--   ThreadId 39
--   ThreadId 35
--   ThreadId 39
--   [1,2,3,4,5]
--   </pre>
pooledMapConcurrentlyN :: (MonadUnliftIO m, Traversable t) => Int -> (a -> m b) -> t a -> m (t b)

-- | Similar to <a>pooledMapConcurrentlyN</a> but with number of threads
--   set from <a>getNumCapabilities</a>. Usually this is useful for CPU
--   bound tasks.
pooledMapConcurrently :: (MonadUnliftIO m, Traversable t) => (a -> m b) -> t a -> m (t b)

-- | Like <a>pooledMapConcurrentlyN</a> but with the return value
--   discarded.
pooledMapConcurrentlyN_ :: (MonadUnliftIO m, Foldable f) => Int -> (a -> m b) -> f a -> m ()

-- | Like <a>pooledMapConcurrently</a> but with the return value discarded.
pooledMapConcurrently_ :: (MonadUnliftIO m, Foldable f) => (a -> m b) -> f a -> m ()

-- | Similar to <a>pooledMapConcurrentlyN</a> but with flipped arguments.
pooledForConcurrentlyN :: (MonadUnliftIO m, Traversable t) => Int -> t a -> (a -> m b) -> m (t b)

-- | Similar to <a>pooledForConcurrentlyN</a> but with number of threads
--   set from <a>getNumCapabilities</a>. Usually this is useful for CPU
--   bound tasks.
pooledForConcurrently :: (MonadUnliftIO m, Traversable t) => t a -> (a -> m b) -> m (t b)

-- | Like <a>pooledMapConcurrentlyN_</a> but with flipped arguments.
pooledForConcurrentlyN_ :: (MonadUnliftIO m, Foldable t) => Int -> t a -> (a -> m b) -> m ()

-- | Like <a>pooledMapConcurrently_</a> but with flipped arguments.
pooledForConcurrently_ :: (MonadUnliftIO m, Foldable f) => f a -> (a -> m b) -> m ()

-- | Pooled version of <a>replicateConcurrently</a>. Performs the action in
--   the pooled threads.
pooledReplicateConcurrentlyN :: MonadUnliftIO m => Int -> Int -> m a -> m [a]

-- | Similar to <a>pooledReplicateConcurrentlyN</a> but with number of
--   threads set from <a>getNumCapabilities</a>. Usually this is useful for
--   CPU bound tasks.
pooledReplicateConcurrently :: MonadUnliftIO m => Int -> m a -> m [a]

-- | Pooled version of <a>replicateConcurrently_</a>. Performs the action
--   in the pooled threads.
pooledReplicateConcurrentlyN_ :: MonadUnliftIO m => Int -> Int -> m a -> m ()

-- | Similar to <a>pooledReplicateConcurrently_</a> but with number of
--   threads set from <a>getNumCapabilities</a>. Usually this is useful for
--   CPU bound tasks.
pooledReplicateConcurrently_ :: MonadUnliftIO m => Int -> m a -> m ()

-- | Unlifted <a>race</a>.
race :: MonadUnliftIO m => m a -> m b -> m (Either a b)

-- | Unlifted <a>race_</a>.
race_ :: MonadUnliftIO m => m a -> m b -> m ()

-- | Unlifted <a>concurrently</a>.
concurrently :: MonadUnliftIO m => m a -> m b -> m (a, b)

-- | Unlifted <a>concurrently_</a>.
concurrently_ :: MonadUnliftIO m => m a -> m b -> m ()

-- | Executes a <a>Traversable</a> container of items concurrently, it uses
--   the <a>Flat</a> type internally.
mapConcurrently :: MonadUnliftIO m => Traversable t => (a -> m b) -> t a -> m (t b)

-- | Similar to <a>mapConcurrently</a> but with arguments flipped
forConcurrently :: MonadUnliftIO m => Traversable t => t a -> (a -> m b) -> m (t b)

-- | Executes a <a>Traversable</a> container of items concurrently, it uses
--   the <a>Flat</a> type internally. This function ignores the results.
mapConcurrently_ :: MonadUnliftIO m => Foldable f => (a -> m b) -> f a -> m ()

-- | Similar to <a>mapConcurrently_</a> but with arguments flipped
forConcurrently_ :: MonadUnliftIO m => Foldable f => f a -> (a -> m b) -> m ()

-- | Unlifted <a>replicateConcurrently</a>.
replicateConcurrently :: MonadUnliftIO f => Int -> f a -> f [a]

-- | Unlifted <a>replicateConcurrently_</a>.
replicateConcurrently_ :: (Applicative m, MonadUnliftIO m) => Int -> m a -> m ()

-- | Unlifted <a>Concurrently</a>.
newtype Concurrently m a
Concurrently :: m a -> Concurrently m a
[runConcurrently] :: Concurrently m a -> m a

-- | A more efficient alternative to <a>Concurrently</a>, which reduces the
--   number of threads that need to be forked. For more information, see
--   <a>this blog post</a>. This is provided as a separate type to
--   <tt>Concurrently</tt> as it has a slightly different API.
--   
--   Use the <a>conc</a> function to construct values of type <a>Conc</a>,
--   and <a>runConc</a> to execute the composed actions. You can use the
--   <tt>Applicative</tt> instance to run different actions and wait for
--   all of them to complete, or the <tt>Alternative</tt> instance to wait
--   for the first thread to complete.
--   
--   In the event of a runtime exception thrown by any of the children
--   threads, or an asynchronous exception received in the parent thread,
--   all threads will be killed with an <a>AsyncCancelled</a> exception and
--   the original exception rethrown. If multiple exceptions are generated
--   by different threads, there are no guarantees on which exception will
--   end up getting rethrown.
--   
--   For many common use cases, you may prefer using helper functions in
--   this module like <a>mapConcurrently</a>.
--   
--   There are some intentional differences in behavior to
--   <tt>Concurrently</tt>:
--   
--   <ul>
--   <li>Children threads are always launched in an unmasked state, not the
--   inherited state of the parent thread.</li>
--   </ul>
--   
--   Note that it is a programmer error to use the <tt>Alternative</tt>
--   instance in such a way that there are no alternatives to an empty,
--   e.g. <tt>runConc (empty <a>|</a> empty)</tt>. In such a case, a
--   <a>ConcException</a> will be thrown. If there was an
--   <tt>Alternative</tt> in the standard libraries without <tt>empty</tt>,
--   this library would use it instead.
data Conc m a

-- | Construct a value of type <a>Conc</a> from an action. Compose these
--   values using the typeclass instances (most commonly <a>Applicative</a>
--   and <a>Alternative</a>) and then run with <a>runConc</a>.
conc :: m a -> Conc m a

-- | Run a <a>Conc</a> value on multiple threads.
runConc :: MonadUnliftIO m => Conc m a -> m a

-- | Things that can go wrong in the structure of a <a>Conc</a>. These are
--   <i>programmer errors</i>.
data ConcException
EmptyWithNoAlternative :: ConcException

-- | The exception thrown by <a>cancel</a> to terminate a thread.
data () => AsyncCancelled
AsyncCancelled :: AsyncCancelled


-- | Unlifted <a>Control.Concurrent.MVar</a>.
module UnliftIO.MVar

-- | An <a>MVar</a> (pronounced "em-var") is a synchronising variable, used
--   for communication between concurrent threads. It can be thought of as
--   a box, which may be empty or full.
data () => MVar a

-- | Lifted <a>newEmptyMVar</a>.
newEmptyMVar :: MonadIO m => m (MVar a)

-- | Lifted <a>newMVar</a>.
newMVar :: MonadIO m => a -> m (MVar a)

-- | Lifted <a>takeMVar</a>.
takeMVar :: MonadIO m => MVar a -> m a

-- | Lifted <a>putMVar</a>.
putMVar :: MonadIO m => MVar a -> a -> m ()

-- | Lifted <a>readMVar</a>.
readMVar :: MonadIO m => MVar a -> m a

-- | Lifted <a>swapMVar</a>.
swapMVar :: MonadIO m => MVar a -> a -> m a

-- | Lifted <a>tryTakeMVar</a>.
tryTakeMVar :: MonadIO m => MVar a -> m (Maybe a)

-- | Lifted <a>tryPutMVar</a>.
tryPutMVar :: MonadIO m => MVar a -> a -> m Bool

-- | Lifted <a>isEmptyMVar</a>.
isEmptyMVar :: MonadIO m => MVar a -> m Bool

-- | Unlifted <a>withMVar</a>.
withMVar :: MonadUnliftIO m => MVar a -> (a -> m b) -> m b

-- | Unlifted <a>withMVarMasked</a>.
withMVarMasked :: MonadUnliftIO m => MVar a -> (a -> m b) -> m b

-- | Unlifted <a>modifyMVar</a>.
modifyMVar :: MonadUnliftIO m => MVar a -> (a -> m (a, b)) -> m b

-- | Unlifted <a>modifyMVar_</a>.
modifyMVar_ :: MonadUnliftIO m => MVar a -> (a -> m a) -> m ()

-- | Unlifted <a>modifyMVarMasked</a>.
modifyMVarMasked :: MonadUnliftIO m => MVar a -> (a -> m (a, b)) -> m b

-- | Unlifted <a>modifyMVarMasked_</a>.
modifyMVarMasked_ :: MonadUnliftIO m => MVar a -> (a -> m a) -> m ()

-- | Lifted <a>tryReadMVar</a>.
tryReadMVar :: MonadIO m => MVar a -> m (Maybe a)

-- | Unlifted <a>mkWeakMVar</a>.
mkWeakMVar :: MonadUnliftIO m => MVar a -> m () -> m (Weak (MVar a))


-- | <h2>Rationale</h2>
--   
--   This module offers functions to handle files that offer better
--   durability and/or atomicity.
--   
--   <h2>When to use functions in this module?</h2>
--   
--   Given the usage of this functions comes at a cost in performance, it
--   is important to consider what are the use cases that are ideal for
--   each of the functions.
--   
--   <h3>Not Durable and not Atomic</h3>
--   
--   For this use case, you want to use the regular functions:
--   
--   <ul>
--   <li><a>withBinaryFile</a></li>
--   <li><a>writeBinaryFile</a></li>
--   </ul>
--   
--   The regular use case for this scenario happens when your program is
--   dealing with outputs that are never going to be consumed again by your
--   program. For example, imagine you have a program that generates sales
--   reports for the last month, this is a report that can be generated
--   quickly; you don't really care if the output file gets corrupted or
--   lost at one particular execution of your program given that is cheap
--   to execute the data export program a second time. In other words, your
--   program doesn't <i>rely</i> on the data contained in this file in
--   order to work.
--   
--   <h3>Atomic but not Durable</h3>
--   
--   Imagine a scenario where your program builds a temporary file that
--   serves as an intermediate step to a bigger task, like Object files
--   (<tt>.o</tt>) in a compilation process. The program will use an
--   existing <tt>.o</tt> file if it is present, or it will build one from
--   scratch if it is not. The file is not really required, but if it is
--   present, it *must* be valid and consistent. In this situation, you
--   care about atomicity, but not durability. You can use the functions
--   for such scenario:
--   
--   <ul>
--   <li><a>withBinaryFileAtomic</a></li>
--   <li><a>writeBinaryFileAtomic</a></li>
--   </ul>
--   
--   <b>Note</b> - there is a peculiar difference between regular file
--   writing functionality and the one that is done atomically. Even if the
--   orignal file is removed while it is being modified, because of
--   atomicity, it will be restored with all modifications, if any. The
--   reason for this is because a copy of the file was made prior to
--   modifications and at the end the existing is atomically replaced. An
--   important consequence of this fact is that whenever the folder
--   containing the file which is being modified is removed, all bets are
--   off and all atomic functions will result in an exception.
--   
--   <h3>Durable but not Atomic</h3>
--   
--   For this use case, you want to use the functions:
--   
--   <ul>
--   <li><a>withBinaryFileDurable</a></li>
--   <li><a>writeBinaryFileDurable</a></li>
--   </ul>
--   
--   The regular use case for this scenario happens when your program deals
--   with file modifications that must be guaranteed to be durable, but you
--   don't care that changes are consistent. If you use this function, more
--   than likely your program is ensuring consistency guarantees through
--   other means, for example, SQLite uses the Write Ahead Log (WAL)
--   algorithm to ensure changes are atomic at an application level.
--   
--   <h3>Durable and Atomic</h3>
--   
--   For this use case, you can use the functions:
--   
--   <ul>
--   <li><a>withBinaryFileDurableAtomic</a></li>
--   <li><a>writeBinaryFileDurableAtomic</a></li>
--   </ul>
--   
--   The regular use case for this scenario happens when you want to ensure
--   that after a program is executed, the modifications done to a file are
--   guaranteed to be saved, and also that changes are rolled-back in case
--   there is a failure (e.g. hard reboot, shutdown, etc).
module UnliftIO.IO.File

-- | Lifted version of <a>writeFile</a>
writeBinaryFile :: MonadIO m => FilePath -> ByteString -> m ()

-- | Same as <a>writeBinaryFileDurableAtomic</a>, except it does not
--   guarantee durability.
--   
--   <h3>Cross-Platform support</h3>
--   
--   This function behaves the same as <a>writeBinaryFile</a> on Windows
--   platforms.
writeBinaryFileAtomic :: MonadIO m => FilePath -> ByteString -> m ()

-- | Similar to <a>writeBinaryFile</a>, but it also ensures that changes
--   executed to the file are guaranteed to be durable. It internally uses
--   <tt>fsync()</tt> and makes sure it synchronizes the file on disk.
--   
--   <h3>Cross-Platform support</h3>
--   
--   This function behaves the same as <a>writeBinaryFile</a> on Windows
--   platforms.
writeBinaryFileDurable :: MonadIO m => FilePath -> ByteString -> m ()

-- | Similar to <a>writeBinaryFile</a>, but it also guarantes that changes
--   executed to the file are durable, also, in case of failure, the
--   modified file is never going to get corrupted. It internally uses
--   <tt>fsync()</tt> and makes sure it synchronizes the file on disk.
--   
--   <h3>Cross-Platform support</h3>
--   
--   This function behaves the same as <a>writeBinaryFile</a> on Windows
--   platforms.
writeBinaryFileDurableAtomic :: MonadIO m => FilePath -> ByteString -> m ()

-- | Unlifted version of <a>withBinaryFile</a>.
withBinaryFile :: MonadUnliftIO m => FilePath -> IOMode -> (Handle -> m a) -> m a

-- | Perform an action on a new or existing file at the destination file
--   path. If previously the file existed at the supplied file path then:
--   
--   <ul>
--   <li>in case of <a>WriteMode</a> it will be overwritten</li>
--   <li>upon <a>ReadWriteMode</a> or <a>AppendMode</a> files contents will
--   be copied over into a temporary file, thus making sure no corruption
--   can happen to an existing file upon any failures, even catastrophic
--   one, yet its contents are availble for modification.</li>
--   <li>There is nothing atomic about <a>ReadMode</a>, so no special
--   treatment there.</li>
--   </ul>
--   
--   It is similar to <a>withBinaryFileDurableAtomic</a>, but without the
--   durability part. It means that all modification can still disappear
--   after it has been succesfully written due to some extreme event like
--   an abrupt power loss, but the contents will not be corrupted in case
--   when the file write did not end successfully.
--   
--   The same performance caveats apply as for
--   <a>withBinaryFileDurableAtomic</a> due to making a copy of the content
--   of existing files during non-truncating writes.
--   
--   <b>Important</b> - Do not close the handle, otherwise it will result
--   in <tt>invalid argument (Bad file descriptor)</tt> exception
--   
--   <b>Note</b> - on Linux operating system and only with supported file
--   systems an anonymous temporary file will be used while working on the
--   file (see <tt>O_TMPFILE</tt> in <tt>man openat</tt>). In case when
--   such feature is not available or not supported a temporary file
--   ".target-file-nameXXX.ext.tmp", where XXX is some random number, will
--   be created alongside the target file in the same directory
withBinaryFileAtomic :: MonadUnliftIO m => FilePath -> IOMode -> (Handle -> m r) -> m r

-- | Opens a file with the following guarantees:
--   
--   <ul>
--   <li>It successfully closes the file in case of an asynchronous
--   exception</li>
--   <li>It reliably saves the file in the correct directory; including
--   edge case situations like a different device being mounted to the
--   current directory, or the current directory being renamed to some
--   other name while the file is being used.</li>
--   <li>It ensures durability by executing an <tt>fsync()</tt> call before
--   closing the file handle</li>
--   </ul>
--   
--   <h3>Cross-Platform support</h3>
--   
--   This function behaves the same as <a>withBinaryFile</a> on Windows
--   platforms.
withBinaryFileDurable :: MonadUnliftIO m => FilePath -> IOMode -> (Handle -> m r) -> m r

-- | Opens a file with the following guarantees:
--   
--   <ul>
--   <li>It successfully closes the file in case of an asynchronous
--   exception</li>
--   <li>It reliably saves the file in the correct directory; including
--   edge case situations like a different device being mounted to the
--   current directory, or the current directory being renamed to some
--   other name while the file is being used.</li>
--   <li>It ensures durability by executing an <tt>fsync()</tt> call before
--   closing the file handle</li>
--   <li>It keeps all changes in a temporary file, and after it is closed
--   it atomically moves the temporary file to the original filepath, in
--   case of catastrophic failure, the original file stays unaffected.</li>
--   </ul>
--   
--   If you do not need durability but only atomicity, use
--   <a>withBinaryFileAtomic</a> instead, which is faster as it does not
--   perform <tt>fsync()</tt>.
--   
--   <b>Important</b> - Make sure not to close the <a>Handle</a>, it will
--   be closed for you, otherwise it will result in <tt>invalid argument
--   (Bad file descriptor)</tt> exception.
--   
--   <h3>Performance Considerations</h3>
--   
--   When using a writable but non-truncating <a>IOMode</a> (i.e.
--   <a>ReadWriteMode</a> and <a>AppendMode</a>), this function performs a
--   copy operation of the specified input file to guarantee the original
--   file is intact in case of a catastrophic failure (no partial writes).
--   This approach may be prohibitive in scenarios where the input file is
--   expected to be large in size.
--   
--   <h3>Cross-Platform support</h3>
--   
--   This function behaves the same as <a>withBinaryFile</a> on Windows
--   platforms.
withBinaryFileDurableAtomic :: MonadUnliftIO m => FilePath -> IOMode -> (Handle -> m r) -> m r

-- | After a file is closed, this function opens it again and executes
--   <tt>fsync()</tt> internally on both the file and the directory that
--   contains it. Note that this function is intended to work around the
--   non-durability of existing file APIs, as opposed to being necessary
--   for the API functions provided in this module.
--   
--   <a>The effectiveness of calling this function is debatable</a>, as it
--   relies on internal implementation details at the Kernel level that
--   might change. We argue that, despite this fact, calling this function
--   may bring benefits in terms of durability.
--   
--   This function does not provide the same guarantee as if you would open
--   and modify a file using <a>withBinaryFileDurable</a> or
--   <a>writeBinaryFileDurable</a>, since they ensure that the
--   <tt>fsync()</tt> is called before the file is closed, so if possible
--   use those instead.
--   
--   <h3>Cross-Platform support</h3>
--   
--   This function is a noop on Windows platforms.
ensureFileDurable :: MonadIO m => FilePath -> m ()


-- | Unlifted <a>Control.Concurrent</a>.
--   
--   This module is not reexported by <a>UnliftIO</a>, use it only if
--   <a>UnliftIO.Async</a> is not enough.
module UnliftIO.Concurrent

-- | A <a>ThreadId</a> is an abstract type representing a handle to a
--   thread. <a>ThreadId</a> is an instance of <a>Eq</a>, <a>Ord</a> and
--   <a>Show</a>, where the <a>Ord</a> instance implements an arbitrary
--   total ordering over <a>ThreadId</a>s. The <a>Show</a> instance lets
--   you convert an arbitrary-valued <a>ThreadId</a> to string form;
--   showing a <a>ThreadId</a> value is occasionally useful when debugging
--   or diagnosing the behaviour of a concurrent program.
--   
--   <i>Note</i>: in GHC, if you have a <a>ThreadId</a>, you essentially
--   have a pointer to the thread itself. This means the thread itself
--   can't be garbage collected until you drop the <a>ThreadId</a>. This
--   misfeature will hopefully be corrected at a later date.
data () => ThreadId

-- | Lifted version of <a>myThreadId</a>.
myThreadId :: MonadIO m => m ThreadId

-- | Unlifted version of <a>forkIO</a>.
forkIO :: MonadUnliftIO m => m () -> m ThreadId

-- | Please use <a>forkIOWithUnmask</a> instead. This function has been
--   deprecated in release 0.2.11 and will be removed in the next major
--   release.

-- | <i>Deprecated: forkWithUnmask has been renamed to forkIOWithUnmask</i>
forkWithUnmask :: MonadUnliftIO m => ((forall a. m a -> m a) -> m ()) -> m ThreadId

-- | Unlifted version of <a>forkIOWithUnmask</a>.
forkIOWithUnmask :: MonadUnliftIO m => ((forall a. m a -> m a) -> m ()) -> m ThreadId

-- | Unlifted version of <a>forkFinally</a>.
forkFinally :: MonadUnliftIO m => m a -> (Either SomeException a -> m ()) -> m ThreadId

-- | Lifted version of <a>killThread</a>.
killThread :: MonadIO m => ThreadId -> m ()

-- | Throw an asynchronous exception to another thread.
--   
--   Synchronously typed exceptions will be wrapped into an
--   <tt>AsyncExceptionWrapper</tt>, see
--   <a>https://github.com/fpco/safe-exceptions#determining-sync-vs-async</a>.
--   
--   It's usually a better idea to use the <a>UnliftIO.Async</a> module,
--   see <a>https://github.com/fpco/safe-exceptions#quickstart</a>.
throwTo :: (Exception e, MonadIO m) => ThreadId -> e -> m ()

-- | Unlifted version of <a>forkOn</a>.
forkOn :: MonadUnliftIO m => Int -> m () -> m ThreadId

-- | Unlifted version of <a>forkOnWithUnmask</a>.
forkOnWithUnmask :: MonadUnliftIO m => Int -> ((forall a. m a -> m a) -> m ()) -> m ThreadId

-- | Lifted version of <a>getNumCapabilities</a>.
getNumCapabilities :: MonadIO m => m Int

-- | Lifted version of <a>setNumCapabilities</a>.
setNumCapabilities :: MonadIO m => Int -> m ()

-- | Lifted version of <a>threadCapability</a>.
threadCapability :: MonadIO m => ThreadId -> m (Int, Bool)

-- | Lifted version of <a>yield</a>.
yield :: MonadIO m => m ()

-- | Lifted version of <a>threadDelay</a>.
threadDelay :: MonadIO m => Int -> m ()

-- | Lifted version of <a>threadWaitRead</a>.
threadWaitRead :: MonadIO m => Fd -> m ()

-- | Lifted version of <a>threadWaitWrite</a>.
threadWaitWrite :: MonadIO m => Fd -> m ()

-- | <a>True</a> if bound threads are supported. If
--   <tt>rtsSupportsBoundThreads</tt> is <a>False</a>,
--   <a>isCurrentThreadBound</a> will always return <a>False</a> and both
--   <a>forkOS</a> and <a>runInBoundThread</a> will fail.
rtsSupportsBoundThreads :: Bool

-- | Unflifted version of <a>forkOS</a>.
forkOS :: MonadUnliftIO m => m () -> m ThreadId

-- | Lifted version of <a>isCurrentThreadBound</a>.
isCurrentThreadBound :: MonadIO m => m Bool

-- | Unlifted version of <a>runInBoundThread</a>.
runInBoundThread :: MonadUnliftIO m => m a -> m a

-- | Unlifted version of <a>runInUnboundThread</a>.
runInUnboundThread :: MonadUnliftIO m => m a -> m a

-- | Lifted version of <a>mkWeakThreadId</a>.
mkWeakThreadId :: MonadIO m => ThreadId -> m (Weak ThreadId)


-- | Memoize the results of actions. In other words: actions will be run
--   once, on demand, and their results saved.
--   
--   Exceptions semantics: if a synchronous exception is thrown while
--   performing the computation, that result will be saved and rethrown
--   each time <a>runMemoized</a> is called subsequently.'
module UnliftIO.Memoize

-- | A "run once" value, with results saved. Extract the value with
--   <a>runMemoized</a>. For single-threaded usage, you can use
--   <a>memoizeRef</a> to create a value. If you need guarantees that only
--   one thread will run the action at a time, use <a>memoizeMVar</a>.
--   
--   Note that this type provides a <a>Show</a> instance for convenience,
--   but not useful information can be provided.
data Memoized a

-- | Extract a value from a <a>Memoized</a>, running an action if no cached
--   value is available.
runMemoized :: MonadIO m => Memoized a -> m a

-- | Create a new <a>Memoized</a> value using an <a>IORef</a> under the
--   surface. Note that the action may be run in multiple threads
--   simultaneously, so this may not be thread safe (depending on the
--   underlying action). Consider using <a>memoizeMVar</a>.
memoizeRef :: MonadUnliftIO m => m a -> m (Memoized a)

-- | Same as <a>memoizeRef</a>, but uses an <a>MVar</a> to ensure that an
--   action is only run once, even in a multithreaded application.
memoizeMVar :: MonadUnliftIO m => m a -> m (Memoized a)
instance GHC.Base.Monad UnliftIO.Memoize.Memoized
instance GHC.Base.Applicative UnliftIO.Memoize.Memoized
instance GHC.Base.Functor UnliftIO.Memoize.Memoized
instance GHC.Show.Show (UnliftIO.Memoize.Memoized a)


-- | Unlifted <a>System.Process</a>.
module UnliftIO.Process
data () => CreateProcess
CreateProcess :: CmdSpec -> Maybe FilePath -> Maybe [(String, String)] -> StdStream -> StdStream -> StdStream -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Maybe GroupID -> Maybe UserID -> Bool -> CreateProcess

-- | Executable &amp; arguments, or shell command. If <a>cwd</a> is
--   <a>Nothing</a>, relative paths are resolved with respect to the
--   current working directory. If <a>cwd</a> is provided, it is
--   implementation-dependent whether relative paths are resolved with
--   respect to <a>cwd</a> or the current working directory, so absolute
--   paths should be used to ensure portability.
[cmdspec] :: CreateProcess -> CmdSpec

-- | Optional path to the working directory for the new process
[cwd] :: CreateProcess -> Maybe FilePath

-- | Optional environment (otherwise inherit from the current process)
[env] :: CreateProcess -> Maybe [(String, String)]

-- | How to determine stdin
[std_in] :: CreateProcess -> StdStream

-- | How to determine stdout
[std_out] :: CreateProcess -> StdStream

-- | How to determine stderr
[std_err] :: CreateProcess -> StdStream

-- | Close all file descriptors except stdin, stdout and stderr in the new
--   process (on Windows, only works if std_in, std_out, and std_err are
--   all Inherit). This implementation will call close on every fd from 3
--   to the maximum of open files, which can be slow for high maximum of
--   open files. XXX verify what happens with fds in nodejs child processes
[close_fds] :: CreateProcess -> Bool

-- | Create a new process group. On JavaScript this also creates a new
--   session.
[create_group] :: CreateProcess -> Bool

-- | Delegate control-C handling. Use this for interactive console
--   processes to let them handle control-C themselves (see below for
--   details).
[delegate_ctlc] :: CreateProcess -> Bool

-- | Use the windows DETACHED_PROCESS flag when creating the process; does
--   nothing on other platforms.
[detach_console] :: CreateProcess -> Bool

-- | Use the windows CREATE_NEW_CONSOLE flag when creating the process;
--   does nothing on other platforms.
--   
--   Default: <tt>False</tt>
[create_new_console] :: CreateProcess -> Bool

-- | Use posix setsid to start the new process in a new session; starts
--   process in a new session on JavaScript; does nothing on other
--   platforms.
[new_session] :: CreateProcess -> Bool

-- | Use posix setgid to set child process's group id; works for JavaScript
--   when system running nodejs is posix. does nothing on other platforms.
--   
--   Default: <tt>Nothing</tt>
[child_group] :: CreateProcess -> Maybe GroupID

-- | Use posix setuid to set child process's user id; works for JavaScript
--   when system running nodejs is posix. does nothing on other platforms.
--   
--   Default: <tt>Nothing</tt>
[child_user] :: CreateProcess -> Maybe UserID

-- | On Windows systems this flag indicates that we should wait for the
--   entire process tree to finish before unblocking. On POSIX systems this
--   flag is ignored. See $exec-on-windows for details.
--   
--   Default: <tt>False</tt>
[use_process_jobs] :: CreateProcess -> Bool
data () => CmdSpec

-- | A command line to execute using the shell
ShellCommand :: String -> CmdSpec

-- | The name of an executable with a list of arguments
--   
--   The <a>FilePath</a> argument names the executable, and is interpreted
--   according to the platform's standard policy for searching for
--   executables. Specifically:
--   
--   <ul>
--   <li>on Unix systems the <a>execvp(3)</a> semantics is used, where if
--   the executable filename does not contain a slash (<tt>/</tt>) then the
--   <tt>PATH</tt> environment variable is searched for the
--   executable.</li>
--   <li>on Windows systems the Win32 <tt>CreateProcess</tt> semantics is
--   used. Briefly: if the filename does not contain a path, then the
--   directory containing the parent executable is searched, followed by
--   the current directory, then some standard locations, and finally the
--   current <tt>PATH</tt>. An <tt>.exe</tt> extension is added if the
--   filename does not already have an extension. For full details see the
--   <a>documentation</a> for the Windows <tt>SearchPath</tt> API.</li>
--   </ul>
--   
--   Windows does not have a mechanism for passing multiple arguments. When
--   using <tt>RawCommand</tt> on Windows, the command line is serialised
--   into a string, with arguments quoted separately. Command line parsing
--   is up individual programs, so the default behaviour may not work for
--   some programs. If you are not getting the desired results, construct
--   the command line yourself and use <a>ShellCommand</a>.
RawCommand :: FilePath -> [String] -> CmdSpec
data () => StdStream

-- | Inherit Handle from parent
Inherit :: StdStream

-- | Use the supplied Handle
UseHandle :: Handle -> StdStream

-- | Create a new pipe. The returned <tt>Handle</tt> will use the default
--   encoding and newline translation mode (just like <tt>Handle</tt>s
--   created by <tt>openFile</tt>).
CreatePipe :: StdStream

-- | Close the stream's file descriptor without passing a Handle. On POSIX
--   systems this may lead to strange behavior in the child process because
--   attempting to read or write after the file has been closed throws an
--   error. This should only be used with child processes that don't use
--   the file descriptor at all. If you wish to ignore the child process's
--   output you should either create a pipe and drain it manually or pass a
--   <tt>Handle</tt> that writes to <tt>/dev/null</tt>.
NoStream :: StdStream

-- | A handle to a process, which can be used to wait for termination of
--   the process using <a>waitForProcess</a>.
--   
--   None of the process-creation functions in this library wait for
--   termination: they all return a <a>ProcessHandle</a> which may be used
--   to wait for the process later.
--   
--   On Windows a second wait method can be used to block for event
--   completion. This requires two handles. A process job handle and a
--   events handle to monitor.
data () => ProcessHandle

-- | Lifted <a>createProcess</a>.
createProcess :: MonadIO m => CreateProcess -> m (Maybe Handle, Maybe Handle, Maybe Handle, ProcessHandle)

-- | Lifted <a>createProcess_</a>.
createProcess_ :: MonadIO m => String -> CreateProcess -> m (Maybe Handle, Maybe Handle, Maybe Handle, ProcessHandle)

-- | Construct a <a>CreateProcess</a> record for passing to
--   <a>createProcess</a>, representing a command to be passed to the
--   shell.
shell :: String -> CreateProcess

-- | Construct a <a>CreateProcess</a> record for passing to
--   <a>createProcess</a>, representing a raw command with arguments.
--   
--   See <a>RawCommand</a> for precise semantics of the specified
--   <tt>FilePath</tt>.
proc :: FilePath -> [String] -> CreateProcess

-- | Lifted <a>callProcess</a>.
callProcess :: MonadIO m => FilePath -> [String] -> m ()

-- | Lifted <a>callCommand</a>.
callCommand :: MonadIO m => String -> m ()

-- | Lifted <a>spawnProcess</a>.
spawnProcess :: MonadIO m => FilePath -> [String] -> m ProcessHandle

-- | Lifted <a>spawnCommand</a>.
spawnCommand :: MonadIO m => String -> m ProcessHandle

-- | Lifted <a>readCreateProcess</a>.
readCreateProcess :: MonadIO m => CreateProcess -> String -> m String

-- | Lifted <a>readProcess</a>.
readProcess :: MonadIO m => FilePath -> [String] -> String -> m String

-- | Lifted <a>readCreateProcessWithExitCode</a>.
readCreateProcessWithExitCode :: MonadIO m => CreateProcess -> String -> m (ExitCode, String, String)

-- | Lifted <a>readProcessWithExitCode</a>.
readProcessWithExitCode :: MonadIO m => FilePath -> [String] -> String -> m (ExitCode, String, String)

-- | Unlifted <a>withCreateProcess</a>.
withCreateProcess :: MonadUnliftIO m => CreateProcess -> (Maybe Handle -> Maybe Handle -> Maybe Handle -> ProcessHandle -> m a) -> m a

-- | Given a program <tt><i>p</i></tt> and arguments <tt><i>args</i></tt>,
--   <tt>showCommandForUser <i>p</i> <i>args</i></tt> returns a string
--   suitable for pasting into <tt>/bin/sh</tt> (on Unix systems) or
--   <tt>CMD.EXE</tt> (on Windows).
showCommandForUser :: FilePath -> [String] -> String

-- | Lifted <a>waitForProcess</a>.
waitForProcess :: MonadIO m => ProcessHandle -> m ExitCode

-- | Lifted <a>getProcessExitCode</a>.
getProcessExitCode :: MonadIO m => ProcessHandle -> m (Maybe ExitCode)

-- | Lifted <a>terminateProcess</a>.
terminateProcess :: MonadIO m => ProcessHandle -> m ()

-- | Lifted <a>interruptProcessGroupOf</a>.
interruptProcessGroupOf :: MonadIO m => ProcessHandle -> m ()

-- | Lifted <a>createPipe</a>.
createPipe :: MonadIO m => m (Handle, Handle)

-- | Lifted <a>createPipeFd</a>.
createPipeFd :: MonadIO m => m (FD, FD)


-- | Unlifted <a>Control.Concurrent.QSem</a>.
module UnliftIO.QSem

-- | <a>QSem</a> is a quantity semaphore in which the resource is acquired
--   and released in units of one. It provides guaranteed FIFO ordering for
--   satisfying blocked <a>waitQSem</a> calls.
--   
--   The pattern
--   
--   <pre>
--   bracket_ waitQSem signalQSem (...)
--   </pre>
--   
--   is safe; it never loses a unit of the resource.
data () => QSem

-- | Lifted <a>newQSem</a>.
newQSem :: MonadIO m => Int -> m QSem

-- | Lifted <a>waitQSem</a>.
waitQSem :: MonadIO m => QSem -> m ()

-- | Lifted <a>signalQSem</a>.
signalQSem :: MonadIO m => QSem -> m ()

-- | <a>withQSem</a> is an exception-safe wrapper for performing the
--   provided operation while holding a unit of value from the semaphore.
--   It ensures the semaphore cannot be leaked if there are exceptions.
withQSem :: MonadUnliftIO m => QSem -> m a -> m a


-- | Unlifted <a>Control.Concurrent.QSemN</a>.
module UnliftIO.QSemN

-- | <a>QSemN</a> is a quantity semaphore in which the resource is acquired
--   and released in units of one. It provides guaranteed FIFO ordering for
--   satisfying blocked <a>waitQSemN</a> calls.
--   
--   The pattern
--   
--   <pre>
--   bracket_ (waitQSemN n) (signalQSemN n) (...)
--   </pre>
--   
--   is safe; it never loses any of the resource.
data () => QSemN

-- | Lifted <a>newQSemN</a>.
newQSemN :: MonadIO m => Int -> m QSemN

-- | Lifted <a>waitQSemN</a>.
waitQSemN :: MonadIO m => QSemN -> Int -> m ()

-- | Lifted <a>signalQSemN</a>.
signalQSemN :: MonadIO m => QSemN -> Int -> m ()

-- | <a>withQSemN</a> is an exception-safe wrapper for performing the
--   provided operation while holding N unit of value from the semaphore.
--   It ensures the semaphore cannot be leaked if there are exceptions.
withQSemN :: MonadUnliftIO m => QSemN -> Int -> m a -> m a


-- | Lifted version of <a>Control.Concurrent.STM</a>
module UnliftIO.STM

-- | A monad supporting atomic memory transactions.
data () => STM a

-- | Lifted version of <a>atomically</a>
atomically :: MonadIO m => STM a -> m a

-- | Renamed <a>retry</a> for unqualified export
retrySTM :: STM a

-- | Renamed <a>check</a> for unqualified export
checkSTM :: Bool -> STM ()

-- | Compose two alternative STM actions (GHC only).
--   
--   If the first action completes without retrying then it forms the
--   result of the <a>orElse</a>. Otherwise, if the first action retries,
--   then the second action is tried in its place. If both actions retry
--   then the <a>orElse</a> as a whole retries.
orElse :: STM a -> STM a -> STM a

-- | Shared memory locations that support atomic memory transactions.
data () => TVar a

-- | Lifted version of <a>newTVarIO</a>
newTVarIO :: MonadIO m => a -> m (TVar a)

-- | Lifted version of <a>readTVarIO</a>
readTVarIO :: MonadIO m => TVar a -> m a

-- | Create a new <a>TVar</a> holding a value supplied
newTVar :: a -> STM (TVar a)

-- | Return the current value stored in a <a>TVar</a>.
readTVar :: TVar a -> STM a

-- | Write the supplied value into a <a>TVar</a>.
writeTVar :: TVar a -> a -> STM ()

-- | Mutate the contents of a <a>TVar</a>. <i>N.B.</i>, this version is
--   non-strict.
modifyTVar :: TVar a -> (a -> a) -> STM ()

-- | Strict version of <a>modifyTVar</a>.
modifyTVar' :: TVar a -> (a -> a) -> STM ()

-- | Like <a>modifyTVar'</a> but the function is a simple state transition
--   that can return a side value which is passed on as the result of the
--   <a>STM</a>.
stateTVar :: TVar s -> (s -> (a, s)) -> STM a

-- | Swap the contents of a <a>TVar</a> for a new value.
swapTVar :: TVar a -> a -> STM a

-- | Lifted version of <a>registerDelay</a>
registerDelay :: MonadIO m => Int -> m (TVar Bool)

-- | Lifted version of <a>mkWeakTVar</a>
mkWeakTVar :: MonadUnliftIO m => TVar a -> m () -> m (Weak (TVar a))

-- | A <a>TMVar</a> is a synchronising variable, used for communication
--   between concurrent threads. It can be thought of as a box, which may
--   be empty or full.
data () => TMVar a

-- | Create a <a>TMVar</a> which contains the supplied value.
newTMVar :: a -> STM (TMVar a)

-- | Create a <a>TMVar</a> which is initially empty.
newEmptyTMVar :: STM (TMVar a)

-- | Lifted version of <a>newTMVarIO</a>
newTMVarIO :: MonadIO m => a -> m (TMVar a)

-- | Lifted version of <a>newEmptyTMVarIO</a>
newEmptyTMVarIO :: MonadIO m => m (TMVar a)

-- | Return the contents of the <a>TMVar</a>. If the <a>TMVar</a> is
--   currently empty, the transaction will <a>retry</a>. After a
--   <a>takeTMVar</a>, the <a>TMVar</a> is left empty.
takeTMVar :: TMVar a -> STM a

-- | Put a value into a <a>TMVar</a>. If the <a>TMVar</a> is currently
--   full, <a>putTMVar</a> will <a>retry</a>.
putTMVar :: TMVar a -> a -> STM ()

-- | This is a combination of <a>takeTMVar</a> and <a>putTMVar</a>; ie. it
--   takes the value from the <a>TMVar</a>, puts it back, and also returns
--   it.
readTMVar :: TMVar a -> STM a

-- | Non-blocking write of a new value to a <a>TMVar</a> Puts if empty.
--   Replaces if populated.
writeTMVar :: TMVar a -> a -> STM ()

-- | A version of <a>readTMVar</a> which does not retry. Instead it returns
--   <tt>Nothing</tt> if no value is available.
tryReadTMVar :: TMVar a -> STM (Maybe a)

-- | Swap the contents of a <a>TMVar</a> for a new value.
swapTMVar :: TMVar a -> a -> STM a

-- | A version of <a>takeTMVar</a> that does not <a>retry</a>. The
--   <a>tryTakeTMVar</a> function returns <a>Nothing</a> if the
--   <a>TMVar</a> was empty, or <tt><a>Just</a> a</tt> if the <a>TMVar</a>
--   was full with contents <tt>a</tt>. After <a>tryTakeTMVar</a>, the
--   <a>TMVar</a> is left empty.
tryTakeTMVar :: TMVar a -> STM (Maybe a)

-- | A version of <a>putTMVar</a> that does not <a>retry</a>. The
--   <a>tryPutTMVar</a> function attempts to put the value <tt>a</tt> into
--   the <a>TMVar</a>, returning <a>True</a> if it was successful, or
--   <a>False</a> otherwise.
tryPutTMVar :: TMVar a -> a -> STM Bool

-- | Check whether a given <a>TMVar</a> is empty.
isEmptyTMVar :: TMVar a -> STM Bool

-- | Lifted version of <a>mkWeakTMVar</a>
mkWeakTMVar :: MonadUnliftIO m => TMVar a -> m () -> m (Weak (TMVar a))

-- | <a>TChan</a> is an abstract type representing an unbounded FIFO
--   channel.
data () => TChan a

-- | Build and return a new instance of <a>TChan</a>
newTChan :: STM (TChan a)

-- | Lifted version of <a>newTChanIO</a>
newTChanIO :: MonadIO m => m (TChan a)

-- | Create a write-only <a>TChan</a>. More precisely, <a>readTChan</a>
--   will <a>retry</a> even after items have been written to the channel.
--   The only way to read a broadcast channel is to duplicate it with
--   <a>dupTChan</a>.
--   
--   Consider a server that broadcasts messages to clients:
--   
--   <pre>
--   serve :: TChan Message -&gt; Client -&gt; IO loop
--   serve broadcastChan client = do
--       myChan &lt;- dupTChan broadcastChan
--       forever $ do
--           message &lt;- readTChan myChan
--           send client message
--   </pre>
--   
--   The problem with using <a>newTChan</a> to create the broadcast channel
--   is that if it is only written to and never read, items will pile up in
--   memory. By using <a>newBroadcastTChan</a> to create the broadcast
--   channel, items can be garbage collected after clients have seen them.
newBroadcastTChan :: STM (TChan a)

-- | Lifted version of <a>newBroadcastTChanIO</a>
newBroadcastTChanIO :: MonadIO m => m (TChan a)

-- | Duplicate a <a>TChan</a>: the duplicate channel begins empty, but data
--   written to either channel from then on will be available from both.
--   Hence this creates a kind of broadcast channel, where data written by
--   anyone is seen by everyone else.
dupTChan :: TChan a -> STM (TChan a)

-- | Clone a <a>TChan</a>: similar to dupTChan, but the cloned channel
--   starts with the same content available as the original channel.
cloneTChan :: TChan a -> STM (TChan a)

-- | Read the next value from the <a>TChan</a>.
readTChan :: TChan a -> STM a

-- | A version of <a>readTChan</a> which does not retry. Instead it returns
--   <tt>Nothing</tt> if no value is available.
tryReadTChan :: TChan a -> STM (Maybe a)

-- | Get the next value from the <tt>TChan</tt> without removing it,
--   retrying if the channel is empty.
peekTChan :: TChan a -> STM a

-- | A version of <a>peekTChan</a> which does not retry. Instead it returns
--   <tt>Nothing</tt> if no value is available.
tryPeekTChan :: TChan a -> STM (Maybe a)

-- | Write a value to a <a>TChan</a>.
writeTChan :: TChan a -> a -> STM ()

-- | Put a data item back onto a channel, where it will be the next item
--   read.
unGetTChan :: TChan a -> a -> STM ()

-- | Returns <a>True</a> if the supplied <a>TChan</a> is empty.
isEmptyTChan :: TChan a -> STM Bool

-- | <a>TQueue</a> is an abstract type representing an unbounded FIFO
--   channel.
data () => TQueue a

-- | Build and returns a new instance of <a>TQueue</a>
newTQueue :: STM (TQueue a)

-- | Lifted version of <a>newTQueueIO</a>
newTQueueIO :: MonadIO m => m (TQueue a)

-- | Read the next value from the <a>TQueue</a>.
readTQueue :: TQueue a -> STM a

-- | A version of <a>readTQueue</a> which does not retry. Instead it
--   returns <tt>Nothing</tt> if no value is available.
tryReadTQueue :: TQueue a -> STM (Maybe a)

-- | Get the next value from the <tt>TQueue</tt> without removing it,
--   retrying if the channel is empty.
peekTQueue :: TQueue a -> STM a

-- | A version of <a>peekTQueue</a> which does not retry. Instead it
--   returns <tt>Nothing</tt> if no value is available.
tryPeekTQueue :: TQueue a -> STM (Maybe a)

-- | Write a value to a <a>TQueue</a>.
writeTQueue :: TQueue a -> a -> STM ()

-- | Put a data item back onto a channel, where it will be the next item
--   read.
unGetTQueue :: TQueue a -> a -> STM ()

-- | Returns <a>True</a> if the supplied <a>TQueue</a> is empty.
isEmptyTQueue :: TQueue a -> STM Bool

-- | <a>TBQueue</a> is an abstract type representing a bounded FIFO
--   channel.
data () => TBQueue a

-- | Builds and returns a new instance of <a>TBQueue</a>.
newTBQueue :: Natural -> STM (TBQueue a)

-- | Lifted version of <a>newTBQueueIO</a>
newTBQueueIO :: MonadIO m => Natural -> m (TBQueue a)

-- | Read the next value from the <a>TBQueue</a>.
readTBQueue :: TBQueue a -> STM a

-- | A version of <a>readTBQueue</a> which does not retry. Instead it
--   returns <tt>Nothing</tt> if no value is available.
tryReadTBQueue :: TBQueue a -> STM (Maybe a)

-- | Efficiently read the entire contents of a <a>TBQueue</a> into a list.
--   This function never retries.
flushTBQueue :: TBQueue a -> STM [a]

-- | Get the next value from the <tt>TBQueue</tt> without removing it,
--   retrying if the channel is empty.
peekTBQueue :: TBQueue a -> STM a

-- | A version of <a>peekTBQueue</a> which does not retry. Instead it
--   returns <tt>Nothing</tt> if no value is available.
tryPeekTBQueue :: TBQueue a -> STM (Maybe a)

-- | Write a value to a <a>TBQueue</a>; blocks if the queue is full.
writeTBQueue :: TBQueue a -> a -> STM ()

-- | Put a data item back onto a channel, where it will be the next item
--   read. Blocks if the queue is full.
unGetTBQueue :: TBQueue a -> a -> STM ()

-- | Return the length of a <a>TBQueue</a>.
lengthTBQueue :: TBQueue a -> STM Natural

-- | Returns <a>True</a> if the supplied <a>TBQueue</a> is empty.
isEmptyTBQueue :: TBQueue a -> STM Bool

-- | Returns <a>True</a> if the supplied <a>TBQueue</a> is full.
isFullTBQueue :: TBQueue a -> STM Bool


-- | Temporary file and directory support.
--   
--   Strongly inspired by/stolen from the
--   <a>https://github.com/feuerbach/temporary</a> package.
--   
--   <h3><b>Copyright notice:</b></h3>
--   
--   The following copyright notice is taken from
--   <a>https://github.com/feuerbach/temporary</a> and is reproduced here
--   as part of license terms of that package, of which this module is a
--   derivate work.
--   
--   <pre>
--   Copyright
--     (c) 2003-2006, Isaac Jones
--     (c) 2005-2009, Duncan Coutts
--     (c) 2008, Maximilian Bolingbroke
--     ... and other contributors
--   
--   All rights reserved.
--   
--   Redistribution and use in source and binary forms, with or without modification, are permitted
--   provided that the following conditions are met:
--   
--       * Redistributions of source code must retain the above copyright notice, this list of
--         conditions and the following disclaimer.
--       * Redistributions in binary form must reproduce the above copyright notice, this list of
--         conditions and the following disclaimer in the documentation and/or other materials
--         provided with the distribution.
--       * Neither the name of Maximilian Bolingbroke nor the names of other contributors may be used to
--         endorse or promote products derived from this software without specific prior written permission.
--   
--   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR
--   IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
--   FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
--   CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
--   DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
--   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
--   IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
--   OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
--   </pre>
module UnliftIO.Temporary

-- | Create and use a temporary file in the system standard temporary
--   directory.
--   
--   Behaves exactly the same as <a>withTempFile</a>, except that the
--   parent temporary directory will be that returned by
--   <a>getCanonicalTemporaryDirectory</a>.
withSystemTempFile :: MonadUnliftIO m => String -> (FilePath -> Handle -> m a) -> m a

-- | Create and use a temporary directory in the system standard temporary
--   directory.
--   
--   Behaves exactly the same as <a>withTempDirectory</a>, except that the
--   parent temporary directory will be that returned by
--   <a>getCanonicalTemporaryDirectory</a>.
withSystemTempDirectory :: MonadUnliftIO m => String -> (FilePath -> m a) -> m a

-- | Use a temporary filename that doesn't already exist.
--   
--   Creates a new temporary file inside the given directory, making use of
--   the template. The temp file is deleted after use. For example:
--   
--   <pre>
--   withTempFile "src" "sdist." $ \tmpFile hFile -&gt; do ...
--   </pre>
--   
--   The <tt>tmpFile</tt> will be file in the given directory, e.g.
--   <tt>src/sdist.342</tt>.
withTempFile :: MonadUnliftIO m => FilePath -> String -> (FilePath -> Handle -> m a) -> m a

-- | Create and use a temporary directory.
--   
--   Creates a new temporary directory inside the given directory, making
--   use of the template. The temp directory is deleted after use. For
--   example:
--   
--   <pre>
--   withTempDirectory "src" "sdist." $ \tmpDir -&gt; do ...
--   </pre>
--   
--   The <tt>tmpDir</tt> will be a new subdirectory of the given directory,
--   e.g. <tt>src/sdist.342</tt>.
withTempDirectory :: MonadUnliftIO m => FilePath -> String -> (FilePath -> m a) -> m a


-- | Unlifted <a>System.Timeout</a>.
module UnliftIO.Timeout

-- | Unlifted <a>timeout</a>.
timeout :: MonadUnliftIO m => Int -> m a -> m (Maybe a)


-- | Please see the README.md file for information on using this package at
--   <a>https://www.stackage.org/package/unliftio</a>.
module UnliftIO
