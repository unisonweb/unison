<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><title>UnliftIO.IO.File</title><link href="linuwial.css" rel="stylesheet" type="text/css" title="Linuwial" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400i,700" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { processClass: "mathjax", ignoreClass: ".*" } });</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><span class="caption">unliftio-0.2.25.0: The MonadUnliftIO typeclass for unlifting monads to IO (batteries included)</span><ul class="links" id="page-menu"><li><a href="src/UnliftIO.IO.File.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>Safe-Inferred</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">UnliftIO.IO.File</p></div><div id="description"><p class="caption">Description</p><div class="doc"><h2>Rationale</h2><p>This module offers functions to handle files that offer better durability and/or
atomicity.</p><h2>When to use functions in this module?</h2><p>Given the usage of this functions comes at a cost in performance, it is important to
consider what are the use cases that are ideal for each of the functions.</p><h3>Not Durable and not Atomic</h3><p>For this use case, you want to use the regular functions:</p><ul><li><code><a href="UnliftIO-IO-File.html#v:withBinaryFile" title="UnliftIO.IO.File">withBinaryFile</a></code></li><li><code><a href="UnliftIO-IO-File.html#v:writeBinaryFile" title="UnliftIO.IO.File">writeBinaryFile</a></code></li></ul><p>The regular use case for this scenario happens when your program is dealing with outputs
that are never going to be consumed again by your program. For example, imagine you have a
program that generates sales reports for the last month, this is a report that can be
generated quickly; you don't really care if the output file gets corrupted or lost at one
particular execution of your program given that is cheap to execute the data export
program a second time. In other words, your program doesn't <em>rely</em> on the data contained
in this file in order to work.</p><h3>Atomic but not Durable</h3><p>Imagine a scenario where your program builds a temporary file that serves as an
intermediate step to a bigger task, like Object files (<code>.o</code>) in a compilation process. The
program will use an existing <code>.o</code> file if it is present, or it will build one from scratch
if it is not. The file is not really required, but if it is present, it *must* be valid
and consistent. In this situation, you care about atomicity, but not durability. You can
use the functions for such scenario:</p><ul><li><code><a href="UnliftIO-IO-File.html#v:withBinaryFileAtomic" title="UnliftIO.IO.File">withBinaryFileAtomic</a></code></li><li><code><a href="UnliftIO-IO-File.html#v:writeBinaryFileAtomic" title="UnliftIO.IO.File">writeBinaryFileAtomic</a></code></li></ul><p><strong>Note</strong> - there is a peculiar difference between regular file writing functionality and
the one that is done atomically. Even if the orignal file is removed while it is being
modified, because of atomicity, it will be restored with all modifications, if any. The
reason for this is because a copy of the file was made prior to modifications and at the
end the existing is atomically replaced. An important consequence of this fact is that
whenever the folder containing the file which is being modified is removed, all bets are
off and all atomic functions will result in an exception.</p><h3>Durable but not Atomic</h3><p>For this use case, you want to use the functions:</p><ul><li><code><a href="UnliftIO-IO-File.html#v:withBinaryFileDurable" title="UnliftIO.IO.File">withBinaryFileDurable</a></code></li><li><code><a href="UnliftIO-IO-File.html#v:writeBinaryFileDurable" title="UnliftIO.IO.File">writeBinaryFileDurable</a></code></li></ul><p>The regular use case for this scenario happens when your program deals with file
modifications that must be guaranteed to be durable, but you don't care that changes are
consistent. If you use this function, more than likely your program is ensuring
consistency guarantees through other means, for example, SQLite uses the Write Ahead Log
(WAL) algorithm to ensure changes are atomic at an application level.</p><h3>Durable and Atomic</h3><p>For this use case, you can use the functions:</p><ul><li><code><a href="UnliftIO-IO-File.html#v:withBinaryFileDurableAtomic" title="UnliftIO.IO.File">withBinaryFileDurableAtomic</a></code></li><li><code><a href="UnliftIO-IO-File.html#v:writeBinaryFileDurableAtomic" title="UnliftIO.IO.File">writeBinaryFileDurableAtomic</a></code></li></ul><p>The regular use case for this scenario happens when you want to ensure that after a
program is executed, the modifications done to a file are guaranteed to be saved, and also
that changes are rolled-back in case there is a failure (e.g.  hard reboot, shutdown,
etc).</p></div></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"><li class="src short"><a href="#v:writeBinaryFile">writeBinaryFile</a> :: <a href="../base-4.18.2.1/Control-Monad-IO-Class.html#t:MonadIO" title="Control.Monad.IO.Class">MonadIO</a> m =&gt; <a href="../base-4.18.2.1/System-IO.html#t:FilePath" title="System.IO">FilePath</a> -&gt; <a href="../bytestring-0.11.5.3/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; m ()</li><li class="src short"><a href="#v:writeBinaryFileAtomic">writeBinaryFileAtomic</a> :: <a href="../base-4.18.2.1/Control-Monad-IO-Class.html#t:MonadIO" title="Control.Monad.IO.Class">MonadIO</a> m =&gt; <a href="../base-4.18.2.1/System-IO.html#t:FilePath" title="System.IO">FilePath</a> -&gt; <a href="../bytestring-0.11.5.3/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; m ()</li><li class="src short"><a href="#v:writeBinaryFileDurable">writeBinaryFileDurable</a> :: <a href="../base-4.18.2.1/Control-Monad-IO-Class.html#t:MonadIO" title="Control.Monad.IO.Class">MonadIO</a> m =&gt; <a href="../base-4.18.2.1/System-IO.html#t:FilePath" title="System.IO">FilePath</a> -&gt; <a href="../bytestring-0.11.5.3/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; m ()</li><li class="src short"><a href="#v:writeBinaryFileDurableAtomic">writeBinaryFileDurableAtomic</a> :: <a href="../base-4.18.2.1/Control-Monad-IO-Class.html#t:MonadIO" title="Control.Monad.IO.Class">MonadIO</a> m =&gt; <a href="../base-4.18.2.1/System-IO.html#t:FilePath" title="System.IO">FilePath</a> -&gt; <a href="../bytestring-0.11.5.3/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; m ()</li><li class="src short"><a href="#v:withBinaryFile">withBinaryFile</a> :: <a href="../unliftio-core-0.2.1.0/Control-Monad-IO-Unlift.html#t:MonadUnliftIO" title="Control.Monad.IO.Unlift">MonadUnliftIO</a> m =&gt; <a href="../base-4.18.2.1/System-IO.html#t:FilePath" title="System.IO">FilePath</a> -&gt; <a href="UnliftIO-IO.html#t:IOMode" title="UnliftIO.IO">IOMode</a> -&gt; (<a href="UnliftIO-IO.html#t:Handle" title="UnliftIO.IO">Handle</a> -&gt; m a) -&gt; m a</li><li class="src short"><a href="#v:withBinaryFileAtomic">withBinaryFileAtomic</a> :: <a href="../unliftio-core-0.2.1.0/Control-Monad-IO-Unlift.html#t:MonadUnliftIO" title="Control.Monad.IO.Unlift">MonadUnliftIO</a> m =&gt; <a href="../base-4.18.2.1/System-IO.html#t:FilePath" title="System.IO">FilePath</a> -&gt; <a href="UnliftIO-IO.html#t:IOMode" title="UnliftIO.IO">IOMode</a> -&gt; (<a href="UnliftIO-IO.html#t:Handle" title="UnliftIO.IO">Handle</a> -&gt; m r) -&gt; m r</li><li class="src short"><a href="#v:withBinaryFileDurable">withBinaryFileDurable</a> :: <a href="../unliftio-core-0.2.1.0/Control-Monad-IO-Unlift.html#t:MonadUnliftIO" title="Control.Monad.IO.Unlift">MonadUnliftIO</a> m =&gt; <a href="../base-4.18.2.1/System-IO.html#t:FilePath" title="System.IO">FilePath</a> -&gt; <a href="UnliftIO-IO.html#t:IOMode" title="UnliftIO.IO">IOMode</a> -&gt; (<a href="UnliftIO-IO.html#t:Handle" title="UnliftIO.IO">Handle</a> -&gt; m r) -&gt; m r</li><li class="src short"><a href="#v:withBinaryFileDurableAtomic">withBinaryFileDurableAtomic</a> :: <a href="../unliftio-core-0.2.1.0/Control-Monad-IO-Unlift.html#t:MonadUnliftIO" title="Control.Monad.IO.Unlift">MonadUnliftIO</a> m =&gt; <a href="../base-4.18.2.1/System-IO.html#t:FilePath" title="System.IO">FilePath</a> -&gt; <a href="UnliftIO-IO.html#t:IOMode" title="UnliftIO.IO">IOMode</a> -&gt; (<a href="UnliftIO-IO.html#t:Handle" title="UnliftIO.IO">Handle</a> -&gt; m r) -&gt; m r</li><li class="src short"><a href="#v:ensureFileDurable">ensureFileDurable</a> :: <a href="../base-4.18.2.1/Control-Monad-IO-Class.html#t:MonadIO" title="Control.Monad.IO.Class">MonadIO</a> m =&gt; <a href="../base-4.18.2.1/System-IO.html#t:FilePath" title="System.IO">FilePath</a> -&gt; m ()</li></ul></details></div><div id="interface"><h1>Documentation</h1><div class="top"><p class="src"><a id="v:writeBinaryFile" class="def">writeBinaryFile</a> :: <a href="../base-4.18.2.1/Control-Monad-IO-Class.html#t:MonadIO" title="Control.Monad.IO.Class">MonadIO</a> m =&gt; <a href="../base-4.18.2.1/System-IO.html#t:FilePath" title="System.IO">FilePath</a> -&gt; <a href="../bytestring-0.11.5.3/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; m () <a href="src/UnliftIO.IO.File.html#writeBinaryFile" class="link">Source</a> <a href="#v:writeBinaryFile" class="selflink">#</a></p><div class="doc"><p>Lifted version of <code><a href="../bytestring-0.11.5.3/Data-ByteString.html#v:writeFile" title="Data.ByteString">writeFile</a></code></p><p><em>Since: 0.2.12</em></p></div></div><div class="top"><p class="src"><a id="v:writeBinaryFileAtomic" class="def">writeBinaryFileAtomic</a> :: <a href="../base-4.18.2.1/Control-Monad-IO-Class.html#t:MonadIO" title="Control.Monad.IO.Class">MonadIO</a> m =&gt; <a href="../base-4.18.2.1/System-IO.html#t:FilePath" title="System.IO">FilePath</a> -&gt; <a href="../bytestring-0.11.5.3/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; m () <a href="src/UnliftIO.IO.File.html#writeBinaryFileAtomic" class="link">Source</a> <a href="#v:writeBinaryFileAtomic" class="selflink">#</a></p><div class="doc"><p>Same as <code><a href="UnliftIO-IO-File.html#v:writeBinaryFileDurableAtomic" title="UnliftIO.IO.File">writeBinaryFileDurableAtomic</a></code>, except it does not guarantee durability.</p><h3>Cross-Platform support</h3><p>This function behaves the same as <code><a href="UnliftIO-IO-File.html#v:writeBinaryFile" title="UnliftIO.IO.File">writeBinaryFile</a></code> on Windows platforms.</p><p><em>Since: 0.2.12</em></p></div></div><div class="top"><p class="src"><a id="v:writeBinaryFileDurable" class="def">writeBinaryFileDurable</a> :: <a href="../base-4.18.2.1/Control-Monad-IO-Class.html#t:MonadIO" title="Control.Monad.IO.Class">MonadIO</a> m =&gt; <a href="../base-4.18.2.1/System-IO.html#t:FilePath" title="System.IO">FilePath</a> -&gt; <a href="../bytestring-0.11.5.3/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; m () <a href="src/UnliftIO.IO.File.html#writeBinaryFileDurable" class="link">Source</a> <a href="#v:writeBinaryFileDurable" class="selflink">#</a></p><div class="doc"><p>Similar to <code><a href="UnliftIO-IO-File.html#v:writeBinaryFile" title="UnliftIO.IO.File">writeBinaryFile</a></code>, but it also ensures that changes executed to the file
 are guaranteed to be durable. It internally uses <code>fsync()</code> and makes sure it
 synchronizes the file on disk.</p><h3>Cross-Platform support</h3><p>This function behaves the same as <code><a href="RIO.html#v:writeBinaryFile" title="RIO">writeBinaryFile</a></code> on Windows platforms.</p><p><em>Since: 0.2.12</em></p></div></div><div class="top"><p class="src"><a id="v:writeBinaryFileDurableAtomic" class="def">writeBinaryFileDurableAtomic</a> :: <a href="../base-4.18.2.1/Control-Monad-IO-Class.html#t:MonadIO" title="Control.Monad.IO.Class">MonadIO</a> m =&gt; <a href="../base-4.18.2.1/System-IO.html#t:FilePath" title="System.IO">FilePath</a> -&gt; <a href="../bytestring-0.11.5.3/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; m () <a href="src/UnliftIO.IO.File.html#writeBinaryFileDurableAtomic" class="link">Source</a> <a href="#v:writeBinaryFileDurableAtomic" class="selflink">#</a></p><div class="doc"><p>Similar to <code><a href="UnliftIO-IO-File.html#v:writeBinaryFile" title="UnliftIO.IO.File">writeBinaryFile</a></code>, but it also guarantes that changes executed to the file
 are durable, also, in case of failure, the modified file is never going to get
 corrupted. It internally uses <code>fsync()</code> and makes sure it synchronizes the file on
 disk.</p><h3>Cross-Platform support</h3><p>This function behaves the same as <code><a href="UnliftIO-IO-File.html#v:writeBinaryFile" title="UnliftIO.IO.File">writeBinaryFile</a></code> on Windows platforms.</p><p><em>Since: 0.2.12</em></p></div></div><div class="top"><p class="src"><a id="v:withBinaryFile" class="def">withBinaryFile</a> :: <a href="../unliftio-core-0.2.1.0/Control-Monad-IO-Unlift.html#t:MonadUnliftIO" title="Control.Monad.IO.Unlift">MonadUnliftIO</a> m =&gt; <a href="../base-4.18.2.1/System-IO.html#t:FilePath" title="System.IO">FilePath</a> -&gt; <a href="UnliftIO-IO.html#t:IOMode" title="UnliftIO.IO">IOMode</a> -&gt; (<a href="UnliftIO-IO.html#t:Handle" title="UnliftIO.IO">Handle</a> -&gt; m a) -&gt; m a <a href="src/UnliftIO.IO.html#withBinaryFile" class="link">Source</a> <a href="#v:withBinaryFile" class="selflink">#</a></p><div class="doc"><p>Unlifted version of <code><a href="../base-4.18.2.1/GHC-IO-StdHandles.html#v:withBinaryFile" title="GHC.IO.StdHandles">withBinaryFile</a></code>.</p><p><em>Since: 0.1.0.0</em></p></div></div><div class="top"><p class="src"><a id="v:withBinaryFileAtomic" class="def">withBinaryFileAtomic</a> :: <a href="../unliftio-core-0.2.1.0/Control-Monad-IO-Unlift.html#t:MonadUnliftIO" title="Control.Monad.IO.Unlift">MonadUnliftIO</a> m =&gt; <a href="../base-4.18.2.1/System-IO.html#t:FilePath" title="System.IO">FilePath</a> -&gt; <a href="UnliftIO-IO.html#t:IOMode" title="UnliftIO.IO">IOMode</a> -&gt; (<a href="UnliftIO-IO.html#t:Handle" title="UnliftIO.IO">Handle</a> -&gt; m r) -&gt; m r <a href="src/UnliftIO.IO.File.html#withBinaryFileAtomic" class="link">Source</a> <a href="#v:withBinaryFileAtomic" class="selflink">#</a></p><div class="doc"><p>Perform an action on a new or existing file at the destination file path. If
 previously the file existed at the supplied file path then:</p><ul><li>in case of <code><a href="UnliftIO-IO.html#v:WriteMode" title="UnliftIO.IO">WriteMode</a></code> it will be overwritten</li><li>upon <code><a href="UnliftIO-IO.html#v:ReadWriteMode" title="UnliftIO.IO">ReadWriteMode</a></code> or <code><a href="UnliftIO-IO.html#v:AppendMode" title="UnliftIO.IO">AppendMode</a></code> files contents will be copied over into a
 temporary file, thus making sure no corruption can happen to an existing file upon any
 failures, even catastrophic one, yet its contents are availble for modification.</li><li>There is nothing atomic about <code><a href="UnliftIO-IO.html#v:ReadMode" title="UnliftIO.IO">ReadMode</a></code>, so no special treatment there.</li></ul><p>It is similar to <code><a href="UnliftIO-IO-File.html#v:withBinaryFileDurableAtomic" title="UnliftIO.IO.File">withBinaryFileDurableAtomic</a></code>, but without the durability part. It
 means that all modification can still disappear after it has been succesfully written
 due to some extreme event like an abrupt power loss, but the contents will not be
 corrupted in case when the file write did not end successfully.</p><p>The same performance caveats apply as for <code><a href="UnliftIO-IO-File.html#v:withBinaryFileDurableAtomic" title="UnliftIO.IO.File">withBinaryFileDurableAtomic</a></code> due to making a
 copy of the content of existing files during non-truncating writes.</p><p><strong>Important</strong> - Do not close the handle, otherwise it will result in <code>invalid argument
 (Bad file descriptor)</code> exception</p><p><strong>Note</strong> - on Linux operating system and only with supported file systems an anonymous
 temporary file will be used while working on the file (see <code>O_TMPFILE</code> in <code>man
 openat</code>). In case when such feature is not available or not supported a temporary file
 &quot;.target-file-nameXXX.ext.tmp&quot;, where XXX is some random number, will be created
 alongside the target file in the same directory</p><p><em>Since: 0.2.12</em></p></div></div><div class="top"><p class="src"><a id="v:withBinaryFileDurable" class="def">withBinaryFileDurable</a> :: <a href="../unliftio-core-0.2.1.0/Control-Monad-IO-Unlift.html#t:MonadUnliftIO" title="Control.Monad.IO.Unlift">MonadUnliftIO</a> m =&gt; <a href="../base-4.18.2.1/System-IO.html#t:FilePath" title="System.IO">FilePath</a> -&gt; <a href="UnliftIO-IO.html#t:IOMode" title="UnliftIO.IO">IOMode</a> -&gt; (<a href="UnliftIO-IO.html#t:Handle" title="UnliftIO.IO">Handle</a> -&gt; m r) -&gt; m r <a href="src/UnliftIO.IO.File.html#withBinaryFileDurable" class="link">Source</a> <a href="#v:withBinaryFileDurable" class="selflink">#</a></p><div class="doc"><p>Opens a file with the following guarantees:</p><ul><li>It successfully closes the file in case of an asynchronous exception</li><li>It reliably saves the file in the correct directory; including edge case situations
   like a different device being mounted to the current directory, or the current
   directory being renamed to some other name while the file is being used.</li><li>It ensures durability by executing an <code>fsync()</code> call before closing the file handle</li></ul><h3>Cross-Platform support</h3><p>This function behaves the same as <code><a href="../base-4.18.2.1/System-IO.html#v:withBinaryFile" title="System.IO">withBinaryFile</a></code> on Windows platforms.</p><p><em>Since: 0.2.12</em></p></div></div><div class="top"><p class="src"><a id="v:withBinaryFileDurableAtomic" class="def">withBinaryFileDurableAtomic</a> :: <a href="../unliftio-core-0.2.1.0/Control-Monad-IO-Unlift.html#t:MonadUnliftIO" title="Control.Monad.IO.Unlift">MonadUnliftIO</a> m =&gt; <a href="../base-4.18.2.1/System-IO.html#t:FilePath" title="System.IO">FilePath</a> -&gt; <a href="UnliftIO-IO.html#t:IOMode" title="UnliftIO.IO">IOMode</a> -&gt; (<a href="UnliftIO-IO.html#t:Handle" title="UnliftIO.IO">Handle</a> -&gt; m r) -&gt; m r <a href="src/UnliftIO.IO.File.html#withBinaryFileDurableAtomic" class="link">Source</a> <a href="#v:withBinaryFileDurableAtomic" class="selflink">#</a></p><div class="doc"><p>Opens a file with the following guarantees:</p><ul><li>It successfully closes the file in case of an asynchronous exception</li><li>It reliably saves the file in the correct directory; including edge case situations
   like a different device being mounted to the current directory, or the current
   directory being renamed to some other name while the file is being used.</li><li>It ensures durability by executing an <code>fsync()</code> call before closing the file handle</li><li>It keeps all changes in a temporary file, and after it is closed it atomically moves
   the temporary file to the original filepath, in case of catastrophic failure, the
   original file stays unaffected.</li></ul><p>If you do not need durability but only atomicity, use <code><a href="UnliftIO-IO-File.html#v:withBinaryFileAtomic" title="UnliftIO.IO.File">withBinaryFileAtomic</a></code> instead,
 which is faster as it does not perform <code>fsync()</code>.</p><p><strong>Important</strong> - Make sure not to close the <code><a href="UnliftIO-IO.html#t:Handle" title="UnliftIO.IO">Handle</a></code>, it will be closed for you,
 otherwise it will result in <code>invalid argument (Bad file descriptor)</code> exception.</p><h3>Performance Considerations</h3><p>When using a writable but non-truncating <code><a href="UnliftIO-IO.html#t:IOMode" title="UnliftIO.IO">IOMode</a></code> (i.e. <code><a href="UnliftIO-IO.html#v:ReadWriteMode" title="UnliftIO.IO">ReadWriteMode</a></code> and
 <code><a href="UnliftIO-IO.html#v:AppendMode" title="UnliftIO.IO">AppendMode</a></code>), this function performs a copy operation of the specified input file to
 guarantee the original file is intact in case of a catastrophic failure (no partial
 writes). This approach may be prohibitive in scenarios where the input file is expected
 to be large in size.</p><h3>Cross-Platform support</h3><p>This function behaves the same as <code><a href="../base-4.18.2.1/System-IO.html#v:withBinaryFile" title="System.IO">withBinaryFile</a></code> on Windows platforms.</p><p><em>Since: 0.2.12</em></p></div></div><div class="top"><p class="src"><a id="v:ensureFileDurable" class="def">ensureFileDurable</a> :: <a href="../base-4.18.2.1/Control-Monad-IO-Class.html#t:MonadIO" title="Control.Monad.IO.Class">MonadIO</a> m =&gt; <a href="../base-4.18.2.1/System-IO.html#t:FilePath" title="System.IO">FilePath</a> -&gt; m () <a href="src/UnliftIO.IO.File.html#ensureFileDurable" class="link">Source</a> <a href="#v:ensureFileDurable" class="selflink">#</a></p><div class="doc"><p>After a file is closed, this function opens it again and executes <code>fsync()</code>
 internally on both the file and the directory that contains it. Note that this function
 is intended to work around the non-durability of existing file APIs, as opposed to
 being necessary for the API functions provided in this module.</p><p><a href="https://stackoverflow.com/questions/37288453/calling-fsync2-after-close2/50158433#50158433">The effectiveness of calling this function is
 debatable</a>,
 as it relies on internal implementation details at the Kernel level that might
 change. We argue that, despite this fact, calling this function may bring benefits in
 terms of durability.</p><p>This function does not provide the same guarantee as if you would open and modify a
 file using <code><a href="UnliftIO-IO-File.html#v:withBinaryFileDurable" title="UnliftIO.IO.File">withBinaryFileDurable</a></code> or <code><a href="UnliftIO-IO-File.html#v:writeBinaryFileDurable" title="UnliftIO.IO.File">writeBinaryFileDurable</a></code>, since they ensure that
 the <code>fsync()</code> is called before the file is closed, so if possible use those instead.</p><h3>Cross-Platform support</h3><p>This function is a noop on Windows platforms.</p><p><em>Since: 0.2.12</em></p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.29.2</p></div></body></html>